# ! [doc = "Peripheral access API for STM32F103 microcontrollers (generated using svd2rust v0.37.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [cfg_attr (docsrs , feature (doc_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 4 ;
#[allow (unused_imports)] use generic :: * ;
#[doc = r"Common register and bit access and modify traits"] pub mod generic { use core :: marker ;
#[doc = " Generic peripheral accessor"] pub struct Periph < RB , const A : usize > { _marker : marker :: PhantomData < RB > , } unsafe impl < RB , const A : usize > Send for Periph < RB , A > { } impl < RB , const A : usize > Periph < RB , A > {
#[doc = "Pointer to the register block"] pub const PTR : * const RB = A as * const _ ;
#[doc = "Return the pointer to the register block"]
#[inline (always)] pub const fn ptr () -> * const RB { Self :: PTR }
#[doc = " Steal an instance of this peripheral"]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Ensure that the new instance of the peripheral cannot be used in a way"]
#[doc = " that may race with any existing instances, for example by only"]
#[doc = " accessing read-only or write-only registers, or by consuming the"]
#[doc = " original peripheral and using critical sections to coordinate"]
#[doc = " access between multiple new instances."]
#[doc = ""]
#[doc = " Additionally, other software such as HALs may rely on only one"]
#[doc = " peripheral instance existing to ensure memory safety; ensure"]
#[doc = " no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : marker :: PhantomData , } } } impl < RB , const A : usize > core :: ops :: Deref for Periph < RB , A > { type Target = RB ;
#[inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } }
#[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"] pub trait RawReg : Copy + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > {
#[doc = " Mask for bits of width `WI`"] fn mask < const WI : u8 > () -> Self ;
#[doc = " `0`"] const ZERO : Self ;
#[doc = " `1`"] const ONE : Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U {
#[inline (always)] fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } const ZERO : Self = 0 ; const ONE : Self = 1 ; } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ;
#[doc = " Raw register type"] pub trait RegisterSpec {
#[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."] type Ux : RawReg ; }
#[doc = " Raw field type"] pub trait FieldSpec : Sized {
#[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."] type Ux : Copy + core :: fmt :: Debug + PartialEq + From < Self > ; }
#[doc = " Marker for fields with fixed values"] pub trait IsEnum : FieldSpec { }
#[doc = " Trait implemented by readable registers to enable the `read` method."]
#[doc = ""]
#[doc = " Registers marked with `Writable` can be also be `modify`'ed."] pub trait Readable : RegisterSpec { }
#[doc = " Trait implemented by writeable registers."]
#[doc = ""]
#[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
#[doc = ""]
#[doc = " Registers marked with `Readable` can be also be `modify`'ed."] pub trait Writable : RegisterSpec {
#[doc = " Is it safe to write any bits to register"] type Safety ;
#[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"] const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = Self :: Ux :: ZERO ;
#[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"] const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = Self :: Ux :: ZERO ; }
#[doc = " Reset value of the register."]
#[doc = ""]
#[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
#[doc = " register by using the `reset` method."] pub trait Resettable : RegisterSpec {
#[doc = " Reset value of the register."] const RESET_VALUE : Self :: Ux = Self :: Ux :: ZERO ;
#[doc = " Reset value of the register."]
#[inline (always)] fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } }
#[doc (hidden)] pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > {
#[doc = "Writable bits"] pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > {
#[doc = " Creates a new instance of the reader."]
#[allow (unused)]
#[inline (always)] pub (crate) const fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > {
#[doc = " Creates a new instance of the reader."]
#[allow (unused)]
#[inline (always)] pub (crate) const fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } }
#[must_use = "after creating `FieldWriter` you need to call field value setting method"] pub struct FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , {
#[doc = " Creates a new instance of the writer"]
#[allow (unused)]
#[inline (always)] pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } }
#[must_use = "after creating `BitWriter` you need to call bit setting method"] pub struct BitWriter < 'a , REG , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , FI , M > BitWriter < 'a , REG , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Creates a new instance of the writer"]
#[allow (unused)]
#[inline (always)] pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } }
#[doc = " Register reader."]
#[doc = ""]
#[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
#[doc = " method."] pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > {
#[doc = " Reads raw bits from register."]
#[inline (always)] pub const fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } }
#[doc = " Register writer."]
#[doc = ""]
#[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."] pub type W < REG > = raw :: W < REG > ; impl < REG : Writable > W < REG > {
#[doc = " Writes raw bits to the register."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
#[inline (always)] pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } impl < REG > W < REG > where REG : Writable < Safety = Safe > , {
#[doc = " Writes raw bits to the register."]
#[inline (always)] pub fn set (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } }
#[doc = " Field reader."]
#[doc = ""]
#[doc = " Result of the `read` methods of fields."] pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ;
#[doc = " Bit-wise field reader"] pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > {
#[doc = " Reads raw bits from field."]
#[inline (always)] pub const fn bits (& self) -> FI :: Ux { self . bits } } impl < FI : FieldSpec > core :: fmt :: Debug for FieldReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > {
#[doc = " Value of the field as raw bits."]
#[inline (always)] pub const fn bit (& self) -> bool { self . bits }
#[doc = " Returns `true` if the bit is clear (0)."]
#[inline (always)] pub const fn bit_is_clear (& self) -> bool { ! self . bit () }
#[doc = " Returns `true` if the bit is set (1)."]
#[inline (always)] pub const fn bit_is_set (& self) -> bool { self . bit () } } impl < FI > core :: fmt :: Debug for BitReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } }
#[doc = " Marker for register/field writers which can take any value of specified width"] pub struct Safe ;
#[doc = " You should check that value is allowed to pass to register/field writer marked with this"] pub struct Unsafe ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct Range < const MIN : u64 , const MAX : u64 > ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct RangeFrom < const MIN : u64 > ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct RangeTo < const MAX : u64 > ;
#[doc = " Write field Proxy"] pub type FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > = raw :: FieldWriter < 'a , REG , WI , FI , Safety > ; impl < REG , const WI : u8 , FI , Safety > FieldWriter < '_ , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , {
#[doc = " Field width"] pub const WIDTH : u8 = WI ;
#[doc = " Field width"]
#[inline (always)] pub const fn width (& self) -> u8 { WI }
#[doc = " Field offset"]
#[inline (always)] pub const fn offset (& self) -> u8 { self . o } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
#[inline (always)] pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << self . o ; self . w } } impl < 'a , REG , const WI : u8 , FI > FieldWriter < 'a , REG , WI , FI , Safe > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , Range < MIN , MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN && value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 > FieldWriter < 'a , REG , WI , FI , RangeFrom < MIN > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , RangeTo < MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : IsEnum , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes `variant` to the field"]
#[inline (always)] pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => {
#[doc (hidden)] pub struct $ mwv ;
#[doc = " Bit-wise write field proxy"] pub type $ writer <'a , REG , FI = bool > = raw :: BitWriter <'a , REG , FI , $ mwv >; impl <'a , REG , FI > $ writer <'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI >, {
#[doc = " Field width"] pub const WIDTH : u8 = 1 ;
#[doc = " Field width"]
#[inline (always)] pub const fn width (& self) -> u8 { Self :: WIDTH }
#[doc = " Field offset"]
#[inline (always)] pub const fn offset (& self) -> u8 { self . o }
#[doc = " Writes bit to the field"]
#[inline (always)] pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: ONE) << self . o ; self . w }
#[doc = " Writes `variant` to the field"]
#[inline (always)] pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , FI > BitWriter < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Sets the field bit"]
#[inline (always)] pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w }
#[doc = " Clears the field bit"]
#[inline (always)] pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Sets the field bit"]
#[inline (always)] pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Clears the field bit"]
#[inline (always)] pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Clears the field bit by passing one"]
#[inline (always)] pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Sets the field bit by passing zero"]
#[inline (always)] pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Toggle the field bit by passing one"]
#[inline (always)] pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Toggle the field bit by passing zero"]
#[inline (always)] pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } }
#[doc = " This structure provides volatile access to registers."]
#[repr (transparent)] pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > {
#[doc = " Returns the underlying memory address of register."]
#[doc = ""]
#[doc = " ```ignore"]
#[doc = " let reg_ptr = periph.reg.as_ptr();"]
#[doc = " ```"]
#[inline (always)] pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > {
#[doc = " Reads the contents of a `Readable` register."]
#[doc = ""]
#[doc = " You can read the raw contents of a register by using `bits`:"]
#[doc = " ```ignore"]
#[doc = " let bits = periph.reg.read().bits();"]
#[doc = " ```"]
#[doc = " or get the content of a particular field of a register:"]
#[doc = " ```ignore"]
#[doc = " let reader = periph.reg.read();"]
#[doc = " let bits = reader.field1().bits();"]
#[doc = " let flag = reader.field2().bit_is_set();"]
#[doc = " ```"]
#[inline (always)] pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > {
#[doc = " Writes the reset value to `Writable` register."]
#[doc = ""]
#[doc = " Resets the register to its initial state."]
#[inline (always)] pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) }
#[doc = " Writes bits to a `Writable` register."]
#[doc = ""]
#[doc = " You can write raw bits into a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
#[doc = " ```"]
#[doc = " or write only the fields you need:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| w"]
#[doc = "     .field1().bits(newfield1bits)"]
#[doc = "     .field2().set_bit()"]
#[doc = "     .field3().variant(VARIANT)"]
#[doc = " );"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT)"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " In the latter case, other fields will be set to their reset value."]
#[inline (always)] pub fn write < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value }
#[doc = " Writes bits to a `Writable` register and produce a value."]
#[doc = ""]
#[doc = " You can write raw bits into a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
#[doc = " ```"]
#[doc = " or write only the fields you need:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| {"]
#[doc = "     w.field1().bits(newfield1bits)"]
#[doc = "         .field2().set_bit()"]
#[doc = "         .field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " In the latter case, other fields will be set to their reset value."]
#[doc = ""]
#[doc = " Values can be returned from the closure:"]
#[doc = " ```ignore"]
#[doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
#[doc = " ```"]
#[inline (always)] pub fn from_write < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Writable > Reg < REG > {
#[doc = " Writes 0 to a `Writable` register."]
#[doc = ""]
#[doc = " Similar to `write`, but unused bits will contain 0."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Unsafe to use with registers which don't allow to write 0."]
#[inline (always)] pub unsafe fn write_with_zero < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: Ux :: ZERO , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value }
#[doc = " Writes 0 to a `Writable` register and produces a value."]
#[doc = ""]
#[doc = " Similar to `write`, but unused bits will contain 0."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Unsafe to use with registers which don't allow to write 0."]
#[inline (always)] pub unsafe fn from_write_with_zero < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: Ux :: ZERO , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Readable + Writable > Reg < REG > {
#[doc = " Modifies the contents of the register by reading and then writing it."]
#[doc = ""]
#[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
#[doc = "    r.bits() | 3"]
#[doc = " ) });"]
#[doc = " ```"]
#[doc = " or"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| w"]
#[doc = "     .field1().bits(newfield1bits)"]
#[doc = "     .field2().set_bit()"]
#[doc = "     .field3().variant(VARIANT)"]
#[doc = " );"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT)"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " Other fields will have the value they had before the call to `modify`."]
#[inline (always)] pub fn modify < F > (& self , f : F) -> REG :: Ux where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; let value = f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ; self . register . set (value) ; value }
#[doc = " Modifies the contents of the register by reading and then writing it"]
#[doc = " and produces a value."]
#[doc = ""]
#[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
#[doc = " ```ignore"]
#[doc = " let bits = periph.reg.modify(|r, w| {"]
#[doc = "     let new_bits = r.bits() | 3;"]
#[doc = "     unsafe {"]
#[doc = "         w.bits(new_bits);"]
#[doc = "     }"]
#[doc = ""]
#[doc = "     new_bits"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits)"]
#[doc = "         .field2().set_bit()"]
#[doc = "         .field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " Other fields will have the value they had before the call to `modify`."]
#[inline (always)] pub fn from_modify < F , T > (& self , f : F) -> T where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> T , { let bits = self . register . get () ; let mut writer = W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& R { bits , _reg : marker :: PhantomData , } , & mut writer ,) ; self . register . set (writer . bits) ; result } } impl < REG : Readable > core :: fmt :: Debug for crate :: generic :: Reg < REG > where R < REG > : core :: fmt :: Debug , { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . read () , f) } } }
#[cfg (feature = "rt")] extern "C" { fn WWDG () ; fn PVD () ; fn TAMPER () ; fn RTC () ; fn FLASH () ; fn RCC () ; fn EXTI0 () ; fn EXTI1 () ; fn EXTI2 () ; fn EXTI3 () ; fn EXTI4 () ; fn DMA1_Channel1 () ; fn DMA1_Channel2 () ; fn DMA1_Channel3 () ; fn DMA1_Channel4 () ; fn DMA1_Channel5 () ; fn DMA1_Channel6 () ; fn DMA1_Channel7 () ; fn ADC1_2 () ; fn USB_HP_CAN_TX () ; fn USB_LP_CAN_RX0 () ; fn CAN_RX1 () ; fn CAN_SCE () ; fn EXTI9_5 () ; fn TIM1_BRK () ; fn TIM1_UP () ; fn TIM1_TRG_COM () ; fn TIM1_CC () ; fn TIM2 () ; fn TIM3 () ; fn TIM4 () ; fn I2C1_EV () ; fn I2C1_ER () ; fn I2C2_EV () ; fn I2C2_ER () ; fn SPI1 () ; fn SPI2 () ; fn USART1 () ; fn USART2 () ; fn USART3 () ; fn EXTI15_10 () ; fn RTCAlarm () ; fn TIM8_BRK () ; fn TIM8_UP () ; fn TIM8_TRG_COM () ; fn TIM8_CC () ; fn ADC3 () ; fn FSMC () ; fn SDIO () ; fn TIM5 () ; fn SPI3 () ; fn UART4 () ; fn UART5 () ; fn TIM6 () ; fn TIM7 () ; fn DMA2_Channel1 () ; fn DMA2_Channel2 () ; fn DMA2_Channel3 () ; fn DMA2_Channel4_5 () ; }
#[doc (hidden)]
#[repr (C)] pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , }
#[cfg (feature = "rt")]
#[doc (hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle] pub static __INTERRUPTS : [Vector ; 60] = [Vector { _handler : WWDG } , Vector { _handler : PVD } , Vector { _handler : TAMPER } , Vector { _handler : RTC } , Vector { _handler : FLASH } , Vector { _handler : RCC } , Vector { _handler : EXTI0 } , Vector { _handler : EXTI1 } , Vector { _handler : EXTI2 } , Vector { _handler : EXTI3 } , Vector { _handler : EXTI4 } , Vector { _handler : DMA1_Channel1 } , Vector { _handler : DMA1_Channel2 } , Vector { _handler : DMA1_Channel3 } , Vector { _handler : DMA1_Channel4 } , Vector { _handler : DMA1_Channel5 } , Vector { _handler : DMA1_Channel6 } , Vector { _handler : DMA1_Channel7 } , Vector { _handler : ADC1_2 } , Vector { _handler : USB_HP_CAN_TX } , Vector { _handler : USB_LP_CAN_RX0 } , Vector { _handler : CAN_RX1 } , Vector { _handler : CAN_SCE } , Vector { _handler : EXTI9_5 } , Vector { _handler : TIM1_BRK } , Vector { _handler : TIM1_UP } , Vector { _handler : TIM1_TRG_COM } , Vector { _handler : TIM1_CC } , Vector { _handler : TIM2 } , Vector { _handler : TIM3 } , Vector { _handler : TIM4 } , Vector { _handler : I2C1_EV } , Vector { _handler : I2C1_ER } , Vector { _handler : I2C2_EV } , Vector { _handler : I2C2_ER } , Vector { _handler : SPI1 } , Vector { _handler : SPI2 } , Vector { _handler : USART1 } , Vector { _handler : USART2 } , Vector { _handler : USART3 } , Vector { _handler : EXTI15_10 } , Vector { _handler : RTCAlarm } , Vector { _reserved : 0 } , Vector { _handler : TIM8_BRK } , Vector { _handler : TIM8_UP } , Vector { _handler : TIM8_TRG_COM } , Vector { _handler : TIM8_CC } , Vector { _handler : ADC3 } , Vector { _handler : FSMC } , Vector { _handler : SDIO } , Vector { _handler : TIM5 } , Vector { _handler : SPI3 } , Vector { _handler : UART4 } , Vector { _handler : UART5 } , Vector { _handler : TIM6 } , Vector { _handler : TIM7 } , Vector { _handler : DMA2_Channel1 } , Vector { _handler : DMA2_Channel2 } , Vector { _handler : DMA2_Channel3 } , Vector { _handler : DMA2_Channel4_5 } ,] ;
#[doc = r"Enumeration of all the interrupts."]
#[derive (Copy , Clone , Debug , PartialEq , Eq)]
#[repr (u16)] pub enum Interrupt {
#[doc = "0 - Window Watchdog interrupt"] WWDG = 0 ,
#[doc = "1 - PVD through EXTI line detection interrupt"] PVD = 1 ,
#[doc = "2 - Tamper interrupt"] TAMPER = 2 ,
#[doc = "3 - RTC global interrupt"] RTC = 3 ,
#[doc = "4 - Flash global interrupt"] FLASH = 4 ,
#[doc = "5 - RCC global interrupt"] RCC = 5 ,
#[doc = "6 - EXTI Line0 interrupt"] EXTI0 = 6 ,
#[doc = "7 - EXTI Line1 interrupt"] EXTI1 = 7 ,
#[doc = "8 - EXTI Line2 interrupt"] EXTI2 = 8 ,
#[doc = "9 - EXTI Line3 interrupt"] EXTI3 = 9 ,
#[doc = "10 - EXTI Line4 interrupt"] EXTI4 = 10 ,
#[doc = "11 - DMA1 Channel1 global interrupt"] DMA1_Channel1 = 11 ,
#[doc = "12 - DMA1 Channel2 global interrupt"] DMA1_Channel2 = 12 ,
#[doc = "13 - DMA1 Channel3 global interrupt"] DMA1_Channel3 = 13 ,
#[doc = "14 - DMA1 Channel4 global interrupt"] DMA1_Channel4 = 14 ,
#[doc = "15 - DMA1 Channel5 global interrupt"] DMA1_Channel5 = 15 ,
#[doc = "16 - DMA1 Channel6 global interrupt"] DMA1_Channel6 = 16 ,
#[doc = "17 - DMA1 Channel7 global interrupt"] DMA1_Channel7 = 17 ,
#[doc = "18 - ADC1 and ADC2 global interrupt"] ADC1_2 = 18 ,
#[doc = "19 - USB High Priority or CAN TX interrupts"] USB_HP_CAN_TX = 19 ,
#[doc = "20 - USB Low Priority or CAN RX0 interrupts"] USB_LP_CAN_RX0 = 20 ,
#[doc = "21 - CAN RX1 interrupt"] CAN_RX1 = 21 ,
#[doc = "22 - CAN SCE interrupt"] CAN_SCE = 22 ,
#[doc = "23 - EXTI Line\\[9:5\\] interrupts"] EXTI9_5 = 23 ,
#[doc = "24 - TIM1 Break interrupt"] TIM1_BRK = 24 ,
#[doc = "25 - TIM1 Update interrupt"] TIM1_UP = 25 ,
#[doc = "26 - TIM1 Trigger and Commutation interrupts"] TIM1_TRG_COM = 26 ,
#[doc = "27 - TIM1 Capture Compare interrupt"] TIM1_CC = 27 ,
#[doc = "28 - TIM2 global interrupt"] TIM2 = 28 ,
#[doc = "29 - TIM3 global interrupt"] TIM3 = 29 ,
#[doc = "30 - TIM4 global interrupt"] TIM4 = 30 ,
#[doc = "31 - I2C1 event interrupt"] I2C1_EV = 31 ,
#[doc = "32 - I2C1 error interrupt"] I2C1_ER = 32 ,
#[doc = "33 - I2C2 event interrupt"] I2C2_EV = 33 ,
#[doc = "34 - I2C2 error interrupt"] I2C2_ER = 34 ,
#[doc = "35 - SPI1 global interrupt"] SPI1 = 35 ,
#[doc = "36 - SPI2 global interrupt"] SPI2 = 36 ,
#[doc = "37 - USART1 global interrupt"] USART1 = 37 ,
#[doc = "38 - USART2 global interrupt"] USART2 = 38 ,
#[doc = "39 - USART3 global interrupt"] USART3 = 39 ,
#[doc = "40 - EXTI Line\\[15:10\\] interrupts"] EXTI15_10 = 40 ,
#[doc = "41 - RTC Alarms through EXTI line interrupt"] RTCAlarm = 41 ,
#[doc = "43 - TIM8 Break interrupt"] TIM8_BRK = 43 ,
#[doc = "44 - TIM8 Update interrupt"] TIM8_UP = 44 ,
#[doc = "45 - TIM8 Trigger and Commutation interrupts"] TIM8_TRG_COM = 45 ,
#[doc = "46 - TIM8 Capture Compare interrupt"] TIM8_CC = 46 ,
#[doc = "47 - ADC3 global interrupt"] ADC3 = 47 ,
#[doc = "48 - FSMC global interrupt"] FSMC = 48 ,
#[doc = "49 - SDIO global interrupt"] SDIO = 49 ,
#[doc = "50 - TIM5 global interrupt"] TIM5 = 50 ,
#[doc = "51 - SPI3 global interrupt"] SPI3 = 51 ,
#[doc = "52 - UART4 global interrupt"] UART4 = 52 ,
#[doc = "53 - UART5 global interrupt"] UART5 = 53 ,
#[doc = "54 - TIM6 global interrupt"] TIM6 = 54 ,
#[doc = "55 - TIM7 global interrupt"] TIM7 = 55 ,
#[doc = "56 - DMA2 Channel1 global interrupt"] DMA2_Channel1 = 56 ,
#[doc = "57 - DMA2 Channel2 global interrupt"] DMA2_Channel2 = 57 ,
#[doc = "58 - DMA2 Channel3 global interrupt"] DMA2_Channel3 = 58 ,
#[doc = "59 - DMA2 Channel4 and DMA2 Channel5 global interrupt"] DMA2_Channel4_5 = 59 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt {
#[inline (always)] fn number (self) -> u16 { self as u16 } }
#[doc = "Flexible static memory controller"] pub type Fsmc = crate :: Periph < fsmc :: RegisterBlock , 0xa000_0000 > ; impl core :: fmt :: Debug for Fsmc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fsmc") . finish () } }
#[doc = "Flexible static memory controller"] pub mod fsmc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { bcr1 : Bcr1 , btr1 : Btr1 , bcr2 : Bcr2 , btr2 : Btr2 , bcr3 : Bcr3 , btr3 : Btr3 , bcr4 : Bcr4 , btr4 : Btr4 , _reserved8 : [u8 ; 0x40] , pcr2 : Pcr2 , sr2 : Sr2 , pmem2 : Pmem2 , patt2 : Patt2 , _reserved12 : [u8 ; 0x04] , eccr2 : Eccr2 , _reserved13 : [u8 ; 0x08] , pcr3 : Pcr3 , sr3 : Sr3 , pmem3 : Pmem3 , patt3 : Patt3 , _reserved17 : [u8 ; 0x04] , eccr3 : Eccr3 , _reserved18 : [u8 ; 0x08] , pcr4 : Pcr4 , sr4 : Sr4 , pmem4 : Pmem4 , patt4 : Patt4 , pio4 : Pio4 , _reserved23 : [u8 ; 0x50] , bwtr1 : Bwtr1 , _reserved24 : [u8 ; 0x04] , bwtr2 : Bwtr2 , _reserved25 : [u8 ; 0x04] , bwtr3 : Bwtr3 , _reserved26 : [u8 ; 0x04] , bwtr4 : Bwtr4 , } impl RegisterBlock {
#[doc = "0x00 - SRAM/NOR-Flash chip-select control register 1"]
#[inline (always)] pub const fn bcr1 (& self) -> & Bcr1 { & self . bcr1 }
#[doc = "0x04 - SRAM/NOR-Flash chip-select timing register 1"]
#[inline (always)] pub const fn btr1 (& self) -> & Btr1 { & self . btr1 }
#[doc = "0x08 - SRAM/NOR-Flash chip-select control register 2"]
#[inline (always)] pub const fn bcr2 (& self) -> & Bcr2 { & self . bcr2 }
#[doc = "0x0c - SRAM/NOR-Flash chip-select timing register 2"]
#[inline (always)] pub const fn btr2 (& self) -> & Btr2 { & self . btr2 }
#[doc = "0x10 - SRAM/NOR-Flash chip-select control register 3"]
#[inline (always)] pub const fn bcr3 (& self) -> & Bcr3 { & self . bcr3 }
#[doc = "0x14 - SRAM/NOR-Flash chip-select timing register 3"]
#[inline (always)] pub const fn btr3 (& self) -> & Btr3 { & self . btr3 }
#[doc = "0x18 - SRAM/NOR-Flash chip-select control register 4"]
#[inline (always)] pub const fn bcr4 (& self) -> & Bcr4 { & self . bcr4 }
#[doc = "0x1c - SRAM/NOR-Flash chip-select timing register 4"]
#[inline (always)] pub const fn btr4 (& self) -> & Btr4 { & self . btr4 }
#[doc = "0x60 - PC Card/NAND Flash control register 2"]
#[inline (always)] pub const fn pcr2 (& self) -> & Pcr2 { & self . pcr2 }
#[doc = "0x64 - FIFO status and interrupt register 2"]
#[inline (always)] pub const fn sr2 (& self) -> & Sr2 { & self . sr2 }
#[doc = "0x68 - Common memory space timing register 2"]
#[inline (always)] pub const fn pmem2 (& self) -> & Pmem2 { & self . pmem2 }
#[doc = "0x6c - Attribute memory space timing register 2"]
#[inline (always)] pub const fn patt2 (& self) -> & Patt2 { & self . patt2 }
#[doc = "0x74 - ECC result register 2"]
#[inline (always)] pub const fn eccr2 (& self) -> & Eccr2 { & self . eccr2 }
#[doc = "0x80 - PC Card/NAND Flash control register 3"]
#[inline (always)] pub const fn pcr3 (& self) -> & Pcr3 { & self . pcr3 }
#[doc = "0x84 - FIFO status and interrupt register 3"]
#[inline (always)] pub const fn sr3 (& self) -> & Sr3 { & self . sr3 }
#[doc = "0x88 - Common memory space timing register 3"]
#[inline (always)] pub const fn pmem3 (& self) -> & Pmem3 { & self . pmem3 }
#[doc = "0x8c - Attribute memory space timing register 3"]
#[inline (always)] pub const fn patt3 (& self) -> & Patt3 { & self . patt3 }
#[doc = "0x94 - ECC result register 3"]
#[inline (always)] pub const fn eccr3 (& self) -> & Eccr3 { & self . eccr3 }
#[doc = "0xa0 - PC Card/NAND Flash control register 4"]
#[inline (always)] pub const fn pcr4 (& self) -> & Pcr4 { & self . pcr4 }
#[doc = "0xa4 - FIFO status and interrupt register 4"]
#[inline (always)] pub const fn sr4 (& self) -> & Sr4 { & self . sr4 }
#[doc = "0xa8 - Common memory space timing register 4"]
#[inline (always)] pub const fn pmem4 (& self) -> & Pmem4 { & self . pmem4 }
#[doc = "0xac - Attribute memory space timing register 4"]
#[inline (always)] pub const fn patt4 (& self) -> & Patt4 { & self . patt4 }
#[doc = "0xb0 - I/O space timing register 4"]
#[inline (always)] pub const fn pio4 (& self) -> & Pio4 { & self . pio4 }
#[doc = "0x104 - SRAM/NOR-Flash write timing registers 1"]
#[inline (always)] pub const fn bwtr1 (& self) -> & Bwtr1 { & self . bwtr1 }
#[doc = "0x10c - SRAM/NOR-Flash write timing registers 2"]
#[inline (always)] pub const fn bwtr2 (& self) -> & Bwtr2 { & self . bwtr2 }
#[doc = "0x114 - SRAM/NOR-Flash write timing registers 3"]
#[inline (always)] pub const fn bwtr3 (& self) -> & Bwtr3 { & self . bwtr3 }
#[doc = "0x11c - SRAM/NOR-Flash write timing registers 4"]
#[inline (always)] pub const fn bwtr4 (& self) -> & Bwtr4 { & self . bwtr4 } }
#[doc = "BCR1 (rw) register accessor: SRAM/NOR-Flash chip-select control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcr1`] module"]
#[doc (alias = "BCR1")] pub type Bcr1 = crate :: Reg < bcr1 :: Bcr1Spec > ;
#[doc = "SRAM/NOR-Flash chip-select control register 1"] pub mod bcr1 {
#[doc = "Register `BCR1` reader"] pub type R = crate :: R < Bcr1Spec > ;
#[doc = "Register `BCR1` writer"] pub type W = crate :: W < Bcr1Spec > ;
#[doc = "Field `MBKEN` reader - MBKEN"] pub type MbkenR = crate :: BitReader ;
#[doc = "Field `MBKEN` writer - MBKEN"] pub type MbkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUXEN` reader - MUXEN"] pub type MuxenR = crate :: BitReader ;
#[doc = "Field `MUXEN` writer - MUXEN"] pub type MuxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MTYP` reader - MTYP"] pub type MtypR = crate :: FieldReader ;
#[doc = "Field `MTYP` writer - MTYP"] pub type MtypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MWID` reader - MWID"] pub type MwidR = crate :: FieldReader ;
#[doc = "Field `MWID` writer - MWID"] pub type MwidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `FACCEN` reader - FACCEN"] pub type FaccenR = crate :: BitReader ;
#[doc = "Field `FACCEN` writer - FACCEN"] pub type FaccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BURSTEN` reader - BURSTEN"] pub type BurstenR = crate :: BitReader ;
#[doc = "Field `BURSTEN` writer - BURSTEN"] pub type BurstenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITPOL` reader - WAITPOL"] pub type WaitpolR = crate :: BitReader ;
#[doc = "Field `WAITPOL` writer - WAITPOL"] pub type WaitpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITCFG` reader - WAITCFG"] pub type WaitcfgR = crate :: BitReader ;
#[doc = "Field `WAITCFG` writer - WAITCFG"] pub type WaitcfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WREN` reader - WREN"] pub type WrenR = crate :: BitReader ;
#[doc = "Field `WREN` writer - WREN"] pub type WrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITEN` reader - WAITEN"] pub type WaitenR = crate :: BitReader ;
#[doc = "Field `WAITEN` writer - WAITEN"] pub type WaitenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTMOD` reader - EXTMOD"] pub type ExtmodR = crate :: BitReader ;
#[doc = "Field `EXTMOD` writer - EXTMOD"] pub type ExtmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ASYNCWAIT` reader - ASYNCWAIT"] pub type AsyncwaitR = crate :: BitReader ;
#[doc = "Field `ASYNCWAIT` writer - ASYNCWAIT"] pub type AsyncwaitW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CBURSTRW` reader - CBURSTRW"] pub type CburstrwR = crate :: BitReader ;
#[doc = "Field `CBURSTRW` writer - CBURSTRW"] pub type CburstrwW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - MBKEN"]
#[inline (always)] pub fn mbken (& self) -> MbkenR { MbkenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - MUXEN"]
#[inline (always)] pub fn muxen (& self) -> MuxenR { MuxenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:3 - MTYP"]
#[inline (always)] pub fn mtyp (& self) -> MtypR { MtypR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - MWID"]
#[inline (always)] pub fn mwid (& self) -> MwidR { MwidR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - FACCEN"]
#[inline (always)] pub fn faccen (& self) -> FaccenR { FaccenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - BURSTEN"]
#[inline (always)] pub fn bursten (& self) -> BurstenR { BurstenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - WAITPOL"]
#[inline (always)] pub fn waitpol (& self) -> WaitpolR { WaitpolR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 11 - WAITCFG"]
#[inline (always)] pub fn waitcfg (& self) -> WaitcfgR { WaitcfgR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - WREN"]
#[inline (always)] pub fn wren (& self) -> WrenR { WrenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - WAITEN"]
#[inline (always)] pub fn waiten (& self) -> WaitenR { WaitenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - EXTMOD"]
#[inline (always)] pub fn extmod (& self) -> ExtmodR { ExtmodR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - ASYNCWAIT"]
#[inline (always)] pub fn asyncwait (& self) -> AsyncwaitR { AsyncwaitR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 19 - CBURSTRW"]
#[inline (always)] pub fn cburstrw (& self) -> CburstrwR { CburstrwR :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 0 - MBKEN"]
#[inline (always)] pub fn mbken (& mut self) -> MbkenW < '_ , Bcr1Spec > { MbkenW :: new (self , 0) }
#[doc = "Bit 1 - MUXEN"]
#[inline (always)] pub fn muxen (& mut self) -> MuxenW < '_ , Bcr1Spec > { MuxenW :: new (self , 1) }
#[doc = "Bits 2:3 - MTYP"]
#[inline (always)] pub fn mtyp (& mut self) -> MtypW < '_ , Bcr1Spec > { MtypW :: new (self , 2) }
#[doc = "Bits 4:5 - MWID"]
#[inline (always)] pub fn mwid (& mut self) -> MwidW < '_ , Bcr1Spec > { MwidW :: new (self , 4) }
#[doc = "Bit 6 - FACCEN"]
#[inline (always)] pub fn faccen (& mut self) -> FaccenW < '_ , Bcr1Spec > { FaccenW :: new (self , 6) }
#[doc = "Bit 8 - BURSTEN"]
#[inline (always)] pub fn bursten (& mut self) -> BurstenW < '_ , Bcr1Spec > { BurstenW :: new (self , 8) }
#[doc = "Bit 9 - WAITPOL"]
#[inline (always)] pub fn waitpol (& mut self) -> WaitpolW < '_ , Bcr1Spec > { WaitpolW :: new (self , 9) }
#[doc = "Bit 11 - WAITCFG"]
#[inline (always)] pub fn waitcfg (& mut self) -> WaitcfgW < '_ , Bcr1Spec > { WaitcfgW :: new (self , 11) }
#[doc = "Bit 12 - WREN"]
#[inline (always)] pub fn wren (& mut self) -> WrenW < '_ , Bcr1Spec > { WrenW :: new (self , 12) }
#[doc = "Bit 13 - WAITEN"]
#[inline (always)] pub fn waiten (& mut self) -> WaitenW < '_ , Bcr1Spec > { WaitenW :: new (self , 13) }
#[doc = "Bit 14 - EXTMOD"]
#[inline (always)] pub fn extmod (& mut self) -> ExtmodW < '_ , Bcr1Spec > { ExtmodW :: new (self , 14) }
#[doc = "Bit 15 - ASYNCWAIT"]
#[inline (always)] pub fn asyncwait (& mut self) -> AsyncwaitW < '_ , Bcr1Spec > { AsyncwaitW :: new (self , 15) }
#[doc = "Bit 19 - CBURSTRW"]
#[inline (always)] pub fn cburstrw (& mut self) -> CburstrwW < '_ , Bcr1Spec > { CburstrwW :: new (self , 19) } }
#[doc = "SRAM/NOR-Flash chip-select control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bcr1Spec ; impl crate :: RegisterSpec for Bcr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bcr1::R`](R) reader structure"] impl crate :: Readable for Bcr1Spec { }
#[doc = "`write(|w| ..)` method takes [`bcr1::W`](W) writer structure"] impl crate :: Writable for Bcr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BCR1 to value 0x30d0"] impl crate :: Resettable for Bcr1Spec { const RESET_VALUE : u32 = 0x30d0 ; } }
#[doc = "BTR1 (rw) register accessor: SRAM/NOR-Flash chip-select timing register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`btr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@btr1`] module"]
#[doc (alias = "BTR1")] pub type Btr1 = crate :: Reg < btr1 :: Btr1Spec > ;
#[doc = "SRAM/NOR-Flash chip-select timing register 1"] pub mod btr1 {
#[doc = "Register `BTR1` reader"] pub type R = crate :: R < Btr1Spec > ;
#[doc = "Register `BTR1` writer"] pub type W = crate :: W < Btr1Spec > ;
#[doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ;
#[doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ;
#[doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ;
#[doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `BUSTURN` reader - BUSTURN"] pub type BusturnR = crate :: FieldReader ;
#[doc = "Field `BUSTURN` writer - BUSTURN"] pub type BusturnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CLKDIV` reader - CLKDIV"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - CLKDIV"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATLAT` reader - DATLAT"] pub type DatlatR = crate :: FieldReader ;
#[doc = "Field `DATLAT` writer - DATLAT"] pub type DatlatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader ;
#[doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:19 - BUSTURN"]
#[inline (always)] pub fn busturn (& self) -> BusturnR { BusturnR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& self) -> DatlatR { DatlatR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& mut self) -> AddsetW < '_ , Btr1Spec > { AddsetW :: new (self , 0) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& mut self) -> AddhldW < '_ , Btr1Spec > { AddhldW :: new (self , 4) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& mut self) -> DatastW < '_ , Btr1Spec > { DatastW :: new (self , 8) }
#[doc = "Bits 16:19 - BUSTURN"]
#[inline (always)] pub fn busturn (& mut self) -> BusturnW < '_ , Btr1Spec > { BusturnW :: new (self , 16) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , Btr1Spec > { ClkdivW :: new (self , 20) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& mut self) -> DatlatW < '_ , Btr1Spec > { DatlatW :: new (self , 24) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& mut self) -> AccmodW < '_ , Btr1Spec > { AccmodW :: new (self , 28) } }
#[doc = "SRAM/NOR-Flash chip-select timing register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`btr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Btr1Spec ; impl crate :: RegisterSpec for Btr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`btr1::R`](R) reader structure"] impl crate :: Readable for Btr1Spec { }
#[doc = "`write(|w| ..)` method takes [`btr1::W`](W) writer structure"] impl crate :: Writable for Btr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BTR1 to value 0xffff_ffff"] impl crate :: Resettable for Btr1Spec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "BCR2 (rw) register accessor: SRAM/NOR-Flash chip-select control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcr2`] module"]
#[doc (alias = "BCR2")] pub type Bcr2 = crate :: Reg < bcr2 :: Bcr2Spec > ;
#[doc = "SRAM/NOR-Flash chip-select control register 2"] pub mod bcr2 {
#[doc = "Register `BCR2` reader"] pub type R = crate :: R < Bcr2Spec > ;
#[doc = "Register `BCR2` writer"] pub type W = crate :: W < Bcr2Spec > ;
#[doc = "Field `MBKEN` reader - MBKEN"] pub type MbkenR = crate :: BitReader ;
#[doc = "Field `MBKEN` writer - MBKEN"] pub type MbkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUXEN` reader - MUXEN"] pub type MuxenR = crate :: BitReader ;
#[doc = "Field `MUXEN` writer - MUXEN"] pub type MuxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MTYP` reader - MTYP"] pub type MtypR = crate :: FieldReader ;
#[doc = "Field `MTYP` writer - MTYP"] pub type MtypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MWID` reader - MWID"] pub type MwidR = crate :: FieldReader ;
#[doc = "Field `MWID` writer - MWID"] pub type MwidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `FACCEN` reader - FACCEN"] pub type FaccenR = crate :: BitReader ;
#[doc = "Field `FACCEN` writer - FACCEN"] pub type FaccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BURSTEN` reader - BURSTEN"] pub type BurstenR = crate :: BitReader ;
#[doc = "Field `BURSTEN` writer - BURSTEN"] pub type BurstenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITPOL` reader - WAITPOL"] pub type WaitpolR = crate :: BitReader ;
#[doc = "Field `WAITPOL` writer - WAITPOL"] pub type WaitpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WRAPMOD` reader - WRAPMOD"] pub type WrapmodR = crate :: BitReader ;
#[doc = "Field `WRAPMOD` writer - WRAPMOD"] pub type WrapmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITCFG` reader - WAITCFG"] pub type WaitcfgR = crate :: BitReader ;
#[doc = "Field `WAITCFG` writer - WAITCFG"] pub type WaitcfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WREN` reader - WREN"] pub type WrenR = crate :: BitReader ;
#[doc = "Field `WREN` writer - WREN"] pub type WrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITEN` reader - WAITEN"] pub type WaitenR = crate :: BitReader ;
#[doc = "Field `WAITEN` writer - WAITEN"] pub type WaitenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTMOD` reader - EXTMOD"] pub type ExtmodR = crate :: BitReader ;
#[doc = "Field `EXTMOD` writer - EXTMOD"] pub type ExtmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ASYNCWAIT` reader - ASYNCWAIT"] pub type AsyncwaitR = crate :: BitReader ;
#[doc = "Field `ASYNCWAIT` writer - ASYNCWAIT"] pub type AsyncwaitW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CBURSTRW` reader - CBURSTRW"] pub type CburstrwR = crate :: BitReader ;
#[doc = "Field `CBURSTRW` writer - CBURSTRW"] pub type CburstrwW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - MBKEN"]
#[inline (always)] pub fn mbken (& self) -> MbkenR { MbkenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - MUXEN"]
#[inline (always)] pub fn muxen (& self) -> MuxenR { MuxenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:3 - MTYP"]
#[inline (always)] pub fn mtyp (& self) -> MtypR { MtypR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - MWID"]
#[inline (always)] pub fn mwid (& self) -> MwidR { MwidR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - FACCEN"]
#[inline (always)] pub fn faccen (& self) -> FaccenR { FaccenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - BURSTEN"]
#[inline (always)] pub fn bursten (& self) -> BurstenR { BurstenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - WAITPOL"]
#[inline (always)] pub fn waitpol (& self) -> WaitpolR { WaitpolR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - WRAPMOD"]
#[inline (always)] pub fn wrapmod (& self) -> WrapmodR { WrapmodR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - WAITCFG"]
#[inline (always)] pub fn waitcfg (& self) -> WaitcfgR { WaitcfgR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - WREN"]
#[inline (always)] pub fn wren (& self) -> WrenR { WrenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - WAITEN"]
#[inline (always)] pub fn waiten (& self) -> WaitenR { WaitenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - EXTMOD"]
#[inline (always)] pub fn extmod (& self) -> ExtmodR { ExtmodR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - ASYNCWAIT"]
#[inline (always)] pub fn asyncwait (& self) -> AsyncwaitR { AsyncwaitR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 19 - CBURSTRW"]
#[inline (always)] pub fn cburstrw (& self) -> CburstrwR { CburstrwR :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 0 - MBKEN"]
#[inline (always)] pub fn mbken (& mut self) -> MbkenW < '_ , Bcr2Spec > { MbkenW :: new (self , 0) }
#[doc = "Bit 1 - MUXEN"]
#[inline (always)] pub fn muxen (& mut self) -> MuxenW < '_ , Bcr2Spec > { MuxenW :: new (self , 1) }
#[doc = "Bits 2:3 - MTYP"]
#[inline (always)] pub fn mtyp (& mut self) -> MtypW < '_ , Bcr2Spec > { MtypW :: new (self , 2) }
#[doc = "Bits 4:5 - MWID"]
#[inline (always)] pub fn mwid (& mut self) -> MwidW < '_ , Bcr2Spec > { MwidW :: new (self , 4) }
#[doc = "Bit 6 - FACCEN"]
#[inline (always)] pub fn faccen (& mut self) -> FaccenW < '_ , Bcr2Spec > { FaccenW :: new (self , 6) }
#[doc = "Bit 8 - BURSTEN"]
#[inline (always)] pub fn bursten (& mut self) -> BurstenW < '_ , Bcr2Spec > { BurstenW :: new (self , 8) }
#[doc = "Bit 9 - WAITPOL"]
#[inline (always)] pub fn waitpol (& mut self) -> WaitpolW < '_ , Bcr2Spec > { WaitpolW :: new (self , 9) }
#[doc = "Bit 10 - WRAPMOD"]
#[inline (always)] pub fn wrapmod (& mut self) -> WrapmodW < '_ , Bcr2Spec > { WrapmodW :: new (self , 10) }
#[doc = "Bit 11 - WAITCFG"]
#[inline (always)] pub fn waitcfg (& mut self) -> WaitcfgW < '_ , Bcr2Spec > { WaitcfgW :: new (self , 11) }
#[doc = "Bit 12 - WREN"]
#[inline (always)] pub fn wren (& mut self) -> WrenW < '_ , Bcr2Spec > { WrenW :: new (self , 12) }
#[doc = "Bit 13 - WAITEN"]
#[inline (always)] pub fn waiten (& mut self) -> WaitenW < '_ , Bcr2Spec > { WaitenW :: new (self , 13) }
#[doc = "Bit 14 - EXTMOD"]
#[inline (always)] pub fn extmod (& mut self) -> ExtmodW < '_ , Bcr2Spec > { ExtmodW :: new (self , 14) }
#[doc = "Bit 15 - ASYNCWAIT"]
#[inline (always)] pub fn asyncwait (& mut self) -> AsyncwaitW < '_ , Bcr2Spec > { AsyncwaitW :: new (self , 15) }
#[doc = "Bit 19 - CBURSTRW"]
#[inline (always)] pub fn cburstrw (& mut self) -> CburstrwW < '_ , Bcr2Spec > { CburstrwW :: new (self , 19) } }
#[doc = "SRAM/NOR-Flash chip-select control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bcr2Spec ; impl crate :: RegisterSpec for Bcr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bcr2::R`](R) reader structure"] impl crate :: Readable for Bcr2Spec { }
#[doc = "`write(|w| ..)` method takes [`bcr2::W`](W) writer structure"] impl crate :: Writable for Bcr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BCR2 to value 0x30d0"] impl crate :: Resettable for Bcr2Spec { const RESET_VALUE : u32 = 0x30d0 ; } }
#[doc = "BTR2 (rw) register accessor: SRAM/NOR-Flash chip-select timing register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`btr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@btr2`] module"]
#[doc (alias = "BTR2")] pub type Btr2 = crate :: Reg < btr2 :: Btr2Spec > ;
#[doc = "SRAM/NOR-Flash chip-select timing register 2"] pub mod btr2 {
#[doc = "Register `BTR2` reader"] pub type R = crate :: R < Btr2Spec > ;
#[doc = "Register `BTR2` writer"] pub type W = crate :: W < Btr2Spec > ;
#[doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ;
#[doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ;
#[doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ;
#[doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `BUSTURN` reader - BUSTURN"] pub type BusturnR = crate :: FieldReader ;
#[doc = "Field `BUSTURN` writer - BUSTURN"] pub type BusturnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CLKDIV` reader - CLKDIV"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - CLKDIV"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATLAT` reader - DATLAT"] pub type DatlatR = crate :: FieldReader ;
#[doc = "Field `DATLAT` writer - DATLAT"] pub type DatlatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader ;
#[doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:19 - BUSTURN"]
#[inline (always)] pub fn busturn (& self) -> BusturnR { BusturnR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& self) -> DatlatR { DatlatR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& mut self) -> AddsetW < '_ , Btr2Spec > { AddsetW :: new (self , 0) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& mut self) -> AddhldW < '_ , Btr2Spec > { AddhldW :: new (self , 4) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& mut self) -> DatastW < '_ , Btr2Spec > { DatastW :: new (self , 8) }
#[doc = "Bits 16:19 - BUSTURN"]
#[inline (always)] pub fn busturn (& mut self) -> BusturnW < '_ , Btr2Spec > { BusturnW :: new (self , 16) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , Btr2Spec > { ClkdivW :: new (self , 20) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& mut self) -> DatlatW < '_ , Btr2Spec > { DatlatW :: new (self , 24) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& mut self) -> AccmodW < '_ , Btr2Spec > { AccmodW :: new (self , 28) } }
#[doc = "SRAM/NOR-Flash chip-select timing register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`btr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Btr2Spec ; impl crate :: RegisterSpec for Btr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`btr2::R`](R) reader structure"] impl crate :: Readable for Btr2Spec { }
#[doc = "`write(|w| ..)` method takes [`btr2::W`](W) writer structure"] impl crate :: Writable for Btr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BTR2 to value 0xffff_ffff"] impl crate :: Resettable for Btr2Spec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "BCR3 (rw) register accessor: SRAM/NOR-Flash chip-select control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcr3`] module"]
#[doc (alias = "BCR3")] pub type Bcr3 = crate :: Reg < bcr3 :: Bcr3Spec > ;
#[doc = "SRAM/NOR-Flash chip-select control register 3"] pub mod bcr3 {
#[doc = "Register `BCR3` reader"] pub type R = crate :: R < Bcr3Spec > ;
#[doc = "Register `BCR3` writer"] pub type W = crate :: W < Bcr3Spec > ;
#[doc = "Field `MBKEN` reader - MBKEN"] pub type MbkenR = crate :: BitReader ;
#[doc = "Field `MBKEN` writer - MBKEN"] pub type MbkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUXEN` reader - MUXEN"] pub type MuxenR = crate :: BitReader ;
#[doc = "Field `MUXEN` writer - MUXEN"] pub type MuxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MTYP` reader - MTYP"] pub type MtypR = crate :: FieldReader ;
#[doc = "Field `MTYP` writer - MTYP"] pub type MtypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MWID` reader - MWID"] pub type MwidR = crate :: FieldReader ;
#[doc = "Field `MWID` writer - MWID"] pub type MwidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `FACCEN` reader - FACCEN"] pub type FaccenR = crate :: BitReader ;
#[doc = "Field `FACCEN` writer - FACCEN"] pub type FaccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BURSTEN` reader - BURSTEN"] pub type BurstenR = crate :: BitReader ;
#[doc = "Field `BURSTEN` writer - BURSTEN"] pub type BurstenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITPOL` reader - WAITPOL"] pub type WaitpolR = crate :: BitReader ;
#[doc = "Field `WAITPOL` writer - WAITPOL"] pub type WaitpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WRAPMOD` reader - WRAPMOD"] pub type WrapmodR = crate :: BitReader ;
#[doc = "Field `WRAPMOD` writer - WRAPMOD"] pub type WrapmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITCFG` reader - WAITCFG"] pub type WaitcfgR = crate :: BitReader ;
#[doc = "Field `WAITCFG` writer - WAITCFG"] pub type WaitcfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WREN` reader - WREN"] pub type WrenR = crate :: BitReader ;
#[doc = "Field `WREN` writer - WREN"] pub type WrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITEN` reader - WAITEN"] pub type WaitenR = crate :: BitReader ;
#[doc = "Field `WAITEN` writer - WAITEN"] pub type WaitenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTMOD` reader - EXTMOD"] pub type ExtmodR = crate :: BitReader ;
#[doc = "Field `EXTMOD` writer - EXTMOD"] pub type ExtmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ASYNCWAIT` reader - ASYNCWAIT"] pub type AsyncwaitR = crate :: BitReader ;
#[doc = "Field `ASYNCWAIT` writer - ASYNCWAIT"] pub type AsyncwaitW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CBURSTRW` reader - CBURSTRW"] pub type CburstrwR = crate :: BitReader ;
#[doc = "Field `CBURSTRW` writer - CBURSTRW"] pub type CburstrwW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - MBKEN"]
#[inline (always)] pub fn mbken (& self) -> MbkenR { MbkenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - MUXEN"]
#[inline (always)] pub fn muxen (& self) -> MuxenR { MuxenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:3 - MTYP"]
#[inline (always)] pub fn mtyp (& self) -> MtypR { MtypR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - MWID"]
#[inline (always)] pub fn mwid (& self) -> MwidR { MwidR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - FACCEN"]
#[inline (always)] pub fn faccen (& self) -> FaccenR { FaccenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - BURSTEN"]
#[inline (always)] pub fn bursten (& self) -> BurstenR { BurstenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - WAITPOL"]
#[inline (always)] pub fn waitpol (& self) -> WaitpolR { WaitpolR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - WRAPMOD"]
#[inline (always)] pub fn wrapmod (& self) -> WrapmodR { WrapmodR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - WAITCFG"]
#[inline (always)] pub fn waitcfg (& self) -> WaitcfgR { WaitcfgR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - WREN"]
#[inline (always)] pub fn wren (& self) -> WrenR { WrenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - WAITEN"]
#[inline (always)] pub fn waiten (& self) -> WaitenR { WaitenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - EXTMOD"]
#[inline (always)] pub fn extmod (& self) -> ExtmodR { ExtmodR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - ASYNCWAIT"]
#[inline (always)] pub fn asyncwait (& self) -> AsyncwaitR { AsyncwaitR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 19 - CBURSTRW"]
#[inline (always)] pub fn cburstrw (& self) -> CburstrwR { CburstrwR :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 0 - MBKEN"]
#[inline (always)] pub fn mbken (& mut self) -> MbkenW < '_ , Bcr3Spec > { MbkenW :: new (self , 0) }
#[doc = "Bit 1 - MUXEN"]
#[inline (always)] pub fn muxen (& mut self) -> MuxenW < '_ , Bcr3Spec > { MuxenW :: new (self , 1) }
#[doc = "Bits 2:3 - MTYP"]
#[inline (always)] pub fn mtyp (& mut self) -> MtypW < '_ , Bcr3Spec > { MtypW :: new (self , 2) }
#[doc = "Bits 4:5 - MWID"]
#[inline (always)] pub fn mwid (& mut self) -> MwidW < '_ , Bcr3Spec > { MwidW :: new (self , 4) }
#[doc = "Bit 6 - FACCEN"]
#[inline (always)] pub fn faccen (& mut self) -> FaccenW < '_ , Bcr3Spec > { FaccenW :: new (self , 6) }
#[doc = "Bit 8 - BURSTEN"]
#[inline (always)] pub fn bursten (& mut self) -> BurstenW < '_ , Bcr3Spec > { BurstenW :: new (self , 8) }
#[doc = "Bit 9 - WAITPOL"]
#[inline (always)] pub fn waitpol (& mut self) -> WaitpolW < '_ , Bcr3Spec > { WaitpolW :: new (self , 9) }
#[doc = "Bit 10 - WRAPMOD"]
#[inline (always)] pub fn wrapmod (& mut self) -> WrapmodW < '_ , Bcr3Spec > { WrapmodW :: new (self , 10) }
#[doc = "Bit 11 - WAITCFG"]
#[inline (always)] pub fn waitcfg (& mut self) -> WaitcfgW < '_ , Bcr3Spec > { WaitcfgW :: new (self , 11) }
#[doc = "Bit 12 - WREN"]
#[inline (always)] pub fn wren (& mut self) -> WrenW < '_ , Bcr3Spec > { WrenW :: new (self , 12) }
#[doc = "Bit 13 - WAITEN"]
#[inline (always)] pub fn waiten (& mut self) -> WaitenW < '_ , Bcr3Spec > { WaitenW :: new (self , 13) }
#[doc = "Bit 14 - EXTMOD"]
#[inline (always)] pub fn extmod (& mut self) -> ExtmodW < '_ , Bcr3Spec > { ExtmodW :: new (self , 14) }
#[doc = "Bit 15 - ASYNCWAIT"]
#[inline (always)] pub fn asyncwait (& mut self) -> AsyncwaitW < '_ , Bcr3Spec > { AsyncwaitW :: new (self , 15) }
#[doc = "Bit 19 - CBURSTRW"]
#[inline (always)] pub fn cburstrw (& mut self) -> CburstrwW < '_ , Bcr3Spec > { CburstrwW :: new (self , 19) } }
#[doc = "SRAM/NOR-Flash chip-select control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bcr3Spec ; impl crate :: RegisterSpec for Bcr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bcr3::R`](R) reader structure"] impl crate :: Readable for Bcr3Spec { }
#[doc = "`write(|w| ..)` method takes [`bcr3::W`](W) writer structure"] impl crate :: Writable for Bcr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BCR3 to value 0x30d0"] impl crate :: Resettable for Bcr3Spec { const RESET_VALUE : u32 = 0x30d0 ; } }
#[doc = "BTR3 (rw) register accessor: SRAM/NOR-Flash chip-select timing register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`btr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@btr3`] module"]
#[doc (alias = "BTR3")] pub type Btr3 = crate :: Reg < btr3 :: Btr3Spec > ;
#[doc = "SRAM/NOR-Flash chip-select timing register 3"] pub mod btr3 {
#[doc = "Register `BTR3` reader"] pub type R = crate :: R < Btr3Spec > ;
#[doc = "Register `BTR3` writer"] pub type W = crate :: W < Btr3Spec > ;
#[doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ;
#[doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ;
#[doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ;
#[doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `BUSTURN` reader - BUSTURN"] pub type BusturnR = crate :: FieldReader ;
#[doc = "Field `BUSTURN` writer - BUSTURN"] pub type BusturnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CLKDIV` reader - CLKDIV"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - CLKDIV"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATLAT` reader - DATLAT"] pub type DatlatR = crate :: FieldReader ;
#[doc = "Field `DATLAT` writer - DATLAT"] pub type DatlatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader ;
#[doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:19 - BUSTURN"]
#[inline (always)] pub fn busturn (& self) -> BusturnR { BusturnR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& self) -> DatlatR { DatlatR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& mut self) -> AddsetW < '_ , Btr3Spec > { AddsetW :: new (self , 0) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& mut self) -> AddhldW < '_ , Btr3Spec > { AddhldW :: new (self , 4) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& mut self) -> DatastW < '_ , Btr3Spec > { DatastW :: new (self , 8) }
#[doc = "Bits 16:19 - BUSTURN"]
#[inline (always)] pub fn busturn (& mut self) -> BusturnW < '_ , Btr3Spec > { BusturnW :: new (self , 16) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , Btr3Spec > { ClkdivW :: new (self , 20) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& mut self) -> DatlatW < '_ , Btr3Spec > { DatlatW :: new (self , 24) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& mut self) -> AccmodW < '_ , Btr3Spec > { AccmodW :: new (self , 28) } }
#[doc = "SRAM/NOR-Flash chip-select timing register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`btr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Btr3Spec ; impl crate :: RegisterSpec for Btr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`btr3::R`](R) reader structure"] impl crate :: Readable for Btr3Spec { }
#[doc = "`write(|w| ..)` method takes [`btr3::W`](W) writer structure"] impl crate :: Writable for Btr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BTR3 to value 0xffff_ffff"] impl crate :: Resettable for Btr3Spec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "BCR4 (rw) register accessor: SRAM/NOR-Flash chip-select control register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcr4`] module"]
#[doc (alias = "BCR4")] pub type Bcr4 = crate :: Reg < bcr4 :: Bcr4Spec > ;
#[doc = "SRAM/NOR-Flash chip-select control register 4"] pub mod bcr4 {
#[doc = "Register `BCR4` reader"] pub type R = crate :: R < Bcr4Spec > ;
#[doc = "Register `BCR4` writer"] pub type W = crate :: W < Bcr4Spec > ;
#[doc = "Field `MBKEN` reader - MBKEN"] pub type MbkenR = crate :: BitReader ;
#[doc = "Field `MBKEN` writer - MBKEN"] pub type MbkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MUXEN` reader - MUXEN"] pub type MuxenR = crate :: BitReader ;
#[doc = "Field `MUXEN` writer - MUXEN"] pub type MuxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MTYP` reader - MTYP"] pub type MtypR = crate :: FieldReader ;
#[doc = "Field `MTYP` writer - MTYP"] pub type MtypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MWID` reader - MWID"] pub type MwidR = crate :: FieldReader ;
#[doc = "Field `MWID` writer - MWID"] pub type MwidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `FACCEN` reader - FACCEN"] pub type FaccenR = crate :: BitReader ;
#[doc = "Field `FACCEN` writer - FACCEN"] pub type FaccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BURSTEN` reader - BURSTEN"] pub type BurstenR = crate :: BitReader ;
#[doc = "Field `BURSTEN` writer - BURSTEN"] pub type BurstenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITPOL` reader - WAITPOL"] pub type WaitpolR = crate :: BitReader ;
#[doc = "Field `WAITPOL` writer - WAITPOL"] pub type WaitpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WRAPMOD` reader - WRAPMOD"] pub type WrapmodR = crate :: BitReader ;
#[doc = "Field `WRAPMOD` writer - WRAPMOD"] pub type WrapmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITCFG` reader - WAITCFG"] pub type WaitcfgR = crate :: BitReader ;
#[doc = "Field `WAITCFG` writer - WAITCFG"] pub type WaitcfgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WREN` reader - WREN"] pub type WrenR = crate :: BitReader ;
#[doc = "Field `WREN` writer - WREN"] pub type WrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITEN` reader - WAITEN"] pub type WaitenR = crate :: BitReader ;
#[doc = "Field `WAITEN` writer - WAITEN"] pub type WaitenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTMOD` reader - EXTMOD"] pub type ExtmodR = crate :: BitReader ;
#[doc = "Field `EXTMOD` writer - EXTMOD"] pub type ExtmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ASYNCWAIT` reader - ASYNCWAIT"] pub type AsyncwaitR = crate :: BitReader ;
#[doc = "Field `ASYNCWAIT` writer - ASYNCWAIT"] pub type AsyncwaitW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CBURSTRW` reader - CBURSTRW"] pub type CburstrwR = crate :: BitReader ;
#[doc = "Field `CBURSTRW` writer - CBURSTRW"] pub type CburstrwW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - MBKEN"]
#[inline (always)] pub fn mbken (& self) -> MbkenR { MbkenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - MUXEN"]
#[inline (always)] pub fn muxen (& self) -> MuxenR { MuxenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:3 - MTYP"]
#[inline (always)] pub fn mtyp (& self) -> MtypR { MtypR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - MWID"]
#[inline (always)] pub fn mwid (& self) -> MwidR { MwidR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - FACCEN"]
#[inline (always)] pub fn faccen (& self) -> FaccenR { FaccenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - BURSTEN"]
#[inline (always)] pub fn bursten (& self) -> BurstenR { BurstenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - WAITPOL"]
#[inline (always)] pub fn waitpol (& self) -> WaitpolR { WaitpolR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - WRAPMOD"]
#[inline (always)] pub fn wrapmod (& self) -> WrapmodR { WrapmodR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - WAITCFG"]
#[inline (always)] pub fn waitcfg (& self) -> WaitcfgR { WaitcfgR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - WREN"]
#[inline (always)] pub fn wren (& self) -> WrenR { WrenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - WAITEN"]
#[inline (always)] pub fn waiten (& self) -> WaitenR { WaitenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - EXTMOD"]
#[inline (always)] pub fn extmod (& self) -> ExtmodR { ExtmodR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - ASYNCWAIT"]
#[inline (always)] pub fn asyncwait (& self) -> AsyncwaitR { AsyncwaitR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 19 - CBURSTRW"]
#[inline (always)] pub fn cburstrw (& self) -> CburstrwR { CburstrwR :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 0 - MBKEN"]
#[inline (always)] pub fn mbken (& mut self) -> MbkenW < '_ , Bcr4Spec > { MbkenW :: new (self , 0) }
#[doc = "Bit 1 - MUXEN"]
#[inline (always)] pub fn muxen (& mut self) -> MuxenW < '_ , Bcr4Spec > { MuxenW :: new (self , 1) }
#[doc = "Bits 2:3 - MTYP"]
#[inline (always)] pub fn mtyp (& mut self) -> MtypW < '_ , Bcr4Spec > { MtypW :: new (self , 2) }
#[doc = "Bits 4:5 - MWID"]
#[inline (always)] pub fn mwid (& mut self) -> MwidW < '_ , Bcr4Spec > { MwidW :: new (self , 4) }
#[doc = "Bit 6 - FACCEN"]
#[inline (always)] pub fn faccen (& mut self) -> FaccenW < '_ , Bcr4Spec > { FaccenW :: new (self , 6) }
#[doc = "Bit 8 - BURSTEN"]
#[inline (always)] pub fn bursten (& mut self) -> BurstenW < '_ , Bcr4Spec > { BurstenW :: new (self , 8) }
#[doc = "Bit 9 - WAITPOL"]
#[inline (always)] pub fn waitpol (& mut self) -> WaitpolW < '_ , Bcr4Spec > { WaitpolW :: new (self , 9) }
#[doc = "Bit 10 - WRAPMOD"]
#[inline (always)] pub fn wrapmod (& mut self) -> WrapmodW < '_ , Bcr4Spec > { WrapmodW :: new (self , 10) }
#[doc = "Bit 11 - WAITCFG"]
#[inline (always)] pub fn waitcfg (& mut self) -> WaitcfgW < '_ , Bcr4Spec > { WaitcfgW :: new (self , 11) }
#[doc = "Bit 12 - WREN"]
#[inline (always)] pub fn wren (& mut self) -> WrenW < '_ , Bcr4Spec > { WrenW :: new (self , 12) }
#[doc = "Bit 13 - WAITEN"]
#[inline (always)] pub fn waiten (& mut self) -> WaitenW < '_ , Bcr4Spec > { WaitenW :: new (self , 13) }
#[doc = "Bit 14 - EXTMOD"]
#[inline (always)] pub fn extmod (& mut self) -> ExtmodW < '_ , Bcr4Spec > { ExtmodW :: new (self , 14) }
#[doc = "Bit 15 - ASYNCWAIT"]
#[inline (always)] pub fn asyncwait (& mut self) -> AsyncwaitW < '_ , Bcr4Spec > { AsyncwaitW :: new (self , 15) }
#[doc = "Bit 19 - CBURSTRW"]
#[inline (always)] pub fn cburstrw (& mut self) -> CburstrwW < '_ , Bcr4Spec > { CburstrwW :: new (self , 19) } }
#[doc = "SRAM/NOR-Flash chip-select control register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bcr4Spec ; impl crate :: RegisterSpec for Bcr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bcr4::R`](R) reader structure"] impl crate :: Readable for Bcr4Spec { }
#[doc = "`write(|w| ..)` method takes [`bcr4::W`](W) writer structure"] impl crate :: Writable for Bcr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BCR4 to value 0x30d0"] impl crate :: Resettable for Bcr4Spec { const RESET_VALUE : u32 = 0x30d0 ; } }
#[doc = "BTR4 (rw) register accessor: SRAM/NOR-Flash chip-select timing register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`btr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@btr4`] module"]
#[doc (alias = "BTR4")] pub type Btr4 = crate :: Reg < btr4 :: Btr4Spec > ;
#[doc = "SRAM/NOR-Flash chip-select timing register 4"] pub mod btr4 {
#[doc = "Register `BTR4` reader"] pub type R = crate :: R < Btr4Spec > ;
#[doc = "Register `BTR4` writer"] pub type W = crate :: W < Btr4Spec > ;
#[doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ;
#[doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ;
#[doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ;
#[doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `BUSTURN` reader - BUSTURN"] pub type BusturnR = crate :: FieldReader ;
#[doc = "Field `BUSTURN` writer - BUSTURN"] pub type BusturnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CLKDIV` reader - CLKDIV"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - CLKDIV"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATLAT` reader - DATLAT"] pub type DatlatR = crate :: FieldReader ;
#[doc = "Field `DATLAT` writer - DATLAT"] pub type DatlatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader ;
#[doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:19 - BUSTURN"]
#[inline (always)] pub fn busturn (& self) -> BusturnR { BusturnR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& self) -> DatlatR { DatlatR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& mut self) -> AddsetW < '_ , Btr4Spec > { AddsetW :: new (self , 0) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& mut self) -> AddhldW < '_ , Btr4Spec > { AddhldW :: new (self , 4) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& mut self) -> DatastW < '_ , Btr4Spec > { DatastW :: new (self , 8) }
#[doc = "Bits 16:19 - BUSTURN"]
#[inline (always)] pub fn busturn (& mut self) -> BusturnW < '_ , Btr4Spec > { BusturnW :: new (self , 16) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , Btr4Spec > { ClkdivW :: new (self , 20) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& mut self) -> DatlatW < '_ , Btr4Spec > { DatlatW :: new (self , 24) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& mut self) -> AccmodW < '_ , Btr4Spec > { AccmodW :: new (self , 28) } }
#[doc = "SRAM/NOR-Flash chip-select timing register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`btr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Btr4Spec ; impl crate :: RegisterSpec for Btr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`btr4::R`](R) reader structure"] impl crate :: Readable for Btr4Spec { }
#[doc = "`write(|w| ..)` method takes [`btr4::W`](W) writer structure"] impl crate :: Writable for Btr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BTR4 to value 0xffff_ffff"] impl crate :: Resettable for Btr4Spec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "PCR2 (rw) register accessor: PC Card/NAND Flash control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`pcr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pcr2`] module"]
#[doc (alias = "PCR2")] pub type Pcr2 = crate :: Reg < pcr2 :: Pcr2Spec > ;
#[doc = "PC Card/NAND Flash control register 2"] pub mod pcr2 {
#[doc = "Register `PCR2` reader"] pub type R = crate :: R < Pcr2Spec > ;
#[doc = "Register `PCR2` writer"] pub type W = crate :: W < Pcr2Spec > ;
#[doc = "Field `PWAITEN` reader - PWAITEN"] pub type PwaitenR = crate :: BitReader ;
#[doc = "Field `PWAITEN` writer - PWAITEN"] pub type PwaitenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PBKEN` reader - PBKEN"] pub type PbkenR = crate :: BitReader ;
#[doc = "Field `PBKEN` writer - PBKEN"] pub type PbkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PTYP` reader - PTYP"] pub type PtypR = crate :: BitReader ;
#[doc = "Field `PTYP` writer - PTYP"] pub type PtypW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWID` reader - PWID"] pub type PwidR = crate :: FieldReader ;
#[doc = "Field `PWID` writer - PWID"] pub type PwidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECCEN` reader - ECCEN"] pub type EccenR = crate :: BitReader ;
#[doc = "Field `ECCEN` writer - ECCEN"] pub type EccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCLR` reader - TCLR"] pub type TclrR = crate :: FieldReader ;
#[doc = "Field `TCLR` writer - TCLR"] pub type TclrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TAR` reader - TAR"] pub type TarR = crate :: FieldReader ;
#[doc = "Field `TAR` writer - TAR"] pub type TarW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ECCPS` reader - ECCPS"] pub type EccpsR = crate :: FieldReader ;
#[doc = "Field `ECCPS` writer - ECCPS"] pub type EccpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bit 1 - PWAITEN"]
#[inline (always)] pub fn pwaiten (& self) -> PwaitenR { PwaitenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - PBKEN"]
#[inline (always)] pub fn pbken (& self) -> PbkenR { PbkenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - PTYP"]
#[inline (always)] pub fn ptyp (& self) -> PtypR { PtypR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - PWID"]
#[inline (always)] pub fn pwid (& self) -> PwidR { PwidR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - ECCEN"]
#[inline (always)] pub fn eccen (& self) -> EccenR { EccenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 9:12 - TCLR"]
#[inline (always)] pub fn tclr (& self) -> TclrR { TclrR :: new (((self . bits >> 9) & 0x0f) as u8) }
#[doc = "Bits 13:16 - TAR"]
#[inline (always)] pub fn tar (& self) -> TarR { TarR :: new (((self . bits >> 13) & 0x0f) as u8) }
#[doc = "Bits 17:19 - ECCPS"]
#[inline (always)] pub fn eccps (& self) -> EccpsR { EccpsR :: new (((self . bits >> 17) & 7) as u8) } } impl W {
#[doc = "Bit 1 - PWAITEN"]
#[inline (always)] pub fn pwaiten (& mut self) -> PwaitenW < '_ , Pcr2Spec > { PwaitenW :: new (self , 1) }
#[doc = "Bit 2 - PBKEN"]
#[inline (always)] pub fn pbken (& mut self) -> PbkenW < '_ , Pcr2Spec > { PbkenW :: new (self , 2) }
#[doc = "Bit 3 - PTYP"]
#[inline (always)] pub fn ptyp (& mut self) -> PtypW < '_ , Pcr2Spec > { PtypW :: new (self , 3) }
#[doc = "Bits 4:5 - PWID"]
#[inline (always)] pub fn pwid (& mut self) -> PwidW < '_ , Pcr2Spec > { PwidW :: new (self , 4) }
#[doc = "Bit 6 - ECCEN"]
#[inline (always)] pub fn eccen (& mut self) -> EccenW < '_ , Pcr2Spec > { EccenW :: new (self , 6) }
#[doc = "Bits 9:12 - TCLR"]
#[inline (always)] pub fn tclr (& mut self) -> TclrW < '_ , Pcr2Spec > { TclrW :: new (self , 9) }
#[doc = "Bits 13:16 - TAR"]
#[inline (always)] pub fn tar (& mut self) -> TarW < '_ , Pcr2Spec > { TarW :: new (self , 13) }
#[doc = "Bits 17:19 - ECCPS"]
#[inline (always)] pub fn eccps (& mut self) -> EccpsW < '_ , Pcr2Spec > { EccpsW :: new (self , 17) } }
#[doc = "PC Card/NAND Flash control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`pcr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pcr2Spec ; impl crate :: RegisterSpec for Pcr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pcr2::R`](R) reader structure"] impl crate :: Readable for Pcr2Spec { }
#[doc = "`write(|w| ..)` method takes [`pcr2::W`](W) writer structure"] impl crate :: Writable for Pcr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PCR2 to value 0x18"] impl crate :: Resettable for Pcr2Spec { const RESET_VALUE : u32 = 0x18 ; } }
#[doc = "SR2 (rw) register accessor: FIFO status and interrupt register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr2`] module"]
#[doc (alias = "SR2")] pub type Sr2 = crate :: Reg < sr2 :: Sr2Spec > ;
#[doc = "FIFO status and interrupt register 2"] pub mod sr2 {
#[doc = "Register `SR2` reader"] pub type R = crate :: R < Sr2Spec > ;
#[doc = "Register `SR2` writer"] pub type W = crate :: W < Sr2Spec > ;
#[doc = "Field `IRS` reader - IRS"] pub type IrsR = crate :: BitReader ;
#[doc = "Field `IRS` writer - IRS"] pub type IrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ILS` reader - ILS"] pub type IlsR = crate :: BitReader ;
#[doc = "Field `ILS` writer - ILS"] pub type IlsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFS` reader - IFS"] pub type IfsR = crate :: BitReader ;
#[doc = "Field `IFS` writer - IFS"] pub type IfsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IREN` reader - IREN"] pub type IrenR = crate :: BitReader ;
#[doc = "Field `IREN` writer - IREN"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ILEN` reader - ILEN"] pub type IlenR = crate :: BitReader ;
#[doc = "Field `ILEN` writer - ILEN"] pub type IlenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFEN` reader - IFEN"] pub type IfenR = crate :: BitReader ;
#[doc = "Field `IFEN` writer - IFEN"] pub type IfenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FEMPT` reader - FEMPT"] pub type FemptR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - IRS"]
#[inline (always)] pub fn irs (& self) -> IrsR { IrsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ILS"]
#[inline (always)] pub fn ils (& self) -> IlsR { IlsR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IFS"]
#[inline (always)] pub fn ifs (& self) -> IfsR { IfsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - IREN"]
#[inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ILEN"]
#[inline (always)] pub fn ilen (& self) -> IlenR { IlenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - IFEN"]
#[inline (always)] pub fn ifen (& self) -> IfenR { IfenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - FEMPT"]
#[inline (always)] pub fn fempt (& self) -> FemptR { FemptR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - IRS"]
#[inline (always)] pub fn irs (& mut self) -> IrsW < '_ , Sr2Spec > { IrsW :: new (self , 0) }
#[doc = "Bit 1 - ILS"]
#[inline (always)] pub fn ils (& mut self) -> IlsW < '_ , Sr2Spec > { IlsW :: new (self , 1) }
#[doc = "Bit 2 - IFS"]
#[inline (always)] pub fn ifs (& mut self) -> IfsW < '_ , Sr2Spec > { IfsW :: new (self , 2) }
#[doc = "Bit 3 - IREN"]
#[inline (always)] pub fn iren (& mut self) -> IrenW < '_ , Sr2Spec > { IrenW :: new (self , 3) }
#[doc = "Bit 4 - ILEN"]
#[inline (always)] pub fn ilen (& mut self) -> IlenW < '_ , Sr2Spec > { IlenW :: new (self , 4) }
#[doc = "Bit 5 - IFEN"]
#[inline (always)] pub fn ifen (& mut self) -> IfenW < '_ , Sr2Spec > { IfenW :: new (self , 5) } }
#[doc = "FIFO status and interrupt register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sr2Spec ; impl crate :: RegisterSpec for Sr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr2::R`](R) reader structure"] impl crate :: Readable for Sr2Spec { }
#[doc = "`write(|w| ..)` method takes [`sr2::W`](W) writer structure"] impl crate :: Writable for Sr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR2 to value 0x40"] impl crate :: Resettable for Sr2Spec { const RESET_VALUE : u32 = 0x40 ; } }
#[doc = "PMEM2 (rw) register accessor: Common memory space timing register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`pmem2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pmem2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pmem2`] module"]
#[doc (alias = "PMEM2")] pub type Pmem2 = crate :: Reg < pmem2 :: Pmem2Spec > ;
#[doc = "Common memory space timing register 2"] pub mod pmem2 {
#[doc = "Register `PMEM2` reader"] pub type R = crate :: R < Pmem2Spec > ;
#[doc = "Register `PMEM2` writer"] pub type W = crate :: W < Pmem2Spec > ;
#[doc = "Field `MEMSETx` reader - MEMSETx"] pub type MemsetxR = crate :: FieldReader ;
#[doc = "Field `MEMSETx` writer - MEMSETx"] pub type MemsetxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMWAITx` reader - MEMWAITx"] pub type MemwaitxR = crate :: FieldReader ;
#[doc = "Field `MEMWAITx` writer - MEMWAITx"] pub type MemwaitxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMHOLDx` reader - MEMHOLDx"] pub type MemholdxR = crate :: FieldReader ;
#[doc = "Field `MEMHOLDx` writer - MEMHOLDx"] pub type MemholdxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMHIZx` reader - MEMHIZx"] pub type MemhizxR = crate :: FieldReader ;
#[doc = "Field `MEMHIZx` writer - MEMHIZx"] pub type MemhizxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - MEMSETx"]
#[inline (always)] pub fn memsetx (& self) -> MemsetxR { MemsetxR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - MEMWAITx"]
#[inline (always)] pub fn memwaitx (& self) -> MemwaitxR { MemwaitxR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - MEMHOLDx"]
#[inline (always)] pub fn memholdx (& self) -> MemholdxR { MemholdxR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - MEMHIZx"]
#[inline (always)] pub fn memhizx (& self) -> MemhizxR { MemhizxR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - MEMSETx"]
#[inline (always)] pub fn memsetx (& mut self) -> MemsetxW < '_ , Pmem2Spec > { MemsetxW :: new (self , 0) }
#[doc = "Bits 8:15 - MEMWAITx"]
#[inline (always)] pub fn memwaitx (& mut self) -> MemwaitxW < '_ , Pmem2Spec > { MemwaitxW :: new (self , 8) }
#[doc = "Bits 16:23 - MEMHOLDx"]
#[inline (always)] pub fn memholdx (& mut self) -> MemholdxW < '_ , Pmem2Spec > { MemholdxW :: new (self , 16) }
#[doc = "Bits 24:31 - MEMHIZx"]
#[inline (always)] pub fn memhizx (& mut self) -> MemhizxW < '_ , Pmem2Spec > { MemhizxW :: new (self , 24) } }
#[doc = "Common memory space timing register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`pmem2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pmem2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pmem2Spec ; impl crate :: RegisterSpec for Pmem2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pmem2::R`](R) reader structure"] impl crate :: Readable for Pmem2Spec { }
#[doc = "`write(|w| ..)` method takes [`pmem2::W`](W) writer structure"] impl crate :: Writable for Pmem2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PMEM2 to value 0xfcfc_fcfc"] impl crate :: Resettable for Pmem2Spec { const RESET_VALUE : u32 = 0xfcfc_fcfc ; } }
#[doc = "PATT2 (rw) register accessor: Attribute memory space timing register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`patt2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`patt2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@patt2`] module"]
#[doc (alias = "PATT2")] pub type Patt2 = crate :: Reg < patt2 :: Patt2Spec > ;
#[doc = "Attribute memory space timing register 2"] pub mod patt2 {
#[doc = "Register `PATT2` reader"] pub type R = crate :: R < Patt2Spec > ;
#[doc = "Register `PATT2` writer"] pub type W = crate :: W < Patt2Spec > ;
#[doc = "Field `ATTSETx` reader - Attribute memory x setup time"] pub type AttsetxR = crate :: FieldReader ;
#[doc = "Field `ATTSETx` writer - Attribute memory x setup time"] pub type AttsetxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTWAITx` reader - Attribute memory x wait time"] pub type AttwaitxR = crate :: FieldReader ;
#[doc = "Field `ATTWAITx` writer - Attribute memory x wait time"] pub type AttwaitxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTHOLDx` reader - Attribute memory x hold time"] pub type AttholdxR = crate :: FieldReader ;
#[doc = "Field `ATTHOLDx` writer - Attribute memory x hold time"] pub type AttholdxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTHIZx` reader - Attribute memory x databus HiZ time"] pub type AtthizxR = crate :: FieldReader ;
#[doc = "Field `ATTHIZx` writer - Attribute memory x databus HiZ time"] pub type AtthizxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Attribute memory x setup time"]
#[inline (always)] pub fn attsetx (& self) -> AttsetxR { AttsetxR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - Attribute memory x wait time"]
#[inline (always)] pub fn attwaitx (& self) -> AttwaitxR { AttwaitxR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - Attribute memory x hold time"]
#[inline (always)] pub fn attholdx (& self) -> AttholdxR { AttholdxR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - Attribute memory x databus HiZ time"]
#[inline (always)] pub fn atthizx (& self) -> AtthizxR { AtthizxR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Attribute memory x setup time"]
#[inline (always)] pub fn attsetx (& mut self) -> AttsetxW < '_ , Patt2Spec > { AttsetxW :: new (self , 0) }
#[doc = "Bits 8:15 - Attribute memory x wait time"]
#[inline (always)] pub fn attwaitx (& mut self) -> AttwaitxW < '_ , Patt2Spec > { AttwaitxW :: new (self , 8) }
#[doc = "Bits 16:23 - Attribute memory x hold time"]
#[inline (always)] pub fn attholdx (& mut self) -> AttholdxW < '_ , Patt2Spec > { AttholdxW :: new (self , 16) }
#[doc = "Bits 24:31 - Attribute memory x databus HiZ time"]
#[inline (always)] pub fn atthizx (& mut self) -> AtthizxW < '_ , Patt2Spec > { AtthizxW :: new (self , 24) } }
#[doc = "Attribute memory space timing register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`patt2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`patt2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Patt2Spec ; impl crate :: RegisterSpec for Patt2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`patt2::R`](R) reader structure"] impl crate :: Readable for Patt2Spec { }
#[doc = "`write(|w| ..)` method takes [`patt2::W`](W) writer structure"] impl crate :: Writable for Patt2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PATT2 to value 0xfcfc_fcfc"] impl crate :: Resettable for Patt2Spec { const RESET_VALUE : u32 = 0xfcfc_fcfc ; } }
#[doc = "ECCR2 (r) register accessor: ECC result register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`eccr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eccr2`] module"]
#[doc (alias = "ECCR2")] pub type Eccr2 = crate :: Reg < eccr2 :: Eccr2Spec > ;
#[doc = "ECC result register 2"] pub mod eccr2 {
#[doc = "Register `ECCR2` reader"] pub type R = crate :: R < Eccr2Spec > ;
#[doc = "Field `ECCx` reader - ECC result"] pub type EccxR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - ECC result"]
#[inline (always)] pub fn eccx (& self) -> EccxR { EccxR :: new (self . bits) } }
#[doc = "ECC result register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`eccr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Eccr2Spec ; impl crate :: RegisterSpec for Eccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`eccr2::R`](R) reader structure"] impl crate :: Readable for Eccr2Spec { }
#[doc = "`reset()` method sets ECCR2 to value 0"] impl crate :: Resettable for Eccr2Spec { } }
#[doc = "PCR3 (rw) register accessor: PC Card/NAND Flash control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`pcr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pcr3`] module"]
#[doc (alias = "PCR3")] pub type Pcr3 = crate :: Reg < pcr3 :: Pcr3Spec > ;
#[doc = "PC Card/NAND Flash control register 3"] pub mod pcr3 {
#[doc = "Register `PCR3` reader"] pub type R = crate :: R < Pcr3Spec > ;
#[doc = "Register `PCR3` writer"] pub type W = crate :: W < Pcr3Spec > ;
#[doc = "Field `PWAITEN` reader - PWAITEN"] pub type PwaitenR = crate :: BitReader ;
#[doc = "Field `PWAITEN` writer - PWAITEN"] pub type PwaitenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PBKEN` reader - PBKEN"] pub type PbkenR = crate :: BitReader ;
#[doc = "Field `PBKEN` writer - PBKEN"] pub type PbkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PTYP` reader - PTYP"] pub type PtypR = crate :: BitReader ;
#[doc = "Field `PTYP` writer - PTYP"] pub type PtypW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWID` reader - PWID"] pub type PwidR = crate :: FieldReader ;
#[doc = "Field `PWID` writer - PWID"] pub type PwidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECCEN` reader - ECCEN"] pub type EccenR = crate :: BitReader ;
#[doc = "Field `ECCEN` writer - ECCEN"] pub type EccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCLR` reader - TCLR"] pub type TclrR = crate :: FieldReader ;
#[doc = "Field `TCLR` writer - TCLR"] pub type TclrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TAR` reader - TAR"] pub type TarR = crate :: FieldReader ;
#[doc = "Field `TAR` writer - TAR"] pub type TarW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ECCPS` reader - ECCPS"] pub type EccpsR = crate :: FieldReader ;
#[doc = "Field `ECCPS` writer - ECCPS"] pub type EccpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bit 1 - PWAITEN"]
#[inline (always)] pub fn pwaiten (& self) -> PwaitenR { PwaitenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - PBKEN"]
#[inline (always)] pub fn pbken (& self) -> PbkenR { PbkenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - PTYP"]
#[inline (always)] pub fn ptyp (& self) -> PtypR { PtypR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - PWID"]
#[inline (always)] pub fn pwid (& self) -> PwidR { PwidR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - ECCEN"]
#[inline (always)] pub fn eccen (& self) -> EccenR { EccenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 9:12 - TCLR"]
#[inline (always)] pub fn tclr (& self) -> TclrR { TclrR :: new (((self . bits >> 9) & 0x0f) as u8) }
#[doc = "Bits 13:16 - TAR"]
#[inline (always)] pub fn tar (& self) -> TarR { TarR :: new (((self . bits >> 13) & 0x0f) as u8) }
#[doc = "Bits 17:19 - ECCPS"]
#[inline (always)] pub fn eccps (& self) -> EccpsR { EccpsR :: new (((self . bits >> 17) & 7) as u8) } } impl W {
#[doc = "Bit 1 - PWAITEN"]
#[inline (always)] pub fn pwaiten (& mut self) -> PwaitenW < '_ , Pcr3Spec > { PwaitenW :: new (self , 1) }
#[doc = "Bit 2 - PBKEN"]
#[inline (always)] pub fn pbken (& mut self) -> PbkenW < '_ , Pcr3Spec > { PbkenW :: new (self , 2) }
#[doc = "Bit 3 - PTYP"]
#[inline (always)] pub fn ptyp (& mut self) -> PtypW < '_ , Pcr3Spec > { PtypW :: new (self , 3) }
#[doc = "Bits 4:5 - PWID"]
#[inline (always)] pub fn pwid (& mut self) -> PwidW < '_ , Pcr3Spec > { PwidW :: new (self , 4) }
#[doc = "Bit 6 - ECCEN"]
#[inline (always)] pub fn eccen (& mut self) -> EccenW < '_ , Pcr3Spec > { EccenW :: new (self , 6) }
#[doc = "Bits 9:12 - TCLR"]
#[inline (always)] pub fn tclr (& mut self) -> TclrW < '_ , Pcr3Spec > { TclrW :: new (self , 9) }
#[doc = "Bits 13:16 - TAR"]
#[inline (always)] pub fn tar (& mut self) -> TarW < '_ , Pcr3Spec > { TarW :: new (self , 13) }
#[doc = "Bits 17:19 - ECCPS"]
#[inline (always)] pub fn eccps (& mut self) -> EccpsW < '_ , Pcr3Spec > { EccpsW :: new (self , 17) } }
#[doc = "PC Card/NAND Flash control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`pcr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pcr3Spec ; impl crate :: RegisterSpec for Pcr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pcr3::R`](R) reader structure"] impl crate :: Readable for Pcr3Spec { }
#[doc = "`write(|w| ..)` method takes [`pcr3::W`](W) writer structure"] impl crate :: Writable for Pcr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PCR3 to value 0x18"] impl crate :: Resettable for Pcr3Spec { const RESET_VALUE : u32 = 0x18 ; } }
#[doc = "SR3 (rw) register accessor: FIFO status and interrupt register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`sr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr3`] module"]
#[doc (alias = "SR3")] pub type Sr3 = crate :: Reg < sr3 :: Sr3Spec > ;
#[doc = "FIFO status and interrupt register 3"] pub mod sr3 {
#[doc = "Register `SR3` reader"] pub type R = crate :: R < Sr3Spec > ;
#[doc = "Register `SR3` writer"] pub type W = crate :: W < Sr3Spec > ;
#[doc = "Field `IRS` reader - IRS"] pub type IrsR = crate :: BitReader ;
#[doc = "Field `IRS` writer - IRS"] pub type IrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ILS` reader - ILS"] pub type IlsR = crate :: BitReader ;
#[doc = "Field `ILS` writer - ILS"] pub type IlsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFS` reader - IFS"] pub type IfsR = crate :: BitReader ;
#[doc = "Field `IFS` writer - IFS"] pub type IfsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IREN` reader - IREN"] pub type IrenR = crate :: BitReader ;
#[doc = "Field `IREN` writer - IREN"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ILEN` reader - ILEN"] pub type IlenR = crate :: BitReader ;
#[doc = "Field `ILEN` writer - ILEN"] pub type IlenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFEN` reader - IFEN"] pub type IfenR = crate :: BitReader ;
#[doc = "Field `IFEN` writer - IFEN"] pub type IfenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FEMPT` reader - FEMPT"] pub type FemptR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - IRS"]
#[inline (always)] pub fn irs (& self) -> IrsR { IrsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ILS"]
#[inline (always)] pub fn ils (& self) -> IlsR { IlsR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IFS"]
#[inline (always)] pub fn ifs (& self) -> IfsR { IfsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - IREN"]
#[inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ILEN"]
#[inline (always)] pub fn ilen (& self) -> IlenR { IlenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - IFEN"]
#[inline (always)] pub fn ifen (& self) -> IfenR { IfenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - FEMPT"]
#[inline (always)] pub fn fempt (& self) -> FemptR { FemptR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - IRS"]
#[inline (always)] pub fn irs (& mut self) -> IrsW < '_ , Sr3Spec > { IrsW :: new (self , 0) }
#[doc = "Bit 1 - ILS"]
#[inline (always)] pub fn ils (& mut self) -> IlsW < '_ , Sr3Spec > { IlsW :: new (self , 1) }
#[doc = "Bit 2 - IFS"]
#[inline (always)] pub fn ifs (& mut self) -> IfsW < '_ , Sr3Spec > { IfsW :: new (self , 2) }
#[doc = "Bit 3 - IREN"]
#[inline (always)] pub fn iren (& mut self) -> IrenW < '_ , Sr3Spec > { IrenW :: new (self , 3) }
#[doc = "Bit 4 - ILEN"]
#[inline (always)] pub fn ilen (& mut self) -> IlenW < '_ , Sr3Spec > { IlenW :: new (self , 4) }
#[doc = "Bit 5 - IFEN"]
#[inline (always)] pub fn ifen (& mut self) -> IfenW < '_ , Sr3Spec > { IfenW :: new (self , 5) } }
#[doc = "FIFO status and interrupt register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`sr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sr3Spec ; impl crate :: RegisterSpec for Sr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr3::R`](R) reader structure"] impl crate :: Readable for Sr3Spec { }
#[doc = "`write(|w| ..)` method takes [`sr3::W`](W) writer structure"] impl crate :: Writable for Sr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR3 to value 0x40"] impl crate :: Resettable for Sr3Spec { const RESET_VALUE : u32 = 0x40 ; } }
#[doc = "PMEM3 (rw) register accessor: Common memory space timing register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`pmem3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pmem3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pmem3`] module"]
#[doc (alias = "PMEM3")] pub type Pmem3 = crate :: Reg < pmem3 :: Pmem3Spec > ;
#[doc = "Common memory space timing register 3"] pub mod pmem3 {
#[doc = "Register `PMEM3` reader"] pub type R = crate :: R < Pmem3Spec > ;
#[doc = "Register `PMEM3` writer"] pub type W = crate :: W < Pmem3Spec > ;
#[doc = "Field `MEMSETx` reader - MEMSETx"] pub type MemsetxR = crate :: FieldReader ;
#[doc = "Field `MEMSETx` writer - MEMSETx"] pub type MemsetxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMWAITx` reader - MEMWAITx"] pub type MemwaitxR = crate :: FieldReader ;
#[doc = "Field `MEMWAITx` writer - MEMWAITx"] pub type MemwaitxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMHOLDx` reader - MEMHOLDx"] pub type MemholdxR = crate :: FieldReader ;
#[doc = "Field `MEMHOLDx` writer - MEMHOLDx"] pub type MemholdxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMHIZx` reader - MEMHIZx"] pub type MemhizxR = crate :: FieldReader ;
#[doc = "Field `MEMHIZx` writer - MEMHIZx"] pub type MemhizxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - MEMSETx"]
#[inline (always)] pub fn memsetx (& self) -> MemsetxR { MemsetxR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - MEMWAITx"]
#[inline (always)] pub fn memwaitx (& self) -> MemwaitxR { MemwaitxR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - MEMHOLDx"]
#[inline (always)] pub fn memholdx (& self) -> MemholdxR { MemholdxR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - MEMHIZx"]
#[inline (always)] pub fn memhizx (& self) -> MemhizxR { MemhizxR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - MEMSETx"]
#[inline (always)] pub fn memsetx (& mut self) -> MemsetxW < '_ , Pmem3Spec > { MemsetxW :: new (self , 0) }
#[doc = "Bits 8:15 - MEMWAITx"]
#[inline (always)] pub fn memwaitx (& mut self) -> MemwaitxW < '_ , Pmem3Spec > { MemwaitxW :: new (self , 8) }
#[doc = "Bits 16:23 - MEMHOLDx"]
#[inline (always)] pub fn memholdx (& mut self) -> MemholdxW < '_ , Pmem3Spec > { MemholdxW :: new (self , 16) }
#[doc = "Bits 24:31 - MEMHIZx"]
#[inline (always)] pub fn memhizx (& mut self) -> MemhizxW < '_ , Pmem3Spec > { MemhizxW :: new (self , 24) } }
#[doc = "Common memory space timing register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`pmem3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pmem3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pmem3Spec ; impl crate :: RegisterSpec for Pmem3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pmem3::R`](R) reader structure"] impl crate :: Readable for Pmem3Spec { }
#[doc = "`write(|w| ..)` method takes [`pmem3::W`](W) writer structure"] impl crate :: Writable for Pmem3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PMEM3 to value 0xfcfc_fcfc"] impl crate :: Resettable for Pmem3Spec { const RESET_VALUE : u32 = 0xfcfc_fcfc ; } }
#[doc = "PATT3 (rw) register accessor: Attribute memory space timing register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`patt3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`patt3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@patt3`] module"]
#[doc (alias = "PATT3")] pub type Patt3 = crate :: Reg < patt3 :: Patt3Spec > ;
#[doc = "Attribute memory space timing register 3"] pub mod patt3 {
#[doc = "Register `PATT3` reader"] pub type R = crate :: R < Patt3Spec > ;
#[doc = "Register `PATT3` writer"] pub type W = crate :: W < Patt3Spec > ;
#[doc = "Field `ATTSETx` reader - ATTSETx"] pub type AttsetxR = crate :: FieldReader ;
#[doc = "Field `ATTSETx` writer - ATTSETx"] pub type AttsetxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTWAITx` reader - ATTWAITx"] pub type AttwaitxR = crate :: FieldReader ;
#[doc = "Field `ATTWAITx` writer - ATTWAITx"] pub type AttwaitxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTHOLDx` reader - ATTHOLDx"] pub type AttholdxR = crate :: FieldReader ;
#[doc = "Field `ATTHOLDx` writer - ATTHOLDx"] pub type AttholdxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTHIZx` reader - ATTHIZx"] pub type AtthizxR = crate :: FieldReader ;
#[doc = "Field `ATTHIZx` writer - ATTHIZx"] pub type AtthizxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - ATTSETx"]
#[inline (always)] pub fn attsetx (& self) -> AttsetxR { AttsetxR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - ATTWAITx"]
#[inline (always)] pub fn attwaitx (& self) -> AttwaitxR { AttwaitxR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - ATTHOLDx"]
#[inline (always)] pub fn attholdx (& self) -> AttholdxR { AttholdxR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - ATTHIZx"]
#[inline (always)] pub fn atthizx (& self) -> AtthizxR { AtthizxR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - ATTSETx"]
#[inline (always)] pub fn attsetx (& mut self) -> AttsetxW < '_ , Patt3Spec > { AttsetxW :: new (self , 0) }
#[doc = "Bits 8:15 - ATTWAITx"]
#[inline (always)] pub fn attwaitx (& mut self) -> AttwaitxW < '_ , Patt3Spec > { AttwaitxW :: new (self , 8) }
#[doc = "Bits 16:23 - ATTHOLDx"]
#[inline (always)] pub fn attholdx (& mut self) -> AttholdxW < '_ , Patt3Spec > { AttholdxW :: new (self , 16) }
#[doc = "Bits 24:31 - ATTHIZx"]
#[inline (always)] pub fn atthizx (& mut self) -> AtthizxW < '_ , Patt3Spec > { AtthizxW :: new (self , 24) } }
#[doc = "Attribute memory space timing register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`patt3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`patt3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Patt3Spec ; impl crate :: RegisterSpec for Patt3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`patt3::R`](R) reader structure"] impl crate :: Readable for Patt3Spec { }
#[doc = "`write(|w| ..)` method takes [`patt3::W`](W) writer structure"] impl crate :: Writable for Patt3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PATT3 to value 0xfcfc_fcfc"] impl crate :: Resettable for Patt3Spec { const RESET_VALUE : u32 = 0xfcfc_fcfc ; } }
#[doc = "ECCR3 (r) register accessor: ECC result register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`eccr3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eccr3`] module"]
#[doc (alias = "ECCR3")] pub type Eccr3 = crate :: Reg < eccr3 :: Eccr3Spec > ;
#[doc = "ECC result register 3"] pub mod eccr3 {
#[doc = "Register `ECCR3` reader"] pub type R = crate :: R < Eccr3Spec > ;
#[doc = "Field `ECCx` reader - ECCx"] pub type EccxR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - ECCx"]
#[inline (always)] pub fn eccx (& self) -> EccxR { EccxR :: new (self . bits) } }
#[doc = "ECC result register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`eccr3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Eccr3Spec ; impl crate :: RegisterSpec for Eccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`eccr3::R`](R) reader structure"] impl crate :: Readable for Eccr3Spec { }
#[doc = "`reset()` method sets ECCR3 to value 0"] impl crate :: Resettable for Eccr3Spec { } }
#[doc = "PCR4 (rw) register accessor: PC Card/NAND Flash control register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`pcr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pcr4`] module"]
#[doc (alias = "PCR4")] pub type Pcr4 = crate :: Reg < pcr4 :: Pcr4Spec > ;
#[doc = "PC Card/NAND Flash control register 4"] pub mod pcr4 {
#[doc = "Register `PCR4` reader"] pub type R = crate :: R < Pcr4Spec > ;
#[doc = "Register `PCR4` writer"] pub type W = crate :: W < Pcr4Spec > ;
#[doc = "Field `PWAITEN` reader - PWAITEN"] pub type PwaitenR = crate :: BitReader ;
#[doc = "Field `PWAITEN` writer - PWAITEN"] pub type PwaitenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PBKEN` reader - PBKEN"] pub type PbkenR = crate :: BitReader ;
#[doc = "Field `PBKEN` writer - PBKEN"] pub type PbkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PTYP` reader - PTYP"] pub type PtypR = crate :: BitReader ;
#[doc = "Field `PTYP` writer - PTYP"] pub type PtypW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWID` reader - PWID"] pub type PwidR = crate :: FieldReader ;
#[doc = "Field `PWID` writer - PWID"] pub type PwidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECCEN` reader - ECCEN"] pub type EccenR = crate :: BitReader ;
#[doc = "Field `ECCEN` writer - ECCEN"] pub type EccenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCLR` reader - TCLR"] pub type TclrR = crate :: FieldReader ;
#[doc = "Field `TCLR` writer - TCLR"] pub type TclrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TAR` reader - TAR"] pub type TarR = crate :: FieldReader ;
#[doc = "Field `TAR` writer - TAR"] pub type TarW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ECCPS` reader - ECCPS"] pub type EccpsR = crate :: FieldReader ;
#[doc = "Field `ECCPS` writer - ECCPS"] pub type EccpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bit 1 - PWAITEN"]
#[inline (always)] pub fn pwaiten (& self) -> PwaitenR { PwaitenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - PBKEN"]
#[inline (always)] pub fn pbken (& self) -> PbkenR { PbkenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - PTYP"]
#[inline (always)] pub fn ptyp (& self) -> PtypR { PtypR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - PWID"]
#[inline (always)] pub fn pwid (& self) -> PwidR { PwidR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - ECCEN"]
#[inline (always)] pub fn eccen (& self) -> EccenR { EccenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 9:12 - TCLR"]
#[inline (always)] pub fn tclr (& self) -> TclrR { TclrR :: new (((self . bits >> 9) & 0x0f) as u8) }
#[doc = "Bits 13:16 - TAR"]
#[inline (always)] pub fn tar (& self) -> TarR { TarR :: new (((self . bits >> 13) & 0x0f) as u8) }
#[doc = "Bits 17:19 - ECCPS"]
#[inline (always)] pub fn eccps (& self) -> EccpsR { EccpsR :: new (((self . bits >> 17) & 7) as u8) } } impl W {
#[doc = "Bit 1 - PWAITEN"]
#[inline (always)] pub fn pwaiten (& mut self) -> PwaitenW < '_ , Pcr4Spec > { PwaitenW :: new (self , 1) }
#[doc = "Bit 2 - PBKEN"]
#[inline (always)] pub fn pbken (& mut self) -> PbkenW < '_ , Pcr4Spec > { PbkenW :: new (self , 2) }
#[doc = "Bit 3 - PTYP"]
#[inline (always)] pub fn ptyp (& mut self) -> PtypW < '_ , Pcr4Spec > { PtypW :: new (self , 3) }
#[doc = "Bits 4:5 - PWID"]
#[inline (always)] pub fn pwid (& mut self) -> PwidW < '_ , Pcr4Spec > { PwidW :: new (self , 4) }
#[doc = "Bit 6 - ECCEN"]
#[inline (always)] pub fn eccen (& mut self) -> EccenW < '_ , Pcr4Spec > { EccenW :: new (self , 6) }
#[doc = "Bits 9:12 - TCLR"]
#[inline (always)] pub fn tclr (& mut self) -> TclrW < '_ , Pcr4Spec > { TclrW :: new (self , 9) }
#[doc = "Bits 13:16 - TAR"]
#[inline (always)] pub fn tar (& mut self) -> TarW < '_ , Pcr4Spec > { TarW :: new (self , 13) }
#[doc = "Bits 17:19 - ECCPS"]
#[inline (always)] pub fn eccps (& mut self) -> EccpsW < '_ , Pcr4Spec > { EccpsW :: new (self , 17) } }
#[doc = "PC Card/NAND Flash control register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`pcr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pcr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pcr4Spec ; impl crate :: RegisterSpec for Pcr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pcr4::R`](R) reader structure"] impl crate :: Readable for Pcr4Spec { }
#[doc = "`write(|w| ..)` method takes [`pcr4::W`](W) writer structure"] impl crate :: Writable for Pcr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PCR4 to value 0x18"] impl crate :: Resettable for Pcr4Spec { const RESET_VALUE : u32 = 0x18 ; } }
#[doc = "SR4 (rw) register accessor: FIFO status and interrupt register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`sr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr4`] module"]
#[doc (alias = "SR4")] pub type Sr4 = crate :: Reg < sr4 :: Sr4Spec > ;
#[doc = "FIFO status and interrupt register 4"] pub mod sr4 {
#[doc = "Register `SR4` reader"] pub type R = crate :: R < Sr4Spec > ;
#[doc = "Register `SR4` writer"] pub type W = crate :: W < Sr4Spec > ;
#[doc = "Field `IRS` reader - IRS"] pub type IrsR = crate :: BitReader ;
#[doc = "Field `IRS` writer - IRS"] pub type IrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ILS` reader - ILS"] pub type IlsR = crate :: BitReader ;
#[doc = "Field `ILS` writer - ILS"] pub type IlsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFS` reader - IFS"] pub type IfsR = crate :: BitReader ;
#[doc = "Field `IFS` writer - IFS"] pub type IfsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IREN` reader - IREN"] pub type IrenR = crate :: BitReader ;
#[doc = "Field `IREN` writer - IREN"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ILEN` reader - ILEN"] pub type IlenR = crate :: BitReader ;
#[doc = "Field `ILEN` writer - ILEN"] pub type IlenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFEN` reader - IFEN"] pub type IfenR = crate :: BitReader ;
#[doc = "Field `IFEN` writer - IFEN"] pub type IfenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FEMPT` reader - FEMPT"] pub type FemptR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - IRS"]
#[inline (always)] pub fn irs (& self) -> IrsR { IrsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ILS"]
#[inline (always)] pub fn ils (& self) -> IlsR { IlsR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IFS"]
#[inline (always)] pub fn ifs (& self) -> IfsR { IfsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - IREN"]
#[inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ILEN"]
#[inline (always)] pub fn ilen (& self) -> IlenR { IlenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - IFEN"]
#[inline (always)] pub fn ifen (& self) -> IfenR { IfenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - FEMPT"]
#[inline (always)] pub fn fempt (& self) -> FemptR { FemptR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - IRS"]
#[inline (always)] pub fn irs (& mut self) -> IrsW < '_ , Sr4Spec > { IrsW :: new (self , 0) }
#[doc = "Bit 1 - ILS"]
#[inline (always)] pub fn ils (& mut self) -> IlsW < '_ , Sr4Spec > { IlsW :: new (self , 1) }
#[doc = "Bit 2 - IFS"]
#[inline (always)] pub fn ifs (& mut self) -> IfsW < '_ , Sr4Spec > { IfsW :: new (self , 2) }
#[doc = "Bit 3 - IREN"]
#[inline (always)] pub fn iren (& mut self) -> IrenW < '_ , Sr4Spec > { IrenW :: new (self , 3) }
#[doc = "Bit 4 - ILEN"]
#[inline (always)] pub fn ilen (& mut self) -> IlenW < '_ , Sr4Spec > { IlenW :: new (self , 4) }
#[doc = "Bit 5 - IFEN"]
#[inline (always)] pub fn ifen (& mut self) -> IfenW < '_ , Sr4Spec > { IfenW :: new (self , 5) } }
#[doc = "FIFO status and interrupt register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`sr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sr4Spec ; impl crate :: RegisterSpec for Sr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr4::R`](R) reader structure"] impl crate :: Readable for Sr4Spec { }
#[doc = "`write(|w| ..)` method takes [`sr4::W`](W) writer structure"] impl crate :: Writable for Sr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR4 to value 0x40"] impl crate :: Resettable for Sr4Spec { const RESET_VALUE : u32 = 0x40 ; } }
#[doc = "PMEM4 (rw) register accessor: Common memory space timing register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`pmem4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pmem4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pmem4`] module"]
#[doc (alias = "PMEM4")] pub type Pmem4 = crate :: Reg < pmem4 :: Pmem4Spec > ;
#[doc = "Common memory space timing register 4"] pub mod pmem4 {
#[doc = "Register `PMEM4` reader"] pub type R = crate :: R < Pmem4Spec > ;
#[doc = "Register `PMEM4` writer"] pub type W = crate :: W < Pmem4Spec > ;
#[doc = "Field `MEMSETx` reader - MEMSETx"] pub type MemsetxR = crate :: FieldReader ;
#[doc = "Field `MEMSETx` writer - MEMSETx"] pub type MemsetxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMWAITx` reader - MEMWAITx"] pub type MemwaitxR = crate :: FieldReader ;
#[doc = "Field `MEMWAITx` writer - MEMWAITx"] pub type MemwaitxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMHOLDx` reader - MEMHOLDx"] pub type MemholdxR = crate :: FieldReader ;
#[doc = "Field `MEMHOLDx` writer - MEMHOLDx"] pub type MemholdxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `MEMHIZx` reader - MEMHIZx"] pub type MemhizxR = crate :: FieldReader ;
#[doc = "Field `MEMHIZx` writer - MEMHIZx"] pub type MemhizxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - MEMSETx"]
#[inline (always)] pub fn memsetx (& self) -> MemsetxR { MemsetxR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - MEMWAITx"]
#[inline (always)] pub fn memwaitx (& self) -> MemwaitxR { MemwaitxR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - MEMHOLDx"]
#[inline (always)] pub fn memholdx (& self) -> MemholdxR { MemholdxR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - MEMHIZx"]
#[inline (always)] pub fn memhizx (& self) -> MemhizxR { MemhizxR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - MEMSETx"]
#[inline (always)] pub fn memsetx (& mut self) -> MemsetxW < '_ , Pmem4Spec > { MemsetxW :: new (self , 0) }
#[doc = "Bits 8:15 - MEMWAITx"]
#[inline (always)] pub fn memwaitx (& mut self) -> MemwaitxW < '_ , Pmem4Spec > { MemwaitxW :: new (self , 8) }
#[doc = "Bits 16:23 - MEMHOLDx"]
#[inline (always)] pub fn memholdx (& mut self) -> MemholdxW < '_ , Pmem4Spec > { MemholdxW :: new (self , 16) }
#[doc = "Bits 24:31 - MEMHIZx"]
#[inline (always)] pub fn memhizx (& mut self) -> MemhizxW < '_ , Pmem4Spec > { MemhizxW :: new (self , 24) } }
#[doc = "Common memory space timing register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`pmem4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pmem4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pmem4Spec ; impl crate :: RegisterSpec for Pmem4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pmem4::R`](R) reader structure"] impl crate :: Readable for Pmem4Spec { }
#[doc = "`write(|w| ..)` method takes [`pmem4::W`](W) writer structure"] impl crate :: Writable for Pmem4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PMEM4 to value 0xfcfc_fcfc"] impl crate :: Resettable for Pmem4Spec { const RESET_VALUE : u32 = 0xfcfc_fcfc ; } }
#[doc = "PATT4 (rw) register accessor: Attribute memory space timing register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`patt4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`patt4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@patt4`] module"]
#[doc (alias = "PATT4")] pub type Patt4 = crate :: Reg < patt4 :: Patt4Spec > ;
#[doc = "Attribute memory space timing register 4"] pub mod patt4 {
#[doc = "Register `PATT4` reader"] pub type R = crate :: R < Patt4Spec > ;
#[doc = "Register `PATT4` writer"] pub type W = crate :: W < Patt4Spec > ;
#[doc = "Field `ATTSETx` reader - ATTSETx"] pub type AttsetxR = crate :: FieldReader ;
#[doc = "Field `ATTSETx` writer - ATTSETx"] pub type AttsetxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTWAITx` reader - ATTWAITx"] pub type AttwaitxR = crate :: FieldReader ;
#[doc = "Field `ATTWAITx` writer - ATTWAITx"] pub type AttwaitxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTHOLDx` reader - ATTHOLDx"] pub type AttholdxR = crate :: FieldReader ;
#[doc = "Field `ATTHOLDx` writer - ATTHOLDx"] pub type AttholdxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ATTHIZx` reader - ATTHIZx"] pub type AtthizxR = crate :: FieldReader ;
#[doc = "Field `ATTHIZx` writer - ATTHIZx"] pub type AtthizxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - ATTSETx"]
#[inline (always)] pub fn attsetx (& self) -> AttsetxR { AttsetxR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - ATTWAITx"]
#[inline (always)] pub fn attwaitx (& self) -> AttwaitxR { AttwaitxR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - ATTHOLDx"]
#[inline (always)] pub fn attholdx (& self) -> AttholdxR { AttholdxR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - ATTHIZx"]
#[inline (always)] pub fn atthizx (& self) -> AtthizxR { AtthizxR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - ATTSETx"]
#[inline (always)] pub fn attsetx (& mut self) -> AttsetxW < '_ , Patt4Spec > { AttsetxW :: new (self , 0) }
#[doc = "Bits 8:15 - ATTWAITx"]
#[inline (always)] pub fn attwaitx (& mut self) -> AttwaitxW < '_ , Patt4Spec > { AttwaitxW :: new (self , 8) }
#[doc = "Bits 16:23 - ATTHOLDx"]
#[inline (always)] pub fn attholdx (& mut self) -> AttholdxW < '_ , Patt4Spec > { AttholdxW :: new (self , 16) }
#[doc = "Bits 24:31 - ATTHIZx"]
#[inline (always)] pub fn atthizx (& mut self) -> AtthizxW < '_ , Patt4Spec > { AtthizxW :: new (self , 24) } }
#[doc = "Attribute memory space timing register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`patt4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`patt4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Patt4Spec ; impl crate :: RegisterSpec for Patt4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`patt4::R`](R) reader structure"] impl crate :: Readable for Patt4Spec { }
#[doc = "`write(|w| ..)` method takes [`patt4::W`](W) writer structure"] impl crate :: Writable for Patt4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PATT4 to value 0xfcfc_fcfc"] impl crate :: Resettable for Patt4Spec { const RESET_VALUE : u32 = 0xfcfc_fcfc ; } }
#[doc = "PIO4 (rw) register accessor: I/O space timing register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`pio4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pio4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pio4`] module"]
#[doc (alias = "PIO4")] pub type Pio4 = crate :: Reg < pio4 :: Pio4Spec > ;
#[doc = "I/O space timing register 4"] pub mod pio4 {
#[doc = "Register `PIO4` reader"] pub type R = crate :: R < Pio4Spec > ;
#[doc = "Register `PIO4` writer"] pub type W = crate :: W < Pio4Spec > ;
#[doc = "Field `IOSETx` reader - IOSETx"] pub type IosetxR = crate :: FieldReader ;
#[doc = "Field `IOSETx` writer - IOSETx"] pub type IosetxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `IOWAITx` reader - IOWAITx"] pub type IowaitxR = crate :: FieldReader ;
#[doc = "Field `IOWAITx` writer - IOWAITx"] pub type IowaitxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `IOHOLDx` reader - IOHOLDx"] pub type IoholdxR = crate :: FieldReader ;
#[doc = "Field `IOHOLDx` writer - IOHOLDx"] pub type IoholdxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `IOHIZx` reader - IOHIZx"] pub type IohizxR = crate :: FieldReader ;
#[doc = "Field `IOHIZx` writer - IOHIZx"] pub type IohizxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - IOSETx"]
#[inline (always)] pub fn iosetx (& self) -> IosetxR { IosetxR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - IOWAITx"]
#[inline (always)] pub fn iowaitx (& self) -> IowaitxR { IowaitxR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - IOHOLDx"]
#[inline (always)] pub fn ioholdx (& self) -> IoholdxR { IoholdxR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - IOHIZx"]
#[inline (always)] pub fn iohizx (& self) -> IohizxR { IohizxR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - IOSETx"]
#[inline (always)] pub fn iosetx (& mut self) -> IosetxW < '_ , Pio4Spec > { IosetxW :: new (self , 0) }
#[doc = "Bits 8:15 - IOWAITx"]
#[inline (always)] pub fn iowaitx (& mut self) -> IowaitxW < '_ , Pio4Spec > { IowaitxW :: new (self , 8) }
#[doc = "Bits 16:23 - IOHOLDx"]
#[inline (always)] pub fn ioholdx (& mut self) -> IoholdxW < '_ , Pio4Spec > { IoholdxW :: new (self , 16) }
#[doc = "Bits 24:31 - IOHIZx"]
#[inline (always)] pub fn iohizx (& mut self) -> IohizxW < '_ , Pio4Spec > { IohizxW :: new (self , 24) } }
#[doc = "I/O space timing register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`pio4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pio4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Pio4Spec ; impl crate :: RegisterSpec for Pio4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pio4::R`](R) reader structure"] impl crate :: Readable for Pio4Spec { }
#[doc = "`write(|w| ..)` method takes [`pio4::W`](W) writer structure"] impl crate :: Writable for Pio4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PIO4 to value 0xfcfc_fcfc"] impl crate :: Resettable for Pio4Spec { const RESET_VALUE : u32 = 0xfcfc_fcfc ; } }
#[doc = "BWTR1 (rw) register accessor: SRAM/NOR-Flash write timing registers 1\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bwtr1`] module"]
#[doc (alias = "BWTR1")] pub type Bwtr1 = crate :: Reg < bwtr1 :: Bwtr1Spec > ;
#[doc = "SRAM/NOR-Flash write timing registers 1"] pub mod bwtr1 {
#[doc = "Register `BWTR1` reader"] pub type R = crate :: R < Bwtr1Spec > ;
#[doc = "Register `BWTR1` writer"] pub type W = crate :: W < Bwtr1Spec > ;
#[doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ;
#[doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ;
#[doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ;
#[doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CLKDIV` reader - CLKDIV"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - CLKDIV"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATLAT` reader - DATLAT"] pub type DatlatR = crate :: FieldReader ;
#[doc = "Field `DATLAT` writer - DATLAT"] pub type DatlatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader ;
#[doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& self) -> DatlatR { DatlatR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& mut self) -> AddsetW < '_ , Bwtr1Spec > { AddsetW :: new (self , 0) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& mut self) -> AddhldW < '_ , Bwtr1Spec > { AddhldW :: new (self , 4) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& mut self) -> DatastW < '_ , Bwtr1Spec > { DatastW :: new (self , 8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , Bwtr1Spec > { ClkdivW :: new (self , 20) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& mut self) -> DatlatW < '_ , Bwtr1Spec > { DatlatW :: new (self , 24) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& mut self) -> AccmodW < '_ , Bwtr1Spec > { AccmodW :: new (self , 28) } }
#[doc = "SRAM/NOR-Flash write timing registers 1\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bwtr1Spec ; impl crate :: RegisterSpec for Bwtr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bwtr1::R`](R) reader structure"] impl crate :: Readable for Bwtr1Spec { }
#[doc = "`write(|w| ..)` method takes [`bwtr1::W`](W) writer structure"] impl crate :: Writable for Bwtr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BWTR1 to value 0x0fff_ffff"] impl crate :: Resettable for Bwtr1Spec { const RESET_VALUE : u32 = 0x0fff_ffff ; } }
#[doc = "BWTR2 (rw) register accessor: SRAM/NOR-Flash write timing registers 2\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bwtr2`] module"]
#[doc (alias = "BWTR2")] pub type Bwtr2 = crate :: Reg < bwtr2 :: Bwtr2Spec > ;
#[doc = "SRAM/NOR-Flash write timing registers 2"] pub mod bwtr2 {
#[doc = "Register `BWTR2` reader"] pub type R = crate :: R < Bwtr2Spec > ;
#[doc = "Register `BWTR2` writer"] pub type W = crate :: W < Bwtr2Spec > ;
#[doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ;
#[doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ;
#[doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ;
#[doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CLKDIV` reader - CLKDIV"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - CLKDIV"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATLAT` reader - DATLAT"] pub type DatlatR = crate :: FieldReader ;
#[doc = "Field `DATLAT` writer - DATLAT"] pub type DatlatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader ;
#[doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& self) -> DatlatR { DatlatR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& mut self) -> AddsetW < '_ , Bwtr2Spec > { AddsetW :: new (self , 0) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& mut self) -> AddhldW < '_ , Bwtr2Spec > { AddhldW :: new (self , 4) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& mut self) -> DatastW < '_ , Bwtr2Spec > { DatastW :: new (self , 8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , Bwtr2Spec > { ClkdivW :: new (self , 20) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& mut self) -> DatlatW < '_ , Bwtr2Spec > { DatlatW :: new (self , 24) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& mut self) -> AccmodW < '_ , Bwtr2Spec > { AccmodW :: new (self , 28) } }
#[doc = "SRAM/NOR-Flash write timing registers 2\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bwtr2Spec ; impl crate :: RegisterSpec for Bwtr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bwtr2::R`](R) reader structure"] impl crate :: Readable for Bwtr2Spec { }
#[doc = "`write(|w| ..)` method takes [`bwtr2::W`](W) writer structure"] impl crate :: Writable for Bwtr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BWTR2 to value 0x0fff_ffff"] impl crate :: Resettable for Bwtr2Spec { const RESET_VALUE : u32 = 0x0fff_ffff ; } }
#[doc = "BWTR3 (rw) register accessor: SRAM/NOR-Flash write timing registers 3\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bwtr3`] module"]
#[doc (alias = "BWTR3")] pub type Bwtr3 = crate :: Reg < bwtr3 :: Bwtr3Spec > ;
#[doc = "SRAM/NOR-Flash write timing registers 3"] pub mod bwtr3 {
#[doc = "Register `BWTR3` reader"] pub type R = crate :: R < Bwtr3Spec > ;
#[doc = "Register `BWTR3` writer"] pub type W = crate :: W < Bwtr3Spec > ;
#[doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ;
#[doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ;
#[doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ;
#[doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CLKDIV` reader - CLKDIV"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - CLKDIV"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATLAT` reader - DATLAT"] pub type DatlatR = crate :: FieldReader ;
#[doc = "Field `DATLAT` writer - DATLAT"] pub type DatlatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader ;
#[doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& self) -> DatlatR { DatlatR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& mut self) -> AddsetW < '_ , Bwtr3Spec > { AddsetW :: new (self , 0) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& mut self) -> AddhldW < '_ , Bwtr3Spec > { AddhldW :: new (self , 4) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& mut self) -> DatastW < '_ , Bwtr3Spec > { DatastW :: new (self , 8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , Bwtr3Spec > { ClkdivW :: new (self , 20) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& mut self) -> DatlatW < '_ , Bwtr3Spec > { DatlatW :: new (self , 24) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& mut self) -> AccmodW < '_ , Bwtr3Spec > { AccmodW :: new (self , 28) } }
#[doc = "SRAM/NOR-Flash write timing registers 3\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bwtr3Spec ; impl crate :: RegisterSpec for Bwtr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bwtr3::R`](R) reader structure"] impl crate :: Readable for Bwtr3Spec { }
#[doc = "`write(|w| ..)` method takes [`bwtr3::W`](W) writer structure"] impl crate :: Writable for Bwtr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BWTR3 to value 0x0fff_ffff"] impl crate :: Resettable for Bwtr3Spec { const RESET_VALUE : u32 = 0x0fff_ffff ; } }
#[doc = "BWTR4 (rw) register accessor: SRAM/NOR-Flash write timing registers 4\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bwtr4`] module"]
#[doc (alias = "BWTR4")] pub type Bwtr4 = crate :: Reg < bwtr4 :: Bwtr4Spec > ;
#[doc = "SRAM/NOR-Flash write timing registers 4"] pub mod bwtr4 {
#[doc = "Register `BWTR4` reader"] pub type R = crate :: R < Bwtr4Spec > ;
#[doc = "Register `BWTR4` writer"] pub type W = crate :: W < Bwtr4Spec > ;
#[doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ;
#[doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ;
#[doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ;
#[doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CLKDIV` reader - CLKDIV"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - CLKDIV"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DATLAT` reader - DATLAT"] pub type DatlatR = crate :: FieldReader ;
#[doc = "Field `DATLAT` writer - DATLAT"] pub type DatlatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader ;
#[doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& self) -> DatlatR { DatlatR :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W {
#[doc = "Bits 0:3 - ADDSET"]
#[inline (always)] pub fn addset (& mut self) -> AddsetW < '_ , Bwtr4Spec > { AddsetW :: new (self , 0) }
#[doc = "Bits 4:7 - ADDHLD"]
#[inline (always)] pub fn addhld (& mut self) -> AddhldW < '_ , Bwtr4Spec > { AddhldW :: new (self , 4) }
#[doc = "Bits 8:15 - DATAST"]
#[inline (always)] pub fn datast (& mut self) -> DatastW < '_ , Bwtr4Spec > { DatastW :: new (self , 8) }
#[doc = "Bits 20:23 - CLKDIV"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , Bwtr4Spec > { ClkdivW :: new (self , 20) }
#[doc = "Bits 24:27 - DATLAT"]
#[inline (always)] pub fn datlat (& mut self) -> DatlatW < '_ , Bwtr4Spec > { DatlatW :: new (self , 24) }
#[doc = "Bits 28:29 - ACCMOD"]
#[inline (always)] pub fn accmod (& mut self) -> AccmodW < '_ , Bwtr4Spec > { AccmodW :: new (self , 28) } }
#[doc = "SRAM/NOR-Flash write timing registers 4\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Bwtr4Spec ; impl crate :: RegisterSpec for Bwtr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bwtr4::R`](R) reader structure"] impl crate :: Readable for Bwtr4Spec { }
#[doc = "`write(|w| ..)` method takes [`bwtr4::W`](W) writer structure"] impl crate :: Writable for Bwtr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BWTR4 to value 0x0fff_ffff"] impl crate :: Resettable for Bwtr4Spec { const RESET_VALUE : u32 = 0x0fff_ffff ; } } }
#[doc = "Power control"] pub type Pwr = crate :: Periph < pwr :: RegisterBlock , 0x4000_7000 > ; impl core :: fmt :: Debug for Pwr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pwr") . finish () } }
#[doc = "Power control"] pub mod pwr {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , csr : Csr , } impl RegisterBlock {
#[doc = "0x00 - Power control register (PWR_CR)"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - Power control register (PWR_CR)"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr } }
#[doc = "CR (rw) register accessor: Power control register (PWR_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Power control register (PWR_CR)"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `LPDS` reader - Low Power Deep Sleep"] pub type LpdsR = crate :: BitReader ;
#[doc = "Field `LPDS` writer - Low Power Deep Sleep"] pub type LpdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PDDS` reader - Power Down Deep Sleep"] pub type PddsR = crate :: BitReader ;
#[doc = "Field `PDDS` writer - Power Down Deep Sleep"] pub type PddsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CWUF` reader - Clear Wake-up Flag"] pub type CwufR = crate :: BitReader ;
#[doc = "Field `CWUF` writer - Clear Wake-up Flag"] pub type CwufW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSBF` reader - Clear STANDBY Flag"] pub type CsbfR = crate :: BitReader ;
#[doc = "Field `CSBF` writer - Clear STANDBY Flag"] pub type CsbfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVDE` reader - Power Voltage Detector Enable"] pub type PvdeR = crate :: BitReader ;
#[doc = "Field `PVDE` writer - Power Voltage Detector Enable"] pub type PvdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLS` reader - PVD Level Selection"] pub type PlsR = crate :: FieldReader ;
#[doc = "Field `PLS` writer - PVD Level Selection"] pub type PlsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DBP` reader - Disable Backup Domain write protection"] pub type DbpR = crate :: BitReader ;
#[doc = "Field `DBP` writer - Disable Backup Domain write protection"] pub type DbpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Low Power Deep Sleep"]
#[inline (always)] pub fn lpds (& self) -> LpdsR { LpdsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Power Down Deep Sleep"]
#[inline (always)] pub fn pdds (& self) -> PddsR { PddsR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Clear Wake-up Flag"]
#[inline (always)] pub fn cwuf (& self) -> CwufR { CwufR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Clear STANDBY Flag"]
#[inline (always)] pub fn csbf (& self) -> CsbfR { CsbfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Power Voltage Detector Enable"]
#[inline (always)] pub fn pvde (& self) -> PvdeR { PvdeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:7 - PVD Level Selection"]
#[inline (always)] pub fn pls (& self) -> PlsR { PlsR :: new (((self . bits >> 5) & 7) as u8) }
#[doc = "Bit 8 - Disable Backup Domain write protection"]
#[inline (always)] pub fn dbp (& self) -> DbpR { DbpR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Low Power Deep Sleep"]
#[inline (always)] pub fn lpds (& mut self) -> LpdsW < '_ , CrSpec > { LpdsW :: new (self , 0) }
#[doc = "Bit 1 - Power Down Deep Sleep"]
#[inline (always)] pub fn pdds (& mut self) -> PddsW < '_ , CrSpec > { PddsW :: new (self , 1) }
#[doc = "Bit 2 - Clear Wake-up Flag"]
#[inline (always)] pub fn cwuf (& mut self) -> CwufW < '_ , CrSpec > { CwufW :: new (self , 2) }
#[doc = "Bit 3 - Clear STANDBY Flag"]
#[inline (always)] pub fn csbf (& mut self) -> CsbfW < '_ , CrSpec > { CsbfW :: new (self , 3) }
#[doc = "Bit 4 - Power Voltage Detector Enable"]
#[inline (always)] pub fn pvde (& mut self) -> PvdeW < '_ , CrSpec > { PvdeW :: new (self , 4) }
#[doc = "Bits 5:7 - PVD Level Selection"]
#[inline (always)] pub fn pls (& mut self) -> PlsW < '_ , CrSpec > { PlsW :: new (self , 5) }
#[doc = "Bit 8 - Disable Backup Domain write protection"]
#[inline (always)] pub fn dbp (& mut self) -> DbpW < '_ , CrSpec > { DbpW :: new (self , 8) } }
#[doc = "Power control register (PWR_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "CSR (rw) register accessor: Power control register (PWR_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "Power control register (PWR_CR)"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Register `CSR` writer"] pub type W = crate :: W < CsrSpec > ;
#[doc = "Field `WUF` reader - Wake-Up Flag"] pub type WufR = crate :: BitReader ;
#[doc = "Field `SBF` reader - STANDBY Flag"] pub type SbfR = crate :: BitReader ;
#[doc = "Field `PVDO` reader - PVD Output"] pub type PvdoR = crate :: BitReader ;
#[doc = "Field `EWUP` reader - Enable WKUP pin"] pub type EwupR = crate :: BitReader ;
#[doc = "Field `EWUP` writer - Enable WKUP pin"] pub type EwupW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Wake-Up Flag"]
#[inline (always)] pub fn wuf (& self) -> WufR { WufR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - STANDBY Flag"]
#[inline (always)] pub fn sbf (& self) -> SbfR { SbfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - PVD Output"]
#[inline (always)] pub fn pvdo (& self) -> PvdoR { PvdoR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 8 - Enable WKUP pin"]
#[inline (always)] pub fn ewup (& self) -> EwupR { EwupR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 8 - Enable WKUP pin"]
#[inline (always)] pub fn ewup (& mut self) -> EwupW < '_ , CsrSpec > { EwupW :: new (self , 8) } }
#[doc = "Power control register (PWR_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"] impl crate :: Writable for CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CSR to value 0"] impl crate :: Resettable for CsrSpec { } } }
#[doc = "Reset and clock control"] pub type Rcc = crate :: Periph < rcc :: RegisterBlock , 0x4002_1000 > ; impl core :: fmt :: Debug for Rcc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rcc") . finish () } }
#[doc = "Reset and clock control"] pub mod rcc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , cfgr : Cfgr , cir : Cir , apb2rstr : Apb2rstr , apb1rstr : Apb1rstr , ahbenr : Ahbenr , apb2enr : Apb2enr , apb1enr : Apb1enr , bdcr : Bdcr , csr : Csr , } impl RegisterBlock {
#[doc = "0x00 - Clock control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - Clock configuration register (RCC_CFGR)"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x08 - Clock interrupt register (RCC_CIR)"]
#[inline (always)] pub const fn cir (& self) -> & Cir { & self . cir }
#[doc = "0x0c - APB2 peripheral reset register (RCC_APB2RSTR)"]
#[inline (always)] pub const fn apb2rstr (& self) -> & Apb2rstr { & self . apb2rstr }
#[doc = "0x10 - APB1 peripheral reset register (RCC_APB1RSTR)"]
#[inline (always)] pub const fn apb1rstr (& self) -> & Apb1rstr { & self . apb1rstr }
#[doc = "0x14 - AHB Peripheral Clock enable register (RCC_AHBENR)"]
#[inline (always)] pub const fn ahbenr (& self) -> & Ahbenr { & self . ahbenr }
#[doc = "0x18 - APB2 peripheral clock enable register (RCC_APB2ENR)"]
#[inline (always)] pub const fn apb2enr (& self) -> & Apb2enr { & self . apb2enr }
#[doc = "0x1c - APB1 peripheral clock enable register (RCC_APB1ENR)"]
#[inline (always)] pub const fn apb1enr (& self) -> & Apb1enr { & self . apb1enr }
#[doc = "0x20 - Backup domain control register (RCC_BDCR)"]
#[inline (always)] pub const fn bdcr (& self) -> & Bdcr { & self . bdcr }
#[doc = "0x24 - Control/status register (RCC_CSR)"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr } }
#[doc = "CR (rw) register accessor: Clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Clock control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `HSION` reader - Internal High Speed clock enable"] pub type HsionR = crate :: BitReader ;
#[doc = "Field `HSION` writer - Internal High Speed clock enable"] pub type HsionW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDY` reader - Internal High Speed clock ready flag"] pub type HsirdyR = crate :: BitReader ;
#[doc = "Field `HSITRIM` reader - Internal High Speed clock trimming"] pub type HsitrimR = crate :: FieldReader ;
#[doc = "Field `HSITRIM` writer - Internal High Speed clock trimming"] pub type HsitrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `HSICAL` reader - Internal High Speed clock Calibration"] pub type HsicalR = crate :: FieldReader ;
#[doc = "Field `HSEON` reader - External High Speed clock enable"] pub type HseonR = crate :: BitReader ;
#[doc = "Field `HSEON` writer - External High Speed clock enable"] pub type HseonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDY` reader - External High Speed clock ready flag"] pub type HserdyR = crate :: BitReader ;
#[doc = "Field `HSEBYP` reader - External High Speed clock Bypass"] pub type HsebypR = crate :: BitReader ;
#[doc = "Field `HSEBYP` writer - External High Speed clock Bypass"] pub type HsebypW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSSON` reader - Clock Security System enable"] pub type CssonR = crate :: BitReader ;
#[doc = "Field `CSSON` writer - Clock Security System enable"] pub type CssonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLON` reader - PLL enable"] pub type PllonR = crate :: BitReader ;
#[doc = "Field `PLLON` writer - PLL enable"] pub type PllonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLRDY` reader - PLL clock ready flag"] pub type PllrdyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Internal High Speed clock enable"]
#[inline (always)] pub fn hsion (& self) -> HsionR { HsionR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Internal High Speed clock ready flag"]
#[inline (always)] pub fn hsirdy (& self) -> HsirdyR { HsirdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 3:7 - Internal High Speed clock trimming"]
#[inline (always)] pub fn hsitrim (& self) -> HsitrimR { HsitrimR :: new (((self . bits >> 3) & 0x1f) as u8) }
#[doc = "Bits 8:15 - Internal High Speed clock Calibration"]
#[inline (always)] pub fn hsical (& self) -> HsicalR { HsicalR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bit 16 - External High Speed clock enable"]
#[inline (always)] pub fn hseon (& self) -> HseonR { HseonR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - External High Speed clock ready flag"]
#[inline (always)] pub fn hserdy (& self) -> HserdyR { HserdyR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - External High Speed clock Bypass"]
#[inline (always)] pub fn hsebyp (& self) -> HsebypR { HsebypR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Clock Security System enable"]
#[inline (always)] pub fn csson (& self) -> CssonR { CssonR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 24 - PLL enable"]
#[inline (always)] pub fn pllon (& self) -> PllonR { PllonR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - PLL clock ready flag"]
#[inline (always)] pub fn pllrdy (& self) -> PllrdyR { PllrdyR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Internal High Speed clock enable"]
#[inline (always)] pub fn hsion (& mut self) -> HsionW < '_ , CrSpec > { HsionW :: new (self , 0) }
#[doc = "Bits 3:7 - Internal High Speed clock trimming"]
#[inline (always)] pub fn hsitrim (& mut self) -> HsitrimW < '_ , CrSpec > { HsitrimW :: new (self , 3) }
#[doc = "Bit 16 - External High Speed clock enable"]
#[inline (always)] pub fn hseon (& mut self) -> HseonW < '_ , CrSpec > { HseonW :: new (self , 16) }
#[doc = "Bit 18 - External High Speed clock Bypass"]
#[inline (always)] pub fn hsebyp (& mut self) -> HsebypW < '_ , CrSpec > { HsebypW :: new (self , 18) }
#[doc = "Bit 19 - Clock Security System enable"]
#[inline (always)] pub fn csson (& mut self) -> CssonW < '_ , CrSpec > { CssonW :: new (self , 19) }
#[doc = "Bit 24 - PLL enable"]
#[inline (always)] pub fn pllon (& mut self) -> PllonW < '_ , CrSpec > { PllonW :: new (self , 24) } }
#[doc = "Clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x83"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x83 ; } }
#[doc = "CFGR (rw) register accessor: Clock configuration register (RCC_CFGR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "Clock configuration register (RCC_CFGR)"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `SW` reader - System clock Switch"] pub type SwR = crate :: FieldReader ;
#[doc = "Field `SW` writer - System clock Switch"] pub type SwW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SWS` reader - System Clock Switch Status"] pub type SwsR = crate :: FieldReader ;
#[doc = "Field `HPRE` reader - AHB prescaler"] pub type HpreR = crate :: FieldReader ;
#[doc = "Field `HPRE` writer - AHB prescaler"] pub type HpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PPRE1` reader - APB Low speed prescaler (APB1)"] pub type Ppre1R = crate :: FieldReader ;
#[doc = "Field `PPRE1` writer - APB Low speed prescaler (APB1)"] pub type Ppre1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PPRE2` reader - APB High speed prescaler (APB2)"] pub type Ppre2R = crate :: FieldReader ;
#[doc = "Field `PPRE2` writer - APB High speed prescaler (APB2)"] pub type Ppre2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `ADCPRE` reader - ADC prescaler"] pub type AdcpreR = crate :: FieldReader ;
#[doc = "Field `ADCPRE` writer - ADC prescaler"] pub type AdcpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PLLSRC` reader - PLL entry clock source"] pub type PllsrcR = crate :: BitReader ;
#[doc = "Field `PLLSRC` writer - PLL entry clock source"] pub type PllsrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLXTPRE` reader - HSE divider for PLL entry"] pub type PllxtpreR = crate :: BitReader ;
#[doc = "Field `PLLXTPRE` writer - HSE divider for PLL entry"] pub type PllxtpreW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLMUL` reader - PLL Multiplication Factor"] pub type PllmulR = crate :: FieldReader ;
#[doc = "Field `PLLMUL` writer - PLL Multiplication Factor"] pub type PllmulW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `OTGFSPRE` reader - USB OTG FS prescaler"] pub type OtgfspreR = crate :: BitReader ;
#[doc = "Field `OTGFSPRE` writer - USB OTG FS prescaler"] pub type OtgfspreW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCO` reader - Microcontroller clock output"] pub type McoR = crate :: FieldReader ;
#[doc = "Field `MCO` writer - Microcontroller clock output"] pub type McoW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - System clock Switch"]
#[inline (always)] pub fn sw (& self) -> SwR { SwR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - System Clock Switch Status"]
#[inline (always)] pub fn sws (& self) -> SwsR { SwsR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - AHB prescaler"]
#[inline (always)] pub fn hpre (& self) -> HpreR { HpreR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:10 - APB Low speed prescaler (APB1)"]
#[inline (always)] pub fn ppre1 (& self) -> Ppre1R { Ppre1R :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 11:13 - APB High speed prescaler (APB2)"]
#[inline (always)] pub fn ppre2 (& self) -> Ppre2R { Ppre2R :: new (((self . bits >> 11) & 7) as u8) }
#[doc = "Bits 14:15 - ADC prescaler"]
#[inline (always)] pub fn adcpre (& self) -> AdcpreR { AdcpreR :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bit 16 - PLL entry clock source"]
#[inline (always)] pub fn pllsrc (& self) -> PllsrcR { PllsrcR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - HSE divider for PLL entry"]
#[inline (always)] pub fn pllxtpre (& self) -> PllxtpreR { PllxtpreR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:21 - PLL Multiplication Factor"]
#[inline (always)] pub fn pllmul (& self) -> PllmulR { PllmulR :: new (((self . bits >> 18) & 0x0f) as u8) }
#[doc = "Bit 22 - USB OTG FS prescaler"]
#[inline (always)] pub fn otgfspre (& self) -> OtgfspreR { OtgfspreR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bits 24:26 - Microcontroller clock output"]
#[inline (always)] pub fn mco (& self) -> McoR { McoR :: new (((self . bits >> 24) & 7) as u8) } } impl W {
#[doc = "Bits 0:1 - System clock Switch"]
#[inline (always)] pub fn sw (& mut self) -> SwW < '_ , CfgrSpec > { SwW :: new (self , 0) }
#[doc = "Bits 4:7 - AHB prescaler"]
#[inline (always)] pub fn hpre (& mut self) -> HpreW < '_ , CfgrSpec > { HpreW :: new (self , 4) }
#[doc = "Bits 8:10 - APB Low speed prescaler (APB1)"]
#[inline (always)] pub fn ppre1 (& mut self) -> Ppre1W < '_ , CfgrSpec > { Ppre1W :: new (self , 8) }
#[doc = "Bits 11:13 - APB High speed prescaler (APB2)"]
#[inline (always)] pub fn ppre2 (& mut self) -> Ppre2W < '_ , CfgrSpec > { Ppre2W :: new (self , 11) }
#[doc = "Bits 14:15 - ADC prescaler"]
#[inline (always)] pub fn adcpre (& mut self) -> AdcpreW < '_ , CfgrSpec > { AdcpreW :: new (self , 14) }
#[doc = "Bit 16 - PLL entry clock source"]
#[inline (always)] pub fn pllsrc (& mut self) -> PllsrcW < '_ , CfgrSpec > { PllsrcW :: new (self , 16) }
#[doc = "Bit 17 - HSE divider for PLL entry"]
#[inline (always)] pub fn pllxtpre (& mut self) -> PllxtpreW < '_ , CfgrSpec > { PllxtpreW :: new (self , 17) }
#[doc = "Bits 18:21 - PLL Multiplication Factor"]
#[inline (always)] pub fn pllmul (& mut self) -> PllmulW < '_ , CfgrSpec > { PllmulW :: new (self , 18) }
#[doc = "Bit 22 - USB OTG FS prescaler"]
#[inline (always)] pub fn otgfspre (& mut self) -> OtgfspreW < '_ , CfgrSpec > { OtgfspreW :: new (self , 22) }
#[doc = "Bits 24:26 - Microcontroller clock output"]
#[inline (always)] pub fn mco (& mut self) -> McoW < '_ , CfgrSpec > { McoW :: new (self , 24) } }
#[doc = "Clock configuration register (RCC_CFGR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0"] impl crate :: Resettable for CfgrSpec { } }
#[doc = "CIR (rw) register accessor: Clock interrupt register (RCC_CIR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cir`] module"]
#[doc (alias = "CIR")] pub type Cir = crate :: Reg < cir :: CirSpec > ;
#[doc = "Clock interrupt register (RCC_CIR)"] pub mod cir {
#[doc = "Register `CIR` reader"] pub type R = crate :: R < CirSpec > ;
#[doc = "Register `CIR` writer"] pub type W = crate :: W < CirSpec > ;
#[doc = "Field `LSIRDYF` reader - LSI Ready Interrupt flag"] pub type LsirdyfR = crate :: BitReader ;
#[doc = "Field `LSERDYF` reader - LSE Ready Interrupt flag"] pub type LserdyfR = crate :: BitReader ;
#[doc = "Field `HSIRDYF` reader - HSI Ready Interrupt flag"] pub type HsirdyfR = crate :: BitReader ;
#[doc = "Field `HSERDYF` reader - HSE Ready Interrupt flag"] pub type HserdyfR = crate :: BitReader ;
#[doc = "Field `PLLRDYF` reader - PLL Ready Interrupt flag"] pub type PllrdyfR = crate :: BitReader ;
#[doc = "Field `CSSF` reader - Clock Security System Interrupt flag"] pub type CssfR = crate :: BitReader ;
#[doc = "Field `LSIRDYIE` reader - LSI Ready Interrupt Enable"] pub type LsirdyieR = crate :: BitReader ;
#[doc = "Field `LSIRDYIE` writer - LSI Ready Interrupt Enable"] pub type LsirdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSERDYIE` reader - LSE Ready Interrupt Enable"] pub type LserdyieR = crate :: BitReader ;
#[doc = "Field `LSERDYIE` writer - LSE Ready Interrupt Enable"] pub type LserdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDYIE` reader - HSI Ready Interrupt Enable"] pub type HsirdyieR = crate :: BitReader ;
#[doc = "Field `HSIRDYIE` writer - HSI Ready Interrupt Enable"] pub type HsirdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDYIE` reader - HSE Ready Interrupt Enable"] pub type HserdyieR = crate :: BitReader ;
#[doc = "Field `HSERDYIE` writer - HSE Ready Interrupt Enable"] pub type HserdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLRDYIE` reader - PLL Ready Interrupt Enable"] pub type PllrdyieR = crate :: BitReader ;
#[doc = "Field `PLLRDYIE` writer - PLL Ready Interrupt Enable"] pub type PllrdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSIRDYC` writer - LSI Ready Interrupt Clear"] pub type LsirdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSERDYC` writer - LSE Ready Interrupt Clear"] pub type LserdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDYC` writer - HSI Ready Interrupt Clear"] pub type HsirdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDYC` writer - HSE Ready Interrupt Clear"] pub type HserdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLLRDYC` writer - PLL Ready Interrupt Clear"] pub type PllrdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSSC` writer - Clock security system interrupt clear"] pub type CsscW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - LSI Ready Interrupt flag"]
#[inline (always)] pub fn lsirdyf (& self) -> LsirdyfR { LsirdyfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - LSE Ready Interrupt flag"]
#[inline (always)] pub fn lserdyf (& self) -> LserdyfR { LserdyfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - HSI Ready Interrupt flag"]
#[inline (always)] pub fn hsirdyf (& self) -> HsirdyfR { HsirdyfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - HSE Ready Interrupt flag"]
#[inline (always)] pub fn hserdyf (& self) -> HserdyfR { HserdyfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - PLL Ready Interrupt flag"]
#[inline (always)] pub fn pllrdyf (& self) -> PllrdyfR { PllrdyfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - Clock Security System Interrupt flag"]
#[inline (always)] pub fn cssf (& self) -> CssfR { CssfR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - LSI Ready Interrupt Enable"]
#[inline (always)] pub fn lsirdyie (& self) -> LsirdyieR { LsirdyieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - LSE Ready Interrupt Enable"]
#[inline (always)] pub fn lserdyie (& self) -> LserdyieR { LserdyieR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - HSI Ready Interrupt Enable"]
#[inline (always)] pub fn hsirdyie (& self) -> HsirdyieR { HsirdyieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - HSE Ready Interrupt Enable"]
#[inline (always)] pub fn hserdyie (& self) -> HserdyieR { HserdyieR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - PLL Ready Interrupt Enable"]
#[inline (always)] pub fn pllrdyie (& self) -> PllrdyieR { PllrdyieR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 8 - LSI Ready Interrupt Enable"]
#[inline (always)] pub fn lsirdyie (& mut self) -> LsirdyieW < '_ , CirSpec > { LsirdyieW :: new (self , 8) }
#[doc = "Bit 9 - LSE Ready Interrupt Enable"]
#[inline (always)] pub fn lserdyie (& mut self) -> LserdyieW < '_ , CirSpec > { LserdyieW :: new (self , 9) }
#[doc = "Bit 10 - HSI Ready Interrupt Enable"]
#[inline (always)] pub fn hsirdyie (& mut self) -> HsirdyieW < '_ , CirSpec > { HsirdyieW :: new (self , 10) }
#[doc = "Bit 11 - HSE Ready Interrupt Enable"]
#[inline (always)] pub fn hserdyie (& mut self) -> HserdyieW < '_ , CirSpec > { HserdyieW :: new (self , 11) }
#[doc = "Bit 12 - PLL Ready Interrupt Enable"]
#[inline (always)] pub fn pllrdyie (& mut self) -> PllrdyieW < '_ , CirSpec > { PllrdyieW :: new (self , 12) }
#[doc = "Bit 16 - LSI Ready Interrupt Clear"]
#[inline (always)] pub fn lsirdyc (& mut self) -> LsirdycW < '_ , CirSpec > { LsirdycW :: new (self , 16) }
#[doc = "Bit 17 - LSE Ready Interrupt Clear"]
#[inline (always)] pub fn lserdyc (& mut self) -> LserdycW < '_ , CirSpec > { LserdycW :: new (self , 17) }
#[doc = "Bit 18 - HSI Ready Interrupt Clear"]
#[inline (always)] pub fn hsirdyc (& mut self) -> HsirdycW < '_ , CirSpec > { HsirdycW :: new (self , 18) }
#[doc = "Bit 19 - HSE Ready Interrupt Clear"]
#[inline (always)] pub fn hserdyc (& mut self) -> HserdycW < '_ , CirSpec > { HserdycW :: new (self , 19) }
#[doc = "Bit 20 - PLL Ready Interrupt Clear"]
#[inline (always)] pub fn pllrdyc (& mut self) -> PllrdycW < '_ , CirSpec > { PllrdycW :: new (self , 20) }
#[doc = "Bit 23 - Clock security system interrupt clear"]
#[inline (always)] pub fn cssc (& mut self) -> CsscW < '_ , CirSpec > { CsscW :: new (self , 23) } }
#[doc = "Clock interrupt register (RCC_CIR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CirSpec ; impl crate :: RegisterSpec for CirSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cir::R`](R) reader structure"] impl crate :: Readable for CirSpec { }
#[doc = "`write(|w| ..)` method takes [`cir::W`](W) writer structure"] impl crate :: Writable for CirSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CIR to value 0"] impl crate :: Resettable for CirSpec { } }
#[doc = "APB2RSTR (rw) register accessor: APB2 peripheral reset register (RCC_APB2RSTR)\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb2rstr`] module"]
#[doc (alias = "APB2RSTR")] pub type Apb2rstr = crate :: Reg < apb2rstr :: Apb2rstrSpec > ;
#[doc = "APB2 peripheral reset register (RCC_APB2RSTR)"] pub mod apb2rstr {
#[doc = "Register `APB2RSTR` reader"] pub type R = crate :: R < Apb2rstrSpec > ;
#[doc = "Register `APB2RSTR` writer"] pub type W = crate :: W < Apb2rstrSpec > ;
#[doc = "Field `AFIORST` reader - Alternate function I/O reset"] pub type AfiorstR = crate :: BitReader ;
#[doc = "Field `AFIORST` writer - Alternate function I/O reset"] pub type AfiorstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPARST` reader - IO port A reset"] pub type IoparstR = crate :: BitReader ;
#[doc = "Field `IOPARST` writer - IO port A reset"] pub type IoparstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPBRST` reader - IO port B reset"] pub type IopbrstR = crate :: BitReader ;
#[doc = "Field `IOPBRST` writer - IO port B reset"] pub type IopbrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPCRST` reader - IO port C reset"] pub type IopcrstR = crate :: BitReader ;
#[doc = "Field `IOPCRST` writer - IO port C reset"] pub type IopcrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPDRST` reader - IO port D reset"] pub type IopdrstR = crate :: BitReader ;
#[doc = "Field `IOPDRST` writer - IO port D reset"] pub type IopdrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPERST` reader - IO port E reset"] pub type IoperstR = crate :: BitReader ;
#[doc = "Field `IOPERST` writer - IO port E reset"] pub type IoperstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPFRST` reader - IO port F reset"] pub type IopfrstR = crate :: BitReader ;
#[doc = "Field `IOPFRST` writer - IO port F reset"] pub type IopfrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPGRST` reader - IO port G reset"] pub type IopgrstR = crate :: BitReader ;
#[doc = "Field `IOPGRST` writer - IO port G reset"] pub type IopgrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC1RST` reader - ADC 1 interface reset"] pub type Adc1rstR = crate :: BitReader ;
#[doc = "Field `ADC1RST` writer - ADC 1 interface reset"] pub type Adc1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC2RST` reader - ADC 2 interface reset"] pub type Adc2rstR = crate :: BitReader ;
#[doc = "Field `ADC2RST` writer - ADC 2 interface reset"] pub type Adc2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM1RST` reader - TIM1 timer reset"] pub type Tim1rstR = crate :: BitReader ;
#[doc = "Field `TIM1RST` writer - TIM1 timer reset"] pub type Tim1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1RST` reader - SPI 1 reset"] pub type Spi1rstR = crate :: BitReader ;
#[doc = "Field `SPI1RST` writer - SPI 1 reset"] pub type Spi1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM8RST` reader - TIM8 timer reset"] pub type Tim8rstR = crate :: BitReader ;
#[doc = "Field `TIM8RST` writer - TIM8 timer reset"] pub type Tim8rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART1RST` reader - USART1 reset"] pub type Usart1rstR = crate :: BitReader ;
#[doc = "Field `USART1RST` writer - USART1 reset"] pub type Usart1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC3RST` reader - ADC 3 interface reset"] pub type Adc3rstR = crate :: BitReader ;
#[doc = "Field `ADC3RST` writer - ADC 3 interface reset"] pub type Adc3rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM9RST` reader - TIM9 timer reset"] pub type Tim9rstR = crate :: BitReader ;
#[doc = "Field `TIM9RST` writer - TIM9 timer reset"] pub type Tim9rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM10RST` reader - TIM10 timer reset"] pub type Tim10rstR = crate :: BitReader ;
#[doc = "Field `TIM10RST` writer - TIM10 timer reset"] pub type Tim10rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM11RST` reader - TIM11 timer reset"] pub type Tim11rstR = crate :: BitReader ;
#[doc = "Field `TIM11RST` writer - TIM11 timer reset"] pub type Tim11rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Alternate function I/O reset"]
#[inline (always)] pub fn afiorst (& self) -> AfiorstR { AfiorstR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - IO port A reset"]
#[inline (always)] pub fn ioparst (& self) -> IoparstR { IoparstR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - IO port B reset"]
#[inline (always)] pub fn iopbrst (& self) -> IopbrstR { IopbrstR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IO port C reset"]
#[inline (always)] pub fn iopcrst (& self) -> IopcrstR { IopcrstR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - IO port D reset"]
#[inline (always)] pub fn iopdrst (& self) -> IopdrstR { IopdrstR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - IO port E reset"]
#[inline (always)] pub fn ioperst (& self) -> IoperstR { IoperstR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - IO port F reset"]
#[inline (always)] pub fn iopfrst (& self) -> IopfrstR { IopfrstR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - IO port G reset"]
#[inline (always)] pub fn iopgrst (& self) -> IopgrstR { IopgrstR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - ADC 1 interface reset"]
#[inline (always)] pub fn adc1rst (& self) -> Adc1rstR { Adc1rstR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - ADC 2 interface reset"]
#[inline (always)] pub fn adc2rst (& self) -> Adc2rstR { Adc2rstR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - TIM1 timer reset"]
#[inline (always)] pub fn tim1rst (& self) -> Tim1rstR { Tim1rstR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - SPI 1 reset"]
#[inline (always)] pub fn spi1rst (& self) -> Spi1rstR { Spi1rstR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - TIM8 timer reset"]
#[inline (always)] pub fn tim8rst (& self) -> Tim8rstR { Tim8rstR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - USART1 reset"]
#[inline (always)] pub fn usart1rst (& self) -> Usart1rstR { Usart1rstR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - ADC 3 interface reset"]
#[inline (always)] pub fn adc3rst (& self) -> Adc3rstR { Adc3rstR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 19 - TIM9 timer reset"]
#[inline (always)] pub fn tim9rst (& self) -> Tim9rstR { Tim9rstR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - TIM10 timer reset"]
#[inline (always)] pub fn tim10rst (& self) -> Tim10rstR { Tim10rstR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - TIM11 timer reset"]
#[inline (always)] pub fn tim11rst (& self) -> Tim11rstR { Tim11rstR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Alternate function I/O reset"]
#[inline (always)] pub fn afiorst (& mut self) -> AfiorstW < '_ , Apb2rstrSpec > { AfiorstW :: new (self , 0) }
#[doc = "Bit 2 - IO port A reset"]
#[inline (always)] pub fn ioparst (& mut self) -> IoparstW < '_ , Apb2rstrSpec > { IoparstW :: new (self , 2) }
#[doc = "Bit 3 - IO port B reset"]
#[inline (always)] pub fn iopbrst (& mut self) -> IopbrstW < '_ , Apb2rstrSpec > { IopbrstW :: new (self , 3) }
#[doc = "Bit 4 - IO port C reset"]
#[inline (always)] pub fn iopcrst (& mut self) -> IopcrstW < '_ , Apb2rstrSpec > { IopcrstW :: new (self , 4) }
#[doc = "Bit 5 - IO port D reset"]
#[inline (always)] pub fn iopdrst (& mut self) -> IopdrstW < '_ , Apb2rstrSpec > { IopdrstW :: new (self , 5) }
#[doc = "Bit 6 - IO port E reset"]
#[inline (always)] pub fn ioperst (& mut self) -> IoperstW < '_ , Apb2rstrSpec > { IoperstW :: new (self , 6) }
#[doc = "Bit 7 - IO port F reset"]
#[inline (always)] pub fn iopfrst (& mut self) -> IopfrstW < '_ , Apb2rstrSpec > { IopfrstW :: new (self , 7) }
#[doc = "Bit 8 - IO port G reset"]
#[inline (always)] pub fn iopgrst (& mut self) -> IopgrstW < '_ , Apb2rstrSpec > { IopgrstW :: new (self , 8) }
#[doc = "Bit 9 - ADC 1 interface reset"]
#[inline (always)] pub fn adc1rst (& mut self) -> Adc1rstW < '_ , Apb2rstrSpec > { Adc1rstW :: new (self , 9) }
#[doc = "Bit 10 - ADC 2 interface reset"]
#[inline (always)] pub fn adc2rst (& mut self) -> Adc2rstW < '_ , Apb2rstrSpec > { Adc2rstW :: new (self , 10) }
#[doc = "Bit 11 - TIM1 timer reset"]
#[inline (always)] pub fn tim1rst (& mut self) -> Tim1rstW < '_ , Apb2rstrSpec > { Tim1rstW :: new (self , 11) }
#[doc = "Bit 12 - SPI 1 reset"]
#[inline (always)] pub fn spi1rst (& mut self) -> Spi1rstW < '_ , Apb2rstrSpec > { Spi1rstW :: new (self , 12) }
#[doc = "Bit 13 - TIM8 timer reset"]
#[inline (always)] pub fn tim8rst (& mut self) -> Tim8rstW < '_ , Apb2rstrSpec > { Tim8rstW :: new (self , 13) }
#[doc = "Bit 14 - USART1 reset"]
#[inline (always)] pub fn usart1rst (& mut self) -> Usart1rstW < '_ , Apb2rstrSpec > { Usart1rstW :: new (self , 14) }
#[doc = "Bit 15 - ADC 3 interface reset"]
#[inline (always)] pub fn adc3rst (& mut self) -> Adc3rstW < '_ , Apb2rstrSpec > { Adc3rstW :: new (self , 15) }
#[doc = "Bit 19 - TIM9 timer reset"]
#[inline (always)] pub fn tim9rst (& mut self) -> Tim9rstW < '_ , Apb2rstrSpec > { Tim9rstW :: new (self , 19) }
#[doc = "Bit 20 - TIM10 timer reset"]
#[inline (always)] pub fn tim10rst (& mut self) -> Tim10rstW < '_ , Apb2rstrSpec > { Tim10rstW :: new (self , 20) }
#[doc = "Bit 21 - TIM11 timer reset"]
#[inline (always)] pub fn tim11rst (& mut self) -> Tim11rstW < '_ , Apb2rstrSpec > { Tim11rstW :: new (self , 21) } }
#[doc = "APB2 peripheral reset register (RCC_APB2RSTR)\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb2rstrSpec ; impl crate :: RegisterSpec for Apb2rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb2rstr::R`](R) reader structure"] impl crate :: Readable for Apb2rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb2rstr::W`](W) writer structure"] impl crate :: Writable for Apb2rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB2RSTR to value 0"] impl crate :: Resettable for Apb2rstrSpec { } }
#[doc = "APB1RSTR (rw) register accessor: APB1 peripheral reset register (RCC_APB1RSTR)\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1rstr`] module"]
#[doc (alias = "APB1RSTR")] pub type Apb1rstr = crate :: Reg < apb1rstr :: Apb1rstrSpec > ;
#[doc = "APB1 peripheral reset register (RCC_APB1RSTR)"] pub mod apb1rstr {
#[doc = "Register `APB1RSTR` reader"] pub type R = crate :: R < Apb1rstrSpec > ;
#[doc = "Register `APB1RSTR` writer"] pub type W = crate :: W < Apb1rstrSpec > ;
#[doc = "Field `TIM2RST` reader - Timer 2 reset"] pub type Tim2rstR = crate :: BitReader ;
#[doc = "Field `TIM2RST` writer - Timer 2 reset"] pub type Tim2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM3RST` reader - Timer 3 reset"] pub type Tim3rstR = crate :: BitReader ;
#[doc = "Field `TIM3RST` writer - Timer 3 reset"] pub type Tim3rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM4RST` reader - Timer 4 reset"] pub type Tim4rstR = crate :: BitReader ;
#[doc = "Field `TIM4RST` writer - Timer 4 reset"] pub type Tim4rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM5RST` reader - Timer 5 reset"] pub type Tim5rstR = crate :: BitReader ;
#[doc = "Field `TIM5RST` writer - Timer 5 reset"] pub type Tim5rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM6RST` reader - Timer 6 reset"] pub type Tim6rstR = crate :: BitReader ;
#[doc = "Field `TIM6RST` writer - Timer 6 reset"] pub type Tim6rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM7RST` reader - Timer 7 reset"] pub type Tim7rstR = crate :: BitReader ;
#[doc = "Field `TIM7RST` writer - Timer 7 reset"] pub type Tim7rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM12RST` reader - Timer 12 reset"] pub type Tim12rstR = crate :: BitReader ;
#[doc = "Field `TIM12RST` writer - Timer 12 reset"] pub type Tim12rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM13RST` reader - Timer 13 reset"] pub type Tim13rstR = crate :: BitReader ;
#[doc = "Field `TIM13RST` writer - Timer 13 reset"] pub type Tim13rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM14RST` reader - Timer 14 reset"] pub type Tim14rstR = crate :: BitReader ;
#[doc = "Field `TIM14RST` writer - Timer 14 reset"] pub type Tim14rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDGRST` reader - Window watchdog reset"] pub type WwdgrstR = crate :: BitReader ;
#[doc = "Field `WWDGRST` writer - Window watchdog reset"] pub type WwdgrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2RST` reader - SPI2 reset"] pub type Spi2rstR = crate :: BitReader ;
#[doc = "Field `SPI2RST` writer - SPI2 reset"] pub type Spi2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI3RST` reader - SPI3 reset"] pub type Spi3rstR = crate :: BitReader ;
#[doc = "Field `SPI3RST` writer - SPI3 reset"] pub type Spi3rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART2RST` reader - USART 2 reset"] pub type Usart2rstR = crate :: BitReader ;
#[doc = "Field `USART2RST` writer - USART 2 reset"] pub type Usart2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART3RST` reader - USART 3 reset"] pub type Usart3rstR = crate :: BitReader ;
#[doc = "Field `USART3RST` writer - USART 3 reset"] pub type Usart3rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART4RST` reader - UART 4 reset"] pub type Uart4rstR = crate :: BitReader ;
#[doc = "Field `UART4RST` writer - UART 4 reset"] pub type Uart4rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART5RST` reader - UART 5 reset"] pub type Uart5rstR = crate :: BitReader ;
#[doc = "Field `UART5RST` writer - UART 5 reset"] pub type Uart5rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1RST` reader - I2C1 reset"] pub type I2c1rstR = crate :: BitReader ;
#[doc = "Field `I2C1RST` writer - I2C1 reset"] pub type I2c1rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C2RST` reader - I2C2 reset"] pub type I2c2rstR = crate :: BitReader ;
#[doc = "Field `I2C2RST` writer - I2C2 reset"] pub type I2c2rstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBRST` reader - USB reset"] pub type UsbrstR = crate :: BitReader ;
#[doc = "Field `USBRST` writer - USB reset"] pub type UsbrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CANRST` reader - CAN reset"] pub type CanrstR = crate :: BitReader ;
#[doc = "Field `CANRST` writer - CAN reset"] pub type CanrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKPRST` reader - Backup interface reset"] pub type BkprstR = crate :: BitReader ;
#[doc = "Field `BKPRST` writer - Backup interface reset"] pub type BkprstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWRRST` reader - Power interface reset"] pub type PwrrstR = crate :: BitReader ;
#[doc = "Field `PWRRST` writer - Power interface reset"] pub type PwrrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DACRST` reader - DAC interface reset"] pub type DacrstR = crate :: BitReader ;
#[doc = "Field `DACRST` writer - DAC interface reset"] pub type DacrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Timer 2 reset"]
#[inline (always)] pub fn tim2rst (& self) -> Tim2rstR { Tim2rstR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Timer 3 reset"]
#[inline (always)] pub fn tim3rst (& self) -> Tim3rstR { Tim3rstR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Timer 4 reset"]
#[inline (always)] pub fn tim4rst (& self) -> Tim4rstR { Tim4rstR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Timer 5 reset"]
#[inline (always)] pub fn tim5rst (& self) -> Tim5rstR { Tim5rstR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Timer 6 reset"]
#[inline (always)] pub fn tim6rst (& self) -> Tim6rstR { Tim6rstR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Timer 7 reset"]
#[inline (always)] pub fn tim7rst (& self) -> Tim7rstR { Tim7rstR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Timer 12 reset"]
#[inline (always)] pub fn tim12rst (& self) -> Tim12rstR { Tim12rstR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Timer 13 reset"]
#[inline (always)] pub fn tim13rst (& self) -> Tim13rstR { Tim13rstR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Timer 14 reset"]
#[inline (always)] pub fn tim14rst (& self) -> Tim14rstR { Tim14rstR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 11 - Window watchdog reset"]
#[inline (always)] pub fn wwdgrst (& self) -> WwdgrstR { WwdgrstR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 14 - SPI2 reset"]
#[inline (always)] pub fn spi2rst (& self) -> Spi2rstR { Spi2rstR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - SPI3 reset"]
#[inline (always)] pub fn spi3rst (& self) -> Spi3rstR { Spi3rstR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - USART 2 reset"]
#[inline (always)] pub fn usart2rst (& self) -> Usart2rstR { Usart2rstR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - USART 3 reset"]
#[inline (always)] pub fn usart3rst (& self) -> Usart3rstR { Usart3rstR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - UART 4 reset"]
#[inline (always)] pub fn uart4rst (& self) -> Uart4rstR { Uart4rstR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - UART 5 reset"]
#[inline (always)] pub fn uart5rst (& self) -> Uart5rstR { Uart5rstR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - I2C1 reset"]
#[inline (always)] pub fn i2c1rst (& self) -> I2c1rstR { I2c1rstR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - I2C2 reset"]
#[inline (always)] pub fn i2c2rst (& self) -> I2c2rstR { I2c2rstR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - USB reset"]
#[inline (always)] pub fn usbrst (& self) -> UsbrstR { UsbrstR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 25 - CAN reset"]
#[inline (always)] pub fn canrst (& self) -> CanrstR { CanrstR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 27 - Backup interface reset"]
#[inline (always)] pub fn bkprst (& self) -> BkprstR { BkprstR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Power interface reset"]
#[inline (always)] pub fn pwrrst (& self) -> PwrrstR { PwrrstR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - DAC interface reset"]
#[inline (always)] pub fn dacrst (& self) -> DacrstR { DacrstR :: new (((self . bits >> 29) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Timer 2 reset"]
#[inline (always)] pub fn tim2rst (& mut self) -> Tim2rstW < '_ , Apb1rstrSpec > { Tim2rstW :: new (self , 0) }
#[doc = "Bit 1 - Timer 3 reset"]
#[inline (always)] pub fn tim3rst (& mut self) -> Tim3rstW < '_ , Apb1rstrSpec > { Tim3rstW :: new (self , 1) }
#[doc = "Bit 2 - Timer 4 reset"]
#[inline (always)] pub fn tim4rst (& mut self) -> Tim4rstW < '_ , Apb1rstrSpec > { Tim4rstW :: new (self , 2) }
#[doc = "Bit 3 - Timer 5 reset"]
#[inline (always)] pub fn tim5rst (& mut self) -> Tim5rstW < '_ , Apb1rstrSpec > { Tim5rstW :: new (self , 3) }
#[doc = "Bit 4 - Timer 6 reset"]
#[inline (always)] pub fn tim6rst (& mut self) -> Tim6rstW < '_ , Apb1rstrSpec > { Tim6rstW :: new (self , 4) }
#[doc = "Bit 5 - Timer 7 reset"]
#[inline (always)] pub fn tim7rst (& mut self) -> Tim7rstW < '_ , Apb1rstrSpec > { Tim7rstW :: new (self , 5) }
#[doc = "Bit 6 - Timer 12 reset"]
#[inline (always)] pub fn tim12rst (& mut self) -> Tim12rstW < '_ , Apb1rstrSpec > { Tim12rstW :: new (self , 6) }
#[doc = "Bit 7 - Timer 13 reset"]
#[inline (always)] pub fn tim13rst (& mut self) -> Tim13rstW < '_ , Apb1rstrSpec > { Tim13rstW :: new (self , 7) }
#[doc = "Bit 8 - Timer 14 reset"]
#[inline (always)] pub fn tim14rst (& mut self) -> Tim14rstW < '_ , Apb1rstrSpec > { Tim14rstW :: new (self , 8) }
#[doc = "Bit 11 - Window watchdog reset"]
#[inline (always)] pub fn wwdgrst (& mut self) -> WwdgrstW < '_ , Apb1rstrSpec > { WwdgrstW :: new (self , 11) }
#[doc = "Bit 14 - SPI2 reset"]
#[inline (always)] pub fn spi2rst (& mut self) -> Spi2rstW < '_ , Apb1rstrSpec > { Spi2rstW :: new (self , 14) }
#[doc = "Bit 15 - SPI3 reset"]
#[inline (always)] pub fn spi3rst (& mut self) -> Spi3rstW < '_ , Apb1rstrSpec > { Spi3rstW :: new (self , 15) }
#[doc = "Bit 17 - USART 2 reset"]
#[inline (always)] pub fn usart2rst (& mut self) -> Usart2rstW < '_ , Apb1rstrSpec > { Usart2rstW :: new (self , 17) }
#[doc = "Bit 18 - USART 3 reset"]
#[inline (always)] pub fn usart3rst (& mut self) -> Usart3rstW < '_ , Apb1rstrSpec > { Usart3rstW :: new (self , 18) }
#[doc = "Bit 19 - UART 4 reset"]
#[inline (always)] pub fn uart4rst (& mut self) -> Uart4rstW < '_ , Apb1rstrSpec > { Uart4rstW :: new (self , 19) }
#[doc = "Bit 20 - UART 5 reset"]
#[inline (always)] pub fn uart5rst (& mut self) -> Uart5rstW < '_ , Apb1rstrSpec > { Uart5rstW :: new (self , 20) }
#[doc = "Bit 21 - I2C1 reset"]
#[inline (always)] pub fn i2c1rst (& mut self) -> I2c1rstW < '_ , Apb1rstrSpec > { I2c1rstW :: new (self , 21) }
#[doc = "Bit 22 - I2C2 reset"]
#[inline (always)] pub fn i2c2rst (& mut self) -> I2c2rstW < '_ , Apb1rstrSpec > { I2c2rstW :: new (self , 22) }
#[doc = "Bit 23 - USB reset"]
#[inline (always)] pub fn usbrst (& mut self) -> UsbrstW < '_ , Apb1rstrSpec > { UsbrstW :: new (self , 23) }
#[doc = "Bit 25 - CAN reset"]
#[inline (always)] pub fn canrst (& mut self) -> CanrstW < '_ , Apb1rstrSpec > { CanrstW :: new (self , 25) }
#[doc = "Bit 27 - Backup interface reset"]
#[inline (always)] pub fn bkprst (& mut self) -> BkprstW < '_ , Apb1rstrSpec > { BkprstW :: new (self , 27) }
#[doc = "Bit 28 - Power interface reset"]
#[inline (always)] pub fn pwrrst (& mut self) -> PwrrstW < '_ , Apb1rstrSpec > { PwrrstW :: new (self , 28) }
#[doc = "Bit 29 - DAC interface reset"]
#[inline (always)] pub fn dacrst (& mut self) -> DacrstW < '_ , Apb1rstrSpec > { DacrstW :: new (self , 29) } }
#[doc = "APB1 peripheral reset register (RCC_APB1RSTR)\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1rstrSpec ; impl crate :: RegisterSpec for Apb1rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1rstr::R`](R) reader structure"] impl crate :: Readable for Apb1rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb1rstr::W`](W) writer structure"] impl crate :: Writable for Apb1rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1RSTR to value 0"] impl crate :: Resettable for Apb1rstrSpec { } }
#[doc = "AHBENR (rw) register accessor: AHB Peripheral Clock enable register (RCC_AHBENR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ahbenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahbenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahbenr`] module"]
#[doc (alias = "AHBENR")] pub type Ahbenr = crate :: Reg < ahbenr :: AhbenrSpec > ;
#[doc = "AHB Peripheral Clock enable register (RCC_AHBENR)"] pub mod ahbenr {
#[doc = "Register `AHBENR` reader"] pub type R = crate :: R < AhbenrSpec > ;
#[doc = "Register `AHBENR` writer"] pub type W = crate :: W < AhbenrSpec > ;
#[doc = "Field `DMA1EN` reader - DMA1 clock enable"] pub type Dma1enR = crate :: BitReader ;
#[doc = "Field `DMA1EN` writer - DMA1 clock enable"] pub type Dma1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA2EN` reader - DMA2 clock enable"] pub type Dma2enR = crate :: BitReader ;
#[doc = "Field `DMA2EN` writer - DMA2 clock enable"] pub type Dma2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAMEN` reader - SRAM interface clock enable"] pub type SramenR = crate :: BitReader ;
#[doc = "Field `SRAMEN` writer - SRAM interface clock enable"] pub type SramenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLITFEN` reader - FLITF clock enable"] pub type FlitfenR = crate :: BitReader ;
#[doc = "Field `FLITFEN` writer - FLITF clock enable"] pub type FlitfenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCEN` reader - CRC clock enable"] pub type CrcenR = crate :: BitReader ;
#[doc = "Field `CRCEN` writer - CRC clock enable"] pub type CrcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSMCEN` reader - FSMC clock enable"] pub type FsmcenR = crate :: BitReader ;
#[doc = "Field `FSMCEN` writer - FSMC clock enable"] pub type FsmcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDIOEN` reader - SDIO clock enable"] pub type SdioenR = crate :: BitReader ;
#[doc = "Field `SDIOEN` writer - SDIO clock enable"] pub type SdioenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DMA1 clock enable"]
#[inline (always)] pub fn dma1en (& self) -> Dma1enR { Dma1enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DMA2 clock enable"]
#[inline (always)] pub fn dma2en (& self) -> Dma2enR { Dma2enR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - SRAM interface clock enable"]
#[inline (always)] pub fn sramen (& self) -> SramenR { SramenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - FLITF clock enable"]
#[inline (always)] pub fn flitfen (& self) -> FlitfenR { FlitfenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - CRC clock enable"]
#[inline (always)] pub fn crcen (& self) -> CrcenR { CrcenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - FSMC clock enable"]
#[inline (always)] pub fn fsmcen (& self) -> FsmcenR { FsmcenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 10 - SDIO clock enable"]
#[inline (always)] pub fn sdioen (& self) -> SdioenR { SdioenR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DMA1 clock enable"]
#[inline (always)] pub fn dma1en (& mut self) -> Dma1enW < '_ , AhbenrSpec > { Dma1enW :: new (self , 0) }
#[doc = "Bit 1 - DMA2 clock enable"]
#[inline (always)] pub fn dma2en (& mut self) -> Dma2enW < '_ , AhbenrSpec > { Dma2enW :: new (self , 1) }
#[doc = "Bit 2 - SRAM interface clock enable"]
#[inline (always)] pub fn sramen (& mut self) -> SramenW < '_ , AhbenrSpec > { SramenW :: new (self , 2) }
#[doc = "Bit 4 - FLITF clock enable"]
#[inline (always)] pub fn flitfen (& mut self) -> FlitfenW < '_ , AhbenrSpec > { FlitfenW :: new (self , 4) }
#[doc = "Bit 6 - CRC clock enable"]
#[inline (always)] pub fn crcen (& mut self) -> CrcenW < '_ , AhbenrSpec > { CrcenW :: new (self , 6) }
#[doc = "Bit 8 - FSMC clock enable"]
#[inline (always)] pub fn fsmcen (& mut self) -> FsmcenW < '_ , AhbenrSpec > { FsmcenW :: new (self , 8) }
#[doc = "Bit 10 - SDIO clock enable"]
#[inline (always)] pub fn sdioen (& mut self) -> SdioenW < '_ , AhbenrSpec > { SdioenW :: new (self , 10) } }
#[doc = "AHB Peripheral Clock enable register (RCC_AHBENR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ahbenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahbenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AhbenrSpec ; impl crate :: RegisterSpec for AhbenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahbenr::R`](R) reader structure"] impl crate :: Readable for AhbenrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahbenr::W`](W) writer structure"] impl crate :: Writable for AhbenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHBENR to value 0x14"] impl crate :: Resettable for AhbenrSpec { const RESET_VALUE : u32 = 0x14 ; } }
#[doc = "APB2ENR (rw) register accessor: APB2 peripheral clock enable register (RCC_APB2ENR)\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb2enr`] module"]
#[doc (alias = "APB2ENR")] pub type Apb2enr = crate :: Reg < apb2enr :: Apb2enrSpec > ;
#[doc = "APB2 peripheral clock enable register (RCC_APB2ENR)"] pub mod apb2enr {
#[doc = "Register `APB2ENR` reader"] pub type R = crate :: R < Apb2enrSpec > ;
#[doc = "Register `APB2ENR` writer"] pub type W = crate :: W < Apb2enrSpec > ;
#[doc = "Field `AFIOEN` reader - Alternate function I/O clock enable"] pub type AfioenR = crate :: BitReader ;
#[doc = "Field `AFIOEN` writer - Alternate function I/O clock enable"] pub type AfioenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPAEN` reader - I/O port A clock enable"] pub type IopaenR = crate :: BitReader ;
#[doc = "Field `IOPAEN` writer - I/O port A clock enable"] pub type IopaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPBEN` reader - I/O port B clock enable"] pub type IopbenR = crate :: BitReader ;
#[doc = "Field `IOPBEN` writer - I/O port B clock enable"] pub type IopbenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPCEN` reader - I/O port C clock enable"] pub type IopcenR = crate :: BitReader ;
#[doc = "Field `IOPCEN` writer - I/O port C clock enable"] pub type IopcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPDEN` reader - I/O port D clock enable"] pub type IopdenR = crate :: BitReader ;
#[doc = "Field `IOPDEN` writer - I/O port D clock enable"] pub type IopdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPEEN` reader - I/O port E clock enable"] pub type IopeenR = crate :: BitReader ;
#[doc = "Field `IOPEEN` writer - I/O port E clock enable"] pub type IopeenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPFEN` reader - I/O port F clock enable"] pub type IopfenR = crate :: BitReader ;
#[doc = "Field `IOPFEN` writer - I/O port F clock enable"] pub type IopfenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOPGEN` reader - I/O port G clock enable"] pub type IopgenR = crate :: BitReader ;
#[doc = "Field `IOPGEN` writer - I/O port G clock enable"] pub type IopgenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC1EN` reader - ADC 1 interface clock enable"] pub type Adc1enR = crate :: BitReader ;
#[doc = "Field `ADC1EN` writer - ADC 1 interface clock enable"] pub type Adc1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC2EN` reader - ADC 2 interface clock enable"] pub type Adc2enR = crate :: BitReader ;
#[doc = "Field `ADC2EN` writer - ADC 2 interface clock enable"] pub type Adc2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM1EN` reader - TIM1 Timer clock enable"] pub type Tim1enR = crate :: BitReader ;
#[doc = "Field `TIM1EN` writer - TIM1 Timer clock enable"] pub type Tim1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1EN` reader - SPI 1 clock enable"] pub type Spi1enR = crate :: BitReader ;
#[doc = "Field `SPI1EN` writer - SPI 1 clock enable"] pub type Spi1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM8EN` reader - TIM8 Timer clock enable"] pub type Tim8enR = crate :: BitReader ;
#[doc = "Field `TIM8EN` writer - TIM8 Timer clock enable"] pub type Tim8enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART1EN` reader - USART1 clock enable"] pub type Usart1enR = crate :: BitReader ;
#[doc = "Field `USART1EN` writer - USART1 clock enable"] pub type Usart1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC3EN` reader - ADC3 interface clock enable"] pub type Adc3enR = crate :: BitReader ;
#[doc = "Field `ADC3EN` writer - ADC3 interface clock enable"] pub type Adc3enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM9EN` reader - TIM9 Timer clock enable"] pub type Tim9enR = crate :: BitReader ;
#[doc = "Field `TIM9EN` writer - TIM9 Timer clock enable"] pub type Tim9enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM10EN` reader - TIM10 Timer clock enable"] pub type Tim10enR = crate :: BitReader ;
#[doc = "Field `TIM10EN` writer - TIM10 Timer clock enable"] pub type Tim10enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM11EN` reader - TIM11 Timer clock enable"] pub type Tim11enR = crate :: BitReader ;
#[doc = "Field `TIM11EN` writer - TIM11 Timer clock enable"] pub type Tim11enW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Alternate function I/O clock enable"]
#[inline (always)] pub fn afioen (& self) -> AfioenR { AfioenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - I/O port A clock enable"]
#[inline (always)] pub fn iopaen (& self) -> IopaenR { IopaenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - I/O port B clock enable"]
#[inline (always)] pub fn iopben (& self) -> IopbenR { IopbenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - I/O port C clock enable"]
#[inline (always)] pub fn iopcen (& self) -> IopcenR { IopcenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - I/O port D clock enable"]
#[inline (always)] pub fn iopden (& self) -> IopdenR { IopdenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - I/O port E clock enable"]
#[inline (always)] pub fn iopeen (& self) -> IopeenR { IopeenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - I/O port F clock enable"]
#[inline (always)] pub fn iopfen (& self) -> IopfenR { IopfenR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - I/O port G clock enable"]
#[inline (always)] pub fn iopgen (& self) -> IopgenR { IopgenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - ADC 1 interface clock enable"]
#[inline (always)] pub fn adc1en (& self) -> Adc1enR { Adc1enR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - ADC 2 interface clock enable"]
#[inline (always)] pub fn adc2en (& self) -> Adc2enR { Adc2enR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - TIM1 Timer clock enable"]
#[inline (always)] pub fn tim1en (& self) -> Tim1enR { Tim1enR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - SPI 1 clock enable"]
#[inline (always)] pub fn spi1en (& self) -> Spi1enR { Spi1enR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - TIM8 Timer clock enable"]
#[inline (always)] pub fn tim8en (& self) -> Tim8enR { Tim8enR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - USART1 clock enable"]
#[inline (always)] pub fn usart1en (& self) -> Usart1enR { Usart1enR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - ADC3 interface clock enable"]
#[inline (always)] pub fn adc3en (& self) -> Adc3enR { Adc3enR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 19 - TIM9 Timer clock enable"]
#[inline (always)] pub fn tim9en (& self) -> Tim9enR { Tim9enR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - TIM10 Timer clock enable"]
#[inline (always)] pub fn tim10en (& self) -> Tim10enR { Tim10enR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - TIM11 Timer clock enable"]
#[inline (always)] pub fn tim11en (& self) -> Tim11enR { Tim11enR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Alternate function I/O clock enable"]
#[inline (always)] pub fn afioen (& mut self) -> AfioenW < '_ , Apb2enrSpec > { AfioenW :: new (self , 0) }
#[doc = "Bit 2 - I/O port A clock enable"]
#[inline (always)] pub fn iopaen (& mut self) -> IopaenW < '_ , Apb2enrSpec > { IopaenW :: new (self , 2) }
#[doc = "Bit 3 - I/O port B clock enable"]
#[inline (always)] pub fn iopben (& mut self) -> IopbenW < '_ , Apb2enrSpec > { IopbenW :: new (self , 3) }
#[doc = "Bit 4 - I/O port C clock enable"]
#[inline (always)] pub fn iopcen (& mut self) -> IopcenW < '_ , Apb2enrSpec > { IopcenW :: new (self , 4) }
#[doc = "Bit 5 - I/O port D clock enable"]
#[inline (always)] pub fn iopden (& mut self) -> IopdenW < '_ , Apb2enrSpec > { IopdenW :: new (self , 5) }
#[doc = "Bit 6 - I/O port E clock enable"]
#[inline (always)] pub fn iopeen (& mut self) -> IopeenW < '_ , Apb2enrSpec > { IopeenW :: new (self , 6) }
#[doc = "Bit 7 - I/O port F clock enable"]
#[inline (always)] pub fn iopfen (& mut self) -> IopfenW < '_ , Apb2enrSpec > { IopfenW :: new (self , 7) }
#[doc = "Bit 8 - I/O port G clock enable"]
#[inline (always)] pub fn iopgen (& mut self) -> IopgenW < '_ , Apb2enrSpec > { IopgenW :: new (self , 8) }
#[doc = "Bit 9 - ADC 1 interface clock enable"]
#[inline (always)] pub fn adc1en (& mut self) -> Adc1enW < '_ , Apb2enrSpec > { Adc1enW :: new (self , 9) }
#[doc = "Bit 10 - ADC 2 interface clock enable"]
#[inline (always)] pub fn adc2en (& mut self) -> Adc2enW < '_ , Apb2enrSpec > { Adc2enW :: new (self , 10) }
#[doc = "Bit 11 - TIM1 Timer clock enable"]
#[inline (always)] pub fn tim1en (& mut self) -> Tim1enW < '_ , Apb2enrSpec > { Tim1enW :: new (self , 11) }
#[doc = "Bit 12 - SPI 1 clock enable"]
#[inline (always)] pub fn spi1en (& mut self) -> Spi1enW < '_ , Apb2enrSpec > { Spi1enW :: new (self , 12) }
#[doc = "Bit 13 - TIM8 Timer clock enable"]
#[inline (always)] pub fn tim8en (& mut self) -> Tim8enW < '_ , Apb2enrSpec > { Tim8enW :: new (self , 13) }
#[doc = "Bit 14 - USART1 clock enable"]
#[inline (always)] pub fn usart1en (& mut self) -> Usart1enW < '_ , Apb2enrSpec > { Usart1enW :: new (self , 14) }
#[doc = "Bit 15 - ADC3 interface clock enable"]
#[inline (always)] pub fn adc3en (& mut self) -> Adc3enW < '_ , Apb2enrSpec > { Adc3enW :: new (self , 15) }
#[doc = "Bit 19 - TIM9 Timer clock enable"]
#[inline (always)] pub fn tim9en (& mut self) -> Tim9enW < '_ , Apb2enrSpec > { Tim9enW :: new (self , 19) }
#[doc = "Bit 20 - TIM10 Timer clock enable"]
#[inline (always)] pub fn tim10en (& mut self) -> Tim10enW < '_ , Apb2enrSpec > { Tim10enW :: new (self , 20) }
#[doc = "Bit 21 - TIM11 Timer clock enable"]
#[inline (always)] pub fn tim11en (& mut self) -> Tim11enW < '_ , Apb2enrSpec > { Tim11enW :: new (self , 21) } }
#[doc = "APB2 peripheral clock enable register (RCC_APB2ENR)\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb2enrSpec ; impl crate :: RegisterSpec for Apb2enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb2enr::R`](R) reader structure"] impl crate :: Readable for Apb2enrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb2enr::W`](W) writer structure"] impl crate :: Writable for Apb2enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB2ENR to value 0"] impl crate :: Resettable for Apb2enrSpec { } }
#[doc = "APB1ENR (rw) register accessor: APB1 peripheral clock enable register (RCC_APB1ENR)\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1enr`] module"]
#[doc (alias = "APB1ENR")] pub type Apb1enr = crate :: Reg < apb1enr :: Apb1enrSpec > ;
#[doc = "APB1 peripheral clock enable register (RCC_APB1ENR)"] pub mod apb1enr {
#[doc = "Register `APB1ENR` reader"] pub type R = crate :: R < Apb1enrSpec > ;
#[doc = "Register `APB1ENR` writer"] pub type W = crate :: W < Apb1enrSpec > ;
#[doc = "Field `TIM2EN` reader - Timer 2 clock enable"] pub type Tim2enR = crate :: BitReader ;
#[doc = "Field `TIM2EN` writer - Timer 2 clock enable"] pub type Tim2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM3EN` reader - Timer 3 clock enable"] pub type Tim3enR = crate :: BitReader ;
#[doc = "Field `TIM3EN` writer - Timer 3 clock enable"] pub type Tim3enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM4EN` reader - Timer 4 clock enable"] pub type Tim4enR = crate :: BitReader ;
#[doc = "Field `TIM4EN` writer - Timer 4 clock enable"] pub type Tim4enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM5EN` reader - Timer 5 clock enable"] pub type Tim5enR = crate :: BitReader ;
#[doc = "Field `TIM5EN` writer - Timer 5 clock enable"] pub type Tim5enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM6EN` reader - Timer 6 clock enable"] pub type Tim6enR = crate :: BitReader ;
#[doc = "Field `TIM6EN` writer - Timer 6 clock enable"] pub type Tim6enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM7EN` reader - Timer 7 clock enable"] pub type Tim7enR = crate :: BitReader ;
#[doc = "Field `TIM7EN` writer - Timer 7 clock enable"] pub type Tim7enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM12EN` reader - Timer 12 clock enable"] pub type Tim12enR = crate :: BitReader ;
#[doc = "Field `TIM12EN` writer - Timer 12 clock enable"] pub type Tim12enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM13EN` reader - Timer 13 clock enable"] pub type Tim13enR = crate :: BitReader ;
#[doc = "Field `TIM13EN` writer - Timer 13 clock enable"] pub type Tim13enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM14EN` reader - Timer 14 clock enable"] pub type Tim14enR = crate :: BitReader ;
#[doc = "Field `TIM14EN` writer - Timer 14 clock enable"] pub type Tim14enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDGEN` reader - Window watchdog clock enable"] pub type WwdgenR = crate :: BitReader ;
#[doc = "Field `WWDGEN` writer - Window watchdog clock enable"] pub type WwdgenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2EN` reader - SPI 2 clock enable"] pub type Spi2enR = crate :: BitReader ;
#[doc = "Field `SPI2EN` writer - SPI 2 clock enable"] pub type Spi2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI3EN` reader - SPI 3 clock enable"] pub type Spi3enR = crate :: BitReader ;
#[doc = "Field `SPI3EN` writer - SPI 3 clock enable"] pub type Spi3enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART2EN` reader - USART 2 clock enable"] pub type Usart2enR = crate :: BitReader ;
#[doc = "Field `USART2EN` writer - USART 2 clock enable"] pub type Usart2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART3EN` reader - USART 3 clock enable"] pub type Usart3enR = crate :: BitReader ;
#[doc = "Field `USART3EN` writer - USART 3 clock enable"] pub type Usart3enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART4EN` reader - UART 4 clock enable"] pub type Uart4enR = crate :: BitReader ;
#[doc = "Field `UART4EN` writer - UART 4 clock enable"] pub type Uart4enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART5EN` reader - UART 5 clock enable"] pub type Uart5enR = crate :: BitReader ;
#[doc = "Field `UART5EN` writer - UART 5 clock enable"] pub type Uart5enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1EN` reader - I2C 1 clock enable"] pub type I2c1enR = crate :: BitReader ;
#[doc = "Field `I2C1EN` writer - I2C 1 clock enable"] pub type I2c1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C2EN` reader - I2C 2 clock enable"] pub type I2c2enR = crate :: BitReader ;
#[doc = "Field `I2C2EN` writer - I2C 2 clock enable"] pub type I2c2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBEN` reader - USB clock enable"] pub type UsbenR = crate :: BitReader ;
#[doc = "Field `USBEN` writer - USB clock enable"] pub type UsbenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CANEN` reader - CAN clock enable"] pub type CanenR = crate :: BitReader ;
#[doc = "Field `CANEN` writer - CAN clock enable"] pub type CanenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKPEN` reader - Backup interface clock enable"] pub type BkpenR = crate :: BitReader ;
#[doc = "Field `BKPEN` writer - Backup interface clock enable"] pub type BkpenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWREN` reader - Power interface clock enable"] pub type PwrenR = crate :: BitReader ;
#[doc = "Field `PWREN` writer - Power interface clock enable"] pub type PwrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DACEN` reader - DAC interface clock enable"] pub type DacenR = crate :: BitReader ;
#[doc = "Field `DACEN` writer - DAC interface clock enable"] pub type DacenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Timer 2 clock enable"]
#[inline (always)] pub fn tim2en (& self) -> Tim2enR { Tim2enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Timer 3 clock enable"]
#[inline (always)] pub fn tim3en (& self) -> Tim3enR { Tim3enR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Timer 4 clock enable"]
#[inline (always)] pub fn tim4en (& self) -> Tim4enR { Tim4enR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Timer 5 clock enable"]
#[inline (always)] pub fn tim5en (& self) -> Tim5enR { Tim5enR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Timer 6 clock enable"]
#[inline (always)] pub fn tim6en (& self) -> Tim6enR { Tim6enR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Timer 7 clock enable"]
#[inline (always)] pub fn tim7en (& self) -> Tim7enR { Tim7enR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Timer 12 clock enable"]
#[inline (always)] pub fn tim12en (& self) -> Tim12enR { Tim12enR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Timer 13 clock enable"]
#[inline (always)] pub fn tim13en (& self) -> Tim13enR { Tim13enR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Timer 14 clock enable"]
#[inline (always)] pub fn tim14en (& self) -> Tim14enR { Tim14enR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 11 - Window watchdog clock enable"]
#[inline (always)] pub fn wwdgen (& self) -> WwdgenR { WwdgenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 14 - SPI 2 clock enable"]
#[inline (always)] pub fn spi2en (& self) -> Spi2enR { Spi2enR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - SPI 3 clock enable"]
#[inline (always)] pub fn spi3en (& self) -> Spi3enR { Spi3enR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - USART 2 clock enable"]
#[inline (always)] pub fn usart2en (& self) -> Usart2enR { Usart2enR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - USART 3 clock enable"]
#[inline (always)] pub fn usart3en (& self) -> Usart3enR { Usart3enR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - UART 4 clock enable"]
#[inline (always)] pub fn uart4en (& self) -> Uart4enR { Uart4enR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - UART 5 clock enable"]
#[inline (always)] pub fn uart5en (& self) -> Uart5enR { Uart5enR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - I2C 1 clock enable"]
#[inline (always)] pub fn i2c1en (& self) -> I2c1enR { I2c1enR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - I2C 2 clock enable"]
#[inline (always)] pub fn i2c2en (& self) -> I2c2enR { I2c2enR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - USB clock enable"]
#[inline (always)] pub fn usben (& self) -> UsbenR { UsbenR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 25 - CAN clock enable"]
#[inline (always)] pub fn canen (& self) -> CanenR { CanenR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 27 - Backup interface clock enable"]
#[inline (always)] pub fn bkpen (& self) -> BkpenR { BkpenR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Power interface clock enable"]
#[inline (always)] pub fn pwren (& self) -> PwrenR { PwrenR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - DAC interface clock enable"]
#[inline (always)] pub fn dacen (& self) -> DacenR { DacenR :: new (((self . bits >> 29) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Timer 2 clock enable"]
#[inline (always)] pub fn tim2en (& mut self) -> Tim2enW < '_ , Apb1enrSpec > { Tim2enW :: new (self , 0) }
#[doc = "Bit 1 - Timer 3 clock enable"]
#[inline (always)] pub fn tim3en (& mut self) -> Tim3enW < '_ , Apb1enrSpec > { Tim3enW :: new (self , 1) }
#[doc = "Bit 2 - Timer 4 clock enable"]
#[inline (always)] pub fn tim4en (& mut self) -> Tim4enW < '_ , Apb1enrSpec > { Tim4enW :: new (self , 2) }
#[doc = "Bit 3 - Timer 5 clock enable"]
#[inline (always)] pub fn tim5en (& mut self) -> Tim5enW < '_ , Apb1enrSpec > { Tim5enW :: new (self , 3) }
#[doc = "Bit 4 - Timer 6 clock enable"]
#[inline (always)] pub fn tim6en (& mut self) -> Tim6enW < '_ , Apb1enrSpec > { Tim6enW :: new (self , 4) }
#[doc = "Bit 5 - Timer 7 clock enable"]
#[inline (always)] pub fn tim7en (& mut self) -> Tim7enW < '_ , Apb1enrSpec > { Tim7enW :: new (self , 5) }
#[doc = "Bit 6 - Timer 12 clock enable"]
#[inline (always)] pub fn tim12en (& mut self) -> Tim12enW < '_ , Apb1enrSpec > { Tim12enW :: new (self , 6) }
#[doc = "Bit 7 - Timer 13 clock enable"]
#[inline (always)] pub fn tim13en (& mut self) -> Tim13enW < '_ , Apb1enrSpec > { Tim13enW :: new (self , 7) }
#[doc = "Bit 8 - Timer 14 clock enable"]
#[inline (always)] pub fn tim14en (& mut self) -> Tim14enW < '_ , Apb1enrSpec > { Tim14enW :: new (self , 8) }
#[doc = "Bit 11 - Window watchdog clock enable"]
#[inline (always)] pub fn wwdgen (& mut self) -> WwdgenW < '_ , Apb1enrSpec > { WwdgenW :: new (self , 11) }
#[doc = "Bit 14 - SPI 2 clock enable"]
#[inline (always)] pub fn spi2en (& mut self) -> Spi2enW < '_ , Apb1enrSpec > { Spi2enW :: new (self , 14) }
#[doc = "Bit 15 - SPI 3 clock enable"]
#[inline (always)] pub fn spi3en (& mut self) -> Spi3enW < '_ , Apb1enrSpec > { Spi3enW :: new (self , 15) }
#[doc = "Bit 17 - USART 2 clock enable"]
#[inline (always)] pub fn usart2en (& mut self) -> Usart2enW < '_ , Apb1enrSpec > { Usart2enW :: new (self , 17) }
#[doc = "Bit 18 - USART 3 clock enable"]
#[inline (always)] pub fn usart3en (& mut self) -> Usart3enW < '_ , Apb1enrSpec > { Usart3enW :: new (self , 18) }
#[doc = "Bit 19 - UART 4 clock enable"]
#[inline (always)] pub fn uart4en (& mut self) -> Uart4enW < '_ , Apb1enrSpec > { Uart4enW :: new (self , 19) }
#[doc = "Bit 20 - UART 5 clock enable"]
#[inline (always)] pub fn uart5en (& mut self) -> Uart5enW < '_ , Apb1enrSpec > { Uart5enW :: new (self , 20) }
#[doc = "Bit 21 - I2C 1 clock enable"]
#[inline (always)] pub fn i2c1en (& mut self) -> I2c1enW < '_ , Apb1enrSpec > { I2c1enW :: new (self , 21) }
#[doc = "Bit 22 - I2C 2 clock enable"]
#[inline (always)] pub fn i2c2en (& mut self) -> I2c2enW < '_ , Apb1enrSpec > { I2c2enW :: new (self , 22) }
#[doc = "Bit 23 - USB clock enable"]
#[inline (always)] pub fn usben (& mut self) -> UsbenW < '_ , Apb1enrSpec > { UsbenW :: new (self , 23) }
#[doc = "Bit 25 - CAN clock enable"]
#[inline (always)] pub fn canen (& mut self) -> CanenW < '_ , Apb1enrSpec > { CanenW :: new (self , 25) }
#[doc = "Bit 27 - Backup interface clock enable"]
#[inline (always)] pub fn bkpen (& mut self) -> BkpenW < '_ , Apb1enrSpec > { BkpenW :: new (self , 27) }
#[doc = "Bit 28 - Power interface clock enable"]
#[inline (always)] pub fn pwren (& mut self) -> PwrenW < '_ , Apb1enrSpec > { PwrenW :: new (self , 28) }
#[doc = "Bit 29 - DAC interface clock enable"]
#[inline (always)] pub fn dacen (& mut self) -> DacenW < '_ , Apb1enrSpec > { DacenW :: new (self , 29) } }
#[doc = "APB1 peripheral clock enable register (RCC_APB1ENR)\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1enrSpec ; impl crate :: RegisterSpec for Apb1enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1enr::R`](R) reader structure"] impl crate :: Readable for Apb1enrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb1enr::W`](W) writer structure"] impl crate :: Writable for Apb1enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1ENR to value 0"] impl crate :: Resettable for Apb1enrSpec { } }
#[doc = "BDCR (rw) register accessor: Backup domain control register (RCC_BDCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`bdcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdcr`] module"]
#[doc (alias = "BDCR")] pub type Bdcr = crate :: Reg < bdcr :: BdcrSpec > ;
#[doc = "Backup domain control register (RCC_BDCR)"] pub mod bdcr {
#[doc = "Register `BDCR` reader"] pub type R = crate :: R < BdcrSpec > ;
#[doc = "Register `BDCR` writer"] pub type W = crate :: W < BdcrSpec > ;
#[doc = "Field `LSEON` reader - External Low Speed oscillator enable"] pub type LseonR = crate :: BitReader ;
#[doc = "Field `LSEON` writer - External Low Speed oscillator enable"] pub type LseonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSERDY` reader - External Low Speed oscillator ready"] pub type LserdyR = crate :: BitReader ;
#[doc = "Field `LSEBYP` reader - External Low Speed oscillator bypass"] pub type LsebypR = crate :: BitReader ;
#[doc = "Field `LSEBYP` writer - External Low Speed oscillator bypass"] pub type LsebypW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTCSEL` reader - RTC clock source selection"] pub type RtcselR = crate :: FieldReader ;
#[doc = "Field `RTCSEL` writer - RTC clock source selection"] pub type RtcselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `RTCEN` reader - RTC clock enable"] pub type RtcenR = crate :: BitReader ;
#[doc = "Field `RTCEN` writer - RTC clock enable"] pub type RtcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BDRST` reader - Backup domain software reset"] pub type BdrstR = crate :: BitReader ;
#[doc = "Field `BDRST` writer - Backup domain software reset"] pub type BdrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - External Low Speed oscillator enable"]
#[inline (always)] pub fn lseon (& self) -> LseonR { LseonR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - External Low Speed oscillator ready"]
#[inline (always)] pub fn lserdy (& self) -> LserdyR { LserdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - External Low Speed oscillator bypass"]
#[inline (always)] pub fn lsebyp (& self) -> LsebypR { LsebypR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 8:9 - RTC clock source selection"]
#[inline (always)] pub fn rtcsel (& self) -> RtcselR { RtcselR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 15 - RTC clock enable"]
#[inline (always)] pub fn rtcen (& self) -> RtcenR { RtcenR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Backup domain software reset"]
#[inline (always)] pub fn bdrst (& self) -> BdrstR { BdrstR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - External Low Speed oscillator enable"]
#[inline (always)] pub fn lseon (& mut self) -> LseonW < '_ , BdcrSpec > { LseonW :: new (self , 0) }
#[doc = "Bit 2 - External Low Speed oscillator bypass"]
#[inline (always)] pub fn lsebyp (& mut self) -> LsebypW < '_ , BdcrSpec > { LsebypW :: new (self , 2) }
#[doc = "Bits 8:9 - RTC clock source selection"]
#[inline (always)] pub fn rtcsel (& mut self) -> RtcselW < '_ , BdcrSpec > { RtcselW :: new (self , 8) }
#[doc = "Bit 15 - RTC clock enable"]
#[inline (always)] pub fn rtcen (& mut self) -> RtcenW < '_ , BdcrSpec > { RtcenW :: new (self , 15) }
#[doc = "Bit 16 - Backup domain software reset"]
#[inline (always)] pub fn bdrst (& mut self) -> BdrstW < '_ , BdcrSpec > { BdrstW :: new (self , 16) } }
#[doc = "Backup domain control register (RCC_BDCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`bdcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdcrSpec ; impl crate :: RegisterSpec for BdcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdcr::R`](R) reader structure"] impl crate :: Readable for BdcrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdcr::W`](W) writer structure"] impl crate :: Writable for BdcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDCR to value 0"] impl crate :: Resettable for BdcrSpec { } }
#[doc = "CSR (rw) register accessor: Control/status register (RCC_CSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "Control/status register (RCC_CSR)"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Register `CSR` writer"] pub type W = crate :: W < CsrSpec > ;
#[doc = "Field `LSION` reader - Internal low speed oscillator enable"] pub type LsionR = crate :: BitReader ;
#[doc = "Field `LSION` writer - Internal low speed oscillator enable"] pub type LsionW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSIRDY` reader - Internal low speed oscillator ready"] pub type LsirdyR = crate :: BitReader ;
#[doc = "Field `RMVF` reader - Remove reset flag"] pub type RmvfR = crate :: BitReader ;
#[doc = "Field `RMVF` writer - Remove reset flag"] pub type RmvfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINRSTF` reader - PIN reset flag"] pub type PinrstfR = crate :: BitReader ;
#[doc = "Field `PINRSTF` writer - PIN reset flag"] pub type PinrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PORRSTF` reader - POR/PDR reset flag"] pub type PorrstfR = crate :: BitReader ;
#[doc = "Field `PORRSTF` writer - POR/PDR reset flag"] pub type PorrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SFTRSTF` reader - Software reset flag"] pub type SftrstfR = crate :: BitReader ;
#[doc = "Field `SFTRSTF` writer - Software reset flag"] pub type SftrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IWDGRSTF` reader - Independent watchdog reset flag"] pub type IwdgrstfR = crate :: BitReader ;
#[doc = "Field `IWDGRSTF` writer - Independent watchdog reset flag"] pub type IwdgrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDGRSTF` reader - Window watchdog reset flag"] pub type WwdgrstfR = crate :: BitReader ;
#[doc = "Field `WWDGRSTF` writer - Window watchdog reset flag"] pub type WwdgrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPWRRSTF` reader - Low-power reset flag"] pub type LpwrrstfR = crate :: BitReader ;
#[doc = "Field `LPWRRSTF` writer - Low-power reset flag"] pub type LpwrrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Internal low speed oscillator enable"]
#[inline (always)] pub fn lsion (& self) -> LsionR { LsionR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Internal low speed oscillator ready"]
#[inline (always)] pub fn lsirdy (& self) -> LsirdyR { LsirdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 24 - Remove reset flag"]
#[inline (always)] pub fn rmvf (& self) -> RmvfR { RmvfR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 26 - PIN reset flag"]
#[inline (always)] pub fn pinrstf (& self) -> PinrstfR { PinrstfR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - POR/PDR reset flag"]
#[inline (always)] pub fn porrstf (& self) -> PorrstfR { PorrstfR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Software reset flag"]
#[inline (always)] pub fn sftrstf (& self) -> SftrstfR { SftrstfR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Independent watchdog reset flag"]
#[inline (always)] pub fn iwdgrstf (& self) -> IwdgrstfR { IwdgrstfR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Window watchdog reset flag"]
#[inline (always)] pub fn wwdgrstf (& self) -> WwdgrstfR { WwdgrstfR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Low-power reset flag"]
#[inline (always)] pub fn lpwrrstf (& self) -> LpwrrstfR { LpwrrstfR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Internal low speed oscillator enable"]
#[inline (always)] pub fn lsion (& mut self) -> LsionW < '_ , CsrSpec > { LsionW :: new (self , 0) }
#[doc = "Bit 24 - Remove reset flag"]
#[inline (always)] pub fn rmvf (& mut self) -> RmvfW < '_ , CsrSpec > { RmvfW :: new (self , 24) }
#[doc = "Bit 26 - PIN reset flag"]
#[inline (always)] pub fn pinrstf (& mut self) -> PinrstfW < '_ , CsrSpec > { PinrstfW :: new (self , 26) }
#[doc = "Bit 27 - POR/PDR reset flag"]
#[inline (always)] pub fn porrstf (& mut self) -> PorrstfW < '_ , CsrSpec > { PorrstfW :: new (self , 27) }
#[doc = "Bit 28 - Software reset flag"]
#[inline (always)] pub fn sftrstf (& mut self) -> SftrstfW < '_ , CsrSpec > { SftrstfW :: new (self , 28) }
#[doc = "Bit 29 - Independent watchdog reset flag"]
#[inline (always)] pub fn iwdgrstf (& mut self) -> IwdgrstfW < '_ , CsrSpec > { IwdgrstfW :: new (self , 29) }
#[doc = "Bit 30 - Window watchdog reset flag"]
#[inline (always)] pub fn wwdgrstf (& mut self) -> WwdgrstfW < '_ , CsrSpec > { WwdgrstfW :: new (self , 30) }
#[doc = "Bit 31 - Low-power reset flag"]
#[inline (always)] pub fn lpwrrstf (& mut self) -> LpwrrstfW < '_ , CsrSpec > { LpwrrstfW :: new (self , 31) } }
#[doc = "Control/status register (RCC_CSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"] impl crate :: Writable for CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CSR to value 0x0c00_0000"] impl crate :: Resettable for CsrSpec { const RESET_VALUE : u32 = 0x0c00_0000 ; } } }
#[doc = "General purpose I/O"] pub type Gpioa = crate :: Periph < gpioa :: RegisterBlock , 0x4001_0800 > ; impl core :: fmt :: Debug for Gpioa { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioa") . finish () } }
#[doc = "General purpose I/O"] pub mod gpioa {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { crl : Crl , crh : Crh , idr : Idr , odr : Odr , bsrr : Bsrr , brr : Brr , lckr : Lckr , } impl RegisterBlock {
#[doc = "0x00 - Port configuration register low (GPIOn_CRL)"]
#[inline (always)] pub const fn crl (& self) -> & Crl { & self . crl }
#[doc = "0x04 - Port configuration register high (GPIOn_CRL)"]
#[inline (always)] pub const fn crh (& self) -> & Crh { & self . crh }
#[doc = "0x08 - Port input data register (GPIOn_IDR)"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x0c - Port output data register (GPIOn_ODR)"]
#[inline (always)] pub const fn odr (& self) -> & Odr { & self . odr }
#[doc = "0x10 - Port bit set/reset register (GPIOn_BSRR)"]
#[inline (always)] pub const fn bsrr (& self) -> & Bsrr { & self . bsrr }
#[doc = "0x14 - Port bit reset register (GPIOn_BRR)"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr }
#[doc = "0x18 - Port configuration lock register"]
#[inline (always)] pub const fn lckr (& self) -> & Lckr { & self . lckr } }
#[doc = "CRL (rw) register accessor: Port configuration register low (GPIOn_CRL)\n\nYou can [`read`](crate::Reg::read) this register and get [`crl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crl`] module"]
#[doc (alias = "CRL")] pub type Crl = crate :: Reg < crl :: CrlSpec > ;
#[doc = "Port configuration register low (GPIOn_CRL)"] pub mod crl {
#[doc = "Register `CRL` reader"] pub type R = crate :: R < CrlSpec > ;
#[doc = "Register `CRL` writer"] pub type W = crate :: W < CrlSpec > ;
#[doc = "Field `MODE0` reader - Port n.0 mode bits"] pub type Mode0R = crate :: FieldReader ;
#[doc = "Field `MODE0` writer - Port n.0 mode bits"] pub type Mode0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF0` reader - Port n.0 configuration bits"] pub type Cnf0R = crate :: FieldReader ;
#[doc = "Field `CNF0` writer - Port n.0 configuration bits"] pub type Cnf0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE1` reader - Port n.1 mode bits"] pub type Mode1R = crate :: FieldReader ;
#[doc = "Field `MODE1` writer - Port n.1 mode bits"] pub type Mode1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF1` reader - Port n.1 configuration bits"] pub type Cnf1R = crate :: FieldReader ;
#[doc = "Field `CNF1` writer - Port n.1 configuration bits"] pub type Cnf1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE2` reader - Port n.2 mode bits"] pub type Mode2R = crate :: FieldReader ;
#[doc = "Field `MODE2` writer - Port n.2 mode bits"] pub type Mode2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF2` reader - Port n.2 configuration bits"] pub type Cnf2R = crate :: FieldReader ;
#[doc = "Field `CNF2` writer - Port n.2 configuration bits"] pub type Cnf2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE3` reader - Port n.3 mode bits"] pub type Mode3R = crate :: FieldReader ;
#[doc = "Field `MODE3` writer - Port n.3 mode bits"] pub type Mode3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF3` reader - Port n.3 configuration bits"] pub type Cnf3R = crate :: FieldReader ;
#[doc = "Field `CNF3` writer - Port n.3 configuration bits"] pub type Cnf3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE4` reader - Port n.4 mode bits"] pub type Mode4R = crate :: FieldReader ;
#[doc = "Field `MODE4` writer - Port n.4 mode bits"] pub type Mode4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF4` reader - Port n.4 configuration bits"] pub type Cnf4R = crate :: FieldReader ;
#[doc = "Field `CNF4` writer - Port n.4 configuration bits"] pub type Cnf4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE5` reader - Port n.5 mode bits"] pub type Mode5R = crate :: FieldReader ;
#[doc = "Field `MODE5` writer - Port n.5 mode bits"] pub type Mode5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF5` reader - Port n.5 configuration bits"] pub type Cnf5R = crate :: FieldReader ;
#[doc = "Field `CNF5` writer - Port n.5 configuration bits"] pub type Cnf5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE6` reader - Port n.6 mode bits"] pub type Mode6R = crate :: FieldReader ;
#[doc = "Field `MODE6` writer - Port n.6 mode bits"] pub type Mode6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF6` reader - Port n.6 configuration bits"] pub type Cnf6R = crate :: FieldReader ;
#[doc = "Field `CNF6` writer - Port n.6 configuration bits"] pub type Cnf6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE7` reader - Port n.7 mode bits"] pub type Mode7R = crate :: FieldReader ;
#[doc = "Field `MODE7` writer - Port n.7 mode bits"] pub type Mode7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF7` reader - Port n.7 configuration bits"] pub type Cnf7R = crate :: FieldReader ;
#[doc = "Field `CNF7` writer - Port n.7 configuration bits"] pub type Cnf7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port n.0 mode bits"]
#[inline (always)] pub fn mode0 (& self) -> Mode0R { Mode0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port n.0 configuration bits"]
#[inline (always)] pub fn cnf0 (& self) -> Cnf0R { Cnf0R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port n.1 mode bits"]
#[inline (always)] pub fn mode1 (& self) -> Mode1R { Mode1R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port n.1 configuration bits"]
#[inline (always)] pub fn cnf1 (& self) -> Cnf1R { Cnf1R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port n.2 mode bits"]
#[inline (always)] pub fn mode2 (& self) -> Mode2R { Mode2R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port n.2 configuration bits"]
#[inline (always)] pub fn cnf2 (& self) -> Cnf2R { Cnf2R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port n.3 mode bits"]
#[inline (always)] pub fn mode3 (& self) -> Mode3R { Mode3R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port n.3 configuration bits"]
#[inline (always)] pub fn cnf3 (& self) -> Cnf3R { Cnf3R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port n.4 mode bits"]
#[inline (always)] pub fn mode4 (& self) -> Mode4R { Mode4R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port n.4 configuration bits"]
#[inline (always)] pub fn cnf4 (& self) -> Cnf4R { Cnf4R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port n.5 mode bits"]
#[inline (always)] pub fn mode5 (& self) -> Mode5R { Mode5R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port n.5 configuration bits"]
#[inline (always)] pub fn cnf5 (& self) -> Cnf5R { Cnf5R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port n.6 mode bits"]
#[inline (always)] pub fn mode6 (& self) -> Mode6R { Mode6R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port n.6 configuration bits"]
#[inline (always)] pub fn cnf6 (& self) -> Cnf6R { Cnf6R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port n.7 mode bits"]
#[inline (always)] pub fn mode7 (& self) -> Mode7R { Mode7R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port n.7 configuration bits"]
#[inline (always)] pub fn cnf7 (& self) -> Cnf7R { Cnf7R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port n.0 mode bits"]
#[inline (always)] pub fn mode0 (& mut self) -> Mode0W < '_ , CrlSpec > { Mode0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port n.0 configuration bits"]
#[inline (always)] pub fn cnf0 (& mut self) -> Cnf0W < '_ , CrlSpec > { Cnf0W :: new (self , 2) }
#[doc = "Bits 4:5 - Port n.1 mode bits"]
#[inline (always)] pub fn mode1 (& mut self) -> Mode1W < '_ , CrlSpec > { Mode1W :: new (self , 4) }
#[doc = "Bits 6:7 - Port n.1 configuration bits"]
#[inline (always)] pub fn cnf1 (& mut self) -> Cnf1W < '_ , CrlSpec > { Cnf1W :: new (self , 6) }
#[doc = "Bits 8:9 - Port n.2 mode bits"]
#[inline (always)] pub fn mode2 (& mut self) -> Mode2W < '_ , CrlSpec > { Mode2W :: new (self , 8) }
#[doc = "Bits 10:11 - Port n.2 configuration bits"]
#[inline (always)] pub fn cnf2 (& mut self) -> Cnf2W < '_ , CrlSpec > { Cnf2W :: new (self , 10) }
#[doc = "Bits 12:13 - Port n.3 mode bits"]
#[inline (always)] pub fn mode3 (& mut self) -> Mode3W < '_ , CrlSpec > { Mode3W :: new (self , 12) }
#[doc = "Bits 14:15 - Port n.3 configuration bits"]
#[inline (always)] pub fn cnf3 (& mut self) -> Cnf3W < '_ , CrlSpec > { Cnf3W :: new (self , 14) }
#[doc = "Bits 16:17 - Port n.4 mode bits"]
#[inline (always)] pub fn mode4 (& mut self) -> Mode4W < '_ , CrlSpec > { Mode4W :: new (self , 16) }
#[doc = "Bits 18:19 - Port n.4 configuration bits"]
#[inline (always)] pub fn cnf4 (& mut self) -> Cnf4W < '_ , CrlSpec > { Cnf4W :: new (self , 18) }
#[doc = "Bits 20:21 - Port n.5 mode bits"]
#[inline (always)] pub fn mode5 (& mut self) -> Mode5W < '_ , CrlSpec > { Mode5W :: new (self , 20) }
#[doc = "Bits 22:23 - Port n.5 configuration bits"]
#[inline (always)] pub fn cnf5 (& mut self) -> Cnf5W < '_ , CrlSpec > { Cnf5W :: new (self , 22) }
#[doc = "Bits 24:25 - Port n.6 mode bits"]
#[inline (always)] pub fn mode6 (& mut self) -> Mode6W < '_ , CrlSpec > { Mode6W :: new (self , 24) }
#[doc = "Bits 26:27 - Port n.6 configuration bits"]
#[inline (always)] pub fn cnf6 (& mut self) -> Cnf6W < '_ , CrlSpec > { Cnf6W :: new (self , 26) }
#[doc = "Bits 28:29 - Port n.7 mode bits"]
#[inline (always)] pub fn mode7 (& mut self) -> Mode7W < '_ , CrlSpec > { Mode7W :: new (self , 28) }
#[doc = "Bits 30:31 - Port n.7 configuration bits"]
#[inline (always)] pub fn cnf7 (& mut self) -> Cnf7W < '_ , CrlSpec > { Cnf7W :: new (self , 30) } }
#[doc = "Port configuration register low (GPIOn_CRL)\n\nYou can [`read`](crate::Reg::read) this register and get [`crl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrlSpec ; impl crate :: RegisterSpec for CrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crl::R`](R) reader structure"] impl crate :: Readable for CrlSpec { }
#[doc = "`write(|w| ..)` method takes [`crl::W`](W) writer structure"] impl crate :: Writable for CrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRL to value 0x4444_4444"] impl crate :: Resettable for CrlSpec { const RESET_VALUE : u32 = 0x4444_4444 ; } }
#[doc = "CRH (rw) register accessor: Port configuration register high (GPIOn_CRL)\n\nYou can [`read`](crate::Reg::read) this register and get [`crh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crh`] module"]
#[doc (alias = "CRH")] pub type Crh = crate :: Reg < crh :: CrhSpec > ;
#[doc = "Port configuration register high (GPIOn_CRL)"] pub mod crh {
#[doc = "Register `CRH` reader"] pub type R = crate :: R < CrhSpec > ;
#[doc = "Register `CRH` writer"] pub type W = crate :: W < CrhSpec > ;
#[doc = "Field `MODE8` reader - Port n.8 mode bits"] pub type Mode8R = crate :: FieldReader ;
#[doc = "Field `MODE8` writer - Port n.8 mode bits"] pub type Mode8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF8` reader - Port n.8 configuration bits"] pub type Cnf8R = crate :: FieldReader ;
#[doc = "Field `CNF8` writer - Port n.8 configuration bits"] pub type Cnf8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE9` reader - Port n.9 mode bits"] pub type Mode9R = crate :: FieldReader ;
#[doc = "Field `MODE9` writer - Port n.9 mode bits"] pub type Mode9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF9` reader - Port n.9 configuration bits"] pub type Cnf9R = crate :: FieldReader ;
#[doc = "Field `CNF9` writer - Port n.9 configuration bits"] pub type Cnf9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE10` reader - Port n.10 mode bits"] pub type Mode10R = crate :: FieldReader ;
#[doc = "Field `MODE10` writer - Port n.10 mode bits"] pub type Mode10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF10` reader - Port n.10 configuration bits"] pub type Cnf10R = crate :: FieldReader ;
#[doc = "Field `CNF10` writer - Port n.10 configuration bits"] pub type Cnf10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE11` reader - Port n.11 mode bits"] pub type Mode11R = crate :: FieldReader ;
#[doc = "Field `MODE11` writer - Port n.11 mode bits"] pub type Mode11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF11` reader - Port n.11 configuration bits"] pub type Cnf11R = crate :: FieldReader ;
#[doc = "Field `CNF11` writer - Port n.11 configuration bits"] pub type Cnf11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE12` reader - Port n.12 mode bits"] pub type Mode12R = crate :: FieldReader ;
#[doc = "Field `MODE12` writer - Port n.12 mode bits"] pub type Mode12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF12` reader - Port n.12 configuration bits"] pub type Cnf12R = crate :: FieldReader ;
#[doc = "Field `CNF12` writer - Port n.12 configuration bits"] pub type Cnf12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE13` reader - Port n.13 mode bits"] pub type Mode13R = crate :: FieldReader ;
#[doc = "Field `MODE13` writer - Port n.13 mode bits"] pub type Mode13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF13` reader - Port n.13 configuration bits"] pub type Cnf13R = crate :: FieldReader ;
#[doc = "Field `CNF13` writer - Port n.13 configuration bits"] pub type Cnf13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE14` reader - Port n.14 mode bits"] pub type Mode14R = crate :: FieldReader ;
#[doc = "Field `MODE14` writer - Port n.14 mode bits"] pub type Mode14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF14` reader - Port n.14 configuration bits"] pub type Cnf14R = crate :: FieldReader ;
#[doc = "Field `CNF14` writer - Port n.14 configuration bits"] pub type Cnf14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE15` reader - Port n.15 mode bits"] pub type Mode15R = crate :: FieldReader ;
#[doc = "Field `MODE15` writer - Port n.15 mode bits"] pub type Mode15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF15` reader - Port n.15 configuration bits"] pub type Cnf15R = crate :: FieldReader ;
#[doc = "Field `CNF15` writer - Port n.15 configuration bits"] pub type Cnf15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port n.8 mode bits"]
#[inline (always)] pub fn mode8 (& self) -> Mode8R { Mode8R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port n.8 configuration bits"]
#[inline (always)] pub fn cnf8 (& self) -> Cnf8R { Cnf8R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port n.9 mode bits"]
#[inline (always)] pub fn mode9 (& self) -> Mode9R { Mode9R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port n.9 configuration bits"]
#[inline (always)] pub fn cnf9 (& self) -> Cnf9R { Cnf9R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port n.10 mode bits"]
#[inline (always)] pub fn mode10 (& self) -> Mode10R { Mode10R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port n.10 configuration bits"]
#[inline (always)] pub fn cnf10 (& self) -> Cnf10R { Cnf10R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port n.11 mode bits"]
#[inline (always)] pub fn mode11 (& self) -> Mode11R { Mode11R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port n.11 configuration bits"]
#[inline (always)] pub fn cnf11 (& self) -> Cnf11R { Cnf11R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port n.12 mode bits"]
#[inline (always)] pub fn mode12 (& self) -> Mode12R { Mode12R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port n.12 configuration bits"]
#[inline (always)] pub fn cnf12 (& self) -> Cnf12R { Cnf12R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port n.13 mode bits"]
#[inline (always)] pub fn mode13 (& self) -> Mode13R { Mode13R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port n.13 configuration bits"]
#[inline (always)] pub fn cnf13 (& self) -> Cnf13R { Cnf13R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port n.14 mode bits"]
#[inline (always)] pub fn mode14 (& self) -> Mode14R { Mode14R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port n.14 configuration bits"]
#[inline (always)] pub fn cnf14 (& self) -> Cnf14R { Cnf14R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port n.15 mode bits"]
#[inline (always)] pub fn mode15 (& self) -> Mode15R { Mode15R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port n.15 configuration bits"]
#[inline (always)] pub fn cnf15 (& self) -> Cnf15R { Cnf15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port n.8 mode bits"]
#[inline (always)] pub fn mode8 (& mut self) -> Mode8W < '_ , CrhSpec > { Mode8W :: new (self , 0) }
#[doc = "Bits 2:3 - Port n.8 configuration bits"]
#[inline (always)] pub fn cnf8 (& mut self) -> Cnf8W < '_ , CrhSpec > { Cnf8W :: new (self , 2) }
#[doc = "Bits 4:5 - Port n.9 mode bits"]
#[inline (always)] pub fn mode9 (& mut self) -> Mode9W < '_ , CrhSpec > { Mode9W :: new (self , 4) }
#[doc = "Bits 6:7 - Port n.9 configuration bits"]
#[inline (always)] pub fn cnf9 (& mut self) -> Cnf9W < '_ , CrhSpec > { Cnf9W :: new (self , 6) }
#[doc = "Bits 8:9 - Port n.10 mode bits"]
#[inline (always)] pub fn mode10 (& mut self) -> Mode10W < '_ , CrhSpec > { Mode10W :: new (self , 8) }
#[doc = "Bits 10:11 - Port n.10 configuration bits"]
#[inline (always)] pub fn cnf10 (& mut self) -> Cnf10W < '_ , CrhSpec > { Cnf10W :: new (self , 10) }
#[doc = "Bits 12:13 - Port n.11 mode bits"]
#[inline (always)] pub fn mode11 (& mut self) -> Mode11W < '_ , CrhSpec > { Mode11W :: new (self , 12) }
#[doc = "Bits 14:15 - Port n.11 configuration bits"]
#[inline (always)] pub fn cnf11 (& mut self) -> Cnf11W < '_ , CrhSpec > { Cnf11W :: new (self , 14) }
#[doc = "Bits 16:17 - Port n.12 mode bits"]
#[inline (always)] pub fn mode12 (& mut self) -> Mode12W < '_ , CrhSpec > { Mode12W :: new (self , 16) }
#[doc = "Bits 18:19 - Port n.12 configuration bits"]
#[inline (always)] pub fn cnf12 (& mut self) -> Cnf12W < '_ , CrhSpec > { Cnf12W :: new (self , 18) }
#[doc = "Bits 20:21 - Port n.13 mode bits"]
#[inline (always)] pub fn mode13 (& mut self) -> Mode13W < '_ , CrhSpec > { Mode13W :: new (self , 20) }
#[doc = "Bits 22:23 - Port n.13 configuration bits"]
#[inline (always)] pub fn cnf13 (& mut self) -> Cnf13W < '_ , CrhSpec > { Cnf13W :: new (self , 22) }
#[doc = "Bits 24:25 - Port n.14 mode bits"]
#[inline (always)] pub fn mode14 (& mut self) -> Mode14W < '_ , CrhSpec > { Mode14W :: new (self , 24) }
#[doc = "Bits 26:27 - Port n.14 configuration bits"]
#[inline (always)] pub fn cnf14 (& mut self) -> Cnf14W < '_ , CrhSpec > { Cnf14W :: new (self , 26) }
#[doc = "Bits 28:29 - Port n.15 mode bits"]
#[inline (always)] pub fn mode15 (& mut self) -> Mode15W < '_ , CrhSpec > { Mode15W :: new (self , 28) }
#[doc = "Bits 30:31 - Port n.15 configuration bits"]
#[inline (always)] pub fn cnf15 (& mut self) -> Cnf15W < '_ , CrhSpec > { Cnf15W :: new (self , 30) } }
#[doc = "Port configuration register high (GPIOn_CRL)\n\nYou can [`read`](crate::Reg::read) this register and get [`crh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrhSpec ; impl crate :: RegisterSpec for CrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crh::R`](R) reader structure"] impl crate :: Readable for CrhSpec { }
#[doc = "`write(|w| ..)` method takes [`crh::W`](W) writer structure"] impl crate :: Writable for CrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRH to value 0x4444_4444"] impl crate :: Resettable for CrhSpec { const RESET_VALUE : u32 = 0x4444_4444 ; } }
#[doc = "IDR (r) register accessor: Port input data register (GPIOn_IDR)\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "Port input data register (GPIOn_IDR)"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Field `IDR0` reader - Port input data"] pub type Idr0R = crate :: BitReader ;
#[doc = "Field `IDR1` reader - Port input data"] pub type Idr1R = crate :: BitReader ;
#[doc = "Field `IDR2` reader - Port input data"] pub type Idr2R = crate :: BitReader ;
#[doc = "Field `IDR3` reader - Port input data"] pub type Idr3R = crate :: BitReader ;
#[doc = "Field `IDR4` reader - Port input data"] pub type Idr4R = crate :: BitReader ;
#[doc = "Field `IDR5` reader - Port input data"] pub type Idr5R = crate :: BitReader ;
#[doc = "Field `IDR6` reader - Port input data"] pub type Idr6R = crate :: BitReader ;
#[doc = "Field `IDR7` reader - Port input data"] pub type Idr7R = crate :: BitReader ;
#[doc = "Field `IDR8` reader - Port input data"] pub type Idr8R = crate :: BitReader ;
#[doc = "Field `IDR9` reader - Port input data"] pub type Idr9R = crate :: BitReader ;
#[doc = "Field `IDR10` reader - Port input data"] pub type Idr10R = crate :: BitReader ;
#[doc = "Field `IDR11` reader - Port input data"] pub type Idr11R = crate :: BitReader ;
#[doc = "Field `IDR12` reader - Port input data"] pub type Idr12R = crate :: BitReader ;
#[doc = "Field `IDR13` reader - Port input data"] pub type Idr13R = crate :: BitReader ;
#[doc = "Field `IDR14` reader - Port input data"] pub type Idr14R = crate :: BitReader ;
#[doc = "Field `IDR15` reader - Port input data"] pub type Idr15R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Port input data"]
#[inline (always)] pub fn idr0 (& self) -> Idr0R { Idr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port input data"]
#[inline (always)] pub fn idr1 (& self) -> Idr1R { Idr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port input data"]
#[inline (always)] pub fn idr2 (& self) -> Idr2R { Idr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port input data"]
#[inline (always)] pub fn idr3 (& self) -> Idr3R { Idr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port input data"]
#[inline (always)] pub fn idr4 (& self) -> Idr4R { Idr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port input data"]
#[inline (always)] pub fn idr5 (& self) -> Idr5R { Idr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port input data"]
#[inline (always)] pub fn idr6 (& self) -> Idr6R { Idr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port input data"]
#[inline (always)] pub fn idr7 (& self) -> Idr7R { Idr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port input data"]
#[inline (always)] pub fn idr8 (& self) -> Idr8R { Idr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port input data"]
#[inline (always)] pub fn idr9 (& self) -> Idr9R { Idr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port input data"]
#[inline (always)] pub fn idr10 (& self) -> Idr10R { Idr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port input data"]
#[inline (always)] pub fn idr11 (& self) -> Idr11R { Idr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port input data"]
#[inline (always)] pub fn idr12 (& self) -> Idr12R { Idr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port input data"]
#[inline (always)] pub fn idr13 (& self) -> Idr13R { Idr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port input data"]
#[inline (always)] pub fn idr14 (& self) -> Idr14R { Idr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port input data"]
#[inline (always)] pub fn idr15 (& self) -> Idr15R { Idr15R :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "Port input data register (GPIOn_IDR)\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "ODR (rw) register accessor: Port output data register (GPIOn_ODR)\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@odr`] module"]
#[doc (alias = "ODR")] pub type Odr = crate :: Reg < odr :: OdrSpec > ;
#[doc = "Port output data register (GPIOn_ODR)"] pub mod odr {
#[doc = "Register `ODR` reader"] pub type R = crate :: R < OdrSpec > ;
#[doc = "Register `ODR` writer"] pub type W = crate :: W < OdrSpec > ;
#[doc = "Field `ODR0` reader - Port output data"] pub type Odr0R = crate :: BitReader ;
#[doc = "Field `ODR0` writer - Port output data"] pub type Odr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR1` reader - Port output data"] pub type Odr1R = crate :: BitReader ;
#[doc = "Field `ODR1` writer - Port output data"] pub type Odr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR2` reader - Port output data"] pub type Odr2R = crate :: BitReader ;
#[doc = "Field `ODR2` writer - Port output data"] pub type Odr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR3` reader - Port output data"] pub type Odr3R = crate :: BitReader ;
#[doc = "Field `ODR3` writer - Port output data"] pub type Odr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR4` reader - Port output data"] pub type Odr4R = crate :: BitReader ;
#[doc = "Field `ODR4` writer - Port output data"] pub type Odr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR5` reader - Port output data"] pub type Odr5R = crate :: BitReader ;
#[doc = "Field `ODR5` writer - Port output data"] pub type Odr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR6` reader - Port output data"] pub type Odr6R = crate :: BitReader ;
#[doc = "Field `ODR6` writer - Port output data"] pub type Odr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR7` reader - Port output data"] pub type Odr7R = crate :: BitReader ;
#[doc = "Field `ODR7` writer - Port output data"] pub type Odr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR8` reader - Port output data"] pub type Odr8R = crate :: BitReader ;
#[doc = "Field `ODR8` writer - Port output data"] pub type Odr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR9` reader - Port output data"] pub type Odr9R = crate :: BitReader ;
#[doc = "Field `ODR9` writer - Port output data"] pub type Odr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR10` reader - Port output data"] pub type Odr10R = crate :: BitReader ;
#[doc = "Field `ODR10` writer - Port output data"] pub type Odr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR11` reader - Port output data"] pub type Odr11R = crate :: BitReader ;
#[doc = "Field `ODR11` writer - Port output data"] pub type Odr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR12` reader - Port output data"] pub type Odr12R = crate :: BitReader ;
#[doc = "Field `ODR12` writer - Port output data"] pub type Odr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR13` reader - Port output data"] pub type Odr13R = crate :: BitReader ;
#[doc = "Field `ODR13` writer - Port output data"] pub type Odr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR14` reader - Port output data"] pub type Odr14R = crate :: BitReader ;
#[doc = "Field `ODR14` writer - Port output data"] pub type Odr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ODR15` reader - Port output data"] pub type Odr15R = crate :: BitReader ;
#[doc = "Field `ODR15` writer - Port output data"] pub type Odr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port output data"]
#[inline (always)] pub fn odr0 (& self) -> Odr0R { Odr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port output data"]
#[inline (always)] pub fn odr1 (& self) -> Odr1R { Odr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port output data"]
#[inline (always)] pub fn odr2 (& self) -> Odr2R { Odr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port output data"]
#[inline (always)] pub fn odr3 (& self) -> Odr3R { Odr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port output data"]
#[inline (always)] pub fn odr4 (& self) -> Odr4R { Odr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port output data"]
#[inline (always)] pub fn odr5 (& self) -> Odr5R { Odr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port output data"]
#[inline (always)] pub fn odr6 (& self) -> Odr6R { Odr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port output data"]
#[inline (always)] pub fn odr7 (& self) -> Odr7R { Odr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port output data"]
#[inline (always)] pub fn odr8 (& self) -> Odr8R { Odr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port output data"]
#[inline (always)] pub fn odr9 (& self) -> Odr9R { Odr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port output data"]
#[inline (always)] pub fn odr10 (& self) -> Odr10R { Odr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port output data"]
#[inline (always)] pub fn odr11 (& self) -> Odr11R { Odr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port output data"]
#[inline (always)] pub fn odr12 (& self) -> Odr12R { Odr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port output data"]
#[inline (always)] pub fn odr13 (& self) -> Odr13R { Odr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port output data"]
#[inline (always)] pub fn odr14 (& self) -> Odr14R { Odr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port output data"]
#[inline (always)] pub fn odr15 (& self) -> Odr15R { Odr15R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port output data"]
#[inline (always)] pub fn odr0 (& mut self) -> Odr0W < '_ , OdrSpec > { Odr0W :: new (self , 0) }
#[doc = "Bit 1 - Port output data"]
#[inline (always)] pub fn odr1 (& mut self) -> Odr1W < '_ , OdrSpec > { Odr1W :: new (self , 1) }
#[doc = "Bit 2 - Port output data"]
#[inline (always)] pub fn odr2 (& mut self) -> Odr2W < '_ , OdrSpec > { Odr2W :: new (self , 2) }
#[doc = "Bit 3 - Port output data"]
#[inline (always)] pub fn odr3 (& mut self) -> Odr3W < '_ , OdrSpec > { Odr3W :: new (self , 3) }
#[doc = "Bit 4 - Port output data"]
#[inline (always)] pub fn odr4 (& mut self) -> Odr4W < '_ , OdrSpec > { Odr4W :: new (self , 4) }
#[doc = "Bit 5 - Port output data"]
#[inline (always)] pub fn odr5 (& mut self) -> Odr5W < '_ , OdrSpec > { Odr5W :: new (self , 5) }
#[doc = "Bit 6 - Port output data"]
#[inline (always)] pub fn odr6 (& mut self) -> Odr6W < '_ , OdrSpec > { Odr6W :: new (self , 6) }
#[doc = "Bit 7 - Port output data"]
#[inline (always)] pub fn odr7 (& mut self) -> Odr7W < '_ , OdrSpec > { Odr7W :: new (self , 7) }
#[doc = "Bit 8 - Port output data"]
#[inline (always)] pub fn odr8 (& mut self) -> Odr8W < '_ , OdrSpec > { Odr8W :: new (self , 8) }
#[doc = "Bit 9 - Port output data"]
#[inline (always)] pub fn odr9 (& mut self) -> Odr9W < '_ , OdrSpec > { Odr9W :: new (self , 9) }
#[doc = "Bit 10 - Port output data"]
#[inline (always)] pub fn odr10 (& mut self) -> Odr10W < '_ , OdrSpec > { Odr10W :: new (self , 10) }
#[doc = "Bit 11 - Port output data"]
#[inline (always)] pub fn odr11 (& mut self) -> Odr11W < '_ , OdrSpec > { Odr11W :: new (self , 11) }
#[doc = "Bit 12 - Port output data"]
#[inline (always)] pub fn odr12 (& mut self) -> Odr12W < '_ , OdrSpec > { Odr12W :: new (self , 12) }
#[doc = "Bit 13 - Port output data"]
#[inline (always)] pub fn odr13 (& mut self) -> Odr13W < '_ , OdrSpec > { Odr13W :: new (self , 13) }
#[doc = "Bit 14 - Port output data"]
#[inline (always)] pub fn odr14 (& mut self) -> Odr14W < '_ , OdrSpec > { Odr14W :: new (self , 14) }
#[doc = "Bit 15 - Port output data"]
#[inline (always)] pub fn odr15 (& mut self) -> Odr15W < '_ , OdrSpec > { Odr15W :: new (self , 15) } }
#[doc = "Port output data register (GPIOn_ODR)\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OdrSpec ; impl crate :: RegisterSpec for OdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`odr::R`](R) reader structure"] impl crate :: Readable for OdrSpec { }
#[doc = "`write(|w| ..)` method takes [`odr::W`](W) writer structure"] impl crate :: Writable for OdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ODR to value 0"] impl crate :: Resettable for OdrSpec { } }
#[doc = "BSRR (w) register accessor: Port bit set/reset register (GPIOn_BSRR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
#[doc (alias = "BSRR")] pub type Bsrr = crate :: Reg < bsrr :: BsrrSpec > ;
#[doc = "Port bit set/reset register (GPIOn_BSRR)"] pub mod bsrr {
#[doc = "Register `BSRR` writer"] pub type W = crate :: W < BsrrSpec > ;
#[doc = "Field `BS0` writer - Set bit 0"] pub type Bs0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS1` writer - Set bit 1"] pub type Bs1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS2` writer - Set bit 1"] pub type Bs2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS3` writer - Set bit 3"] pub type Bs3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS4` writer - Set bit 4"] pub type Bs4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS5` writer - Set bit 5"] pub type Bs5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS6` writer - Set bit 6"] pub type Bs6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS7` writer - Set bit 7"] pub type Bs7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS8` writer - Set bit 8"] pub type Bs8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS9` writer - Set bit 9"] pub type Bs9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS10` writer - Set bit 10"] pub type Bs10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS11` writer - Set bit 11"] pub type Bs11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS12` writer - Set bit 12"] pub type Bs12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS13` writer - Set bit 13"] pub type Bs13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS14` writer - Set bit 14"] pub type Bs14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS15` writer - Set bit 15"] pub type Bs15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR0` writer - Reset bit 0"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Reset bit 1"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Reset bit 2"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Reset bit 3"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Reset bit 4"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Reset bit 5"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Reset bit 6"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Reset bit 7"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Reset bit 8"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Reset bit 9"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Reset bit 10"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Reset bit 11"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Reset bit 12"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Reset bit 13"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Reset bit 14"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Reset bit 15"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Set bit 0"]
#[inline (always)] pub fn bs0 (& mut self) -> Bs0W < '_ , BsrrSpec > { Bs0W :: new (self , 0) }
#[doc = "Bit 1 - Set bit 1"]
#[inline (always)] pub fn bs1 (& mut self) -> Bs1W < '_ , BsrrSpec > { Bs1W :: new (self , 1) }
#[doc = "Bit 2 - Set bit 1"]
#[inline (always)] pub fn bs2 (& mut self) -> Bs2W < '_ , BsrrSpec > { Bs2W :: new (self , 2) }
#[doc = "Bit 3 - Set bit 3"]
#[inline (always)] pub fn bs3 (& mut self) -> Bs3W < '_ , BsrrSpec > { Bs3W :: new (self , 3) }
#[doc = "Bit 4 - Set bit 4"]
#[inline (always)] pub fn bs4 (& mut self) -> Bs4W < '_ , BsrrSpec > { Bs4W :: new (self , 4) }
#[doc = "Bit 5 - Set bit 5"]
#[inline (always)] pub fn bs5 (& mut self) -> Bs5W < '_ , BsrrSpec > { Bs5W :: new (self , 5) }
#[doc = "Bit 6 - Set bit 6"]
#[inline (always)] pub fn bs6 (& mut self) -> Bs6W < '_ , BsrrSpec > { Bs6W :: new (self , 6) }
#[doc = "Bit 7 - Set bit 7"]
#[inline (always)] pub fn bs7 (& mut self) -> Bs7W < '_ , BsrrSpec > { Bs7W :: new (self , 7) }
#[doc = "Bit 8 - Set bit 8"]
#[inline (always)] pub fn bs8 (& mut self) -> Bs8W < '_ , BsrrSpec > { Bs8W :: new (self , 8) }
#[doc = "Bit 9 - Set bit 9"]
#[inline (always)] pub fn bs9 (& mut self) -> Bs9W < '_ , BsrrSpec > { Bs9W :: new (self , 9) }
#[doc = "Bit 10 - Set bit 10"]
#[inline (always)] pub fn bs10 (& mut self) -> Bs10W < '_ , BsrrSpec > { Bs10W :: new (self , 10) }
#[doc = "Bit 11 - Set bit 11"]
#[inline (always)] pub fn bs11 (& mut self) -> Bs11W < '_ , BsrrSpec > { Bs11W :: new (self , 11) }
#[doc = "Bit 12 - Set bit 12"]
#[inline (always)] pub fn bs12 (& mut self) -> Bs12W < '_ , BsrrSpec > { Bs12W :: new (self , 12) }
#[doc = "Bit 13 - Set bit 13"]
#[inline (always)] pub fn bs13 (& mut self) -> Bs13W < '_ , BsrrSpec > { Bs13W :: new (self , 13) }
#[doc = "Bit 14 - Set bit 14"]
#[inline (always)] pub fn bs14 (& mut self) -> Bs14W < '_ , BsrrSpec > { Bs14W :: new (self , 14) }
#[doc = "Bit 15 - Set bit 15"]
#[inline (always)] pub fn bs15 (& mut self) -> Bs15W < '_ , BsrrSpec > { Bs15W :: new (self , 15) }
#[doc = "Bit 16 - Reset bit 0"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BsrrSpec > { Br0W :: new (self , 16) }
#[doc = "Bit 17 - Reset bit 1"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BsrrSpec > { Br1W :: new (self , 17) }
#[doc = "Bit 18 - Reset bit 2"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BsrrSpec > { Br2W :: new (self , 18) }
#[doc = "Bit 19 - Reset bit 3"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BsrrSpec > { Br3W :: new (self , 19) }
#[doc = "Bit 20 - Reset bit 4"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BsrrSpec > { Br4W :: new (self , 20) }
#[doc = "Bit 21 - Reset bit 5"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BsrrSpec > { Br5W :: new (self , 21) }
#[doc = "Bit 22 - Reset bit 6"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BsrrSpec > { Br6W :: new (self , 22) }
#[doc = "Bit 23 - Reset bit 7"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BsrrSpec > { Br7W :: new (self , 23) }
#[doc = "Bit 24 - Reset bit 8"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BsrrSpec > { Br8W :: new (self , 24) }
#[doc = "Bit 25 - Reset bit 9"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BsrrSpec > { Br9W :: new (self , 25) }
#[doc = "Bit 26 - Reset bit 10"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BsrrSpec > { Br10W :: new (self , 26) }
#[doc = "Bit 27 - Reset bit 11"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BsrrSpec > { Br11W :: new (self , 27) }
#[doc = "Bit 28 - Reset bit 12"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BsrrSpec > { Br12W :: new (self , 28) }
#[doc = "Bit 29 - Reset bit 13"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BsrrSpec > { Br13W :: new (self , 29) }
#[doc = "Bit 30 - Reset bit 14"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BsrrSpec > { Br14W :: new (self , 30) }
#[doc = "Bit 31 - Reset bit 15"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BsrrSpec > { Br15W :: new (self , 31) } }
#[doc = "Port bit set/reset register (GPIOn_BSRR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BsrrSpec ; impl crate :: RegisterSpec for BsrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"] impl crate :: Writable for BsrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BSRR to value 0"] impl crate :: Resettable for BsrrSpec { } }
#[doc = "BRR (w) register accessor: Port bit reset register (GPIOn_BRR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "Port bit reset register (GPIOn_BRR)"] pub mod brr {
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `BR0` writer - Reset bit 0"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Reset bit 1"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Reset bit 1"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Reset bit 3"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Reset bit 4"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Reset bit 5"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Reset bit 6"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Reset bit 7"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Reset bit 8"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Reset bit 9"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Reset bit 10"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Reset bit 11"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Reset bit 12"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Reset bit 13"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Reset bit 14"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Reset bit 15"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Reset bit 0"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BrrSpec > { Br0W :: new (self , 0) }
#[doc = "Bit 1 - Reset bit 1"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BrrSpec > { Br1W :: new (self , 1) }
#[doc = "Bit 2 - Reset bit 1"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BrrSpec > { Br2W :: new (self , 2) }
#[doc = "Bit 3 - Reset bit 3"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BrrSpec > { Br3W :: new (self , 3) }
#[doc = "Bit 4 - Reset bit 4"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BrrSpec > { Br4W :: new (self , 4) }
#[doc = "Bit 5 - Reset bit 5"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BrrSpec > { Br5W :: new (self , 5) }
#[doc = "Bit 6 - Reset bit 6"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BrrSpec > { Br6W :: new (self , 6) }
#[doc = "Bit 7 - Reset bit 7"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BrrSpec > { Br7W :: new (self , 7) }
#[doc = "Bit 8 - Reset bit 8"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BrrSpec > { Br8W :: new (self , 8) }
#[doc = "Bit 9 - Reset bit 9"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BrrSpec > { Br9W :: new (self , 9) }
#[doc = "Bit 10 - Reset bit 10"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BrrSpec > { Br10W :: new (self , 10) }
#[doc = "Bit 11 - Reset bit 11"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BrrSpec > { Br11W :: new (self , 11) }
#[doc = "Bit 12 - Reset bit 12"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BrrSpec > { Br12W :: new (self , 12) }
#[doc = "Bit 13 - Reset bit 13"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BrrSpec > { Br13W :: new (self , 13) }
#[doc = "Bit 14 - Reset bit 14"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BrrSpec > { Br14W :: new (self , 14) }
#[doc = "Bit 15 - Reset bit 15"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BrrSpec > { Br15W :: new (self , 15) } }
#[doc = "Port bit reset register (GPIOn_BRR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } }
#[doc = "LCKR (rw) register accessor: Port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lckr`] module"]
#[doc (alias = "LCKR")] pub type Lckr = crate :: Reg < lckr :: LckrSpec > ;
#[doc = "Port configuration lock register"] pub mod lckr {
#[doc = "Register `LCKR` reader"] pub type R = crate :: R < LckrSpec > ;
#[doc = "Register `LCKR` writer"] pub type W = crate :: W < LckrSpec > ;
#[doc = "Field `LCK0` reader - Port A Lock bit 0"] pub type Lck0R = crate :: BitReader ;
#[doc = "Field `LCK0` writer - Port A Lock bit 0"] pub type Lck0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK1` reader - Port A Lock bit 1"] pub type Lck1R = crate :: BitReader ;
#[doc = "Field `LCK1` writer - Port A Lock bit 1"] pub type Lck1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK2` reader - Port A Lock bit 2"] pub type Lck2R = crate :: BitReader ;
#[doc = "Field `LCK2` writer - Port A Lock bit 2"] pub type Lck2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK3` reader - Port A Lock bit 3"] pub type Lck3R = crate :: BitReader ;
#[doc = "Field `LCK3` writer - Port A Lock bit 3"] pub type Lck3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK4` reader - Port A Lock bit 4"] pub type Lck4R = crate :: BitReader ;
#[doc = "Field `LCK4` writer - Port A Lock bit 4"] pub type Lck4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK5` reader - Port A Lock bit 5"] pub type Lck5R = crate :: BitReader ;
#[doc = "Field `LCK5` writer - Port A Lock bit 5"] pub type Lck5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK6` reader - Port A Lock bit 6"] pub type Lck6R = crate :: BitReader ;
#[doc = "Field `LCK6` writer - Port A Lock bit 6"] pub type Lck6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK7` reader - Port A Lock bit 7"] pub type Lck7R = crate :: BitReader ;
#[doc = "Field `LCK7` writer - Port A Lock bit 7"] pub type Lck7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK8` reader - Port A Lock bit 8"] pub type Lck8R = crate :: BitReader ;
#[doc = "Field `LCK8` writer - Port A Lock bit 8"] pub type Lck8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK9` reader - Port A Lock bit 9"] pub type Lck9R = crate :: BitReader ;
#[doc = "Field `LCK9` writer - Port A Lock bit 9"] pub type Lck9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK10` reader - Port A Lock bit 10"] pub type Lck10R = crate :: BitReader ;
#[doc = "Field `LCK10` writer - Port A Lock bit 10"] pub type Lck10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK11` reader - Port A Lock bit 11"] pub type Lck11R = crate :: BitReader ;
#[doc = "Field `LCK11` writer - Port A Lock bit 11"] pub type Lck11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK12` reader - Port A Lock bit 12"] pub type Lck12R = crate :: BitReader ;
#[doc = "Field `LCK12` writer - Port A Lock bit 12"] pub type Lck12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK13` reader - Port A Lock bit 13"] pub type Lck13R = crate :: BitReader ;
#[doc = "Field `LCK13` writer - Port A Lock bit 13"] pub type Lck13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK14` reader - Port A Lock bit 14"] pub type Lck14R = crate :: BitReader ;
#[doc = "Field `LCK14` writer - Port A Lock bit 14"] pub type Lck14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCK15` reader - Port A Lock bit 15"] pub type Lck15R = crate :: BitReader ;
#[doc = "Field `LCK15` writer - Port A Lock bit 15"] pub type Lck15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCKK` reader - Lock key"] pub type LckkR = crate :: BitReader ;
#[doc = "Field `LCKK` writer - Lock key"] pub type LckkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Port A Lock bit 0"]
#[inline (always)] pub fn lck0 (& self) -> Lck0R { Lck0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port A Lock bit 1"]
#[inline (always)] pub fn lck1 (& self) -> Lck1R { Lck1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port A Lock bit 2"]
#[inline (always)] pub fn lck2 (& self) -> Lck2R { Lck2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port A Lock bit 3"]
#[inline (always)] pub fn lck3 (& self) -> Lck3R { Lck3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port A Lock bit 4"]
#[inline (always)] pub fn lck4 (& self) -> Lck4R { Lck4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port A Lock bit 5"]
#[inline (always)] pub fn lck5 (& self) -> Lck5R { Lck5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port A Lock bit 6"]
#[inline (always)] pub fn lck6 (& self) -> Lck6R { Lck6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port A Lock bit 7"]
#[inline (always)] pub fn lck7 (& self) -> Lck7R { Lck7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port A Lock bit 8"]
#[inline (always)] pub fn lck8 (& self) -> Lck8R { Lck8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Port A Lock bit 9"]
#[inline (always)] pub fn lck9 (& self) -> Lck9R { Lck9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Port A Lock bit 10"]
#[inline (always)] pub fn lck10 (& self) -> Lck10R { Lck10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Port A Lock bit 11"]
#[inline (always)] pub fn lck11 (& self) -> Lck11R { Lck11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Port A Lock bit 12"]
#[inline (always)] pub fn lck12 (& self) -> Lck12R { Lck12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Port A Lock bit 13"]
#[inline (always)] pub fn lck13 (& self) -> Lck13R { Lck13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Port A Lock bit 14"]
#[inline (always)] pub fn lck14 (& self) -> Lck14R { Lck14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Port A Lock bit 15"]
#[inline (always)] pub fn lck15 (& self) -> Lck15R { Lck15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Lock key"]
#[inline (always)] pub fn lckk (& self) -> LckkR { LckkR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Port A Lock bit 0"]
#[inline (always)] pub fn lck0 (& mut self) -> Lck0W < '_ , LckrSpec > { Lck0W :: new (self , 0) }
#[doc = "Bit 1 - Port A Lock bit 1"]
#[inline (always)] pub fn lck1 (& mut self) -> Lck1W < '_ , LckrSpec > { Lck1W :: new (self , 1) }
#[doc = "Bit 2 - Port A Lock bit 2"]
#[inline (always)] pub fn lck2 (& mut self) -> Lck2W < '_ , LckrSpec > { Lck2W :: new (self , 2) }
#[doc = "Bit 3 - Port A Lock bit 3"]
#[inline (always)] pub fn lck3 (& mut self) -> Lck3W < '_ , LckrSpec > { Lck3W :: new (self , 3) }
#[doc = "Bit 4 - Port A Lock bit 4"]
#[inline (always)] pub fn lck4 (& mut self) -> Lck4W < '_ , LckrSpec > { Lck4W :: new (self , 4) }
#[doc = "Bit 5 - Port A Lock bit 5"]
#[inline (always)] pub fn lck5 (& mut self) -> Lck5W < '_ , LckrSpec > { Lck5W :: new (self , 5) }
#[doc = "Bit 6 - Port A Lock bit 6"]
#[inline (always)] pub fn lck6 (& mut self) -> Lck6W < '_ , LckrSpec > { Lck6W :: new (self , 6) }
#[doc = "Bit 7 - Port A Lock bit 7"]
#[inline (always)] pub fn lck7 (& mut self) -> Lck7W < '_ , LckrSpec > { Lck7W :: new (self , 7) }
#[doc = "Bit 8 - Port A Lock bit 8"]
#[inline (always)] pub fn lck8 (& mut self) -> Lck8W < '_ , LckrSpec > { Lck8W :: new (self , 8) }
#[doc = "Bit 9 - Port A Lock bit 9"]
#[inline (always)] pub fn lck9 (& mut self) -> Lck9W < '_ , LckrSpec > { Lck9W :: new (self , 9) }
#[doc = "Bit 10 - Port A Lock bit 10"]
#[inline (always)] pub fn lck10 (& mut self) -> Lck10W < '_ , LckrSpec > { Lck10W :: new (self , 10) }
#[doc = "Bit 11 - Port A Lock bit 11"]
#[inline (always)] pub fn lck11 (& mut self) -> Lck11W < '_ , LckrSpec > { Lck11W :: new (self , 11) }
#[doc = "Bit 12 - Port A Lock bit 12"]
#[inline (always)] pub fn lck12 (& mut self) -> Lck12W < '_ , LckrSpec > { Lck12W :: new (self , 12) }
#[doc = "Bit 13 - Port A Lock bit 13"]
#[inline (always)] pub fn lck13 (& mut self) -> Lck13W < '_ , LckrSpec > { Lck13W :: new (self , 13) }
#[doc = "Bit 14 - Port A Lock bit 14"]
#[inline (always)] pub fn lck14 (& mut self) -> Lck14W < '_ , LckrSpec > { Lck14W :: new (self , 14) }
#[doc = "Bit 15 - Port A Lock bit 15"]
#[inline (always)] pub fn lck15 (& mut self) -> Lck15W < '_ , LckrSpec > { Lck15W :: new (self , 15) }
#[doc = "Bit 16 - Lock key"]
#[inline (always)] pub fn lckk (& mut self) -> LckkW < '_ , LckrSpec > { LckkW :: new (self , 16) } }
#[doc = "Port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LckrSpec ; impl crate :: RegisterSpec for LckrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`lckr::R`](R) reader structure"] impl crate :: Readable for LckrSpec { }
#[doc = "`write(|w| ..)` method takes [`lckr::W`](W) writer structure"] impl crate :: Writable for LckrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCKR to value 0"] impl crate :: Resettable for LckrSpec { } } }
#[doc = "General purpose I/O"] pub type Gpiob = crate :: Periph < gpioa :: RegisterBlock , 0x4001_0c00 > ; impl core :: fmt :: Debug for Gpiob { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiob") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpiob ;
#[doc = "General purpose I/O"] pub type Gpioc = crate :: Periph < gpioa :: RegisterBlock , 0x4001_1000 > ; impl core :: fmt :: Debug for Gpioc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioc") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpioc ;
#[doc = "General purpose I/O"] pub type Gpiod = crate :: Periph < gpioa :: RegisterBlock , 0x4001_1400 > ; impl core :: fmt :: Debug for Gpiod { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiod") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpiod ;
#[doc = "General purpose I/O"] pub type Gpioe = crate :: Periph < gpioa :: RegisterBlock , 0x4001_1800 > ; impl core :: fmt :: Debug for Gpioe { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioe") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpioe ;
#[doc = "General purpose I/O"] pub type Gpiof = crate :: Periph < gpioa :: RegisterBlock , 0x4001_1c00 > ; impl core :: fmt :: Debug for Gpiof { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiof") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpiof ;
#[doc = "General purpose I/O"] pub type Gpiog = crate :: Periph < gpioa :: RegisterBlock , 0x4001_2000 > ; impl core :: fmt :: Debug for Gpiog { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiog") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpiog ;
#[doc = "Alternate function I/O"] pub type Afio = crate :: Periph < afio :: RegisterBlock , 0x4001_0000 > ; impl core :: fmt :: Debug for Afio { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Afio") . finish () } }
#[doc = "Alternate function I/O"] pub mod afio {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { evcr : Evcr , mapr : Mapr , exticr1 : Exticr1 , exticr2 : Exticr2 , exticr3 : Exticr3 , exticr4 : Exticr4 , _reserved6 : [u8 ; 0x04] , mapr2 : Mapr2 , } impl RegisterBlock {
#[doc = "0x00 - Event Control Register (AFIO_EVCR)"]
#[inline (always)] pub const fn evcr (& self) -> & Evcr { & self . evcr }
#[doc = "0x04 - AF remap and debug I/O configuration register (AFIO_MAPR)"]
#[inline (always)] pub const fn mapr (& self) -> & Mapr { & self . mapr }
#[doc = "0x08 - External interrupt configuration register 1 (AFIO_EXTICR1)"]
#[inline (always)] pub const fn exticr1 (& self) -> & Exticr1 { & self . exticr1 }
#[doc = "0x0c - External interrupt configuration register 2 (AFIO_EXTICR2)"]
#[inline (always)] pub const fn exticr2 (& self) -> & Exticr2 { & self . exticr2 }
#[doc = "0x10 - External interrupt configuration register 3 (AFIO_EXTICR3)"]
#[inline (always)] pub const fn exticr3 (& self) -> & Exticr3 { & self . exticr3 }
#[doc = "0x14 - External interrupt configuration register 4 (AFIO_EXTICR4)"]
#[inline (always)] pub const fn exticr4 (& self) -> & Exticr4 { & self . exticr4 }
#[doc = "0x1c - AF remap and debug I/O configuration register"]
#[inline (always)] pub const fn mapr2 (& self) -> & Mapr2 { & self . mapr2 } }
#[doc = "EVCR (rw) register accessor: Event Control Register (AFIO_EVCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`evcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@evcr`] module"]
#[doc (alias = "EVCR")] pub type Evcr = crate :: Reg < evcr :: EvcrSpec > ;
#[doc = "Event Control Register (AFIO_EVCR)"] pub mod evcr {
#[doc = "Register `EVCR` reader"] pub type R = crate :: R < EvcrSpec > ;
#[doc = "Register `EVCR` writer"] pub type W = crate :: W < EvcrSpec > ;
#[doc = "Field `PIN` reader - Pin selection"] pub type PinR = crate :: FieldReader ;
#[doc = "Field `PIN` writer - Pin selection"] pub type PinW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PORT` reader - Port selection"] pub type PortR = crate :: FieldReader ;
#[doc = "Field `PORT` writer - Port selection"] pub type PortW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EVOE` reader - Event Output Enable"] pub type EvoeR = crate :: BitReader ;
#[doc = "Field `EVOE` writer - Event Output Enable"] pub type EvoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Pin selection"]
#[inline (always)] pub fn pin (& self) -> PinR { PinR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:6 - Port selection"]
#[inline (always)] pub fn port (& self) -> PortR { PortR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Event Output Enable"]
#[inline (always)] pub fn evoe (& self) -> EvoeR { EvoeR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Pin selection"]
#[inline (always)] pub fn pin (& mut self) -> PinW < '_ , EvcrSpec > { PinW :: new (self , 0) }
#[doc = "Bits 4:6 - Port selection"]
#[inline (always)] pub fn port (& mut self) -> PortW < '_ , EvcrSpec > { PortW :: new (self , 4) }
#[doc = "Bit 7 - Event Output Enable"]
#[inline (always)] pub fn evoe (& mut self) -> EvoeW < '_ , EvcrSpec > { EvoeW :: new (self , 7) } }
#[doc = "Event Control Register (AFIO_EVCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`evcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`evcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EvcrSpec ; impl crate :: RegisterSpec for EvcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`evcr::R`](R) reader structure"] impl crate :: Readable for EvcrSpec { }
#[doc = "`write(|w| ..)` method takes [`evcr::W`](W) writer structure"] impl crate :: Writable for EvcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EVCR to value 0"] impl crate :: Resettable for EvcrSpec { } }
#[doc = "MAPR (rw) register accessor: AF remap and debug I/O configuration register (AFIO_MAPR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mapr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mapr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mapr`] module"]
#[doc (alias = "MAPR")] pub type Mapr = crate :: Reg < mapr :: MaprSpec > ;
#[doc = "AF remap and debug I/O configuration register (AFIO_MAPR)"] pub mod mapr {
#[doc = "Register `MAPR` reader"] pub type R = crate :: R < MaprSpec > ;
#[doc = "Register `MAPR` writer"] pub type W = crate :: W < MaprSpec > ;
#[doc = "Field `SPI1_REMAP` reader - SPI1 remapping"] pub type Spi1RemapR = crate :: BitReader ;
#[doc = "Field `SPI1_REMAP` writer - SPI1 remapping"] pub type Spi1RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1_REMAP` reader - I2C1 remapping"] pub type I2c1RemapR = crate :: BitReader ;
#[doc = "Field `I2C1_REMAP` writer - I2C1 remapping"] pub type I2c1RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART1_REMAP` reader - USART1 remapping"] pub type Usart1RemapR = crate :: BitReader ;
#[doc = "Field `USART1_REMAP` writer - USART1 remapping"] pub type Usart1RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART2_REMAP` reader - USART2 remapping"] pub type Usart2RemapR = crate :: BitReader ;
#[doc = "Field `USART2_REMAP` writer - USART2 remapping"] pub type Usart2RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USART3_REMAP` reader - USART3 remapping"] pub type Usart3RemapR = crate :: FieldReader ;
#[doc = "Field `USART3_REMAP` writer - USART3 remapping"] pub type Usart3RemapW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TIM1_REMAP` reader - TIM1 remapping"] pub type Tim1RemapR = crate :: FieldReader ;
#[doc = "Field `TIM1_REMAP` writer - TIM1 remapping"] pub type Tim1RemapW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TIM2_REMAP` reader - TIM2 remapping"] pub type Tim2RemapR = crate :: FieldReader ;
#[doc = "Field `TIM2_REMAP` writer - TIM2 remapping"] pub type Tim2RemapW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TIM3_REMAP` reader - TIM3 remapping"] pub type Tim3RemapR = crate :: FieldReader ;
#[doc = "Field `TIM3_REMAP` writer - TIM3 remapping"] pub type Tim3RemapW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TIM4_REMAP` reader - TIM4 remapping"] pub type Tim4RemapR = crate :: BitReader ;
#[doc = "Field `TIM4_REMAP` writer - TIM4 remapping"] pub type Tim4RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CAN_REMAP` reader - CAN1 remapping"] pub type CanRemapR = crate :: FieldReader ;
#[doc = "Field `CAN_REMAP` writer - CAN1 remapping"] pub type CanRemapW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PD01_REMAP` reader - Port D0/Port D1 mapping on OSCIN/OSCOUT"] pub type Pd01RemapR = crate :: BitReader ;
#[doc = "Field `PD01_REMAP` writer - Port D0/Port D1 mapping on OSCIN/OSCOUT"] pub type Pd01RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM5CH4_IREMAP` reader - Set and cleared by software"] pub type Tim5ch4IremapR = crate :: BitReader ;
#[doc = "Field `TIM5CH4_IREMAP` writer - Set and cleared by software"] pub type Tim5ch4IremapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC1_ETRGINJ_REMAP` reader - ADC 1 External trigger injected conversion remapping"] pub type Adc1EtrginjRemapR = crate :: BitReader ;
#[doc = "Field `ADC1_ETRGINJ_REMAP` writer - ADC 1 External trigger injected conversion remapping"] pub type Adc1EtrginjRemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC1_ETRGREG_REMAP` reader - ADC 1 external trigger regular conversion remapping"] pub type Adc1EtrgregRemapR = crate :: BitReader ;
#[doc = "Field `ADC1_ETRGREG_REMAP` writer - ADC 1 external trigger regular conversion remapping"] pub type Adc1EtrgregRemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC2_ETRGINJ_REMAP` reader - ADC 2 external trigger injected conversion remapping"] pub type Adc2EtrginjRemapR = crate :: BitReader ;
#[doc = "Field `ADC2_ETRGINJ_REMAP` writer - ADC 2 external trigger injected conversion remapping"] pub type Adc2EtrginjRemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC2_ETRGREG_REMAP` reader - ADC 2 external trigger regular conversion remapping"] pub type Adc2EtrgregRemapR = crate :: BitReader ;
#[doc = "Field `ADC2_ETRGREG_REMAP` writer - ADC 2 external trigger regular conversion remapping"] pub type Adc2EtrgregRemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWJ_CFG` writer - Serial wire JTAG configuration"] pub type SwjCfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bit 0 - SPI1 remapping"]
#[inline (always)] pub fn spi1_remap (& self) -> Spi1RemapR { Spi1RemapR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - I2C1 remapping"]
#[inline (always)] pub fn i2c1_remap (& self) -> I2c1RemapR { I2c1RemapR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - USART1 remapping"]
#[inline (always)] pub fn usart1_remap (& self) -> Usart1RemapR { Usart1RemapR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - USART2 remapping"]
#[inline (always)] pub fn usart2_remap (& self) -> Usart2RemapR { Usart2RemapR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - USART3 remapping"]
#[inline (always)] pub fn usart3_remap (& self) -> Usart3RemapR { Usart3RemapR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - TIM1 remapping"]
#[inline (always)] pub fn tim1_remap (& self) -> Tim1RemapR { Tim1RemapR :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - TIM2 remapping"]
#[inline (always)] pub fn tim2_remap (& self) -> Tim2RemapR { Tim2RemapR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - TIM3 remapping"]
#[inline (always)] pub fn tim3_remap (& self) -> Tim3RemapR { Tim3RemapR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bit 12 - TIM4 remapping"]
#[inline (always)] pub fn tim4_remap (& self) -> Tim4RemapR { Tim4RemapR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:14 - CAN1 remapping"]
#[inline (always)] pub fn can_remap (& self) -> CanRemapR { CanRemapR :: new (((self . bits >> 13) & 3) as u8) }
#[doc = "Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT"]
#[inline (always)] pub fn pd01_remap (& self) -> Pd01RemapR { Pd01RemapR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Set and cleared by software"]
#[inline (always)] pub fn tim5ch4_iremap (& self) -> Tim5ch4IremapR { Tim5ch4IremapR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - ADC 1 External trigger injected conversion remapping"]
#[inline (always)] pub fn adc1_etrginj_remap (& self) -> Adc1EtrginjRemapR { Adc1EtrginjRemapR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - ADC 1 external trigger regular conversion remapping"]
#[inline (always)] pub fn adc1_etrgreg_remap (& self) -> Adc1EtrgregRemapR { Adc1EtrgregRemapR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - ADC 2 external trigger injected conversion remapping"]
#[inline (always)] pub fn adc2_etrginj_remap (& self) -> Adc2EtrginjRemapR { Adc2EtrginjRemapR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - ADC 2 external trigger regular conversion remapping"]
#[inline (always)] pub fn adc2_etrgreg_remap (& self) -> Adc2EtrgregRemapR { Adc2EtrgregRemapR :: new (((self . bits >> 20) & 1) != 0) } } impl W {
#[doc = "Bit 0 - SPI1 remapping"]
#[inline (always)] pub fn spi1_remap (& mut self) -> Spi1RemapW < '_ , MaprSpec > { Spi1RemapW :: new (self , 0) }
#[doc = "Bit 1 - I2C1 remapping"]
#[inline (always)] pub fn i2c1_remap (& mut self) -> I2c1RemapW < '_ , MaprSpec > { I2c1RemapW :: new (self , 1) }
#[doc = "Bit 2 - USART1 remapping"]
#[inline (always)] pub fn usart1_remap (& mut self) -> Usart1RemapW < '_ , MaprSpec > { Usart1RemapW :: new (self , 2) }
#[doc = "Bit 3 - USART2 remapping"]
#[inline (always)] pub fn usart2_remap (& mut self) -> Usart2RemapW < '_ , MaprSpec > { Usart2RemapW :: new (self , 3) }
#[doc = "Bits 4:5 - USART3 remapping"]
#[inline (always)] pub fn usart3_remap (& mut self) -> Usart3RemapW < '_ , MaprSpec > { Usart3RemapW :: new (self , 4) }
#[doc = "Bits 6:7 - TIM1 remapping"]
#[inline (always)] pub fn tim1_remap (& mut self) -> Tim1RemapW < '_ , MaprSpec > { Tim1RemapW :: new (self , 6) }
#[doc = "Bits 8:9 - TIM2 remapping"]
#[inline (always)] pub fn tim2_remap (& mut self) -> Tim2RemapW < '_ , MaprSpec > { Tim2RemapW :: new (self , 8) }
#[doc = "Bits 10:11 - TIM3 remapping"]
#[inline (always)] pub fn tim3_remap (& mut self) -> Tim3RemapW < '_ , MaprSpec > { Tim3RemapW :: new (self , 10) }
#[doc = "Bit 12 - TIM4 remapping"]
#[inline (always)] pub fn tim4_remap (& mut self) -> Tim4RemapW < '_ , MaprSpec > { Tim4RemapW :: new (self , 12) }
#[doc = "Bits 13:14 - CAN1 remapping"]
#[inline (always)] pub fn can_remap (& mut self) -> CanRemapW < '_ , MaprSpec > { CanRemapW :: new (self , 13) }
#[doc = "Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT"]
#[inline (always)] pub fn pd01_remap (& mut self) -> Pd01RemapW < '_ , MaprSpec > { Pd01RemapW :: new (self , 15) }
#[doc = "Bit 16 - Set and cleared by software"]
#[inline (always)] pub fn tim5ch4_iremap (& mut self) -> Tim5ch4IremapW < '_ , MaprSpec > { Tim5ch4IremapW :: new (self , 16) }
#[doc = "Bit 17 - ADC 1 External trigger injected conversion remapping"]
#[inline (always)] pub fn adc1_etrginj_remap (& mut self) -> Adc1EtrginjRemapW < '_ , MaprSpec > { Adc1EtrginjRemapW :: new (self , 17) }
#[doc = "Bit 18 - ADC 1 external trigger regular conversion remapping"]
#[inline (always)] pub fn adc1_etrgreg_remap (& mut self) -> Adc1EtrgregRemapW < '_ , MaprSpec > { Adc1EtrgregRemapW :: new (self , 18) }
#[doc = "Bit 19 - ADC 2 external trigger injected conversion remapping"]
#[inline (always)] pub fn adc2_etrginj_remap (& mut self) -> Adc2EtrginjRemapW < '_ , MaprSpec > { Adc2EtrginjRemapW :: new (self , 19) }
#[doc = "Bit 20 - ADC 2 external trigger regular conversion remapping"]
#[inline (always)] pub fn adc2_etrgreg_remap (& mut self) -> Adc2EtrgregRemapW < '_ , MaprSpec > { Adc2EtrgregRemapW :: new (self , 20) }
#[doc = "Bits 24:26 - Serial wire JTAG configuration"]
#[inline (always)] pub fn swj_cfg (& mut self) -> SwjCfgW < '_ , MaprSpec > { SwjCfgW :: new (self , 24) } }
#[doc = "AF remap and debug I/O configuration register (AFIO_MAPR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mapr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mapr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MaprSpec ; impl crate :: RegisterSpec for MaprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mapr::R`](R) reader structure"] impl crate :: Readable for MaprSpec { }
#[doc = "`write(|w| ..)` method takes [`mapr::W`](W) writer structure"] impl crate :: Writable for MaprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MAPR to value 0"] impl crate :: Resettable for MaprSpec { } }
#[doc = "EXTICR1 (rw) register accessor: External interrupt configuration register 1 (AFIO_EXTICR1)\n\nYou can [`read`](crate::Reg::read) this register and get [`exticr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`exticr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@exticr1`] module"]
#[doc (alias = "EXTICR1")] pub type Exticr1 = crate :: Reg < exticr1 :: Exticr1Spec > ;
#[doc = "External interrupt configuration register 1 (AFIO_EXTICR1)"] pub mod exticr1 {
#[doc = "Register `EXTICR1` reader"] pub type R = crate :: R < Exticr1Spec > ;
#[doc = "Register `EXTICR1` writer"] pub type W = crate :: W < Exticr1Spec > ;
#[doc = "Field `EXTI0` reader - EXTI0 configuration"] pub type Exti0R = crate :: FieldReader ;
#[doc = "Field `EXTI0` writer - EXTI0 configuration"] pub type Exti0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI1` reader - EXTI1 configuration"] pub type Exti1R = crate :: FieldReader ;
#[doc = "Field `EXTI1` writer - EXTI1 configuration"] pub type Exti1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI2` reader - EXTI2 configuration"] pub type Exti2R = crate :: FieldReader ;
#[doc = "Field `EXTI2` writer - EXTI2 configuration"] pub type Exti2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI3` reader - EXTI3 configuration"] pub type Exti3R = crate :: FieldReader ;
#[doc = "Field `EXTI3` writer - EXTI3 configuration"] pub type Exti3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - EXTI0 configuration"]
#[inline (always)] pub fn exti0 (& self) -> Exti0R { Exti0R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - EXTI1 configuration"]
#[inline (always)] pub fn exti1 (& self) -> Exti1R { Exti1R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - EXTI2 configuration"]
#[inline (always)] pub fn exti2 (& self) -> Exti2R { Exti2R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - EXTI3 configuration"]
#[inline (always)] pub fn exti3 (& self) -> Exti3R { Exti3R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - EXTI0 configuration"]
#[inline (always)] pub fn exti0 (& mut self) -> Exti0W < '_ , Exticr1Spec > { Exti0W :: new (self , 0) }
#[doc = "Bits 4:7 - EXTI1 configuration"]
#[inline (always)] pub fn exti1 (& mut self) -> Exti1W < '_ , Exticr1Spec > { Exti1W :: new (self , 4) }
#[doc = "Bits 8:11 - EXTI2 configuration"]
#[inline (always)] pub fn exti2 (& mut self) -> Exti2W < '_ , Exticr1Spec > { Exti2W :: new (self , 8) }
#[doc = "Bits 12:15 - EXTI3 configuration"]
#[inline (always)] pub fn exti3 (& mut self) -> Exti3W < '_ , Exticr1Spec > { Exti3W :: new (self , 12) } }
#[doc = "External interrupt configuration register 1 (AFIO_EXTICR1)\n\nYou can [`read`](crate::Reg::read) this register and get [`exticr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`exticr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Exticr1Spec ; impl crate :: RegisterSpec for Exticr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`exticr1::R`](R) reader structure"] impl crate :: Readable for Exticr1Spec { }
#[doc = "`write(|w| ..)` method takes [`exticr1::W`](W) writer structure"] impl crate :: Writable for Exticr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EXTICR1 to value 0"] impl crate :: Resettable for Exticr1Spec { } }
#[doc = "EXTICR2 (rw) register accessor: External interrupt configuration register 2 (AFIO_EXTICR2)\n\nYou can [`read`](crate::Reg::read) this register and get [`exticr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`exticr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@exticr2`] module"]
#[doc (alias = "EXTICR2")] pub type Exticr2 = crate :: Reg < exticr2 :: Exticr2Spec > ;
#[doc = "External interrupt configuration register 2 (AFIO_EXTICR2)"] pub mod exticr2 {
#[doc = "Register `EXTICR2` reader"] pub type R = crate :: R < Exticr2Spec > ;
#[doc = "Register `EXTICR2` writer"] pub type W = crate :: W < Exticr2Spec > ;
#[doc = "Field `EXTI4` reader - EXTI4 configuration"] pub type Exti4R = crate :: FieldReader ;
#[doc = "Field `EXTI4` writer - EXTI4 configuration"] pub type Exti4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI5` reader - EXTI5 configuration"] pub type Exti5R = crate :: FieldReader ;
#[doc = "Field `EXTI5` writer - EXTI5 configuration"] pub type Exti5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI6` reader - EXTI6 configuration"] pub type Exti6R = crate :: FieldReader ;
#[doc = "Field `EXTI6` writer - EXTI6 configuration"] pub type Exti6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI7` reader - EXTI7 configuration"] pub type Exti7R = crate :: FieldReader ;
#[doc = "Field `EXTI7` writer - EXTI7 configuration"] pub type Exti7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - EXTI4 configuration"]
#[inline (always)] pub fn exti4 (& self) -> Exti4R { Exti4R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - EXTI5 configuration"]
#[inline (always)] pub fn exti5 (& self) -> Exti5R { Exti5R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - EXTI6 configuration"]
#[inline (always)] pub fn exti6 (& self) -> Exti6R { Exti6R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - EXTI7 configuration"]
#[inline (always)] pub fn exti7 (& self) -> Exti7R { Exti7R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - EXTI4 configuration"]
#[inline (always)] pub fn exti4 (& mut self) -> Exti4W < '_ , Exticr2Spec > { Exti4W :: new (self , 0) }
#[doc = "Bits 4:7 - EXTI5 configuration"]
#[inline (always)] pub fn exti5 (& mut self) -> Exti5W < '_ , Exticr2Spec > { Exti5W :: new (self , 4) }
#[doc = "Bits 8:11 - EXTI6 configuration"]
#[inline (always)] pub fn exti6 (& mut self) -> Exti6W < '_ , Exticr2Spec > { Exti6W :: new (self , 8) }
#[doc = "Bits 12:15 - EXTI7 configuration"]
#[inline (always)] pub fn exti7 (& mut self) -> Exti7W < '_ , Exticr2Spec > { Exti7W :: new (self , 12) } }
#[doc = "External interrupt configuration register 2 (AFIO_EXTICR2)\n\nYou can [`read`](crate::Reg::read) this register and get [`exticr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`exticr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Exticr2Spec ; impl crate :: RegisterSpec for Exticr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`exticr2::R`](R) reader structure"] impl crate :: Readable for Exticr2Spec { }
#[doc = "`write(|w| ..)` method takes [`exticr2::W`](W) writer structure"] impl crate :: Writable for Exticr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EXTICR2 to value 0"] impl crate :: Resettable for Exticr2Spec { } }
#[doc = "EXTICR3 (rw) register accessor: External interrupt configuration register 3 (AFIO_EXTICR3)\n\nYou can [`read`](crate::Reg::read) this register and get [`exticr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`exticr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@exticr3`] module"]
#[doc (alias = "EXTICR3")] pub type Exticr3 = crate :: Reg < exticr3 :: Exticr3Spec > ;
#[doc = "External interrupt configuration register 3 (AFIO_EXTICR3)"] pub mod exticr3 {
#[doc = "Register `EXTICR3` reader"] pub type R = crate :: R < Exticr3Spec > ;
#[doc = "Register `EXTICR3` writer"] pub type W = crate :: W < Exticr3Spec > ;
#[doc = "Field `EXTI8` reader - EXTI8 configuration"] pub type Exti8R = crate :: FieldReader ;
#[doc = "Field `EXTI8` writer - EXTI8 configuration"] pub type Exti8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI9` reader - EXTI9 configuration"] pub type Exti9R = crate :: FieldReader ;
#[doc = "Field `EXTI9` writer - EXTI9 configuration"] pub type Exti9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI10` reader - EXTI10 configuration"] pub type Exti10R = crate :: FieldReader ;
#[doc = "Field `EXTI10` writer - EXTI10 configuration"] pub type Exti10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI11` reader - EXTI11 configuration"] pub type Exti11R = crate :: FieldReader ;
#[doc = "Field `EXTI11` writer - EXTI11 configuration"] pub type Exti11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - EXTI8 configuration"]
#[inline (always)] pub fn exti8 (& self) -> Exti8R { Exti8R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - EXTI9 configuration"]
#[inline (always)] pub fn exti9 (& self) -> Exti9R { Exti9R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - EXTI10 configuration"]
#[inline (always)] pub fn exti10 (& self) -> Exti10R { Exti10R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - EXTI11 configuration"]
#[inline (always)] pub fn exti11 (& self) -> Exti11R { Exti11R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - EXTI8 configuration"]
#[inline (always)] pub fn exti8 (& mut self) -> Exti8W < '_ , Exticr3Spec > { Exti8W :: new (self , 0) }
#[doc = "Bits 4:7 - EXTI9 configuration"]
#[inline (always)] pub fn exti9 (& mut self) -> Exti9W < '_ , Exticr3Spec > { Exti9W :: new (self , 4) }
#[doc = "Bits 8:11 - EXTI10 configuration"]
#[inline (always)] pub fn exti10 (& mut self) -> Exti10W < '_ , Exticr3Spec > { Exti10W :: new (self , 8) }
#[doc = "Bits 12:15 - EXTI11 configuration"]
#[inline (always)] pub fn exti11 (& mut self) -> Exti11W < '_ , Exticr3Spec > { Exti11W :: new (self , 12) } }
#[doc = "External interrupt configuration register 3 (AFIO_EXTICR3)\n\nYou can [`read`](crate::Reg::read) this register and get [`exticr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`exticr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Exticr3Spec ; impl crate :: RegisterSpec for Exticr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`exticr3::R`](R) reader structure"] impl crate :: Readable for Exticr3Spec { }
#[doc = "`write(|w| ..)` method takes [`exticr3::W`](W) writer structure"] impl crate :: Writable for Exticr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EXTICR3 to value 0"] impl crate :: Resettable for Exticr3Spec { } }
#[doc = "EXTICR4 (rw) register accessor: External interrupt configuration register 4 (AFIO_EXTICR4)\n\nYou can [`read`](crate::Reg::read) this register and get [`exticr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`exticr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@exticr4`] module"]
#[doc (alias = "EXTICR4")] pub type Exticr4 = crate :: Reg < exticr4 :: Exticr4Spec > ;
#[doc = "External interrupt configuration register 4 (AFIO_EXTICR4)"] pub mod exticr4 {
#[doc = "Register `EXTICR4` reader"] pub type R = crate :: R < Exticr4Spec > ;
#[doc = "Register `EXTICR4` writer"] pub type W = crate :: W < Exticr4Spec > ;
#[doc = "Field `EXTI12` reader - EXTI12 configuration"] pub type Exti12R = crate :: FieldReader ;
#[doc = "Field `EXTI12` writer - EXTI12 configuration"] pub type Exti12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI13` reader - EXTI13 configuration"] pub type Exti13R = crate :: FieldReader ;
#[doc = "Field `EXTI13` writer - EXTI13 configuration"] pub type Exti13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI14` reader - EXTI14 configuration"] pub type Exti14R = crate :: FieldReader ;
#[doc = "Field `EXTI14` writer - EXTI14 configuration"] pub type Exti14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI15` reader - EXTI15 configuration"] pub type Exti15R = crate :: FieldReader ;
#[doc = "Field `EXTI15` writer - EXTI15 configuration"] pub type Exti15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - EXTI12 configuration"]
#[inline (always)] pub fn exti12 (& self) -> Exti12R { Exti12R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - EXTI13 configuration"]
#[inline (always)] pub fn exti13 (& self) -> Exti13R { Exti13R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - EXTI14 configuration"]
#[inline (always)] pub fn exti14 (& self) -> Exti14R { Exti14R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - EXTI15 configuration"]
#[inline (always)] pub fn exti15 (& self) -> Exti15R { Exti15R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - EXTI12 configuration"]
#[inline (always)] pub fn exti12 (& mut self) -> Exti12W < '_ , Exticr4Spec > { Exti12W :: new (self , 0) }
#[doc = "Bits 4:7 - EXTI13 configuration"]
#[inline (always)] pub fn exti13 (& mut self) -> Exti13W < '_ , Exticr4Spec > { Exti13W :: new (self , 4) }
#[doc = "Bits 8:11 - EXTI14 configuration"]
#[inline (always)] pub fn exti14 (& mut self) -> Exti14W < '_ , Exticr4Spec > { Exti14W :: new (self , 8) }
#[doc = "Bits 12:15 - EXTI15 configuration"]
#[inline (always)] pub fn exti15 (& mut self) -> Exti15W < '_ , Exticr4Spec > { Exti15W :: new (self , 12) } }
#[doc = "External interrupt configuration register 4 (AFIO_EXTICR4)\n\nYou can [`read`](crate::Reg::read) this register and get [`exticr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`exticr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Exticr4Spec ; impl crate :: RegisterSpec for Exticr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`exticr4::R`](R) reader structure"] impl crate :: Readable for Exticr4Spec { }
#[doc = "`write(|w| ..)` method takes [`exticr4::W`](W) writer structure"] impl crate :: Writable for Exticr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EXTICR4 to value 0"] impl crate :: Resettable for Exticr4Spec { } }
#[doc = "MAPR2 (rw) register accessor: AF remap and debug I/O configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`mapr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mapr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mapr2`] module"]
#[doc (alias = "MAPR2")] pub type Mapr2 = crate :: Reg < mapr2 :: Mapr2Spec > ;
#[doc = "AF remap and debug I/O configuration register"] pub mod mapr2 {
#[doc = "Register `MAPR2` reader"] pub type R = crate :: R < Mapr2Spec > ;
#[doc = "Register `MAPR2` writer"] pub type W = crate :: W < Mapr2Spec > ;
#[doc = "Field `TIM9_REMAP` reader - TIM9 remapping"] pub type Tim9RemapR = crate :: BitReader ;
#[doc = "Field `TIM9_REMAP` writer - TIM9 remapping"] pub type Tim9RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM10_REMAP` reader - TIM10 remapping"] pub type Tim10RemapR = crate :: BitReader ;
#[doc = "Field `TIM10_REMAP` writer - TIM10 remapping"] pub type Tim10RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM11_REMAP` reader - TIM11 remapping"] pub type Tim11RemapR = crate :: BitReader ;
#[doc = "Field `TIM11_REMAP` writer - TIM11 remapping"] pub type Tim11RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM13_REMAP` reader - TIM13 remapping"] pub type Tim13RemapR = crate :: BitReader ;
#[doc = "Field `TIM13_REMAP` writer - TIM13 remapping"] pub type Tim13RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM14_REMAP` reader - TIM14 remapping"] pub type Tim14RemapR = crate :: BitReader ;
#[doc = "Field `TIM14_REMAP` writer - TIM14 remapping"] pub type Tim14RemapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSMC_NADV` reader - NADV connect/disconnect"] pub type FsmcNadvR = crate :: BitReader ;
#[doc = "Field `FSMC_NADV` writer - NADV connect/disconnect"] pub type FsmcNadvW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 5 - TIM9 remapping"]
#[inline (always)] pub fn tim9_remap (& self) -> Tim9RemapR { Tim9RemapR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - TIM10 remapping"]
#[inline (always)] pub fn tim10_remap (& self) -> Tim10RemapR { Tim10RemapR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TIM11 remapping"]
#[inline (always)] pub fn tim11_remap (& self) -> Tim11RemapR { Tim11RemapR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - TIM13 remapping"]
#[inline (always)] pub fn tim13_remap (& self) -> Tim13RemapR { Tim13RemapR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - TIM14 remapping"]
#[inline (always)] pub fn tim14_remap (& self) -> Tim14RemapR { Tim14RemapR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - NADV connect/disconnect"]
#[inline (always)] pub fn fsmc_nadv (& self) -> FsmcNadvR { FsmcNadvR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 5 - TIM9 remapping"]
#[inline (always)] pub fn tim9_remap (& mut self) -> Tim9RemapW < '_ , Mapr2Spec > { Tim9RemapW :: new (self , 5) }
#[doc = "Bit 6 - TIM10 remapping"]
#[inline (always)] pub fn tim10_remap (& mut self) -> Tim10RemapW < '_ , Mapr2Spec > { Tim10RemapW :: new (self , 6) }
#[doc = "Bit 7 - TIM11 remapping"]
#[inline (always)] pub fn tim11_remap (& mut self) -> Tim11RemapW < '_ , Mapr2Spec > { Tim11RemapW :: new (self , 7) }
#[doc = "Bit 8 - TIM13 remapping"]
#[inline (always)] pub fn tim13_remap (& mut self) -> Tim13RemapW < '_ , Mapr2Spec > { Tim13RemapW :: new (self , 8) }
#[doc = "Bit 9 - TIM14 remapping"]
#[inline (always)] pub fn tim14_remap (& mut self) -> Tim14RemapW < '_ , Mapr2Spec > { Tim14RemapW :: new (self , 9) }
#[doc = "Bit 10 - NADV connect/disconnect"]
#[inline (always)] pub fn fsmc_nadv (& mut self) -> FsmcNadvW < '_ , Mapr2Spec > { FsmcNadvW :: new (self , 10) } }
#[doc = "AF remap and debug I/O configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`mapr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mapr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Mapr2Spec ; impl crate :: RegisterSpec for Mapr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mapr2::R`](R) reader structure"] impl crate :: Readable for Mapr2Spec { }
#[doc = "`write(|w| ..)` method takes [`mapr2::W`](W) writer structure"] impl crate :: Writable for Mapr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MAPR2 to value 0"] impl crate :: Resettable for Mapr2Spec { } } }
#[doc = "EXTI"] pub type Exti = crate :: Periph < exti :: RegisterBlock , 0x4001_0400 > ; impl core :: fmt :: Debug for Exti { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Exti") . finish () } }
#[doc = "EXTI"] pub mod exti {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { imr : Imr , emr : Emr , rtsr : Rtsr , ftsr : Ftsr , swier : Swier , pr : Pr , } impl RegisterBlock {
#[doc = "0x00 - Interrupt mask register (EXTI_IMR)"]
#[inline (always)] pub const fn imr (& self) -> & Imr { & self . imr }
#[doc = "0x04 - Event mask register (EXTI_EMR)"]
#[inline (always)] pub const fn emr (& self) -> & Emr { & self . emr }
#[doc = "0x08 - Rising Trigger selection register (EXTI_RTSR)"]
#[inline (always)] pub const fn rtsr (& self) -> & Rtsr { & self . rtsr }
#[doc = "0x0c - Falling Trigger selection register (EXTI_FTSR)"]
#[inline (always)] pub const fn ftsr (& self) -> & Ftsr { & self . ftsr }
#[doc = "0x10 - Software interrupt event register (EXTI_SWIER)"]
#[inline (always)] pub const fn swier (& self) -> & Swier { & self . swier }
#[doc = "0x14 - Pending register (EXTI_PR)"]
#[inline (always)] pub const fn pr (& self) -> & Pr { & self . pr } }
#[doc = "IMR (rw) register accessor: Interrupt mask register (EXTI_IMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`imr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`imr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@imr`] module"]
#[doc (alias = "IMR")] pub type Imr = crate :: Reg < imr :: ImrSpec > ;
#[doc = "Interrupt mask register (EXTI_IMR)"] pub mod imr {
#[doc = "Register `IMR` reader"] pub type R = crate :: R < ImrSpec > ;
#[doc = "Register `IMR` writer"] pub type W = crate :: W < ImrSpec > ;
#[doc = "Field `MR0` reader - Interrupt Mask on line 0"] pub type Mr0R = crate :: BitReader ;
#[doc = "Field `MR0` writer - Interrupt Mask on line 0"] pub type Mr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR1` reader - Interrupt Mask on line 1"] pub type Mr1R = crate :: BitReader ;
#[doc = "Field `MR1` writer - Interrupt Mask on line 1"] pub type Mr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR2` reader - Interrupt Mask on line 2"] pub type Mr2R = crate :: BitReader ;
#[doc = "Field `MR2` writer - Interrupt Mask on line 2"] pub type Mr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR3` reader - Interrupt Mask on line 3"] pub type Mr3R = crate :: BitReader ;
#[doc = "Field `MR3` writer - Interrupt Mask on line 3"] pub type Mr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR4` reader - Interrupt Mask on line 4"] pub type Mr4R = crate :: BitReader ;
#[doc = "Field `MR4` writer - Interrupt Mask on line 4"] pub type Mr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR5` reader - Interrupt Mask on line 5"] pub type Mr5R = crate :: BitReader ;
#[doc = "Field `MR5` writer - Interrupt Mask on line 5"] pub type Mr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR6` reader - Interrupt Mask on line 6"] pub type Mr6R = crate :: BitReader ;
#[doc = "Field `MR6` writer - Interrupt Mask on line 6"] pub type Mr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR7` reader - Interrupt Mask on line 7"] pub type Mr7R = crate :: BitReader ;
#[doc = "Field `MR7` writer - Interrupt Mask on line 7"] pub type Mr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR8` reader - Interrupt Mask on line 8"] pub type Mr8R = crate :: BitReader ;
#[doc = "Field `MR8` writer - Interrupt Mask on line 8"] pub type Mr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR9` reader - Interrupt Mask on line 9"] pub type Mr9R = crate :: BitReader ;
#[doc = "Field `MR9` writer - Interrupt Mask on line 9"] pub type Mr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR10` reader - Interrupt Mask on line 10"] pub type Mr10R = crate :: BitReader ;
#[doc = "Field `MR10` writer - Interrupt Mask on line 10"] pub type Mr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR11` reader - Interrupt Mask on line 11"] pub type Mr11R = crate :: BitReader ;
#[doc = "Field `MR11` writer - Interrupt Mask on line 11"] pub type Mr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR12` reader - Interrupt Mask on line 12"] pub type Mr12R = crate :: BitReader ;
#[doc = "Field `MR12` writer - Interrupt Mask on line 12"] pub type Mr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR13` reader - Interrupt Mask on line 13"] pub type Mr13R = crate :: BitReader ;
#[doc = "Field `MR13` writer - Interrupt Mask on line 13"] pub type Mr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR14` reader - Interrupt Mask on line 14"] pub type Mr14R = crate :: BitReader ;
#[doc = "Field `MR14` writer - Interrupt Mask on line 14"] pub type Mr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR15` reader - Interrupt Mask on line 15"] pub type Mr15R = crate :: BitReader ;
#[doc = "Field `MR15` writer - Interrupt Mask on line 15"] pub type Mr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR16` reader - Interrupt Mask on line 16"] pub type Mr16R = crate :: BitReader ;
#[doc = "Field `MR16` writer - Interrupt Mask on line 16"] pub type Mr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR17` reader - Interrupt Mask on line 17"] pub type Mr17R = crate :: BitReader ;
#[doc = "Field `MR17` writer - Interrupt Mask on line 17"] pub type Mr17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR18` reader - Interrupt Mask on line 18"] pub type Mr18R = crate :: BitReader ;
#[doc = "Field `MR18` writer - Interrupt Mask on line 18"] pub type Mr18W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Interrupt Mask on line 0"]
#[inline (always)] pub fn mr0 (& self) -> Mr0R { Mr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Interrupt Mask on line 1"]
#[inline (always)] pub fn mr1 (& self) -> Mr1R { Mr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Interrupt Mask on line 2"]
#[inline (always)] pub fn mr2 (& self) -> Mr2R { Mr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Interrupt Mask on line 3"]
#[inline (always)] pub fn mr3 (& self) -> Mr3R { Mr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Interrupt Mask on line 4"]
#[inline (always)] pub fn mr4 (& self) -> Mr4R { Mr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Interrupt Mask on line 5"]
#[inline (always)] pub fn mr5 (& self) -> Mr5R { Mr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Interrupt Mask on line 6"]
#[inline (always)] pub fn mr6 (& self) -> Mr6R { Mr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Interrupt Mask on line 7"]
#[inline (always)] pub fn mr7 (& self) -> Mr7R { Mr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Interrupt Mask on line 8"]
#[inline (always)] pub fn mr8 (& self) -> Mr8R { Mr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Interrupt Mask on line 9"]
#[inline (always)] pub fn mr9 (& self) -> Mr9R { Mr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Interrupt Mask on line 10"]
#[inline (always)] pub fn mr10 (& self) -> Mr10R { Mr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Interrupt Mask on line 11"]
#[inline (always)] pub fn mr11 (& self) -> Mr11R { Mr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Interrupt Mask on line 12"]
#[inline (always)] pub fn mr12 (& self) -> Mr12R { Mr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Interrupt Mask on line 13"]
#[inline (always)] pub fn mr13 (& self) -> Mr13R { Mr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Interrupt Mask on line 14"]
#[inline (always)] pub fn mr14 (& self) -> Mr14R { Mr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Interrupt Mask on line 15"]
#[inline (always)] pub fn mr15 (& self) -> Mr15R { Mr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Interrupt Mask on line 16"]
#[inline (always)] pub fn mr16 (& self) -> Mr16R { Mr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Interrupt Mask on line 17"]
#[inline (always)] pub fn mr17 (& self) -> Mr17R { Mr17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Interrupt Mask on line 18"]
#[inline (always)] pub fn mr18 (& self) -> Mr18R { Mr18R :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Interrupt Mask on line 0"]
#[inline (always)] pub fn mr0 (& mut self) -> Mr0W < '_ , ImrSpec > { Mr0W :: new (self , 0) }
#[doc = "Bit 1 - Interrupt Mask on line 1"]
#[inline (always)] pub fn mr1 (& mut self) -> Mr1W < '_ , ImrSpec > { Mr1W :: new (self , 1) }
#[doc = "Bit 2 - Interrupt Mask on line 2"]
#[inline (always)] pub fn mr2 (& mut self) -> Mr2W < '_ , ImrSpec > { Mr2W :: new (self , 2) }
#[doc = "Bit 3 - Interrupt Mask on line 3"]
#[inline (always)] pub fn mr3 (& mut self) -> Mr3W < '_ , ImrSpec > { Mr3W :: new (self , 3) }
#[doc = "Bit 4 - Interrupt Mask on line 4"]
#[inline (always)] pub fn mr4 (& mut self) -> Mr4W < '_ , ImrSpec > { Mr4W :: new (self , 4) }
#[doc = "Bit 5 - Interrupt Mask on line 5"]
#[inline (always)] pub fn mr5 (& mut self) -> Mr5W < '_ , ImrSpec > { Mr5W :: new (self , 5) }
#[doc = "Bit 6 - Interrupt Mask on line 6"]
#[inline (always)] pub fn mr6 (& mut self) -> Mr6W < '_ , ImrSpec > { Mr6W :: new (self , 6) }
#[doc = "Bit 7 - Interrupt Mask on line 7"]
#[inline (always)] pub fn mr7 (& mut self) -> Mr7W < '_ , ImrSpec > { Mr7W :: new (self , 7) }
#[doc = "Bit 8 - Interrupt Mask on line 8"]
#[inline (always)] pub fn mr8 (& mut self) -> Mr8W < '_ , ImrSpec > { Mr8W :: new (self , 8) }
#[doc = "Bit 9 - Interrupt Mask on line 9"]
#[inline (always)] pub fn mr9 (& mut self) -> Mr9W < '_ , ImrSpec > { Mr9W :: new (self , 9) }
#[doc = "Bit 10 - Interrupt Mask on line 10"]
#[inline (always)] pub fn mr10 (& mut self) -> Mr10W < '_ , ImrSpec > { Mr10W :: new (self , 10) }
#[doc = "Bit 11 - Interrupt Mask on line 11"]
#[inline (always)] pub fn mr11 (& mut self) -> Mr11W < '_ , ImrSpec > { Mr11W :: new (self , 11) }
#[doc = "Bit 12 - Interrupt Mask on line 12"]
#[inline (always)] pub fn mr12 (& mut self) -> Mr12W < '_ , ImrSpec > { Mr12W :: new (self , 12) }
#[doc = "Bit 13 - Interrupt Mask on line 13"]
#[inline (always)] pub fn mr13 (& mut self) -> Mr13W < '_ , ImrSpec > { Mr13W :: new (self , 13) }
#[doc = "Bit 14 - Interrupt Mask on line 14"]
#[inline (always)] pub fn mr14 (& mut self) -> Mr14W < '_ , ImrSpec > { Mr14W :: new (self , 14) }
#[doc = "Bit 15 - Interrupt Mask on line 15"]
#[inline (always)] pub fn mr15 (& mut self) -> Mr15W < '_ , ImrSpec > { Mr15W :: new (self , 15) }
#[doc = "Bit 16 - Interrupt Mask on line 16"]
#[inline (always)] pub fn mr16 (& mut self) -> Mr16W < '_ , ImrSpec > { Mr16W :: new (self , 16) }
#[doc = "Bit 17 - Interrupt Mask on line 17"]
#[inline (always)] pub fn mr17 (& mut self) -> Mr17W < '_ , ImrSpec > { Mr17W :: new (self , 17) }
#[doc = "Bit 18 - Interrupt Mask on line 18"]
#[inline (always)] pub fn mr18 (& mut self) -> Mr18W < '_ , ImrSpec > { Mr18W :: new (self , 18) } }
#[doc = "Interrupt mask register (EXTI_IMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`imr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`imr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ImrSpec ; impl crate :: RegisterSpec for ImrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`imr::R`](R) reader structure"] impl crate :: Readable for ImrSpec { }
#[doc = "`write(|w| ..)` method takes [`imr::W`](W) writer structure"] impl crate :: Writable for ImrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IMR to value 0"] impl crate :: Resettable for ImrSpec { } }
#[doc = "EMR (rw) register accessor: Event mask register (EXTI_EMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`emr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`emr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@emr`] module"]
#[doc (alias = "EMR")] pub type Emr = crate :: Reg < emr :: EmrSpec > ;
#[doc = "Event mask register (EXTI_EMR)"] pub mod emr {
#[doc = "Register `EMR` reader"] pub type R = crate :: R < EmrSpec > ;
#[doc = "Register `EMR` writer"] pub type W = crate :: W < EmrSpec > ;
#[doc = "Field `MR0` reader - Event Mask on line 0"] pub type Mr0R = crate :: BitReader ;
#[doc = "Field `MR0` writer - Event Mask on line 0"] pub type Mr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR1` reader - Event Mask on line 1"] pub type Mr1R = crate :: BitReader ;
#[doc = "Field `MR1` writer - Event Mask on line 1"] pub type Mr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR2` reader - Event Mask on line 2"] pub type Mr2R = crate :: BitReader ;
#[doc = "Field `MR2` writer - Event Mask on line 2"] pub type Mr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR3` reader - Event Mask on line 3"] pub type Mr3R = crate :: BitReader ;
#[doc = "Field `MR3` writer - Event Mask on line 3"] pub type Mr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR4` reader - Event Mask on line 4"] pub type Mr4R = crate :: BitReader ;
#[doc = "Field `MR4` writer - Event Mask on line 4"] pub type Mr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR5` reader - Event Mask on line 5"] pub type Mr5R = crate :: BitReader ;
#[doc = "Field `MR5` writer - Event Mask on line 5"] pub type Mr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR6` reader - Event Mask on line 6"] pub type Mr6R = crate :: BitReader ;
#[doc = "Field `MR6` writer - Event Mask on line 6"] pub type Mr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR7` reader - Event Mask on line 7"] pub type Mr7R = crate :: BitReader ;
#[doc = "Field `MR7` writer - Event Mask on line 7"] pub type Mr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR8` reader - Event Mask on line 8"] pub type Mr8R = crate :: BitReader ;
#[doc = "Field `MR8` writer - Event Mask on line 8"] pub type Mr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR9` reader - Event Mask on line 9"] pub type Mr9R = crate :: BitReader ;
#[doc = "Field `MR9` writer - Event Mask on line 9"] pub type Mr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR10` reader - Event Mask on line 10"] pub type Mr10R = crate :: BitReader ;
#[doc = "Field `MR10` writer - Event Mask on line 10"] pub type Mr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR11` reader - Event Mask on line 11"] pub type Mr11R = crate :: BitReader ;
#[doc = "Field `MR11` writer - Event Mask on line 11"] pub type Mr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR12` reader - Event Mask on line 12"] pub type Mr12R = crate :: BitReader ;
#[doc = "Field `MR12` writer - Event Mask on line 12"] pub type Mr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR13` reader - Event Mask on line 13"] pub type Mr13R = crate :: BitReader ;
#[doc = "Field `MR13` writer - Event Mask on line 13"] pub type Mr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR14` reader - Event Mask on line 14"] pub type Mr14R = crate :: BitReader ;
#[doc = "Field `MR14` writer - Event Mask on line 14"] pub type Mr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR15` reader - Event Mask on line 15"] pub type Mr15R = crate :: BitReader ;
#[doc = "Field `MR15` writer - Event Mask on line 15"] pub type Mr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR16` reader - Event Mask on line 16"] pub type Mr16R = crate :: BitReader ;
#[doc = "Field `MR16` writer - Event Mask on line 16"] pub type Mr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR17` reader - Event Mask on line 17"] pub type Mr17R = crate :: BitReader ;
#[doc = "Field `MR17` writer - Event Mask on line 17"] pub type Mr17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MR18` reader - Event Mask on line 18"] pub type Mr18R = crate :: BitReader ;
#[doc = "Field `MR18` writer - Event Mask on line 18"] pub type Mr18W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Event Mask on line 0"]
#[inline (always)] pub fn mr0 (& self) -> Mr0R { Mr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Event Mask on line 1"]
#[inline (always)] pub fn mr1 (& self) -> Mr1R { Mr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Event Mask on line 2"]
#[inline (always)] pub fn mr2 (& self) -> Mr2R { Mr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Event Mask on line 3"]
#[inline (always)] pub fn mr3 (& self) -> Mr3R { Mr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Event Mask on line 4"]
#[inline (always)] pub fn mr4 (& self) -> Mr4R { Mr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Event Mask on line 5"]
#[inline (always)] pub fn mr5 (& self) -> Mr5R { Mr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Event Mask on line 6"]
#[inline (always)] pub fn mr6 (& self) -> Mr6R { Mr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Event Mask on line 7"]
#[inline (always)] pub fn mr7 (& self) -> Mr7R { Mr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Event Mask on line 8"]
#[inline (always)] pub fn mr8 (& self) -> Mr8R { Mr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Mask on line 9"]
#[inline (always)] pub fn mr9 (& self) -> Mr9R { Mr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Event Mask on line 10"]
#[inline (always)] pub fn mr10 (& self) -> Mr10R { Mr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Event Mask on line 11"]
#[inline (always)] pub fn mr11 (& self) -> Mr11R { Mr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Event Mask on line 12"]
#[inline (always)] pub fn mr12 (& self) -> Mr12R { Mr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Event Mask on line 13"]
#[inline (always)] pub fn mr13 (& self) -> Mr13R { Mr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Event Mask on line 14"]
#[inline (always)] pub fn mr14 (& self) -> Mr14R { Mr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Event Mask on line 15"]
#[inline (always)] pub fn mr15 (& self) -> Mr15R { Mr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Event Mask on line 16"]
#[inline (always)] pub fn mr16 (& self) -> Mr16R { Mr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Event Mask on line 17"]
#[inline (always)] pub fn mr17 (& self) -> Mr17R { Mr17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Event Mask on line 18"]
#[inline (always)] pub fn mr18 (& self) -> Mr18R { Mr18R :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Event Mask on line 0"]
#[inline (always)] pub fn mr0 (& mut self) -> Mr0W < '_ , EmrSpec > { Mr0W :: new (self , 0) }
#[doc = "Bit 1 - Event Mask on line 1"]
#[inline (always)] pub fn mr1 (& mut self) -> Mr1W < '_ , EmrSpec > { Mr1W :: new (self , 1) }
#[doc = "Bit 2 - Event Mask on line 2"]
#[inline (always)] pub fn mr2 (& mut self) -> Mr2W < '_ , EmrSpec > { Mr2W :: new (self , 2) }
#[doc = "Bit 3 - Event Mask on line 3"]
#[inline (always)] pub fn mr3 (& mut self) -> Mr3W < '_ , EmrSpec > { Mr3W :: new (self , 3) }
#[doc = "Bit 4 - Event Mask on line 4"]
#[inline (always)] pub fn mr4 (& mut self) -> Mr4W < '_ , EmrSpec > { Mr4W :: new (self , 4) }
#[doc = "Bit 5 - Event Mask on line 5"]
#[inline (always)] pub fn mr5 (& mut self) -> Mr5W < '_ , EmrSpec > { Mr5W :: new (self , 5) }
#[doc = "Bit 6 - Event Mask on line 6"]
#[inline (always)] pub fn mr6 (& mut self) -> Mr6W < '_ , EmrSpec > { Mr6W :: new (self , 6) }
#[doc = "Bit 7 - Event Mask on line 7"]
#[inline (always)] pub fn mr7 (& mut self) -> Mr7W < '_ , EmrSpec > { Mr7W :: new (self , 7) }
#[doc = "Bit 8 - Event Mask on line 8"]
#[inline (always)] pub fn mr8 (& mut self) -> Mr8W < '_ , EmrSpec > { Mr8W :: new (self , 8) }
#[doc = "Bit 9 - Event Mask on line 9"]
#[inline (always)] pub fn mr9 (& mut self) -> Mr9W < '_ , EmrSpec > { Mr9W :: new (self , 9) }
#[doc = "Bit 10 - Event Mask on line 10"]
#[inline (always)] pub fn mr10 (& mut self) -> Mr10W < '_ , EmrSpec > { Mr10W :: new (self , 10) }
#[doc = "Bit 11 - Event Mask on line 11"]
#[inline (always)] pub fn mr11 (& mut self) -> Mr11W < '_ , EmrSpec > { Mr11W :: new (self , 11) }
#[doc = "Bit 12 - Event Mask on line 12"]
#[inline (always)] pub fn mr12 (& mut self) -> Mr12W < '_ , EmrSpec > { Mr12W :: new (self , 12) }
#[doc = "Bit 13 - Event Mask on line 13"]
#[inline (always)] pub fn mr13 (& mut self) -> Mr13W < '_ , EmrSpec > { Mr13W :: new (self , 13) }
#[doc = "Bit 14 - Event Mask on line 14"]
#[inline (always)] pub fn mr14 (& mut self) -> Mr14W < '_ , EmrSpec > { Mr14W :: new (self , 14) }
#[doc = "Bit 15 - Event Mask on line 15"]
#[inline (always)] pub fn mr15 (& mut self) -> Mr15W < '_ , EmrSpec > { Mr15W :: new (self , 15) }
#[doc = "Bit 16 - Event Mask on line 16"]
#[inline (always)] pub fn mr16 (& mut self) -> Mr16W < '_ , EmrSpec > { Mr16W :: new (self , 16) }
#[doc = "Bit 17 - Event Mask on line 17"]
#[inline (always)] pub fn mr17 (& mut self) -> Mr17W < '_ , EmrSpec > { Mr17W :: new (self , 17) }
#[doc = "Bit 18 - Event Mask on line 18"]
#[inline (always)] pub fn mr18 (& mut self) -> Mr18W < '_ , EmrSpec > { Mr18W :: new (self , 18) } }
#[doc = "Event mask register (EXTI_EMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`emr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`emr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EmrSpec ; impl crate :: RegisterSpec for EmrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`emr::R`](R) reader structure"] impl crate :: Readable for EmrSpec { }
#[doc = "`write(|w| ..)` method takes [`emr::W`](W) writer structure"] impl crate :: Writable for EmrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EMR to value 0"] impl crate :: Resettable for EmrSpec { } }
#[doc = "RTSR (rw) register accessor: Rising Trigger selection register (EXTI_RTSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`rtsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtsr`] module"]
#[doc (alias = "RTSR")] pub type Rtsr = crate :: Reg < rtsr :: RtsrSpec > ;
#[doc = "Rising Trigger selection register (EXTI_RTSR)"] pub mod rtsr {
#[doc = "Register `RTSR` reader"] pub type R = crate :: R < RtsrSpec > ;
#[doc = "Register `RTSR` writer"] pub type W = crate :: W < RtsrSpec > ;
#[doc = "Field `TR0` reader - Rising trigger event configuration of line 0"] pub type Tr0R = crate :: BitReader ;
#[doc = "Field `TR0` writer - Rising trigger event configuration of line 0"] pub type Tr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR1` reader - Rising trigger event configuration of line 1"] pub type Tr1R = crate :: BitReader ;
#[doc = "Field `TR1` writer - Rising trigger event configuration of line 1"] pub type Tr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR2` reader - Rising trigger event configuration of line 2"] pub type Tr2R = crate :: BitReader ;
#[doc = "Field `TR2` writer - Rising trigger event configuration of line 2"] pub type Tr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR3` reader - Rising trigger event configuration of line 3"] pub type Tr3R = crate :: BitReader ;
#[doc = "Field `TR3` writer - Rising trigger event configuration of line 3"] pub type Tr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR4` reader - Rising trigger event configuration of line 4"] pub type Tr4R = crate :: BitReader ;
#[doc = "Field `TR4` writer - Rising trigger event configuration of line 4"] pub type Tr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR5` reader - Rising trigger event configuration of line 5"] pub type Tr5R = crate :: BitReader ;
#[doc = "Field `TR5` writer - Rising trigger event configuration of line 5"] pub type Tr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR6` reader - Rising trigger event configuration of line 6"] pub type Tr6R = crate :: BitReader ;
#[doc = "Field `TR6` writer - Rising trigger event configuration of line 6"] pub type Tr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR7` reader - Rising trigger event configuration of line 7"] pub type Tr7R = crate :: BitReader ;
#[doc = "Field `TR7` writer - Rising trigger event configuration of line 7"] pub type Tr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR8` reader - Rising trigger event configuration of line 8"] pub type Tr8R = crate :: BitReader ;
#[doc = "Field `TR8` writer - Rising trigger event configuration of line 8"] pub type Tr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR9` reader - Rising trigger event configuration of line 9"] pub type Tr9R = crate :: BitReader ;
#[doc = "Field `TR9` writer - Rising trigger event configuration of line 9"] pub type Tr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR10` reader - Rising trigger event configuration of line 10"] pub type Tr10R = crate :: BitReader ;
#[doc = "Field `TR10` writer - Rising trigger event configuration of line 10"] pub type Tr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR11` reader - Rising trigger event configuration of line 11"] pub type Tr11R = crate :: BitReader ;
#[doc = "Field `TR11` writer - Rising trigger event configuration of line 11"] pub type Tr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR12` reader - Rising trigger event configuration of line 12"] pub type Tr12R = crate :: BitReader ;
#[doc = "Field `TR12` writer - Rising trigger event configuration of line 12"] pub type Tr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR13` reader - Rising trigger event configuration of line 13"] pub type Tr13R = crate :: BitReader ;
#[doc = "Field `TR13` writer - Rising trigger event configuration of line 13"] pub type Tr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR14` reader - Rising trigger event configuration of line 14"] pub type Tr14R = crate :: BitReader ;
#[doc = "Field `TR14` writer - Rising trigger event configuration of line 14"] pub type Tr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR15` reader - Rising trigger event configuration of line 15"] pub type Tr15R = crate :: BitReader ;
#[doc = "Field `TR15` writer - Rising trigger event configuration of line 15"] pub type Tr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR16` reader - Rising trigger event configuration of line 16"] pub type Tr16R = crate :: BitReader ;
#[doc = "Field `TR16` writer - Rising trigger event configuration of line 16"] pub type Tr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR17` reader - Rising trigger event configuration of line 17"] pub type Tr17R = crate :: BitReader ;
#[doc = "Field `TR17` writer - Rising trigger event configuration of line 17"] pub type Tr17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR18` reader - Rising trigger event configuration of line 18"] pub type Tr18R = crate :: BitReader ;
#[doc = "Field `TR18` writer - Rising trigger event configuration of line 18"] pub type Tr18W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Rising trigger event configuration of line 0"]
#[inline (always)] pub fn tr0 (& self) -> Tr0R { Tr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Rising trigger event configuration of line 1"]
#[inline (always)] pub fn tr1 (& self) -> Tr1R { Tr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Rising trigger event configuration of line 2"]
#[inline (always)] pub fn tr2 (& self) -> Tr2R { Tr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Rising trigger event configuration of line 3"]
#[inline (always)] pub fn tr3 (& self) -> Tr3R { Tr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Rising trigger event configuration of line 4"]
#[inline (always)] pub fn tr4 (& self) -> Tr4R { Tr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Rising trigger event configuration of line 5"]
#[inline (always)] pub fn tr5 (& self) -> Tr5R { Tr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Rising trigger event configuration of line 6"]
#[inline (always)] pub fn tr6 (& self) -> Tr6R { Tr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Rising trigger event configuration of line 7"]
#[inline (always)] pub fn tr7 (& self) -> Tr7R { Tr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Rising trigger event configuration of line 8"]
#[inline (always)] pub fn tr8 (& self) -> Tr8R { Tr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Rising trigger event configuration of line 9"]
#[inline (always)] pub fn tr9 (& self) -> Tr9R { Tr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Rising trigger event configuration of line 10"]
#[inline (always)] pub fn tr10 (& self) -> Tr10R { Tr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Rising trigger event configuration of line 11"]
#[inline (always)] pub fn tr11 (& self) -> Tr11R { Tr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Rising trigger event configuration of line 12"]
#[inline (always)] pub fn tr12 (& self) -> Tr12R { Tr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Rising trigger event configuration of line 13"]
#[inline (always)] pub fn tr13 (& self) -> Tr13R { Tr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Rising trigger event configuration of line 14"]
#[inline (always)] pub fn tr14 (& self) -> Tr14R { Tr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Rising trigger event configuration of line 15"]
#[inline (always)] pub fn tr15 (& self) -> Tr15R { Tr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Rising trigger event configuration of line 16"]
#[inline (always)] pub fn tr16 (& self) -> Tr16R { Tr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Rising trigger event configuration of line 17"]
#[inline (always)] pub fn tr17 (& self) -> Tr17R { Tr17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Rising trigger event configuration of line 18"]
#[inline (always)] pub fn tr18 (& self) -> Tr18R { Tr18R :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Rising trigger event configuration of line 0"]
#[inline (always)] pub fn tr0 (& mut self) -> Tr0W < '_ , RtsrSpec > { Tr0W :: new (self , 0) }
#[doc = "Bit 1 - Rising trigger event configuration of line 1"]
#[inline (always)] pub fn tr1 (& mut self) -> Tr1W < '_ , RtsrSpec > { Tr1W :: new (self , 1) }
#[doc = "Bit 2 - Rising trigger event configuration of line 2"]
#[inline (always)] pub fn tr2 (& mut self) -> Tr2W < '_ , RtsrSpec > { Tr2W :: new (self , 2) }
#[doc = "Bit 3 - Rising trigger event configuration of line 3"]
#[inline (always)] pub fn tr3 (& mut self) -> Tr3W < '_ , RtsrSpec > { Tr3W :: new (self , 3) }
#[doc = "Bit 4 - Rising trigger event configuration of line 4"]
#[inline (always)] pub fn tr4 (& mut self) -> Tr4W < '_ , RtsrSpec > { Tr4W :: new (self , 4) }
#[doc = "Bit 5 - Rising trigger event configuration of line 5"]
#[inline (always)] pub fn tr5 (& mut self) -> Tr5W < '_ , RtsrSpec > { Tr5W :: new (self , 5) }
#[doc = "Bit 6 - Rising trigger event configuration of line 6"]
#[inline (always)] pub fn tr6 (& mut self) -> Tr6W < '_ , RtsrSpec > { Tr6W :: new (self , 6) }
#[doc = "Bit 7 - Rising trigger event configuration of line 7"]
#[inline (always)] pub fn tr7 (& mut self) -> Tr7W < '_ , RtsrSpec > { Tr7W :: new (self , 7) }
#[doc = "Bit 8 - Rising trigger event configuration of line 8"]
#[inline (always)] pub fn tr8 (& mut self) -> Tr8W < '_ , RtsrSpec > { Tr8W :: new (self , 8) }
#[doc = "Bit 9 - Rising trigger event configuration of line 9"]
#[inline (always)] pub fn tr9 (& mut self) -> Tr9W < '_ , RtsrSpec > { Tr9W :: new (self , 9) }
#[doc = "Bit 10 - Rising trigger event configuration of line 10"]
#[inline (always)] pub fn tr10 (& mut self) -> Tr10W < '_ , RtsrSpec > { Tr10W :: new (self , 10) }
#[doc = "Bit 11 - Rising trigger event configuration of line 11"]
#[inline (always)] pub fn tr11 (& mut self) -> Tr11W < '_ , RtsrSpec > { Tr11W :: new (self , 11) }
#[doc = "Bit 12 - Rising trigger event configuration of line 12"]
#[inline (always)] pub fn tr12 (& mut self) -> Tr12W < '_ , RtsrSpec > { Tr12W :: new (self , 12) }
#[doc = "Bit 13 - Rising trigger event configuration of line 13"]
#[inline (always)] pub fn tr13 (& mut self) -> Tr13W < '_ , RtsrSpec > { Tr13W :: new (self , 13) }
#[doc = "Bit 14 - Rising trigger event configuration of line 14"]
#[inline (always)] pub fn tr14 (& mut self) -> Tr14W < '_ , RtsrSpec > { Tr14W :: new (self , 14) }
#[doc = "Bit 15 - Rising trigger event configuration of line 15"]
#[inline (always)] pub fn tr15 (& mut self) -> Tr15W < '_ , RtsrSpec > { Tr15W :: new (self , 15) }
#[doc = "Bit 16 - Rising trigger event configuration of line 16"]
#[inline (always)] pub fn tr16 (& mut self) -> Tr16W < '_ , RtsrSpec > { Tr16W :: new (self , 16) }
#[doc = "Bit 17 - Rising trigger event configuration of line 17"]
#[inline (always)] pub fn tr17 (& mut self) -> Tr17W < '_ , RtsrSpec > { Tr17W :: new (self , 17) }
#[doc = "Bit 18 - Rising trigger event configuration of line 18"]
#[inline (always)] pub fn tr18 (& mut self) -> Tr18W < '_ , RtsrSpec > { Tr18W :: new (self , 18) } }
#[doc = "Rising Trigger selection register (EXTI_RTSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`rtsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RtsrSpec ; impl crate :: RegisterSpec for RtsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rtsr::R`](R) reader structure"] impl crate :: Readable for RtsrSpec { }
#[doc = "`write(|w| ..)` method takes [`rtsr::W`](W) writer structure"] impl crate :: Writable for RtsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTSR to value 0"] impl crate :: Resettable for RtsrSpec { } }
#[doc = "FTSR (rw) register accessor: Falling Trigger selection register (EXTI_FTSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ftsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ftsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ftsr`] module"]
#[doc (alias = "FTSR")] pub type Ftsr = crate :: Reg < ftsr :: FtsrSpec > ;
#[doc = "Falling Trigger selection register (EXTI_FTSR)"] pub mod ftsr {
#[doc = "Register `FTSR` reader"] pub type R = crate :: R < FtsrSpec > ;
#[doc = "Register `FTSR` writer"] pub type W = crate :: W < FtsrSpec > ;
#[doc = "Field `TR0` reader - Falling trigger event configuration of line 0"] pub type Tr0R = crate :: BitReader ;
#[doc = "Field `TR0` writer - Falling trigger event configuration of line 0"] pub type Tr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR1` reader - Falling trigger event configuration of line 1"] pub type Tr1R = crate :: BitReader ;
#[doc = "Field `TR1` writer - Falling trigger event configuration of line 1"] pub type Tr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR2` reader - Falling trigger event configuration of line 2"] pub type Tr2R = crate :: BitReader ;
#[doc = "Field `TR2` writer - Falling trigger event configuration of line 2"] pub type Tr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR3` reader - Falling trigger event configuration of line 3"] pub type Tr3R = crate :: BitReader ;
#[doc = "Field `TR3` writer - Falling trigger event configuration of line 3"] pub type Tr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR4` reader - Falling trigger event configuration of line 4"] pub type Tr4R = crate :: BitReader ;
#[doc = "Field `TR4` writer - Falling trigger event configuration of line 4"] pub type Tr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR5` reader - Falling trigger event configuration of line 5"] pub type Tr5R = crate :: BitReader ;
#[doc = "Field `TR5` writer - Falling trigger event configuration of line 5"] pub type Tr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR6` reader - Falling trigger event configuration of line 6"] pub type Tr6R = crate :: BitReader ;
#[doc = "Field `TR6` writer - Falling trigger event configuration of line 6"] pub type Tr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR7` reader - Falling trigger event configuration of line 7"] pub type Tr7R = crate :: BitReader ;
#[doc = "Field `TR7` writer - Falling trigger event configuration of line 7"] pub type Tr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR8` reader - Falling trigger event configuration of line 8"] pub type Tr8R = crate :: BitReader ;
#[doc = "Field `TR8` writer - Falling trigger event configuration of line 8"] pub type Tr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR9` reader - Falling trigger event configuration of line 9"] pub type Tr9R = crate :: BitReader ;
#[doc = "Field `TR9` writer - Falling trigger event configuration of line 9"] pub type Tr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR10` reader - Falling trigger event configuration of line 10"] pub type Tr10R = crate :: BitReader ;
#[doc = "Field `TR10` writer - Falling trigger event configuration of line 10"] pub type Tr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR11` reader - Falling trigger event configuration of line 11"] pub type Tr11R = crate :: BitReader ;
#[doc = "Field `TR11` writer - Falling trigger event configuration of line 11"] pub type Tr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR12` reader - Falling trigger event configuration of line 12"] pub type Tr12R = crate :: BitReader ;
#[doc = "Field `TR12` writer - Falling trigger event configuration of line 12"] pub type Tr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR13` reader - Falling trigger event configuration of line 13"] pub type Tr13R = crate :: BitReader ;
#[doc = "Field `TR13` writer - Falling trigger event configuration of line 13"] pub type Tr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR14` reader - Falling trigger event configuration of line 14"] pub type Tr14R = crate :: BitReader ;
#[doc = "Field `TR14` writer - Falling trigger event configuration of line 14"] pub type Tr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR15` reader - Falling trigger event configuration of line 15"] pub type Tr15R = crate :: BitReader ;
#[doc = "Field `TR15` writer - Falling trigger event configuration of line 15"] pub type Tr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR16` reader - Falling trigger event configuration of line 16"] pub type Tr16R = crate :: BitReader ;
#[doc = "Field `TR16` writer - Falling trigger event configuration of line 16"] pub type Tr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR17` reader - Falling trigger event configuration of line 17"] pub type Tr17R = crate :: BitReader ;
#[doc = "Field `TR17` writer - Falling trigger event configuration of line 17"] pub type Tr17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR18` reader - Falling trigger event configuration of line 18"] pub type Tr18R = crate :: BitReader ;
#[doc = "Field `TR18` writer - Falling trigger event configuration of line 18"] pub type Tr18W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Falling trigger event configuration of line 0"]
#[inline (always)] pub fn tr0 (& self) -> Tr0R { Tr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Falling trigger event configuration of line 1"]
#[inline (always)] pub fn tr1 (& self) -> Tr1R { Tr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Falling trigger event configuration of line 2"]
#[inline (always)] pub fn tr2 (& self) -> Tr2R { Tr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Falling trigger event configuration of line 3"]
#[inline (always)] pub fn tr3 (& self) -> Tr3R { Tr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Falling trigger event configuration of line 4"]
#[inline (always)] pub fn tr4 (& self) -> Tr4R { Tr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Falling trigger event configuration of line 5"]
#[inline (always)] pub fn tr5 (& self) -> Tr5R { Tr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Falling trigger event configuration of line 6"]
#[inline (always)] pub fn tr6 (& self) -> Tr6R { Tr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Falling trigger event configuration of line 7"]
#[inline (always)] pub fn tr7 (& self) -> Tr7R { Tr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Falling trigger event configuration of line 8"]
#[inline (always)] pub fn tr8 (& self) -> Tr8R { Tr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Falling trigger event configuration of line 9"]
#[inline (always)] pub fn tr9 (& self) -> Tr9R { Tr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Falling trigger event configuration of line 10"]
#[inline (always)] pub fn tr10 (& self) -> Tr10R { Tr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Falling trigger event configuration of line 11"]
#[inline (always)] pub fn tr11 (& self) -> Tr11R { Tr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Falling trigger event configuration of line 12"]
#[inline (always)] pub fn tr12 (& self) -> Tr12R { Tr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Falling trigger event configuration of line 13"]
#[inline (always)] pub fn tr13 (& self) -> Tr13R { Tr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Falling trigger event configuration of line 14"]
#[inline (always)] pub fn tr14 (& self) -> Tr14R { Tr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Falling trigger event configuration of line 15"]
#[inline (always)] pub fn tr15 (& self) -> Tr15R { Tr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Falling trigger event configuration of line 16"]
#[inline (always)] pub fn tr16 (& self) -> Tr16R { Tr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Falling trigger event configuration of line 17"]
#[inline (always)] pub fn tr17 (& self) -> Tr17R { Tr17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Falling trigger event configuration of line 18"]
#[inline (always)] pub fn tr18 (& self) -> Tr18R { Tr18R :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Falling trigger event configuration of line 0"]
#[inline (always)] pub fn tr0 (& mut self) -> Tr0W < '_ , FtsrSpec > { Tr0W :: new (self , 0) }
#[doc = "Bit 1 - Falling trigger event configuration of line 1"]
#[inline (always)] pub fn tr1 (& mut self) -> Tr1W < '_ , FtsrSpec > { Tr1W :: new (self , 1) }
#[doc = "Bit 2 - Falling trigger event configuration of line 2"]
#[inline (always)] pub fn tr2 (& mut self) -> Tr2W < '_ , FtsrSpec > { Tr2W :: new (self , 2) }
#[doc = "Bit 3 - Falling trigger event configuration of line 3"]
#[inline (always)] pub fn tr3 (& mut self) -> Tr3W < '_ , FtsrSpec > { Tr3W :: new (self , 3) }
#[doc = "Bit 4 - Falling trigger event configuration of line 4"]
#[inline (always)] pub fn tr4 (& mut self) -> Tr4W < '_ , FtsrSpec > { Tr4W :: new (self , 4) }
#[doc = "Bit 5 - Falling trigger event configuration of line 5"]
#[inline (always)] pub fn tr5 (& mut self) -> Tr5W < '_ , FtsrSpec > { Tr5W :: new (self , 5) }
#[doc = "Bit 6 - Falling trigger event configuration of line 6"]
#[inline (always)] pub fn tr6 (& mut self) -> Tr6W < '_ , FtsrSpec > { Tr6W :: new (self , 6) }
#[doc = "Bit 7 - Falling trigger event configuration of line 7"]
#[inline (always)] pub fn tr7 (& mut self) -> Tr7W < '_ , FtsrSpec > { Tr7W :: new (self , 7) }
#[doc = "Bit 8 - Falling trigger event configuration of line 8"]
#[inline (always)] pub fn tr8 (& mut self) -> Tr8W < '_ , FtsrSpec > { Tr8W :: new (self , 8) }
#[doc = "Bit 9 - Falling trigger event configuration of line 9"]
#[inline (always)] pub fn tr9 (& mut self) -> Tr9W < '_ , FtsrSpec > { Tr9W :: new (self , 9) }
#[doc = "Bit 10 - Falling trigger event configuration of line 10"]
#[inline (always)] pub fn tr10 (& mut self) -> Tr10W < '_ , FtsrSpec > { Tr10W :: new (self , 10) }
#[doc = "Bit 11 - Falling trigger event configuration of line 11"]
#[inline (always)] pub fn tr11 (& mut self) -> Tr11W < '_ , FtsrSpec > { Tr11W :: new (self , 11) }
#[doc = "Bit 12 - Falling trigger event configuration of line 12"]
#[inline (always)] pub fn tr12 (& mut self) -> Tr12W < '_ , FtsrSpec > { Tr12W :: new (self , 12) }
#[doc = "Bit 13 - Falling trigger event configuration of line 13"]
#[inline (always)] pub fn tr13 (& mut self) -> Tr13W < '_ , FtsrSpec > { Tr13W :: new (self , 13) }
#[doc = "Bit 14 - Falling trigger event configuration of line 14"]
#[inline (always)] pub fn tr14 (& mut self) -> Tr14W < '_ , FtsrSpec > { Tr14W :: new (self , 14) }
#[doc = "Bit 15 - Falling trigger event configuration of line 15"]
#[inline (always)] pub fn tr15 (& mut self) -> Tr15W < '_ , FtsrSpec > { Tr15W :: new (self , 15) }
#[doc = "Bit 16 - Falling trigger event configuration of line 16"]
#[inline (always)] pub fn tr16 (& mut self) -> Tr16W < '_ , FtsrSpec > { Tr16W :: new (self , 16) }
#[doc = "Bit 17 - Falling trigger event configuration of line 17"]
#[inline (always)] pub fn tr17 (& mut self) -> Tr17W < '_ , FtsrSpec > { Tr17W :: new (self , 17) }
#[doc = "Bit 18 - Falling trigger event configuration of line 18"]
#[inline (always)] pub fn tr18 (& mut self) -> Tr18W < '_ , FtsrSpec > { Tr18W :: new (self , 18) } }
#[doc = "Falling Trigger selection register (EXTI_FTSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ftsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ftsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FtsrSpec ; impl crate :: RegisterSpec for FtsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ftsr::R`](R) reader structure"] impl crate :: Readable for FtsrSpec { }
#[doc = "`write(|w| ..)` method takes [`ftsr::W`](W) writer structure"] impl crate :: Writable for FtsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FTSR to value 0"] impl crate :: Resettable for FtsrSpec { } }
#[doc = "SWIER (rw) register accessor: Software interrupt event register (EXTI_SWIER)\n\nYou can [`read`](crate::Reg::read) this register and get [`swier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@swier`] module"]
#[doc (alias = "SWIER")] pub type Swier = crate :: Reg < swier :: SwierSpec > ;
#[doc = "Software interrupt event register (EXTI_SWIER)"] pub mod swier {
#[doc = "Register `SWIER` reader"] pub type R = crate :: R < SwierSpec > ;
#[doc = "Register `SWIER` writer"] pub type W = crate :: W < SwierSpec > ;
#[doc = "Field `SWIER0` reader - Software Interrupt on line 0"] pub type Swier0R = crate :: BitReader ;
#[doc = "Field `SWIER0` writer - Software Interrupt on line 0"] pub type Swier0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER1` reader - Software Interrupt on line 1"] pub type Swier1R = crate :: BitReader ;
#[doc = "Field `SWIER1` writer - Software Interrupt on line 1"] pub type Swier1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER2` reader - Software Interrupt on line 2"] pub type Swier2R = crate :: BitReader ;
#[doc = "Field `SWIER2` writer - Software Interrupt on line 2"] pub type Swier2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER3` reader - Software Interrupt on line 3"] pub type Swier3R = crate :: BitReader ;
#[doc = "Field `SWIER3` writer - Software Interrupt on line 3"] pub type Swier3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER4` reader - Software Interrupt on line 4"] pub type Swier4R = crate :: BitReader ;
#[doc = "Field `SWIER4` writer - Software Interrupt on line 4"] pub type Swier4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER5` reader - Software Interrupt on line 5"] pub type Swier5R = crate :: BitReader ;
#[doc = "Field `SWIER5` writer - Software Interrupt on line 5"] pub type Swier5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER6` reader - Software Interrupt on line 6"] pub type Swier6R = crate :: BitReader ;
#[doc = "Field `SWIER6` writer - Software Interrupt on line 6"] pub type Swier6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER7` reader - Software Interrupt on line 7"] pub type Swier7R = crate :: BitReader ;
#[doc = "Field `SWIER7` writer - Software Interrupt on line 7"] pub type Swier7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER8` reader - Software Interrupt on line 8"] pub type Swier8R = crate :: BitReader ;
#[doc = "Field `SWIER8` writer - Software Interrupt on line 8"] pub type Swier8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER9` reader - Software Interrupt on line 9"] pub type Swier9R = crate :: BitReader ;
#[doc = "Field `SWIER9` writer - Software Interrupt on line 9"] pub type Swier9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER10` reader - Software Interrupt on line 10"] pub type Swier10R = crate :: BitReader ;
#[doc = "Field `SWIER10` writer - Software Interrupt on line 10"] pub type Swier10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER11` reader - Software Interrupt on line 11"] pub type Swier11R = crate :: BitReader ;
#[doc = "Field `SWIER11` writer - Software Interrupt on line 11"] pub type Swier11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER12` reader - Software Interrupt on line 12"] pub type Swier12R = crate :: BitReader ;
#[doc = "Field `SWIER12` writer - Software Interrupt on line 12"] pub type Swier12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER13` reader - Software Interrupt on line 13"] pub type Swier13R = crate :: BitReader ;
#[doc = "Field `SWIER13` writer - Software Interrupt on line 13"] pub type Swier13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER14` reader - Software Interrupt on line 14"] pub type Swier14R = crate :: BitReader ;
#[doc = "Field `SWIER14` writer - Software Interrupt on line 14"] pub type Swier14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER15` reader - Software Interrupt on line 15"] pub type Swier15R = crate :: BitReader ;
#[doc = "Field `SWIER15` writer - Software Interrupt on line 15"] pub type Swier15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER16` reader - Software Interrupt on line 16"] pub type Swier16R = crate :: BitReader ;
#[doc = "Field `SWIER16` writer - Software Interrupt on line 16"] pub type Swier16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER17` reader - Software Interrupt on line 17"] pub type Swier17R = crate :: BitReader ;
#[doc = "Field `SWIER17` writer - Software Interrupt on line 17"] pub type Swier17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER18` reader - Software Interrupt on line 18"] pub type Swier18R = crate :: BitReader ;
#[doc = "Field `SWIER18` writer - Software Interrupt on line 18"] pub type Swier18W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Software Interrupt on line 0"]
#[inline (always)] pub fn swier0 (& self) -> Swier0R { Swier0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Software Interrupt on line 1"]
#[inline (always)] pub fn swier1 (& self) -> Swier1R { Swier1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Software Interrupt on line 2"]
#[inline (always)] pub fn swier2 (& self) -> Swier2R { Swier2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Software Interrupt on line 3"]
#[inline (always)] pub fn swier3 (& self) -> Swier3R { Swier3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Software Interrupt on line 4"]
#[inline (always)] pub fn swier4 (& self) -> Swier4R { Swier4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Software Interrupt on line 5"]
#[inline (always)] pub fn swier5 (& self) -> Swier5R { Swier5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Software Interrupt on line 6"]
#[inline (always)] pub fn swier6 (& self) -> Swier6R { Swier6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Software Interrupt on line 7"]
#[inline (always)] pub fn swier7 (& self) -> Swier7R { Swier7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Software Interrupt on line 8"]
#[inline (always)] pub fn swier8 (& self) -> Swier8R { Swier8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Software Interrupt on line 9"]
#[inline (always)] pub fn swier9 (& self) -> Swier9R { Swier9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Software Interrupt on line 10"]
#[inline (always)] pub fn swier10 (& self) -> Swier10R { Swier10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Software Interrupt on line 11"]
#[inline (always)] pub fn swier11 (& self) -> Swier11R { Swier11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Software Interrupt on line 12"]
#[inline (always)] pub fn swier12 (& self) -> Swier12R { Swier12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Software Interrupt on line 13"]
#[inline (always)] pub fn swier13 (& self) -> Swier13R { Swier13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Software Interrupt on line 14"]
#[inline (always)] pub fn swier14 (& self) -> Swier14R { Swier14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Software Interrupt on line 15"]
#[inline (always)] pub fn swier15 (& self) -> Swier15R { Swier15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Software Interrupt on line 16"]
#[inline (always)] pub fn swier16 (& self) -> Swier16R { Swier16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Software Interrupt on line 17"]
#[inline (always)] pub fn swier17 (& self) -> Swier17R { Swier17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Software Interrupt on line 18"]
#[inline (always)] pub fn swier18 (& self) -> Swier18R { Swier18R :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Software Interrupt on line 0"]
#[inline (always)] pub fn swier0 (& mut self) -> Swier0W < '_ , SwierSpec > { Swier0W :: new (self , 0) }
#[doc = "Bit 1 - Software Interrupt on line 1"]
#[inline (always)] pub fn swier1 (& mut self) -> Swier1W < '_ , SwierSpec > { Swier1W :: new (self , 1) }
#[doc = "Bit 2 - Software Interrupt on line 2"]
#[inline (always)] pub fn swier2 (& mut self) -> Swier2W < '_ , SwierSpec > { Swier2W :: new (self , 2) }
#[doc = "Bit 3 - Software Interrupt on line 3"]
#[inline (always)] pub fn swier3 (& mut self) -> Swier3W < '_ , SwierSpec > { Swier3W :: new (self , 3) }
#[doc = "Bit 4 - Software Interrupt on line 4"]
#[inline (always)] pub fn swier4 (& mut self) -> Swier4W < '_ , SwierSpec > { Swier4W :: new (self , 4) }
#[doc = "Bit 5 - Software Interrupt on line 5"]
#[inline (always)] pub fn swier5 (& mut self) -> Swier5W < '_ , SwierSpec > { Swier5W :: new (self , 5) }
#[doc = "Bit 6 - Software Interrupt on line 6"]
#[inline (always)] pub fn swier6 (& mut self) -> Swier6W < '_ , SwierSpec > { Swier6W :: new (self , 6) }
#[doc = "Bit 7 - Software Interrupt on line 7"]
#[inline (always)] pub fn swier7 (& mut self) -> Swier7W < '_ , SwierSpec > { Swier7W :: new (self , 7) }
#[doc = "Bit 8 - Software Interrupt on line 8"]
#[inline (always)] pub fn swier8 (& mut self) -> Swier8W < '_ , SwierSpec > { Swier8W :: new (self , 8) }
#[doc = "Bit 9 - Software Interrupt on line 9"]
#[inline (always)] pub fn swier9 (& mut self) -> Swier9W < '_ , SwierSpec > { Swier9W :: new (self , 9) }
#[doc = "Bit 10 - Software Interrupt on line 10"]
#[inline (always)] pub fn swier10 (& mut self) -> Swier10W < '_ , SwierSpec > { Swier10W :: new (self , 10) }
#[doc = "Bit 11 - Software Interrupt on line 11"]
#[inline (always)] pub fn swier11 (& mut self) -> Swier11W < '_ , SwierSpec > { Swier11W :: new (self , 11) }
#[doc = "Bit 12 - Software Interrupt on line 12"]
#[inline (always)] pub fn swier12 (& mut self) -> Swier12W < '_ , SwierSpec > { Swier12W :: new (self , 12) }
#[doc = "Bit 13 - Software Interrupt on line 13"]
#[inline (always)] pub fn swier13 (& mut self) -> Swier13W < '_ , SwierSpec > { Swier13W :: new (self , 13) }
#[doc = "Bit 14 - Software Interrupt on line 14"]
#[inline (always)] pub fn swier14 (& mut self) -> Swier14W < '_ , SwierSpec > { Swier14W :: new (self , 14) }
#[doc = "Bit 15 - Software Interrupt on line 15"]
#[inline (always)] pub fn swier15 (& mut self) -> Swier15W < '_ , SwierSpec > { Swier15W :: new (self , 15) }
#[doc = "Bit 16 - Software Interrupt on line 16"]
#[inline (always)] pub fn swier16 (& mut self) -> Swier16W < '_ , SwierSpec > { Swier16W :: new (self , 16) }
#[doc = "Bit 17 - Software Interrupt on line 17"]
#[inline (always)] pub fn swier17 (& mut self) -> Swier17W < '_ , SwierSpec > { Swier17W :: new (self , 17) }
#[doc = "Bit 18 - Software Interrupt on line 18"]
#[inline (always)] pub fn swier18 (& mut self) -> Swier18W < '_ , SwierSpec > { Swier18W :: new (self , 18) } }
#[doc = "Software interrupt event register (EXTI_SWIER)\n\nYou can [`read`](crate::Reg::read) this register and get [`swier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SwierSpec ; impl crate :: RegisterSpec for SwierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`swier::R`](R) reader structure"] impl crate :: Readable for SwierSpec { }
#[doc = "`write(|w| ..)` method takes [`swier::W`](W) writer structure"] impl crate :: Writable for SwierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SWIER to value 0"] impl crate :: Resettable for SwierSpec { } }
#[doc = "PR (rw) register accessor: Pending register (EXTI_PR)\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pr`] module"]
#[doc (alias = "PR")] pub type Pr = crate :: Reg < pr :: PrSpec > ;
#[doc = "Pending register (EXTI_PR)"] pub mod pr {
#[doc = "Register `PR` reader"] pub type R = crate :: R < PrSpec > ;
#[doc = "Register `PR` writer"] pub type W = crate :: W < PrSpec > ;
#[doc = "Field `PR0` reader - Pending bit 0"] pub type Pr0R = crate :: BitReader ;
#[doc = "Field `PR0` writer - Pending bit 0"] pub type Pr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR1` reader - Pending bit 1"] pub type Pr1R = crate :: BitReader ;
#[doc = "Field `PR1` writer - Pending bit 1"] pub type Pr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR2` reader - Pending bit 2"] pub type Pr2R = crate :: BitReader ;
#[doc = "Field `PR2` writer - Pending bit 2"] pub type Pr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR3` reader - Pending bit 3"] pub type Pr3R = crate :: BitReader ;
#[doc = "Field `PR3` writer - Pending bit 3"] pub type Pr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR4` reader - Pending bit 4"] pub type Pr4R = crate :: BitReader ;
#[doc = "Field `PR4` writer - Pending bit 4"] pub type Pr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR5` reader - Pending bit 5"] pub type Pr5R = crate :: BitReader ;
#[doc = "Field `PR5` writer - Pending bit 5"] pub type Pr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR6` reader - Pending bit 6"] pub type Pr6R = crate :: BitReader ;
#[doc = "Field `PR6` writer - Pending bit 6"] pub type Pr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR7` reader - Pending bit 7"] pub type Pr7R = crate :: BitReader ;
#[doc = "Field `PR7` writer - Pending bit 7"] pub type Pr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR8` reader - Pending bit 8"] pub type Pr8R = crate :: BitReader ;
#[doc = "Field `PR8` writer - Pending bit 8"] pub type Pr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR9` reader - Pending bit 9"] pub type Pr9R = crate :: BitReader ;
#[doc = "Field `PR9` writer - Pending bit 9"] pub type Pr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR10` reader - Pending bit 10"] pub type Pr10R = crate :: BitReader ;
#[doc = "Field `PR10` writer - Pending bit 10"] pub type Pr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR11` reader - Pending bit 11"] pub type Pr11R = crate :: BitReader ;
#[doc = "Field `PR11` writer - Pending bit 11"] pub type Pr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR12` reader - Pending bit 12"] pub type Pr12R = crate :: BitReader ;
#[doc = "Field `PR12` writer - Pending bit 12"] pub type Pr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR13` reader - Pending bit 13"] pub type Pr13R = crate :: BitReader ;
#[doc = "Field `PR13` writer - Pending bit 13"] pub type Pr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR14` reader - Pending bit 14"] pub type Pr14R = crate :: BitReader ;
#[doc = "Field `PR14` writer - Pending bit 14"] pub type Pr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR15` reader - Pending bit 15"] pub type Pr15R = crate :: BitReader ;
#[doc = "Field `PR15` writer - Pending bit 15"] pub type Pr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR16` reader - Pending bit 16"] pub type Pr16R = crate :: BitReader ;
#[doc = "Field `PR16` writer - Pending bit 16"] pub type Pr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR17` reader - Pending bit 17"] pub type Pr17R = crate :: BitReader ;
#[doc = "Field `PR17` writer - Pending bit 17"] pub type Pr17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR18` reader - Pending bit 18"] pub type Pr18R = crate :: BitReader ;
#[doc = "Field `PR18` writer - Pending bit 18"] pub type Pr18W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Pending bit 0"]
#[inline (always)] pub fn pr0 (& self) -> Pr0R { Pr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Pending bit 1"]
#[inline (always)] pub fn pr1 (& self) -> Pr1R { Pr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Pending bit 2"]
#[inline (always)] pub fn pr2 (& self) -> Pr2R { Pr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Pending bit 3"]
#[inline (always)] pub fn pr3 (& self) -> Pr3R { Pr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Pending bit 4"]
#[inline (always)] pub fn pr4 (& self) -> Pr4R { Pr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Pending bit 5"]
#[inline (always)] pub fn pr5 (& self) -> Pr5R { Pr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Pending bit 6"]
#[inline (always)] pub fn pr6 (& self) -> Pr6R { Pr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Pending bit 7"]
#[inline (always)] pub fn pr7 (& self) -> Pr7R { Pr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Pending bit 8"]
#[inline (always)] pub fn pr8 (& self) -> Pr8R { Pr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Pending bit 9"]
#[inline (always)] pub fn pr9 (& self) -> Pr9R { Pr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Pending bit 10"]
#[inline (always)] pub fn pr10 (& self) -> Pr10R { Pr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Pending bit 11"]
#[inline (always)] pub fn pr11 (& self) -> Pr11R { Pr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Pending bit 12"]
#[inline (always)] pub fn pr12 (& self) -> Pr12R { Pr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Pending bit 13"]
#[inline (always)] pub fn pr13 (& self) -> Pr13R { Pr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Pending bit 14"]
#[inline (always)] pub fn pr14 (& self) -> Pr14R { Pr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Pending bit 15"]
#[inline (always)] pub fn pr15 (& self) -> Pr15R { Pr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Pending bit 16"]
#[inline (always)] pub fn pr16 (& self) -> Pr16R { Pr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Pending bit 17"]
#[inline (always)] pub fn pr17 (& self) -> Pr17R { Pr17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Pending bit 18"]
#[inline (always)] pub fn pr18 (& self) -> Pr18R { Pr18R :: new (((self . bits >> 18) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Pending bit 0"]
#[inline (always)] pub fn pr0 (& mut self) -> Pr0W < '_ , PrSpec > { Pr0W :: new (self , 0) }
#[doc = "Bit 1 - Pending bit 1"]
#[inline (always)] pub fn pr1 (& mut self) -> Pr1W < '_ , PrSpec > { Pr1W :: new (self , 1) }
#[doc = "Bit 2 - Pending bit 2"]
#[inline (always)] pub fn pr2 (& mut self) -> Pr2W < '_ , PrSpec > { Pr2W :: new (self , 2) }
#[doc = "Bit 3 - Pending bit 3"]
#[inline (always)] pub fn pr3 (& mut self) -> Pr3W < '_ , PrSpec > { Pr3W :: new (self , 3) }
#[doc = "Bit 4 - Pending bit 4"]
#[inline (always)] pub fn pr4 (& mut self) -> Pr4W < '_ , PrSpec > { Pr4W :: new (self , 4) }
#[doc = "Bit 5 - Pending bit 5"]
#[inline (always)] pub fn pr5 (& mut self) -> Pr5W < '_ , PrSpec > { Pr5W :: new (self , 5) }
#[doc = "Bit 6 - Pending bit 6"]
#[inline (always)] pub fn pr6 (& mut self) -> Pr6W < '_ , PrSpec > { Pr6W :: new (self , 6) }
#[doc = "Bit 7 - Pending bit 7"]
#[inline (always)] pub fn pr7 (& mut self) -> Pr7W < '_ , PrSpec > { Pr7W :: new (self , 7) }
#[doc = "Bit 8 - Pending bit 8"]
#[inline (always)] pub fn pr8 (& mut self) -> Pr8W < '_ , PrSpec > { Pr8W :: new (self , 8) }
#[doc = "Bit 9 - Pending bit 9"]
#[inline (always)] pub fn pr9 (& mut self) -> Pr9W < '_ , PrSpec > { Pr9W :: new (self , 9) }
#[doc = "Bit 10 - Pending bit 10"]
#[inline (always)] pub fn pr10 (& mut self) -> Pr10W < '_ , PrSpec > { Pr10W :: new (self , 10) }
#[doc = "Bit 11 - Pending bit 11"]
#[inline (always)] pub fn pr11 (& mut self) -> Pr11W < '_ , PrSpec > { Pr11W :: new (self , 11) }
#[doc = "Bit 12 - Pending bit 12"]
#[inline (always)] pub fn pr12 (& mut self) -> Pr12W < '_ , PrSpec > { Pr12W :: new (self , 12) }
#[doc = "Bit 13 - Pending bit 13"]
#[inline (always)] pub fn pr13 (& mut self) -> Pr13W < '_ , PrSpec > { Pr13W :: new (self , 13) }
#[doc = "Bit 14 - Pending bit 14"]
#[inline (always)] pub fn pr14 (& mut self) -> Pr14W < '_ , PrSpec > { Pr14W :: new (self , 14) }
#[doc = "Bit 15 - Pending bit 15"]
#[inline (always)] pub fn pr15 (& mut self) -> Pr15W < '_ , PrSpec > { Pr15W :: new (self , 15) }
#[doc = "Bit 16 - Pending bit 16"]
#[inline (always)] pub fn pr16 (& mut self) -> Pr16W < '_ , PrSpec > { Pr16W :: new (self , 16) }
#[doc = "Bit 17 - Pending bit 17"]
#[inline (always)] pub fn pr17 (& mut self) -> Pr17W < '_ , PrSpec > { Pr17W :: new (self , 17) }
#[doc = "Bit 18 - Pending bit 18"]
#[inline (always)] pub fn pr18 (& mut self) -> Pr18W < '_ , PrSpec > { Pr18W :: new (self , 18) } }
#[doc = "Pending register (EXTI_PR)\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrSpec ; impl crate :: RegisterSpec for PrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pr::R`](R) reader structure"] impl crate :: Readable for PrSpec { }
#[doc = "`write(|w| ..)` method takes [`pr::W`](W) writer structure"] impl crate :: Writable for PrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PR to value 0"] impl crate :: Resettable for PrSpec { } } }
#[doc = "DMA controller"] pub type Dma1 = crate :: Periph < dma1 :: RegisterBlock , 0x4002_0000 > ; impl core :: fmt :: Debug for Dma1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma1") . finish () } }
#[doc = "DMA controller"] pub mod dma1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { isr : Isr , ifcr : Ifcr , ccr1 : Ccr1 , cndtr1 : Cndtr1 , cpar1 : Cpar1 , cmar1 : Cmar1 , _reserved6 : [u8 ; 0x04] , ccr2 : Ccr2 , cndtr2 : Cndtr2 , cpar2 : Cpar2 , cmar2 : Cmar2 , _reserved10 : [u8 ; 0x04] , ccr3 : Ccr3 , cndtr3 : Cndtr3 , cpar3 : Cpar3 , cmar3 : Cmar3 , _reserved14 : [u8 ; 0x04] , ccr4 : Ccr4 , cndtr4 : Cndtr4 , cpar4 : Cpar4 , cmar4 : Cmar4 , _reserved18 : [u8 ; 0x04] , ccr5 : Ccr5 , cndtr5 : Cndtr5 , cpar5 : Cpar5 , cmar5 : Cmar5 , _reserved22 : [u8 ; 0x04] , ccr6 : Ccr6 , cndtr6 : Cndtr6 , cpar6 : Cpar6 , cmar6 : Cmar6 , _reserved26 : [u8 ; 0x04] , ccr7 : Ccr7 , cndtr7 : Cndtr7 , cpar7 : Cpar7 , cmar7 : Cmar7 , } impl RegisterBlock {
#[doc = "0x00 - DMA interrupt status register (DMA_ISR)"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x04 - DMA interrupt flag clear register (DMA_IFCR)"]
#[inline (always)] pub const fn ifcr (& self) -> & Ifcr { & self . ifcr }
#[doc = "0x08 - DMA channel configuration register (DMA_CCR)"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x0c - DMA channel 1 number of data register"]
#[inline (always)] pub const fn cndtr1 (& self) -> & Cndtr1 { & self . cndtr1 }
#[doc = "0x10 - DMA channel 1 peripheral address register"]
#[inline (always)] pub const fn cpar1 (& self) -> & Cpar1 { & self . cpar1 }
#[doc = "0x14 - DMA channel 1 memory address register"]
#[inline (always)] pub const fn cmar1 (& self) -> & Cmar1 { & self . cmar1 }
#[doc = "0x1c - DMA channel configuration register (DMA_CCR)"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x20 - DMA channel 2 number of data register"]
#[inline (always)] pub const fn cndtr2 (& self) -> & Cndtr2 { & self . cndtr2 }
#[doc = "0x24 - DMA channel 2 peripheral address register"]
#[inline (always)] pub const fn cpar2 (& self) -> & Cpar2 { & self . cpar2 }
#[doc = "0x28 - DMA channel 2 memory address register"]
#[inline (always)] pub const fn cmar2 (& self) -> & Cmar2 { & self . cmar2 }
#[doc = "0x30 - DMA channel configuration register (DMA_CCR)"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x34 - DMA channel 3 number of data register"]
#[inline (always)] pub const fn cndtr3 (& self) -> & Cndtr3 { & self . cndtr3 }
#[doc = "0x38 - DMA channel 3 peripheral address register"]
#[inline (always)] pub const fn cpar3 (& self) -> & Cpar3 { & self . cpar3 }
#[doc = "0x3c - DMA channel 3 memory address register"]
#[inline (always)] pub const fn cmar3 (& self) -> & Cmar3 { & self . cmar3 }
#[doc = "0x44 - DMA channel configuration register (DMA_CCR)"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x48 - DMA channel 4 number of data register"]
#[inline (always)] pub const fn cndtr4 (& self) -> & Cndtr4 { & self . cndtr4 }
#[doc = "0x4c - DMA channel 4 peripheral address register"]
#[inline (always)] pub const fn cpar4 (& self) -> & Cpar4 { & self . cpar4 }
#[doc = "0x50 - DMA channel 4 memory address register"]
#[inline (always)] pub const fn cmar4 (& self) -> & Cmar4 { & self . cmar4 }
#[doc = "0x58 - DMA channel configuration register (DMA_CCR)"]
#[inline (always)] pub const fn ccr5 (& self) -> & Ccr5 { & self . ccr5 }
#[doc = "0x5c - DMA channel 5 number of data register"]
#[inline (always)] pub const fn cndtr5 (& self) -> & Cndtr5 { & self . cndtr5 }
#[doc = "0x60 - DMA channel 5 peripheral address register"]
#[inline (always)] pub const fn cpar5 (& self) -> & Cpar5 { & self . cpar5 }
#[doc = "0x64 - DMA channel 5 memory address register"]
#[inline (always)] pub const fn cmar5 (& self) -> & Cmar5 { & self . cmar5 }
#[doc = "0x6c - DMA channel configuration register (DMA_CCR)"]
#[inline (always)] pub const fn ccr6 (& self) -> & Ccr6 { & self . ccr6 }
#[doc = "0x70 - DMA channel 6 number of data register"]
#[inline (always)] pub const fn cndtr6 (& self) -> & Cndtr6 { & self . cndtr6 }
#[doc = "0x74 - DMA channel 6 peripheral address register"]
#[inline (always)] pub const fn cpar6 (& self) -> & Cpar6 { & self . cpar6 }
#[doc = "0x78 - DMA channel 6 memory address register"]
#[inline (always)] pub const fn cmar6 (& self) -> & Cmar6 { & self . cmar6 }
#[doc = "0x80 - DMA channel configuration register (DMA_CCR)"]
#[inline (always)] pub const fn ccr7 (& self) -> & Ccr7 { & self . ccr7 }
#[doc = "0x84 - DMA channel 7 number of data register"]
#[inline (always)] pub const fn cndtr7 (& self) -> & Cndtr7 { & self . cndtr7 }
#[doc = "0x88 - DMA channel 7 peripheral address register"]
#[inline (always)] pub const fn cpar7 (& self) -> & Cpar7 { & self . cpar7 }
#[doc = "0x8c - DMA channel 7 memory address register"]
#[inline (always)] pub const fn cmar7 (& self) -> & Cmar7 { & self . cmar7 } }
#[doc = "ISR (r) register accessor: DMA interrupt status register (DMA_ISR)\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "DMA interrupt status register (DMA_ISR)"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `GIF1` reader - Channel 1 Global interrupt flag"] pub type Gif1R = crate :: BitReader ;
#[doc = "Field `TCIF1` reader - Channel 1 Transfer Complete flag"] pub type Tcif1R = crate :: BitReader ;
#[doc = "Field `HTIF1` reader - Channel 1 Half Transfer Complete flag"] pub type Htif1R = crate :: BitReader ;
#[doc = "Field `TEIF1` reader - Channel 1 Transfer Error flag"] pub type Teif1R = crate :: BitReader ;
#[doc = "Field `GIF2` reader - Channel 2 Global interrupt flag"] pub type Gif2R = crate :: BitReader ;
#[doc = "Field `TCIF2` reader - Channel 2 Transfer Complete flag"] pub type Tcif2R = crate :: BitReader ;
#[doc = "Field `HTIF2` reader - Channel 2 Half Transfer Complete flag"] pub type Htif2R = crate :: BitReader ;
#[doc = "Field `TEIF2` reader - Channel 2 Transfer Error flag"] pub type Teif2R = crate :: BitReader ;
#[doc = "Field `GIF3` reader - Channel 3 Global interrupt flag"] pub type Gif3R = crate :: BitReader ;
#[doc = "Field `TCIF3` reader - Channel 3 Transfer Complete flag"] pub type Tcif3R = crate :: BitReader ;
#[doc = "Field `HTIF3` reader - Channel 3 Half Transfer Complete flag"] pub type Htif3R = crate :: BitReader ;
#[doc = "Field `TEIF3` reader - Channel 3 Transfer Error flag"] pub type Teif3R = crate :: BitReader ;
#[doc = "Field `GIF4` reader - Channel 4 Global interrupt flag"] pub type Gif4R = crate :: BitReader ;
#[doc = "Field `TCIF4` reader - Channel 4 Transfer Complete flag"] pub type Tcif4R = crate :: BitReader ;
#[doc = "Field `HTIF4` reader - Channel 4 Half Transfer Complete flag"] pub type Htif4R = crate :: BitReader ;
#[doc = "Field `TEIF4` reader - Channel 4 Transfer Error flag"] pub type Teif4R = crate :: BitReader ;
#[doc = "Field `GIF5` reader - Channel 5 Global interrupt flag"] pub type Gif5R = crate :: BitReader ;
#[doc = "Field `TCIF5` reader - Channel 5 Transfer Complete flag"] pub type Tcif5R = crate :: BitReader ;
#[doc = "Field `HTIF5` reader - Channel 5 Half Transfer Complete flag"] pub type Htif5R = crate :: BitReader ;
#[doc = "Field `TEIF5` reader - Channel 5 Transfer Error flag"] pub type Teif5R = crate :: BitReader ;
#[doc = "Field `GIF6` reader - Channel 6 Global interrupt flag"] pub type Gif6R = crate :: BitReader ;
#[doc = "Field `TCIF6` reader - Channel 6 Transfer Complete flag"] pub type Tcif6R = crate :: BitReader ;
#[doc = "Field `HTIF6` reader - Channel 6 Half Transfer Complete flag"] pub type Htif6R = crate :: BitReader ;
#[doc = "Field `TEIF6` reader - Channel 6 Transfer Error flag"] pub type Teif6R = crate :: BitReader ;
#[doc = "Field `GIF7` reader - Channel 7 Global interrupt flag"] pub type Gif7R = crate :: BitReader ;
#[doc = "Field `TCIF7` reader - Channel 7 Transfer Complete flag"] pub type Tcif7R = crate :: BitReader ;
#[doc = "Field `HTIF7` reader - Channel 7 Half Transfer Complete flag"] pub type Htif7R = crate :: BitReader ;
#[doc = "Field `TEIF7` reader - Channel 7 Transfer Error flag"] pub type Teif7R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Channel 1 Global interrupt flag"]
#[inline (always)] pub fn gif1 (& self) -> Gif1R { Gif1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel 1 Transfer Complete flag"]
#[inline (always)] pub fn tcif1 (& self) -> Tcif1R { Tcif1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Channel 1 Half Transfer Complete flag"]
#[inline (always)] pub fn htif1 (& self) -> Htif1R { Htif1R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Channel 1 Transfer Error flag"]
#[inline (always)] pub fn teif1 (& self) -> Teif1R { Teif1R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Channel 2 Global interrupt flag"]
#[inline (always)] pub fn gif2 (& self) -> Gif2R { Gif2R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Channel 2 Transfer Complete flag"]
#[inline (always)] pub fn tcif2 (& self) -> Tcif2R { Tcif2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Channel 2 Half Transfer Complete flag"]
#[inline (always)] pub fn htif2 (& self) -> Htif2R { Htif2R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Channel 2 Transfer Error flag"]
#[inline (always)] pub fn teif2 (& self) -> Teif2R { Teif2R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Channel 3 Global interrupt flag"]
#[inline (always)] pub fn gif3 (& self) -> Gif3R { Gif3R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Channel 3 Transfer Complete flag"]
#[inline (always)] pub fn tcif3 (& self) -> Tcif3R { Tcif3R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Channel 3 Half Transfer Complete flag"]
#[inline (always)] pub fn htif3 (& self) -> Htif3R { Htif3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Channel 3 Transfer Error flag"]
#[inline (always)] pub fn teif3 (& self) -> Teif3R { Teif3R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Channel 4 Global interrupt flag"]
#[inline (always)] pub fn gif4 (& self) -> Gif4R { Gif4R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Channel 4 Transfer Complete flag"]
#[inline (always)] pub fn tcif4 (& self) -> Tcif4R { Tcif4R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Channel 4 Half Transfer Complete flag"]
#[inline (always)] pub fn htif4 (& self) -> Htif4R { Htif4R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Channel 4 Transfer Error flag"]
#[inline (always)] pub fn teif4 (& self) -> Teif4R { Teif4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Channel 5 Global interrupt flag"]
#[inline (always)] pub fn gif5 (& self) -> Gif5R { Gif5R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Channel 5 Transfer Complete flag"]
#[inline (always)] pub fn tcif5 (& self) -> Tcif5R { Tcif5R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Channel 5 Half Transfer Complete flag"]
#[inline (always)] pub fn htif5 (& self) -> Htif5R { Htif5R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Channel 5 Transfer Error flag"]
#[inline (always)] pub fn teif5 (& self) -> Teif5R { Teif5R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Channel 6 Global interrupt flag"]
#[inline (always)] pub fn gif6 (& self) -> Gif6R { Gif6R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Channel 6 Transfer Complete flag"]
#[inline (always)] pub fn tcif6 (& self) -> Tcif6R { Tcif6R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Channel 6 Half Transfer Complete flag"]
#[inline (always)] pub fn htif6 (& self) -> Htif6R { Htif6R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Channel 6 Transfer Error flag"]
#[inline (always)] pub fn teif6 (& self) -> Teif6R { Teif6R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Channel 7 Global interrupt flag"]
#[inline (always)] pub fn gif7 (& self) -> Gif7R { Gif7R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Channel 7 Transfer Complete flag"]
#[inline (always)] pub fn tcif7 (& self) -> Tcif7R { Tcif7R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Channel 7 Half Transfer Complete flag"]
#[inline (always)] pub fn htif7 (& self) -> Htif7R { Htif7R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Channel 7 Transfer Error flag"]
#[inline (always)] pub fn teif7 (& self) -> Teif7R { Teif7R :: new (((self . bits >> 27) & 1) != 0) } }
#[doc = "DMA interrupt status register (DMA_ISR)\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "IFCR (w) register accessor: DMA interrupt flag clear register (DMA_IFCR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ifcr`] module"]
#[doc (alias = "IFCR")] pub type Ifcr = crate :: Reg < ifcr :: IfcrSpec > ;
#[doc = "DMA interrupt flag clear register (DMA_IFCR)"] pub mod ifcr {
#[doc = "Register `IFCR` writer"] pub type W = crate :: W < IfcrSpec > ;
#[doc = "Field `CGIF1` writer - Channel 1 Global interrupt clear"] pub type Cgif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF1` writer - Channel 1 Transfer Complete clear"] pub type Ctcif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF1` writer - Channel 1 Half Transfer clear"] pub type Chtif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF1` writer - Channel 1 Transfer Error clear"] pub type Cteif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF2` writer - Channel 2 Global interrupt clear"] pub type Cgif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF2` writer - Channel 2 Transfer Complete clear"] pub type Ctcif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF2` writer - Channel 2 Half Transfer clear"] pub type Chtif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF2` writer - Channel 2 Transfer Error clear"] pub type Cteif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF3` writer - Channel 3 Global interrupt clear"] pub type Cgif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF3` writer - Channel 3 Transfer Complete clear"] pub type Ctcif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF3` writer - Channel 3 Half Transfer clear"] pub type Chtif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF3` writer - Channel 3 Transfer Error clear"] pub type Cteif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF4` writer - Channel 4 Global interrupt clear"] pub type Cgif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF4` writer - Channel 4 Transfer Complete clear"] pub type Ctcif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF4` writer - Channel 4 Half Transfer clear"] pub type Chtif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF4` writer - Channel 4 Transfer Error clear"] pub type Cteif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF5` writer - Channel 5 Global interrupt clear"] pub type Cgif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF5` writer - Channel 5 Transfer Complete clear"] pub type Ctcif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF5` writer - Channel 5 Half Transfer clear"] pub type Chtif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF5` writer - Channel 5 Transfer Error clear"] pub type Cteif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF6` writer - Channel 6 Global interrupt clear"] pub type Cgif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF6` writer - Channel 6 Transfer Complete clear"] pub type Ctcif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF6` writer - Channel 6 Half Transfer clear"] pub type Chtif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF6` writer - Channel 6 Transfer Error clear"] pub type Cteif6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF7` writer - Channel 7 Global interrupt clear"] pub type Cgif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF7` writer - Channel 7 Transfer Complete clear"] pub type Ctcif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF7` writer - Channel 7 Half Transfer clear"] pub type Chtif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF7` writer - Channel 7 Transfer Error clear"] pub type Cteif7W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Channel 1 Global interrupt clear"]
#[inline (always)] pub fn cgif1 (& mut self) -> Cgif1W < '_ , IfcrSpec > { Cgif1W :: new (self , 0) }
#[doc = "Bit 1 - Channel 1 Transfer Complete clear"]
#[inline (always)] pub fn ctcif1 (& mut self) -> Ctcif1W < '_ , IfcrSpec > { Ctcif1W :: new (self , 1) }
#[doc = "Bit 2 - Channel 1 Half Transfer clear"]
#[inline (always)] pub fn chtif1 (& mut self) -> Chtif1W < '_ , IfcrSpec > { Chtif1W :: new (self , 2) }
#[doc = "Bit 3 - Channel 1 Transfer Error clear"]
#[inline (always)] pub fn cteif1 (& mut self) -> Cteif1W < '_ , IfcrSpec > { Cteif1W :: new (self , 3) }
#[doc = "Bit 4 - Channel 2 Global interrupt clear"]
#[inline (always)] pub fn cgif2 (& mut self) -> Cgif2W < '_ , IfcrSpec > { Cgif2W :: new (self , 4) }
#[doc = "Bit 5 - Channel 2 Transfer Complete clear"]
#[inline (always)] pub fn ctcif2 (& mut self) -> Ctcif2W < '_ , IfcrSpec > { Ctcif2W :: new (self , 5) }
#[doc = "Bit 6 - Channel 2 Half Transfer clear"]
#[inline (always)] pub fn chtif2 (& mut self) -> Chtif2W < '_ , IfcrSpec > { Chtif2W :: new (self , 6) }
#[doc = "Bit 7 - Channel 2 Transfer Error clear"]
#[inline (always)] pub fn cteif2 (& mut self) -> Cteif2W < '_ , IfcrSpec > { Cteif2W :: new (self , 7) }
#[doc = "Bit 8 - Channel 3 Global interrupt clear"]
#[inline (always)] pub fn cgif3 (& mut self) -> Cgif3W < '_ , IfcrSpec > { Cgif3W :: new (self , 8) }
#[doc = "Bit 9 - Channel 3 Transfer Complete clear"]
#[inline (always)] pub fn ctcif3 (& mut self) -> Ctcif3W < '_ , IfcrSpec > { Ctcif3W :: new (self , 9) }
#[doc = "Bit 10 - Channel 3 Half Transfer clear"]
#[inline (always)] pub fn chtif3 (& mut self) -> Chtif3W < '_ , IfcrSpec > { Chtif3W :: new (self , 10) }
#[doc = "Bit 11 - Channel 3 Transfer Error clear"]
#[inline (always)] pub fn cteif3 (& mut self) -> Cteif3W < '_ , IfcrSpec > { Cteif3W :: new (self , 11) }
#[doc = "Bit 12 - Channel 4 Global interrupt clear"]
#[inline (always)] pub fn cgif4 (& mut self) -> Cgif4W < '_ , IfcrSpec > { Cgif4W :: new (self , 12) }
#[doc = "Bit 13 - Channel 4 Transfer Complete clear"]
#[inline (always)] pub fn ctcif4 (& mut self) -> Ctcif4W < '_ , IfcrSpec > { Ctcif4W :: new (self , 13) }
#[doc = "Bit 14 - Channel 4 Half Transfer clear"]
#[inline (always)] pub fn chtif4 (& mut self) -> Chtif4W < '_ , IfcrSpec > { Chtif4W :: new (self , 14) }
#[doc = "Bit 15 - Channel 4 Transfer Error clear"]
#[inline (always)] pub fn cteif4 (& mut self) -> Cteif4W < '_ , IfcrSpec > { Cteif4W :: new (self , 15) }
#[doc = "Bit 16 - Channel 5 Global interrupt clear"]
#[inline (always)] pub fn cgif5 (& mut self) -> Cgif5W < '_ , IfcrSpec > { Cgif5W :: new (self , 16) }
#[doc = "Bit 17 - Channel 5 Transfer Complete clear"]
#[inline (always)] pub fn ctcif5 (& mut self) -> Ctcif5W < '_ , IfcrSpec > { Ctcif5W :: new (self , 17) }
#[doc = "Bit 18 - Channel 5 Half Transfer clear"]
#[inline (always)] pub fn chtif5 (& mut self) -> Chtif5W < '_ , IfcrSpec > { Chtif5W :: new (self , 18) }
#[doc = "Bit 19 - Channel 5 Transfer Error clear"]
#[inline (always)] pub fn cteif5 (& mut self) -> Cteif5W < '_ , IfcrSpec > { Cteif5W :: new (self , 19) }
#[doc = "Bit 20 - Channel 6 Global interrupt clear"]
#[inline (always)] pub fn cgif6 (& mut self) -> Cgif6W < '_ , IfcrSpec > { Cgif6W :: new (self , 20) }
#[doc = "Bit 21 - Channel 6 Transfer Complete clear"]
#[inline (always)] pub fn ctcif6 (& mut self) -> Ctcif6W < '_ , IfcrSpec > { Ctcif6W :: new (self , 21) }
#[doc = "Bit 22 - Channel 6 Half Transfer clear"]
#[inline (always)] pub fn chtif6 (& mut self) -> Chtif6W < '_ , IfcrSpec > { Chtif6W :: new (self , 22) }
#[doc = "Bit 23 - Channel 6 Transfer Error clear"]
#[inline (always)] pub fn cteif6 (& mut self) -> Cteif6W < '_ , IfcrSpec > { Cteif6W :: new (self , 23) }
#[doc = "Bit 24 - Channel 7 Global interrupt clear"]
#[inline (always)] pub fn cgif7 (& mut self) -> Cgif7W < '_ , IfcrSpec > { Cgif7W :: new (self , 24) }
#[doc = "Bit 25 - Channel 7 Transfer Complete clear"]
#[inline (always)] pub fn ctcif7 (& mut self) -> Ctcif7W < '_ , IfcrSpec > { Ctcif7W :: new (self , 25) }
#[doc = "Bit 26 - Channel 7 Half Transfer clear"]
#[inline (always)] pub fn chtif7 (& mut self) -> Chtif7W < '_ , IfcrSpec > { Chtif7W :: new (self , 26) }
#[doc = "Bit 27 - Channel 7 Transfer Error clear"]
#[inline (always)] pub fn cteif7 (& mut self) -> Cteif7W < '_ , IfcrSpec > { Cteif7W :: new (self , 27) } }
#[doc = "DMA interrupt flag clear register (DMA_IFCR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IfcrSpec ; impl crate :: RegisterSpec for IfcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ifcr::W`](W) writer structure"] impl crate :: Writable for IfcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IFCR to value 0"] impl crate :: Resettable for IfcrSpec { } }
#[doc = "CCR1 (rw) register accessor: DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "DMA channel configuration register (DMA_CCR)"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half Transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half Transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel Priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel Priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr1Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr1Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr1Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr1Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr1Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr1Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr1Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr1Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr1Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr1Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr1Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr1Spec > { Mem2memW :: new (self , 14) } }
#[doc = "DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CNDTR1 (rw) register accessor: DMA channel 1 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr1`] module"]
#[doc (alias = "CNDTR1")] pub type Cndtr1 = crate :: Reg < cndtr1 :: Cndtr1Spec > ;
#[doc = "DMA channel 1 number of data register"] pub mod cndtr1 {
#[doc = "Register `CNDTR1` reader"] pub type R = crate :: R < Cndtr1Spec > ;
#[doc = "Register `CNDTR1` writer"] pub type W = crate :: W < Cndtr1Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr1Spec > { NdtW :: new (self , 0) } }
#[doc = "DMA channel 1 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr1Spec ; impl crate :: RegisterSpec for Cndtr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr1::R`](R) reader structure"] impl crate :: Readable for Cndtr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr1::W`](W) writer structure"] impl crate :: Writable for Cndtr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR1 to value 0"] impl crate :: Resettable for Cndtr1Spec { } }
#[doc = "CPAR1 (rw) register accessor: DMA channel 1 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar1`] module"]
#[doc (alias = "CPAR1")] pub type Cpar1 = crate :: Reg < cpar1 :: Cpar1Spec > ;
#[doc = "DMA channel 1 peripheral address register"] pub mod cpar1 {
#[doc = "Register `CPAR1` reader"] pub type R = crate :: R < Cpar1Spec > ;
#[doc = "Register `CPAR1` writer"] pub type W = crate :: W < Cpar1Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar1Spec > { PaW :: new (self , 0) } }
#[doc = "DMA channel 1 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar1Spec ; impl crate :: RegisterSpec for Cpar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar1::R`](R) reader structure"] impl crate :: Readable for Cpar1Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar1::W`](W) writer structure"] impl crate :: Writable for Cpar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR1 to value 0"] impl crate :: Resettable for Cpar1Spec { } }
#[doc = "CMAR1 (rw) register accessor: DMA channel 1 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar1`] module"]
#[doc (alias = "CMAR1")] pub type Cmar1 = crate :: Reg < cmar1 :: Cmar1Spec > ;
#[doc = "DMA channel 1 memory address register"] pub mod cmar1 {
#[doc = "Register `CMAR1` reader"] pub type R = crate :: R < Cmar1Spec > ;
#[doc = "Register `CMAR1` writer"] pub type W = crate :: W < Cmar1Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar1Spec > { MaW :: new (self , 0) } }
#[doc = "DMA channel 1 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar1Spec ; impl crate :: RegisterSpec for Cmar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar1::R`](R) reader structure"] impl crate :: Readable for Cmar1Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar1::W`](W) writer structure"] impl crate :: Writable for Cmar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR1 to value 0"] impl crate :: Resettable for Cmar1Spec { } }
#[doc = "CCR2 (rw) register accessor: DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "DMA channel configuration register (DMA_CCR)"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half Transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half Transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel Priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel Priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr2Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr2Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr2Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr2Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr2Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr2Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr2Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr2Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr2Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr2Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr2Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr2Spec > { Mem2memW :: new (self , 14) } }
#[doc = "DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CNDTR2 (rw) register accessor: DMA channel 2 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr2`] module"]
#[doc (alias = "CNDTR2")] pub type Cndtr2 = crate :: Reg < cndtr2 :: Cndtr2Spec > ;
#[doc = "DMA channel 2 number of data register"] pub mod cndtr2 {
#[doc = "Register `CNDTR2` reader"] pub type R = crate :: R < Cndtr2Spec > ;
#[doc = "Register `CNDTR2` writer"] pub type W = crate :: W < Cndtr2Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr2Spec > { NdtW :: new (self , 0) } }
#[doc = "DMA channel 2 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr2Spec ; impl crate :: RegisterSpec for Cndtr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr2::R`](R) reader structure"] impl crate :: Readable for Cndtr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr2::W`](W) writer structure"] impl crate :: Writable for Cndtr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR2 to value 0"] impl crate :: Resettable for Cndtr2Spec { } }
#[doc = "CPAR2 (rw) register accessor: DMA channel 2 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar2`] module"]
#[doc (alias = "CPAR2")] pub type Cpar2 = crate :: Reg < cpar2 :: Cpar2Spec > ;
#[doc = "DMA channel 2 peripheral address register"] pub mod cpar2 {
#[doc = "Register `CPAR2` reader"] pub type R = crate :: R < Cpar2Spec > ;
#[doc = "Register `CPAR2` writer"] pub type W = crate :: W < Cpar2Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar2Spec > { PaW :: new (self , 0) } }
#[doc = "DMA channel 2 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar2Spec ; impl crate :: RegisterSpec for Cpar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar2::R`](R) reader structure"] impl crate :: Readable for Cpar2Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar2::W`](W) writer structure"] impl crate :: Writable for Cpar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR2 to value 0"] impl crate :: Resettable for Cpar2Spec { } }
#[doc = "CMAR2 (rw) register accessor: DMA channel 2 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar2`] module"]
#[doc (alias = "CMAR2")] pub type Cmar2 = crate :: Reg < cmar2 :: Cmar2Spec > ;
#[doc = "DMA channel 2 memory address register"] pub mod cmar2 {
#[doc = "Register `CMAR2` reader"] pub type R = crate :: R < Cmar2Spec > ;
#[doc = "Register `CMAR2` writer"] pub type W = crate :: W < Cmar2Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar2Spec > { MaW :: new (self , 0) } }
#[doc = "DMA channel 2 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar2Spec ; impl crate :: RegisterSpec for Cmar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar2::R`](R) reader structure"] impl crate :: Readable for Cmar2Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar2::W`](W) writer structure"] impl crate :: Writable for Cmar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR2 to value 0"] impl crate :: Resettable for Cmar2Spec { } }
#[doc = "CCR3 (rw) register accessor: DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "DMA channel configuration register (DMA_CCR)"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half Transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half Transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel Priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel Priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr3Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr3Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr3Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr3Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr3Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr3Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr3Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr3Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr3Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr3Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr3Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr3Spec > { Mem2memW :: new (self , 14) } }
#[doc = "DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CNDTR3 (rw) register accessor: DMA channel 3 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr3`] module"]
#[doc (alias = "CNDTR3")] pub type Cndtr3 = crate :: Reg < cndtr3 :: Cndtr3Spec > ;
#[doc = "DMA channel 3 number of data register"] pub mod cndtr3 {
#[doc = "Register `CNDTR3` reader"] pub type R = crate :: R < Cndtr3Spec > ;
#[doc = "Register `CNDTR3` writer"] pub type W = crate :: W < Cndtr3Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr3Spec > { NdtW :: new (self , 0) } }
#[doc = "DMA channel 3 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr3Spec ; impl crate :: RegisterSpec for Cndtr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr3::R`](R) reader structure"] impl crate :: Readable for Cndtr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr3::W`](W) writer structure"] impl crate :: Writable for Cndtr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR3 to value 0"] impl crate :: Resettable for Cndtr3Spec { } }
#[doc = "CPAR3 (rw) register accessor: DMA channel 3 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar3`] module"]
#[doc (alias = "CPAR3")] pub type Cpar3 = crate :: Reg < cpar3 :: Cpar3Spec > ;
#[doc = "DMA channel 3 peripheral address register"] pub mod cpar3 {
#[doc = "Register `CPAR3` reader"] pub type R = crate :: R < Cpar3Spec > ;
#[doc = "Register `CPAR3` writer"] pub type W = crate :: W < Cpar3Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar3Spec > { PaW :: new (self , 0) } }
#[doc = "DMA channel 3 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar3Spec ; impl crate :: RegisterSpec for Cpar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar3::R`](R) reader structure"] impl crate :: Readable for Cpar3Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar3::W`](W) writer structure"] impl crate :: Writable for Cpar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR3 to value 0"] impl crate :: Resettable for Cpar3Spec { } }
#[doc = "CMAR3 (rw) register accessor: DMA channel 3 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar3`] module"]
#[doc (alias = "CMAR3")] pub type Cmar3 = crate :: Reg < cmar3 :: Cmar3Spec > ;
#[doc = "DMA channel 3 memory address register"] pub mod cmar3 {
#[doc = "Register `CMAR3` reader"] pub type R = crate :: R < Cmar3Spec > ;
#[doc = "Register `CMAR3` writer"] pub type W = crate :: W < Cmar3Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar3Spec > { MaW :: new (self , 0) } }
#[doc = "DMA channel 3 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar3Spec ; impl crate :: RegisterSpec for Cmar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar3::R`](R) reader structure"] impl crate :: Readable for Cmar3Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar3::W`](W) writer structure"] impl crate :: Writable for Cmar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR3 to value 0"] impl crate :: Resettable for Cmar3Spec { } }
#[doc = "CCR4 (rw) register accessor: DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "DMA channel configuration register (DMA_CCR)"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half Transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half Transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel Priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel Priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr4Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr4Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr4Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr4Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr4Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr4Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr4Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr4Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr4Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr4Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr4Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr4Spec > { Mem2memW :: new (self , 14) } }
#[doc = "DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "CNDTR4 (rw) register accessor: DMA channel 4 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr4`] module"]
#[doc (alias = "CNDTR4")] pub type Cndtr4 = crate :: Reg < cndtr4 :: Cndtr4Spec > ;
#[doc = "DMA channel 4 number of data register"] pub mod cndtr4 {
#[doc = "Register `CNDTR4` reader"] pub type R = crate :: R < Cndtr4Spec > ;
#[doc = "Register `CNDTR4` writer"] pub type W = crate :: W < Cndtr4Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr4Spec > { NdtW :: new (self , 0) } }
#[doc = "DMA channel 4 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr4Spec ; impl crate :: RegisterSpec for Cndtr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr4::R`](R) reader structure"] impl crate :: Readable for Cndtr4Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr4::W`](W) writer structure"] impl crate :: Writable for Cndtr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR4 to value 0"] impl crate :: Resettable for Cndtr4Spec { } }
#[doc = "CPAR4 (rw) register accessor: DMA channel 4 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar4`] module"]
#[doc (alias = "CPAR4")] pub type Cpar4 = crate :: Reg < cpar4 :: Cpar4Spec > ;
#[doc = "DMA channel 4 peripheral address register"] pub mod cpar4 {
#[doc = "Register `CPAR4` reader"] pub type R = crate :: R < Cpar4Spec > ;
#[doc = "Register `CPAR4` writer"] pub type W = crate :: W < Cpar4Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar4Spec > { PaW :: new (self , 0) } }
#[doc = "DMA channel 4 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar4Spec ; impl crate :: RegisterSpec for Cpar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar4::R`](R) reader structure"] impl crate :: Readable for Cpar4Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar4::W`](W) writer structure"] impl crate :: Writable for Cpar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR4 to value 0"] impl crate :: Resettable for Cpar4Spec { } }
#[doc = "CMAR4 (rw) register accessor: DMA channel 4 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar4`] module"]
#[doc (alias = "CMAR4")] pub type Cmar4 = crate :: Reg < cmar4 :: Cmar4Spec > ;
#[doc = "DMA channel 4 memory address register"] pub mod cmar4 {
#[doc = "Register `CMAR4` reader"] pub type R = crate :: R < Cmar4Spec > ;
#[doc = "Register `CMAR4` writer"] pub type W = crate :: W < Cmar4Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar4Spec > { MaW :: new (self , 0) } }
#[doc = "DMA channel 4 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar4Spec ; impl crate :: RegisterSpec for Cmar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar4::R`](R) reader structure"] impl crate :: Readable for Cmar4Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar4::W`](W) writer structure"] impl crate :: Writable for Cmar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR4 to value 0"] impl crate :: Resettable for Cmar4Spec { } }
#[doc = "CCR5 (rw) register accessor: DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr5`] module"]
#[doc (alias = "CCR5")] pub type Ccr5 = crate :: Reg < ccr5 :: Ccr5Spec > ;
#[doc = "DMA channel configuration register (DMA_CCR)"] pub mod ccr5 {
#[doc = "Register `CCR5` reader"] pub type R = crate :: R < Ccr5Spec > ;
#[doc = "Register `CCR5` writer"] pub type W = crate :: W < Ccr5Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half Transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half Transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel Priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel Priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr5Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr5Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr5Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr5Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr5Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr5Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr5Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr5Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr5Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr5Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr5Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr5Spec > { Mem2memW :: new (self , 14) } }
#[doc = "DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr5Spec ; impl crate :: RegisterSpec for Ccr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr5::R`](R) reader structure"] impl crate :: Readable for Ccr5Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr5::W`](W) writer structure"] impl crate :: Writable for Ccr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR5 to value 0"] impl crate :: Resettable for Ccr5Spec { } }
#[doc = "CNDTR5 (rw) register accessor: DMA channel 5 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr5`] module"]
#[doc (alias = "CNDTR5")] pub type Cndtr5 = crate :: Reg < cndtr5 :: Cndtr5Spec > ;
#[doc = "DMA channel 5 number of data register"] pub mod cndtr5 {
#[doc = "Register `CNDTR5` reader"] pub type R = crate :: R < Cndtr5Spec > ;
#[doc = "Register `CNDTR5` writer"] pub type W = crate :: W < Cndtr5Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr5Spec > { NdtW :: new (self , 0) } }
#[doc = "DMA channel 5 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr5Spec ; impl crate :: RegisterSpec for Cndtr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr5::R`](R) reader structure"] impl crate :: Readable for Cndtr5Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr5::W`](W) writer structure"] impl crate :: Writable for Cndtr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR5 to value 0"] impl crate :: Resettable for Cndtr5Spec { } }
#[doc = "CPAR5 (rw) register accessor: DMA channel 5 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar5`] module"]
#[doc (alias = "CPAR5")] pub type Cpar5 = crate :: Reg < cpar5 :: Cpar5Spec > ;
#[doc = "DMA channel 5 peripheral address register"] pub mod cpar5 {
#[doc = "Register `CPAR5` reader"] pub type R = crate :: R < Cpar5Spec > ;
#[doc = "Register `CPAR5` writer"] pub type W = crate :: W < Cpar5Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar5Spec > { PaW :: new (self , 0) } }
#[doc = "DMA channel 5 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar5Spec ; impl crate :: RegisterSpec for Cpar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar5::R`](R) reader structure"] impl crate :: Readable for Cpar5Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar5::W`](W) writer structure"] impl crate :: Writable for Cpar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR5 to value 0"] impl crate :: Resettable for Cpar5Spec { } }
#[doc = "CMAR5 (rw) register accessor: DMA channel 5 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar5`] module"]
#[doc (alias = "CMAR5")] pub type Cmar5 = crate :: Reg < cmar5 :: Cmar5Spec > ;
#[doc = "DMA channel 5 memory address register"] pub mod cmar5 {
#[doc = "Register `CMAR5` reader"] pub type R = crate :: R < Cmar5Spec > ;
#[doc = "Register `CMAR5` writer"] pub type W = crate :: W < Cmar5Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar5Spec > { MaW :: new (self , 0) } }
#[doc = "DMA channel 5 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar5Spec ; impl crate :: RegisterSpec for Cmar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar5::R`](R) reader structure"] impl crate :: Readable for Cmar5Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar5::W`](W) writer structure"] impl crate :: Writable for Cmar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR5 to value 0"] impl crate :: Resettable for Cmar5Spec { } }
#[doc = "CCR6 (rw) register accessor: DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr6`] module"]
#[doc (alias = "CCR6")] pub type Ccr6 = crate :: Reg < ccr6 :: Ccr6Spec > ;
#[doc = "DMA channel configuration register (DMA_CCR)"] pub mod ccr6 {
#[doc = "Register `CCR6` reader"] pub type R = crate :: R < Ccr6Spec > ;
#[doc = "Register `CCR6` writer"] pub type W = crate :: W < Ccr6Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half Transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half Transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel Priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel Priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr6Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr6Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr6Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr6Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr6Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr6Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr6Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr6Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr6Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr6Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr6Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr6Spec > { Mem2memW :: new (self , 14) } }
#[doc = "DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr6Spec ; impl crate :: RegisterSpec for Ccr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr6::R`](R) reader structure"] impl crate :: Readable for Ccr6Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr6::W`](W) writer structure"] impl crate :: Writable for Ccr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR6 to value 0"] impl crate :: Resettable for Ccr6Spec { } }
#[doc = "CNDTR6 (rw) register accessor: DMA channel 6 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr6`] module"]
#[doc (alias = "CNDTR6")] pub type Cndtr6 = crate :: Reg < cndtr6 :: Cndtr6Spec > ;
#[doc = "DMA channel 6 number of data register"] pub mod cndtr6 {
#[doc = "Register `CNDTR6` reader"] pub type R = crate :: R < Cndtr6Spec > ;
#[doc = "Register `CNDTR6` writer"] pub type W = crate :: W < Cndtr6Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr6Spec > { NdtW :: new (self , 0) } }
#[doc = "DMA channel 6 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr6Spec ; impl crate :: RegisterSpec for Cndtr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr6::R`](R) reader structure"] impl crate :: Readable for Cndtr6Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr6::W`](W) writer structure"] impl crate :: Writable for Cndtr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR6 to value 0"] impl crate :: Resettable for Cndtr6Spec { } }
#[doc = "CPAR6 (rw) register accessor: DMA channel 6 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar6`] module"]
#[doc (alias = "CPAR6")] pub type Cpar6 = crate :: Reg < cpar6 :: Cpar6Spec > ;
#[doc = "DMA channel 6 peripheral address register"] pub mod cpar6 {
#[doc = "Register `CPAR6` reader"] pub type R = crate :: R < Cpar6Spec > ;
#[doc = "Register `CPAR6` writer"] pub type W = crate :: W < Cpar6Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar6Spec > { PaW :: new (self , 0) } }
#[doc = "DMA channel 6 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar6Spec ; impl crate :: RegisterSpec for Cpar6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar6::R`](R) reader structure"] impl crate :: Readable for Cpar6Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar6::W`](W) writer structure"] impl crate :: Writable for Cpar6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR6 to value 0"] impl crate :: Resettable for Cpar6Spec { } }
#[doc = "CMAR6 (rw) register accessor: DMA channel 6 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar6`] module"]
#[doc (alias = "CMAR6")] pub type Cmar6 = crate :: Reg < cmar6 :: Cmar6Spec > ;
#[doc = "DMA channel 6 memory address register"] pub mod cmar6 {
#[doc = "Register `CMAR6` reader"] pub type R = crate :: R < Cmar6Spec > ;
#[doc = "Register `CMAR6` writer"] pub type W = crate :: W < Cmar6Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar6Spec > { MaW :: new (self , 0) } }
#[doc = "DMA channel 6 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar6Spec ; impl crate :: RegisterSpec for Cmar6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar6::R`](R) reader structure"] impl crate :: Readable for Cmar6Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar6::W`](W) writer structure"] impl crate :: Writable for Cmar6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR6 to value 0"] impl crate :: Resettable for Cmar6Spec { } }
#[doc = "CCR7 (rw) register accessor: DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr7`] module"]
#[doc (alias = "CCR7")] pub type Ccr7 = crate :: Reg < ccr7 :: Ccr7Spec > ;
#[doc = "DMA channel configuration register (DMA_CCR)"] pub mod ccr7 {
#[doc = "Register `CCR7` reader"] pub type R = crate :: R < Ccr7Spec > ;
#[doc = "Register `CCR7` writer"] pub type W = crate :: W < Ccr7Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half Transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half Transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel Priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel Priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr7Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr7Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half Transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr7Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr7Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr7Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr7Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr7Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr7Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr7Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr7Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel Priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr7Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr7Spec > { Mem2memW :: new (self , 14) } }
#[doc = "DMA channel configuration register (DMA_CCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr7Spec ; impl crate :: RegisterSpec for Ccr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr7::R`](R) reader structure"] impl crate :: Readable for Ccr7Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr7::W`](W) writer structure"] impl crate :: Writable for Ccr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR7 to value 0"] impl crate :: Resettable for Ccr7Spec { } }
#[doc = "CNDTR7 (rw) register accessor: DMA channel 7 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr7`] module"]
#[doc (alias = "CNDTR7")] pub type Cndtr7 = crate :: Reg < cndtr7 :: Cndtr7Spec > ;
#[doc = "DMA channel 7 number of data register"] pub mod cndtr7 {
#[doc = "Register `CNDTR7` reader"] pub type R = crate :: R < Cndtr7Spec > ;
#[doc = "Register `CNDTR7` writer"] pub type W = crate :: W < Cndtr7Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr7Spec > { NdtW :: new (self , 0) } }
#[doc = "DMA channel 7 number of data register\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr7Spec ; impl crate :: RegisterSpec for Cndtr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr7::R`](R) reader structure"] impl crate :: Readable for Cndtr7Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr7::W`](W) writer structure"] impl crate :: Writable for Cndtr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR7 to value 0"] impl crate :: Resettable for Cndtr7Spec { } }
#[doc = "CPAR7 (rw) register accessor: DMA channel 7 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar7`] module"]
#[doc (alias = "CPAR7")] pub type Cpar7 = crate :: Reg < cpar7 :: Cpar7Spec > ;
#[doc = "DMA channel 7 peripheral address register"] pub mod cpar7 {
#[doc = "Register `CPAR7` reader"] pub type R = crate :: R < Cpar7Spec > ;
#[doc = "Register `CPAR7` writer"] pub type W = crate :: W < Cpar7Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar7Spec > { PaW :: new (self , 0) } }
#[doc = "DMA channel 7 peripheral address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar7Spec ; impl crate :: RegisterSpec for Cpar7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar7::R`](R) reader structure"] impl crate :: Readable for Cpar7Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar7::W`](W) writer structure"] impl crate :: Writable for Cpar7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR7 to value 0"] impl crate :: Resettable for Cpar7Spec { } }
#[doc = "CMAR7 (rw) register accessor: DMA channel 7 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar7`] module"]
#[doc (alias = "CMAR7")] pub type Cmar7 = crate :: Reg < cmar7 :: Cmar7Spec > ;
#[doc = "DMA channel 7 memory address register"] pub mod cmar7 {
#[doc = "Register `CMAR7` reader"] pub type R = crate :: R < Cmar7Spec > ;
#[doc = "Register `CMAR7` writer"] pub type W = crate :: W < Cmar7Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar7Spec > { MaW :: new (self , 0) } }
#[doc = "DMA channel 7 memory address register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar7Spec ; impl crate :: RegisterSpec for Cmar7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar7::R`](R) reader structure"] impl crate :: Readable for Cmar7Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar7::W`](W) writer structure"] impl crate :: Writable for Cmar7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR7 to value 0"] impl crate :: Resettable for Cmar7Spec { } } }
#[doc = "DMA controller"] pub type Dma2 = crate :: Periph < dma1 :: RegisterBlock , 0x4002_0400 > ; impl core :: fmt :: Debug for Dma2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma2") . finish () } }
#[doc = "DMA controller"] pub use self :: dma1 as dma2 ;
#[doc = "Secure digital input/output interface"] pub type Sdio = crate :: Periph < sdio :: RegisterBlock , 0x4001_8000 > ; impl core :: fmt :: Debug for Sdio { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sdio") . finish () } }
#[doc = "Secure digital input/output interface"] pub mod sdio {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { power : Power , clkcr : Clkcr , arg : Arg , cmd : Cmd , respcmd : Respcmd , respi1 : Respi1 , resp2 : Resp2 , resp3 : Resp3 , resp4 : Resp4 , dtimer : Dtimer , dlen : Dlen , dctrl : Dctrl , dcount : Dcount , sta : Sta , icr : Icr , mask : Mask , _reserved16 : [u8 ; 0x08] , fifocnt : Fifocnt , _reserved17 : [u8 ; 0x34] , fifo : Fifo , } impl RegisterBlock {
#[doc = "0x00 - Bits 1:0 = PWRCTRL: Power supply control bits"]
#[inline (always)] pub const fn power (& self) -> & Power { & self . power }
#[doc = "0x04 - SDI clock control register (SDIO_CLKCR)"]
#[inline (always)] pub const fn clkcr (& self) -> & Clkcr { & self . clkcr }
#[doc = "0x08 - Bits 31:0 = : Command argument"]
#[inline (always)] pub const fn arg (& self) -> & Arg { & self . arg }
#[doc = "0x0c - SDIO command register (SDIO_CMD)"]
#[inline (always)] pub const fn cmd (& self) -> & Cmd { & self . cmd }
#[doc = "0x10 - SDIO command register"]
#[inline (always)] pub const fn respcmd (& self) -> & Respcmd { & self . respcmd }
#[doc = "0x14 - Bits 31:0 = CARDSTATUS1"]
#[inline (always)] pub const fn respi1 (& self) -> & Respi1 { & self . respi1 }
#[doc = "0x18 - Bits 31:0 = CARDSTATUS2"]
#[inline (always)] pub const fn resp2 (& self) -> & Resp2 { & self . resp2 }
#[doc = "0x1c - Bits 31:0 = CARDSTATUS3"]
#[inline (always)] pub const fn resp3 (& self) -> & Resp3 { & self . resp3 }
#[doc = "0x20 - Bits 31:0 = CARDSTATUS4"]
#[inline (always)] pub const fn resp4 (& self) -> & Resp4 { & self . resp4 }
#[doc = "0x24 - Bits 31:0 = DATATIME: Data timeout period"]
#[inline (always)] pub const fn dtimer (& self) -> & Dtimer { & self . dtimer }
#[doc = "0x28 - Bits 24:0 = DATALENGTH: Data length value"]
#[inline (always)] pub const fn dlen (& self) -> & Dlen { & self . dlen }
#[doc = "0x2c - SDIO data control register (SDIO_DCTRL)"]
#[inline (always)] pub const fn dctrl (& self) -> & Dctrl { & self . dctrl }
#[doc = "0x30 - Bits 24:0 = DATACOUNT: Data count value"]
#[inline (always)] pub const fn dcount (& self) -> & Dcount { & self . dcount }
#[doc = "0x34 - SDIO status register (SDIO_STA)"]
#[inline (always)] pub const fn sta (& self) -> & Sta { & self . sta }
#[doc = "0x38 - SDIO interrupt clear register (SDIO_ICR)"]
#[inline (always)] pub const fn icr (& self) -> & Icr { & self . icr }
#[doc = "0x3c - SDIO mask register (SDIO_MASK)"]
#[inline (always)] pub const fn mask (& self) -> & Mask { & self . mask }
#[doc = "0x48 - Bits 23:0 = FIFOCOUNT: Remaining number of words to be written to or read from the FIFO"]
#[inline (always)] pub const fn fifocnt (& self) -> & Fifocnt { & self . fifocnt }
#[doc = "0x80 - bits 31:0 = FIFOData: Receive and transmit FIFO data"]
#[inline (always)] pub const fn fifo (& self) -> & Fifo { & self . fifo } }
#[doc = "POWER (rw) register accessor: Bits 1:0 = PWRCTRL: Power supply control bits\n\nYou can [`read`](crate::Reg::read) this register and get [`power::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`power::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@power`] module"]
#[doc (alias = "POWER")] pub type Power = crate :: Reg < power :: PowerSpec > ;
#[doc = "Bits 1:0 = PWRCTRL: Power supply control bits"] pub mod power {
#[doc = "Register `POWER` reader"] pub type R = crate :: R < PowerSpec > ;
#[doc = "Register `POWER` writer"] pub type W = crate :: W < PowerSpec > ;
#[doc = "Field `PWRCTRL` reader - PWRCTRL"] pub type PwrctrlR = crate :: FieldReader ;
#[doc = "Field `PWRCTRL` writer - PWRCTRL"] pub type PwrctrlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - PWRCTRL"]
#[inline (always)] pub fn pwrctrl (& self) -> PwrctrlR { PwrctrlR :: new ((self . bits & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - PWRCTRL"]
#[inline (always)] pub fn pwrctrl (& mut self) -> PwrctrlW < '_ , PowerSpec > { PwrctrlW :: new (self , 0) } }
#[doc = "Bits 1:0 = PWRCTRL: Power supply control bits\n\nYou can [`read`](crate::Reg::read) this register and get [`power::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`power::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PowerSpec ; impl crate :: RegisterSpec for PowerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`power::R`](R) reader structure"] impl crate :: Readable for PowerSpec { }
#[doc = "`write(|w| ..)` method takes [`power::W`](W) writer structure"] impl crate :: Writable for PowerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets POWER to value 0"] impl crate :: Resettable for PowerSpec { } }
#[doc = "CLKCR (rw) register accessor: SDI clock control register (SDIO_CLKCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`clkcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clkcr`] module"]
#[doc (alias = "CLKCR")] pub type Clkcr = crate :: Reg < clkcr :: ClkcrSpec > ;
#[doc = "SDI clock control register (SDIO_CLKCR)"] pub mod clkcr {
#[doc = "Register `CLKCR` reader"] pub type R = crate :: R < ClkcrSpec > ;
#[doc = "Register `CLKCR` writer"] pub type W = crate :: W < ClkcrSpec > ;
#[doc = "Field `CLKDIV` reader - Clock divide factor"] pub type ClkdivR = crate :: FieldReader ;
#[doc = "Field `CLKDIV` writer - Clock divide factor"] pub type ClkdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CLKEN` reader - Clock enable bit"] pub type ClkenR = crate :: BitReader ;
#[doc = "Field `CLKEN` writer - Clock enable bit"] pub type ClkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWRSAV` reader - Power saving configuration bit"] pub type PwrsavR = crate :: BitReader ;
#[doc = "Field `PWRSAV` writer - Power saving configuration bit"] pub type PwrsavW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BYPASS` reader - Clock divider bypass enable bit"] pub type BypassR = crate :: BitReader ;
#[doc = "Field `BYPASS` writer - Clock divider bypass enable bit"] pub type BypassW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WIDBUS` reader - Wide bus mode enable bit"] pub type WidbusR = crate :: FieldReader ;
#[doc = "Field `WIDBUS` writer - Wide bus mode enable bit"] pub type WidbusW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NEGEDGE` reader - SDIO_CK dephasing selection bit"] pub type NegedgeR = crate :: BitReader ;
#[doc = "Field `NEGEDGE` writer - SDIO_CK dephasing selection bit"] pub type NegedgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HWFC_EN` reader - HW Flow Control enable"] pub type HwfcEnR = crate :: BitReader ;
#[doc = "Field `HWFC_EN` writer - HW Flow Control enable"] pub type HwfcEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Clock divide factor"]
#[inline (always)] pub fn clkdiv (& self) -> ClkdivR { ClkdivR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Clock enable bit"]
#[inline (always)] pub fn clken (& self) -> ClkenR { ClkenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Power saving configuration bit"]
#[inline (always)] pub fn pwrsav (& self) -> PwrsavR { PwrsavR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Clock divider bypass enable bit"]
#[inline (always)] pub fn bypass (& self) -> BypassR { BypassR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bits 11:12 - Wide bus mode enable bit"]
#[inline (always)] pub fn widbus (& self) -> WidbusR { WidbusR :: new (((self . bits >> 11) & 3) as u8) }
#[doc = "Bit 13 - SDIO_CK dephasing selection bit"]
#[inline (always)] pub fn negedge (& self) -> NegedgeR { NegedgeR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - HW Flow Control enable"]
#[inline (always)] pub fn hwfc_en (& self) -> HwfcEnR { HwfcEnR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Clock divide factor"]
#[inline (always)] pub fn clkdiv (& mut self) -> ClkdivW < '_ , ClkcrSpec > { ClkdivW :: new (self , 0) }
#[doc = "Bit 8 - Clock enable bit"]
#[inline (always)] pub fn clken (& mut self) -> ClkenW < '_ , ClkcrSpec > { ClkenW :: new (self , 8) }
#[doc = "Bit 9 - Power saving configuration bit"]
#[inline (always)] pub fn pwrsav (& mut self) -> PwrsavW < '_ , ClkcrSpec > { PwrsavW :: new (self , 9) }
#[doc = "Bit 10 - Clock divider bypass enable bit"]
#[inline (always)] pub fn bypass (& mut self) -> BypassW < '_ , ClkcrSpec > { BypassW :: new (self , 10) }
#[doc = "Bits 11:12 - Wide bus mode enable bit"]
#[inline (always)] pub fn widbus (& mut self) -> WidbusW < '_ , ClkcrSpec > { WidbusW :: new (self , 11) }
#[doc = "Bit 13 - SDIO_CK dephasing selection bit"]
#[inline (always)] pub fn negedge (& mut self) -> NegedgeW < '_ , ClkcrSpec > { NegedgeW :: new (self , 13) }
#[doc = "Bit 14 - HW Flow Control enable"]
#[inline (always)] pub fn hwfc_en (& mut self) -> HwfcEnW < '_ , ClkcrSpec > { HwfcEnW :: new (self , 14) } }
#[doc = "SDI clock control register (SDIO_CLKCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`clkcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clkcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ClkcrSpec ; impl crate :: RegisterSpec for ClkcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`clkcr::R`](R) reader structure"] impl crate :: Readable for ClkcrSpec { }
#[doc = "`write(|w| ..)` method takes [`clkcr::W`](W) writer structure"] impl crate :: Writable for ClkcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLKCR to value 0"] impl crate :: Resettable for ClkcrSpec { } }
#[doc = "ARG (rw) register accessor: Bits 31:0 = : Command argument\n\nYou can [`read`](crate::Reg::read) this register and get [`arg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arg`] module"]
#[doc (alias = "ARG")] pub type Arg = crate :: Reg < arg :: ArgSpec > ;
#[doc = "Bits 31:0 = : Command argument"] pub mod arg {
#[doc = "Register `ARG` reader"] pub type R = crate :: R < ArgSpec > ;
#[doc = "Register `ARG` writer"] pub type W = crate :: W < ArgSpec > ;
#[doc = "Field `CMDARG` reader - Command argument"] pub type CmdargR = crate :: FieldReader < u32 > ;
#[doc = "Field `CMDARG` writer - Command argument"] pub type CmdargW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Command argument"]
#[inline (always)] pub fn cmdarg (& self) -> CmdargR { CmdargR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Command argument"]
#[inline (always)] pub fn cmdarg (& mut self) -> CmdargW < '_ , ArgSpec > { CmdargW :: new (self , 0) } }
#[doc = "Bits 31:0 = : Command argument\n\nYou can [`read`](crate::Reg::read) this register and get [`arg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArgSpec ; impl crate :: RegisterSpec for ArgSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arg::R`](R) reader structure"] impl crate :: Readable for ArgSpec { }
#[doc = "`write(|w| ..)` method takes [`arg::W`](W) writer structure"] impl crate :: Writable for ArgSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARG to value 0"] impl crate :: Resettable for ArgSpec { } }
#[doc = "CMD (rw) register accessor: SDIO command register (SDIO_CMD)\n\nYou can [`read`](crate::Reg::read) this register and get [`cmd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmd`] module"]
#[doc (alias = "CMD")] pub type Cmd = crate :: Reg < cmd :: CmdSpec > ;
#[doc = "SDIO command register (SDIO_CMD)"] pub mod cmd {
#[doc = "Register `CMD` reader"] pub type R = crate :: R < CmdSpec > ;
#[doc = "Register `CMD` writer"] pub type W = crate :: W < CmdSpec > ;
#[doc = "Field `CMDINDEX` reader - CMDINDEX"] pub type CmdindexR = crate :: FieldReader ;
#[doc = "Field `CMDINDEX` writer - CMDINDEX"] pub type CmdindexW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `WAITRESP` reader - WAITRESP"] pub type WaitrespR = crate :: FieldReader ;
#[doc = "Field `WAITRESP` writer - WAITRESP"] pub type WaitrespW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `WAITINT` reader - WAITINT"] pub type WaitintR = crate :: BitReader ;
#[doc = "Field `WAITINT` writer - WAITINT"] pub type WaitintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAITPEND` reader - WAITPEND"] pub type WaitpendR = crate :: BitReader ;
#[doc = "Field `WAITPEND` writer - WAITPEND"] pub type WaitpendW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPSMEN` reader - CPSMEN"] pub type CpsmenR = crate :: BitReader ;
#[doc = "Field `CPSMEN` writer - CPSMEN"] pub type CpsmenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDIOSuspend` reader - SDIOSuspend"] pub type SdiosuspendR = crate :: BitReader ;
#[doc = "Field `SDIOSuspend` writer - SDIOSuspend"] pub type SdiosuspendW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENCMDcompl` reader - ENCMDcompl"] pub type EncmdcomplR = crate :: BitReader ;
#[doc = "Field `ENCMDcompl` writer - ENCMDcompl"] pub type EncmdcomplW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `nIEN` reader - nIEN"] pub type NIenR = crate :: BitReader ;
#[doc = "Field `nIEN` writer - nIEN"] pub type NIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CE_ATACMD` reader - CE_ATACMD"] pub type CeAtacmdR = crate :: BitReader ;
#[doc = "Field `CE_ATACMD` writer - CE_ATACMD"] pub type CeAtacmdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:5 - CMDINDEX"]
#[inline (always)] pub fn cmdindex (& self) -> CmdindexR { CmdindexR :: new ((self . bits & 0x3f) as u8) }
#[doc = "Bits 6:7 - WAITRESP"]
#[inline (always)] pub fn waitresp (& self) -> WaitrespR { WaitrespR :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bit 8 - WAITINT"]
#[inline (always)] pub fn waitint (& self) -> WaitintR { WaitintR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - WAITPEND"]
#[inline (always)] pub fn waitpend (& self) -> WaitpendR { WaitpendR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - CPSMEN"]
#[inline (always)] pub fn cpsmen (& self) -> CpsmenR { CpsmenR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - SDIOSuspend"]
#[inline (always)] pub fn sdiosuspend (& self) -> SdiosuspendR { SdiosuspendR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - ENCMDcompl"]
#[inline (always)] pub fn encmdcompl (& self) -> EncmdcomplR { EncmdcomplR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - nIEN"]
#[inline (always)] pub fn n_ien (& self) -> NIenR { NIenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - CE_ATACMD"]
#[inline (always)] pub fn ce_atacmd (& self) -> CeAtacmdR { CeAtacmdR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bits 0:5 - CMDINDEX"]
#[inline (always)] pub fn cmdindex (& mut self) -> CmdindexW < '_ , CmdSpec > { CmdindexW :: new (self , 0) }
#[doc = "Bits 6:7 - WAITRESP"]
#[inline (always)] pub fn waitresp (& mut self) -> WaitrespW < '_ , CmdSpec > { WaitrespW :: new (self , 6) }
#[doc = "Bit 8 - WAITINT"]
#[inline (always)] pub fn waitint (& mut self) -> WaitintW < '_ , CmdSpec > { WaitintW :: new (self , 8) }
#[doc = "Bit 9 - WAITPEND"]
#[inline (always)] pub fn waitpend (& mut self) -> WaitpendW < '_ , CmdSpec > { WaitpendW :: new (self , 9) }
#[doc = "Bit 10 - CPSMEN"]
#[inline (always)] pub fn cpsmen (& mut self) -> CpsmenW < '_ , CmdSpec > { CpsmenW :: new (self , 10) }
#[doc = "Bit 11 - SDIOSuspend"]
#[inline (always)] pub fn sdiosuspend (& mut self) -> SdiosuspendW < '_ , CmdSpec > { SdiosuspendW :: new (self , 11) }
#[doc = "Bit 12 - ENCMDcompl"]
#[inline (always)] pub fn encmdcompl (& mut self) -> EncmdcomplW < '_ , CmdSpec > { EncmdcomplW :: new (self , 12) }
#[doc = "Bit 13 - nIEN"]
#[inline (always)] pub fn n_ien (& mut self) -> NIenW < '_ , CmdSpec > { NIenW :: new (self , 13) }
#[doc = "Bit 14 - CE_ATACMD"]
#[inline (always)] pub fn ce_atacmd (& mut self) -> CeAtacmdW < '_ , CmdSpec > { CeAtacmdW :: new (self , 14) } }
#[doc = "SDIO command register (SDIO_CMD)\n\nYou can [`read`](crate::Reg::read) this register and get [`cmd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CmdSpec ; impl crate :: RegisterSpec for CmdSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmd::R`](R) reader structure"] impl crate :: Readable for CmdSpec { }
#[doc = "`write(|w| ..)` method takes [`cmd::W`](W) writer structure"] impl crate :: Writable for CmdSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMD to value 0"] impl crate :: Resettable for CmdSpec { } }
#[doc = "RESPCMD (r) register accessor: SDIO command register\n\nYou can [`read`](crate::Reg::read) this register and get [`respcmd::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@respcmd`] module"]
#[doc (alias = "RESPCMD")] pub type Respcmd = crate :: Reg < respcmd :: RespcmdSpec > ;
#[doc = "SDIO command register"] pub mod respcmd {
#[doc = "Register `RESPCMD` reader"] pub type R = crate :: R < RespcmdSpec > ;
#[doc = "Field `RESPCMD` reader - RESPCMD"] pub type RespcmdR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:5 - RESPCMD"]
#[inline (always)] pub fn respcmd (& self) -> RespcmdR { RespcmdR :: new ((self . bits & 0x3f) as u8) } }
#[doc = "SDIO command register\n\nYou can [`read`](crate::Reg::read) this register and get [`respcmd::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RespcmdSpec ; impl crate :: RegisterSpec for RespcmdSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`respcmd::R`](R) reader structure"] impl crate :: Readable for RespcmdSpec { }
#[doc = "`reset()` method sets RESPCMD to value 0"] impl crate :: Resettable for RespcmdSpec { } }
#[doc = "RESPI1 (r) register accessor: Bits 31:0 = CARDSTATUS1\n\nYou can [`read`](crate::Reg::read) this register and get [`respi1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@respi1`] module"]
#[doc (alias = "RESPI1")] pub type Respi1 = crate :: Reg < respi1 :: Respi1Spec > ;
#[doc = "Bits 31:0 = CARDSTATUS1"] pub mod respi1 {
#[doc = "Register `RESPI1` reader"] pub type R = crate :: R < Respi1Spec > ;
#[doc = "Field `CARDSTATUS1` reader - CARDSTATUS1"] pub type Cardstatus1R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - CARDSTATUS1"]
#[inline (always)] pub fn cardstatus1 (& self) -> Cardstatus1R { Cardstatus1R :: new (self . bits) } }
#[doc = "Bits 31:0 = CARDSTATUS1\n\nYou can [`read`](crate::Reg::read) this register and get [`respi1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Respi1Spec ; impl crate :: RegisterSpec for Respi1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`respi1::R`](R) reader structure"] impl crate :: Readable for Respi1Spec { }
#[doc = "`reset()` method sets RESPI1 to value 0"] impl crate :: Resettable for Respi1Spec { } }
#[doc = "RESP2 (r) register accessor: Bits 31:0 = CARDSTATUS2\n\nYou can [`read`](crate::Reg::read) this register and get [`resp2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@resp2`] module"]
#[doc (alias = "RESP2")] pub type Resp2 = crate :: Reg < resp2 :: Resp2Spec > ;
#[doc = "Bits 31:0 = CARDSTATUS2"] pub mod resp2 {
#[doc = "Register `RESP2` reader"] pub type R = crate :: R < Resp2Spec > ;
#[doc = "Field `CARDSTATUS2` reader - CARDSTATUS2"] pub type Cardstatus2R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - CARDSTATUS2"]
#[inline (always)] pub fn cardstatus2 (& self) -> Cardstatus2R { Cardstatus2R :: new (self . bits) } }
#[doc = "Bits 31:0 = CARDSTATUS2\n\nYou can [`read`](crate::Reg::read) this register and get [`resp2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Resp2Spec ; impl crate :: RegisterSpec for Resp2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`resp2::R`](R) reader structure"] impl crate :: Readable for Resp2Spec { }
#[doc = "`reset()` method sets RESP2 to value 0"] impl crate :: Resettable for Resp2Spec { } }
#[doc = "RESP3 (r) register accessor: Bits 31:0 = CARDSTATUS3\n\nYou can [`read`](crate::Reg::read) this register and get [`resp3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@resp3`] module"]
#[doc (alias = "RESP3")] pub type Resp3 = crate :: Reg < resp3 :: Resp3Spec > ;
#[doc = "Bits 31:0 = CARDSTATUS3"] pub mod resp3 {
#[doc = "Register `RESP3` reader"] pub type R = crate :: R < Resp3Spec > ;
#[doc = "Field `CARDSTATUS3` reader - CARDSTATUS3"] pub type Cardstatus3R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - CARDSTATUS3"]
#[inline (always)] pub fn cardstatus3 (& self) -> Cardstatus3R { Cardstatus3R :: new (self . bits) } }
#[doc = "Bits 31:0 = CARDSTATUS3\n\nYou can [`read`](crate::Reg::read) this register and get [`resp3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Resp3Spec ; impl crate :: RegisterSpec for Resp3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`resp3::R`](R) reader structure"] impl crate :: Readable for Resp3Spec { }
#[doc = "`reset()` method sets RESP3 to value 0"] impl crate :: Resettable for Resp3Spec { } }
#[doc = "RESP4 (r) register accessor: Bits 31:0 = CARDSTATUS4\n\nYou can [`read`](crate::Reg::read) this register and get [`resp4::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@resp4`] module"]
#[doc (alias = "RESP4")] pub type Resp4 = crate :: Reg < resp4 :: Resp4Spec > ;
#[doc = "Bits 31:0 = CARDSTATUS4"] pub mod resp4 {
#[doc = "Register `RESP4` reader"] pub type R = crate :: R < Resp4Spec > ;
#[doc = "Field `CARDSTATUS4` reader - CARDSTATUS4"] pub type Cardstatus4R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - CARDSTATUS4"]
#[inline (always)] pub fn cardstatus4 (& self) -> Cardstatus4R { Cardstatus4R :: new (self . bits) } }
#[doc = "Bits 31:0 = CARDSTATUS4\n\nYou can [`read`](crate::Reg::read) this register and get [`resp4::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Resp4Spec ; impl crate :: RegisterSpec for Resp4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`resp4::R`](R) reader structure"] impl crate :: Readable for Resp4Spec { }
#[doc = "`reset()` method sets RESP4 to value 0"] impl crate :: Resettable for Resp4Spec { } }
#[doc = "DTIMER (rw) register accessor: Bits 31:0 = DATATIME: Data timeout period\n\nYou can [`read`](crate::Reg::read) this register and get [`dtimer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dtimer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dtimer`] module"]
#[doc (alias = "DTIMER")] pub type Dtimer = crate :: Reg < dtimer :: DtimerSpec > ;
#[doc = "Bits 31:0 = DATATIME: Data timeout period"] pub mod dtimer {
#[doc = "Register `DTIMER` reader"] pub type R = crate :: R < DtimerSpec > ;
#[doc = "Register `DTIMER` writer"] pub type W = crate :: W < DtimerSpec > ;
#[doc = "Field `DATATIME` reader - Data timeout period"] pub type DatatimeR = crate :: FieldReader < u32 > ;
#[doc = "Field `DATATIME` writer - Data timeout period"] pub type DatatimeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data timeout period"]
#[inline (always)] pub fn datatime (& self) -> DatatimeR { DatatimeR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data timeout period"]
#[inline (always)] pub fn datatime (& mut self) -> DatatimeW < '_ , DtimerSpec > { DatatimeW :: new (self , 0) } }
#[doc = "Bits 31:0 = DATATIME: Data timeout period\n\nYou can [`read`](crate::Reg::read) this register and get [`dtimer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dtimer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DtimerSpec ; impl crate :: RegisterSpec for DtimerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dtimer::R`](R) reader structure"] impl crate :: Readable for DtimerSpec { }
#[doc = "`write(|w| ..)` method takes [`dtimer::W`](W) writer structure"] impl crate :: Writable for DtimerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DTIMER to value 0"] impl crate :: Resettable for DtimerSpec { } }
#[doc = "DLEN (rw) register accessor: Bits 24:0 = DATALENGTH: Data length value\n\nYou can [`read`](crate::Reg::read) this register and get [`dlen::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dlen::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dlen`] module"]
#[doc (alias = "DLEN")] pub type Dlen = crate :: Reg < dlen :: DlenSpec > ;
#[doc = "Bits 24:0 = DATALENGTH: Data length value"] pub mod dlen {
#[doc = "Register `DLEN` reader"] pub type R = crate :: R < DlenSpec > ;
#[doc = "Register `DLEN` writer"] pub type W = crate :: W < DlenSpec > ;
#[doc = "Field `DATALENGTH` reader - Data length value"] pub type DatalengthR = crate :: FieldReader < u32 > ;
#[doc = "Field `DATALENGTH` writer - Data length value"] pub type DatalengthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 25 , u32 > ; impl R {
#[doc = "Bits 0:24 - Data length value"]
#[inline (always)] pub fn datalength (& self) -> DatalengthR { DatalengthR :: new (self . bits & 0x01ff_ffff) } } impl W {
#[doc = "Bits 0:24 - Data length value"]
#[inline (always)] pub fn datalength (& mut self) -> DatalengthW < '_ , DlenSpec > { DatalengthW :: new (self , 0) } }
#[doc = "Bits 24:0 = DATALENGTH: Data length value\n\nYou can [`read`](crate::Reg::read) this register and get [`dlen::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dlen::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DlenSpec ; impl crate :: RegisterSpec for DlenSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dlen::R`](R) reader structure"] impl crate :: Readable for DlenSpec { }
#[doc = "`write(|w| ..)` method takes [`dlen::W`](W) writer structure"] impl crate :: Writable for DlenSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DLEN to value 0"] impl crate :: Resettable for DlenSpec { } }
#[doc = "DCTRL (rw) register accessor: SDIO data control register (SDIO_DCTRL)\n\nYou can [`read`](crate::Reg::read) this register and get [`dctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dctrl`] module"]
#[doc (alias = "DCTRL")] pub type Dctrl = crate :: Reg < dctrl :: DctrlSpec > ;
#[doc = "SDIO data control register (SDIO_DCTRL)"] pub mod dctrl {
#[doc = "Register `DCTRL` reader"] pub type R = crate :: R < DctrlSpec > ;
#[doc = "Register `DCTRL` writer"] pub type W = crate :: W < DctrlSpec > ;
#[doc = "Field `DTEN` reader - DTEN"] pub type DtenR = crate :: BitReader ;
#[doc = "Field `DTEN` writer - DTEN"] pub type DtenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTDIR` reader - DTDIR"] pub type DtdirR = crate :: BitReader ;
#[doc = "Field `DTDIR` writer - DTDIR"] pub type DtdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTMODE` reader - DTMODE"] pub type DtmodeR = crate :: BitReader ;
#[doc = "Field `DTMODE` writer - DTMODE"] pub type DtmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAEN` reader - DMAEN"] pub type DmaenR = crate :: BitReader ;
#[doc = "Field `DMAEN` writer - DMAEN"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBLOCKSIZE` reader - DBLOCKSIZE"] pub type DblocksizeR = crate :: FieldReader ;
#[doc = "Field `DBLOCKSIZE` writer - DBLOCKSIZE"] pub type DblocksizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PWSTART` reader - PWSTART"] pub type PwstartR = crate :: BitReader ;
#[doc = "Field `PWSTART` writer - PWSTART"] pub type PwstartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWSTOP` reader - PWSTOP"] pub type PwstopR = crate :: BitReader ;
#[doc = "Field `PWSTOP` writer - PWSTOP"] pub type PwstopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RWMOD` reader - RWMOD"] pub type RwmodR = crate :: BitReader ;
#[doc = "Field `RWMOD` writer - RWMOD"] pub type RwmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDIOEN` reader - SDIOEN"] pub type SdioenR = crate :: BitReader ;
#[doc = "Field `SDIOEN` writer - SDIOEN"] pub type SdioenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DTEN"]
#[inline (always)] pub fn dten (& self) -> DtenR { DtenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DTDIR"]
#[inline (always)] pub fn dtdir (& self) -> DtdirR { DtdirR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - DTMODE"]
#[inline (always)] pub fn dtmode (& self) -> DtmodeR { DtmodeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - DMAEN"]
#[inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:7 - DBLOCKSIZE"]
#[inline (always)] pub fn dblocksize (& self) -> DblocksizeR { DblocksizeR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bit 8 - PWSTART"]
#[inline (always)] pub fn pwstart (& self) -> PwstartR { PwstartR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - PWSTOP"]
#[inline (always)] pub fn pwstop (& self) -> PwstopR { PwstopR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - RWMOD"]
#[inline (always)] pub fn rwmod (& self) -> RwmodR { RwmodR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - SDIOEN"]
#[inline (always)] pub fn sdioen (& self) -> SdioenR { SdioenR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DTEN"]
#[inline (always)] pub fn dten (& mut self) -> DtenW < '_ , DctrlSpec > { DtenW :: new (self , 0) }
#[doc = "Bit 1 - DTDIR"]
#[inline (always)] pub fn dtdir (& mut self) -> DtdirW < '_ , DctrlSpec > { DtdirW :: new (self , 1) }
#[doc = "Bit 2 - DTMODE"]
#[inline (always)] pub fn dtmode (& mut self) -> DtmodeW < '_ , DctrlSpec > { DtmodeW :: new (self , 2) }
#[doc = "Bit 3 - DMAEN"]
#[inline (always)] pub fn dmaen (& mut self) -> DmaenW < '_ , DctrlSpec > { DmaenW :: new (self , 3) }
#[doc = "Bits 4:7 - DBLOCKSIZE"]
#[inline (always)] pub fn dblocksize (& mut self) -> DblocksizeW < '_ , DctrlSpec > { DblocksizeW :: new (self , 4) }
#[doc = "Bit 8 - PWSTART"]
#[inline (always)] pub fn pwstart (& mut self) -> PwstartW < '_ , DctrlSpec > { PwstartW :: new (self , 8) }
#[doc = "Bit 9 - PWSTOP"]
#[inline (always)] pub fn pwstop (& mut self) -> PwstopW < '_ , DctrlSpec > { PwstopW :: new (self , 9) }
#[doc = "Bit 10 - RWMOD"]
#[inline (always)] pub fn rwmod (& mut self) -> RwmodW < '_ , DctrlSpec > { RwmodW :: new (self , 10) }
#[doc = "Bit 11 - SDIOEN"]
#[inline (always)] pub fn sdioen (& mut self) -> SdioenW < '_ , DctrlSpec > { SdioenW :: new (self , 11) } }
#[doc = "SDIO data control register (SDIO_DCTRL)\n\nYou can [`read`](crate::Reg::read) this register and get [`dctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DctrlSpec ; impl crate :: RegisterSpec for DctrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dctrl::R`](R) reader structure"] impl crate :: Readable for DctrlSpec { }
#[doc = "`write(|w| ..)` method takes [`dctrl::W`](W) writer structure"] impl crate :: Writable for DctrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCTRL to value 0"] impl crate :: Resettable for DctrlSpec { } }
#[doc = "DCOUNT (r) register accessor: Bits 24:0 = DATACOUNT: Data count value\n\nYou can [`read`](crate::Reg::read) this register and get [`dcount::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcount`] module"]
#[doc (alias = "DCOUNT")] pub type Dcount = crate :: Reg < dcount :: DcountSpec > ;
#[doc = "Bits 24:0 = DATACOUNT: Data count value"] pub mod dcount {
#[doc = "Register `DCOUNT` reader"] pub type R = crate :: R < DcountSpec > ;
#[doc = "Field `DATACOUNT` reader - Data count value"] pub type DatacountR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:24 - Data count value"]
#[inline (always)] pub fn datacount (& self) -> DatacountR { DatacountR :: new (self . bits & 0x01ff_ffff) } }
#[doc = "Bits 24:0 = DATACOUNT: Data count value\n\nYou can [`read`](crate::Reg::read) this register and get [`dcount::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcountSpec ; impl crate :: RegisterSpec for DcountSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcount::R`](R) reader structure"] impl crate :: Readable for DcountSpec { }
#[doc = "`reset()` method sets DCOUNT to value 0"] impl crate :: Resettable for DcountSpec { } }
#[doc = "STA (r) register accessor: SDIO status register (SDIO_STA)\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sta`] module"]
#[doc (alias = "STA")] pub type Sta = crate :: Reg < sta :: StaSpec > ;
#[doc = "SDIO status register (SDIO_STA)"] pub mod sta {
#[doc = "Register `STA` reader"] pub type R = crate :: R < StaSpec > ;
#[doc = "Field `CCRCFAIL` reader - CCRCFAIL"] pub type CcrcfailR = crate :: BitReader ;
#[doc = "Field `DCRCFAIL` reader - DCRCFAIL"] pub type DcrcfailR = crate :: BitReader ;
#[doc = "Field `CTIMEOUT` reader - CTIMEOUT"] pub type CtimeoutR = crate :: BitReader ;
#[doc = "Field `DTIMEOUT` reader - DTIMEOUT"] pub type DtimeoutR = crate :: BitReader ;
#[doc = "Field `TXUNDERR` reader - TXUNDERR"] pub type TxunderrR = crate :: BitReader ;
#[doc = "Field `RXOVERR` reader - RXOVERR"] pub type RxoverrR = crate :: BitReader ;
#[doc = "Field `CMDREND` reader - CMDREND"] pub type CmdrendR = crate :: BitReader ;
#[doc = "Field `CMDSENT` reader - CMDSENT"] pub type CmdsentR = crate :: BitReader ;
#[doc = "Field `DATAEND` reader - DATAEND"] pub type DataendR = crate :: BitReader ;
#[doc = "Field `STBITERR` reader - STBITERR"] pub type StbiterrR = crate :: BitReader ;
#[doc = "Field `DBCKEND` reader - DBCKEND"] pub type DbckendR = crate :: BitReader ;
#[doc = "Field `CMDACT` reader - CMDACT"] pub type CmdactR = crate :: BitReader ;
#[doc = "Field `TXACT` reader - TXACT"] pub type TxactR = crate :: BitReader ;
#[doc = "Field `RXACT` reader - RXACT"] pub type RxactR = crate :: BitReader ;
#[doc = "Field `TXFIFOHE` reader - TXFIFOHE"] pub type TxfifoheR = crate :: BitReader ;
#[doc = "Field `RXFIFOHF` reader - RXFIFOHF"] pub type RxfifohfR = crate :: BitReader ;
#[doc = "Field `TXFIFOF` reader - TXFIFOF"] pub type TxfifofR = crate :: BitReader ;
#[doc = "Field `RXFIFOF` reader - RXFIFOF"] pub type RxfifofR = crate :: BitReader ;
#[doc = "Field `TXFIFOE` reader - TXFIFOE"] pub type TxfifoeR = crate :: BitReader ;
#[doc = "Field `RXFIFOE` reader - RXFIFOE"] pub type RxfifoeR = crate :: BitReader ;
#[doc = "Field `TXDAVL` reader - TXDAVL"] pub type TxdavlR = crate :: BitReader ;
#[doc = "Field `RXDAVL` reader - RXDAVL"] pub type RxdavlR = crate :: BitReader ;
#[doc = "Field `SDIOIT` reader - SDIOIT"] pub type SdioitR = crate :: BitReader ;
#[doc = "Field `CEATAEND` reader - CEATAEND"] pub type CeataendR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - CCRCFAIL"]
#[inline (always)] pub fn ccrcfail (& self) -> CcrcfailR { CcrcfailR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DCRCFAIL"]
#[inline (always)] pub fn dcrcfail (& self) -> DcrcfailR { DcrcfailR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CTIMEOUT"]
#[inline (always)] pub fn ctimeout (& self) -> CtimeoutR { CtimeoutR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - DTIMEOUT"]
#[inline (always)] pub fn dtimeout (& self) -> DtimeoutR { DtimeoutR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - TXUNDERR"]
#[inline (always)] pub fn txunderr (& self) -> TxunderrR { TxunderrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXOVERR"]
#[inline (always)] pub fn rxoverr (& self) -> RxoverrR { RxoverrR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - CMDREND"]
#[inline (always)] pub fn cmdrend (& self) -> CmdrendR { CmdrendR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - CMDSENT"]
#[inline (always)] pub fn cmdsent (& self) -> CmdsentR { CmdsentR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - DATAEND"]
#[inline (always)] pub fn dataend (& self) -> DataendR { DataendR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - STBITERR"]
#[inline (always)] pub fn stbiterr (& self) -> StbiterrR { StbiterrR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - DBCKEND"]
#[inline (always)] pub fn dbckend (& self) -> DbckendR { DbckendR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - CMDACT"]
#[inline (always)] pub fn cmdact (& self) -> CmdactR { CmdactR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - TXACT"]
#[inline (always)] pub fn txact (& self) -> TxactR { TxactR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - RXACT"]
#[inline (always)] pub fn rxact (& self) -> RxactR { RxactR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - TXFIFOHE"]
#[inline (always)] pub fn txfifohe (& self) -> TxfifoheR { TxfifoheR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - RXFIFOHF"]
#[inline (always)] pub fn rxfifohf (& self) -> RxfifohfR { RxfifohfR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - TXFIFOF"]
#[inline (always)] pub fn txfifof (& self) -> TxfifofR { TxfifofR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - RXFIFOF"]
#[inline (always)] pub fn rxfifof (& self) -> RxfifofR { RxfifofR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TXFIFOE"]
#[inline (always)] pub fn txfifoe (& self) -> TxfifoeR { TxfifoeR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - RXFIFOE"]
#[inline (always)] pub fn rxfifoe (& self) -> RxfifoeR { RxfifoeR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - TXDAVL"]
#[inline (always)] pub fn txdavl (& self) -> TxdavlR { TxdavlR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - RXDAVL"]
#[inline (always)] pub fn rxdavl (& self) -> RxdavlR { RxdavlR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - SDIOIT"]
#[inline (always)] pub fn sdioit (& self) -> SdioitR { SdioitR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - CEATAEND"]
#[inline (always)] pub fn ceataend (& self) -> CeataendR { CeataendR :: new (((self . bits >> 23) & 1) != 0) } }
#[doc = "SDIO status register (SDIO_STA)\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StaSpec ; impl crate :: RegisterSpec for StaSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sta::R`](R) reader structure"] impl crate :: Readable for StaSpec { }
#[doc = "`reset()` method sets STA to value 0"] impl crate :: Resettable for StaSpec { } }
#[doc = "ICR (rw) register accessor: SDIO interrupt clear register (SDIO_ICR)\n\nYou can [`read`](crate::Reg::read) this register and get [`icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`] module"]
#[doc (alias = "ICR")] pub type Icr = crate :: Reg < icr :: IcrSpec > ;
#[doc = "SDIO interrupt clear register (SDIO_ICR)"] pub mod icr {
#[doc = "Register `ICR` reader"] pub type R = crate :: R < IcrSpec > ;
#[doc = "Register `ICR` writer"] pub type W = crate :: W < IcrSpec > ;
#[doc = "Field `CCRCFAILC` reader - CCRCFAILC"] pub type CcrcfailcR = crate :: BitReader ;
#[doc = "Field `CCRCFAILC` writer - CCRCFAILC"] pub type CcrcfailcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DCRCFAILC` reader - DCRCFAILC"] pub type DcrcfailcR = crate :: BitReader ;
#[doc = "Field `DCRCFAILC` writer - DCRCFAILC"] pub type DcrcfailcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTIMEOUTC` reader - CTIMEOUTC"] pub type CtimeoutcR = crate :: BitReader ;
#[doc = "Field `CTIMEOUTC` writer - CTIMEOUTC"] pub type CtimeoutcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTIMEOUTC` reader - DTIMEOUTC"] pub type DtimeoutcR = crate :: BitReader ;
#[doc = "Field `DTIMEOUTC` writer - DTIMEOUTC"] pub type DtimeoutcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXUNDERRC` reader - TXUNDERRC"] pub type TxunderrcR = crate :: BitReader ;
#[doc = "Field `TXUNDERRC` writer - TXUNDERRC"] pub type TxunderrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXOVERRC` reader - RXOVERRC"] pub type RxoverrcR = crate :: BitReader ;
#[doc = "Field `RXOVERRC` writer - RXOVERRC"] pub type RxoverrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMDRENDC` reader - CMDRENDC"] pub type CmdrendcR = crate :: BitReader ;
#[doc = "Field `CMDRENDC` writer - CMDRENDC"] pub type CmdrendcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMDSENTC` reader - CMDSENTC"] pub type CmdsentcR = crate :: BitReader ;
#[doc = "Field `CMDSENTC` writer - CMDSENTC"] pub type CmdsentcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DATAENDC` reader - DATAENDC"] pub type DataendcR = crate :: BitReader ;
#[doc = "Field `DATAENDC` writer - DATAENDC"] pub type DataendcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STBITERRC` reader - STBITERRC"] pub type StbiterrcR = crate :: BitReader ;
#[doc = "Field `STBITERRC` writer - STBITERRC"] pub type StbiterrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBCKENDC` reader - DBCKENDC"] pub type DbckendcR = crate :: BitReader ;
#[doc = "Field `DBCKENDC` writer - DBCKENDC"] pub type DbckendcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDIOITC` reader - SDIOITC"] pub type SdioitcR = crate :: BitReader ;
#[doc = "Field `SDIOITC` writer - SDIOITC"] pub type SdioitcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CEATAENDC` reader - CEATAENDC"] pub type CeataendcR = crate :: BitReader ;
#[doc = "Field `CEATAENDC` writer - CEATAENDC"] pub type CeataendcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CCRCFAILC"]
#[inline (always)] pub fn ccrcfailc (& self) -> CcrcfailcR { CcrcfailcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DCRCFAILC"]
#[inline (always)] pub fn dcrcfailc (& self) -> DcrcfailcR { DcrcfailcR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CTIMEOUTC"]
#[inline (always)] pub fn ctimeoutc (& self) -> CtimeoutcR { CtimeoutcR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - DTIMEOUTC"]
#[inline (always)] pub fn dtimeoutc (& self) -> DtimeoutcR { DtimeoutcR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - TXUNDERRC"]
#[inline (always)] pub fn txunderrc (& self) -> TxunderrcR { TxunderrcR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXOVERRC"]
#[inline (always)] pub fn rxoverrc (& self) -> RxoverrcR { RxoverrcR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - CMDRENDC"]
#[inline (always)] pub fn cmdrendc (& self) -> CmdrendcR { CmdrendcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - CMDSENTC"]
#[inline (always)] pub fn cmdsentc (& self) -> CmdsentcR { CmdsentcR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - DATAENDC"]
#[inline (always)] pub fn dataendc (& self) -> DataendcR { DataendcR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - STBITERRC"]
#[inline (always)] pub fn stbiterrc (& self) -> StbiterrcR { StbiterrcR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - DBCKENDC"]
#[inline (always)] pub fn dbckendc (& self) -> DbckendcR { DbckendcR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 22 - SDIOITC"]
#[inline (always)] pub fn sdioitc (& self) -> SdioitcR { SdioitcR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - CEATAENDC"]
#[inline (always)] pub fn ceataendc (& self) -> CeataendcR { CeataendcR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CCRCFAILC"]
#[inline (always)] pub fn ccrcfailc (& mut self) -> CcrcfailcW < '_ , IcrSpec > { CcrcfailcW :: new (self , 0) }
#[doc = "Bit 1 - DCRCFAILC"]
#[inline (always)] pub fn dcrcfailc (& mut self) -> DcrcfailcW < '_ , IcrSpec > { DcrcfailcW :: new (self , 1) }
#[doc = "Bit 2 - CTIMEOUTC"]
#[inline (always)] pub fn ctimeoutc (& mut self) -> CtimeoutcW < '_ , IcrSpec > { CtimeoutcW :: new (self , 2) }
#[doc = "Bit 3 - DTIMEOUTC"]
#[inline (always)] pub fn dtimeoutc (& mut self) -> DtimeoutcW < '_ , IcrSpec > { DtimeoutcW :: new (self , 3) }
#[doc = "Bit 4 - TXUNDERRC"]
#[inline (always)] pub fn txunderrc (& mut self) -> TxunderrcW < '_ , IcrSpec > { TxunderrcW :: new (self , 4) }
#[doc = "Bit 5 - RXOVERRC"]
#[inline (always)] pub fn rxoverrc (& mut self) -> RxoverrcW < '_ , IcrSpec > { RxoverrcW :: new (self , 5) }
#[doc = "Bit 6 - CMDRENDC"]
#[inline (always)] pub fn cmdrendc (& mut self) -> CmdrendcW < '_ , IcrSpec > { CmdrendcW :: new (self , 6) }
#[doc = "Bit 7 - CMDSENTC"]
#[inline (always)] pub fn cmdsentc (& mut self) -> CmdsentcW < '_ , IcrSpec > { CmdsentcW :: new (self , 7) }
#[doc = "Bit 8 - DATAENDC"]
#[inline (always)] pub fn dataendc (& mut self) -> DataendcW < '_ , IcrSpec > { DataendcW :: new (self , 8) }
#[doc = "Bit 9 - STBITERRC"]
#[inline (always)] pub fn stbiterrc (& mut self) -> StbiterrcW < '_ , IcrSpec > { StbiterrcW :: new (self , 9) }
#[doc = "Bit 10 - DBCKENDC"]
#[inline (always)] pub fn dbckendc (& mut self) -> DbckendcW < '_ , IcrSpec > { DbckendcW :: new (self , 10) }
#[doc = "Bit 22 - SDIOITC"]
#[inline (always)] pub fn sdioitc (& mut self) -> SdioitcW < '_ , IcrSpec > { SdioitcW :: new (self , 22) }
#[doc = "Bit 23 - CEATAENDC"]
#[inline (always)] pub fn ceataendc (& mut self) -> CeataendcW < '_ , IcrSpec > { CeataendcW :: new (self , 23) } }
#[doc = "SDIO interrupt clear register (SDIO_ICR)\n\nYou can [`read`](crate::Reg::read) this register and get [`icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`icr::R`](R) reader structure"] impl crate :: Readable for IcrSpec { }
#[doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"] impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ICR to value 0"] impl crate :: Resettable for IcrSpec { } }
#[doc = "MASK (rw) register accessor: SDIO mask register (SDIO_MASK)\n\nYou can [`read`](crate::Reg::read) this register and get [`mask::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mask`] module"]
#[doc (alias = "MASK")] pub type Mask = crate :: Reg < mask :: MaskSpec > ;
#[doc = "SDIO mask register (SDIO_MASK)"] pub mod mask {
#[doc = "Register `MASK` reader"] pub type R = crate :: R < MaskSpec > ;
#[doc = "Register `MASK` writer"] pub type W = crate :: W < MaskSpec > ;
#[doc = "Field `CCRCFAILIE` reader - CCRCFAILIE"] pub type CcrcfailieR = crate :: BitReader ;
#[doc = "Field `CCRCFAILIE` writer - CCRCFAILIE"] pub type CcrcfailieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DCRCFAILIE` reader - DCRCFAILIE"] pub type DcrcfailieR = crate :: BitReader ;
#[doc = "Field `DCRCFAILIE` writer - DCRCFAILIE"] pub type DcrcfailieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTIMEOUTIE` reader - CTIMEOUTIE"] pub type CtimeoutieR = crate :: BitReader ;
#[doc = "Field `CTIMEOUTIE` writer - CTIMEOUTIE"] pub type CtimeoutieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTIMEOUTIE` reader - DTIMEOUTIE"] pub type DtimeoutieR = crate :: BitReader ;
#[doc = "Field `DTIMEOUTIE` writer - DTIMEOUTIE"] pub type DtimeoutieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXUNDERRIE` reader - TXUNDERRIE"] pub type TxunderrieR = crate :: BitReader ;
#[doc = "Field `TXUNDERRIE` writer - TXUNDERRIE"] pub type TxunderrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXOVERRIE` reader - RXOVERRIE"] pub type RxoverrieR = crate :: BitReader ;
#[doc = "Field `RXOVERRIE` writer - RXOVERRIE"] pub type RxoverrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMDRENDIE` reader - CMDRENDIE"] pub type CmdrendieR = crate :: BitReader ;
#[doc = "Field `CMDRENDIE` writer - CMDRENDIE"] pub type CmdrendieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMDSENTIE` reader - CMDSENTIE"] pub type CmdsentieR = crate :: BitReader ;
#[doc = "Field `CMDSENTIE` writer - CMDSENTIE"] pub type CmdsentieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DATAENDIE` reader - DATAENDIE"] pub type DataendieR = crate :: BitReader ;
#[doc = "Field `DATAENDIE` writer - DATAENDIE"] pub type DataendieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STBITERRIE` reader - STBITERRIE"] pub type StbiterrieR = crate :: BitReader ;
#[doc = "Field `STBITERRIE` writer - STBITERRIE"] pub type StbiterrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBACKENDIE` reader - DBACKENDIE"] pub type DbackendieR = crate :: BitReader ;
#[doc = "Field `DBACKENDIE` writer - DBACKENDIE"] pub type DbackendieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMDACTIE` reader - CMDACTIE"] pub type CmdactieR = crate :: BitReader ;
#[doc = "Field `CMDACTIE` writer - CMDACTIE"] pub type CmdactieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXACTIE` reader - TXACTIE"] pub type TxactieR = crate :: BitReader ;
#[doc = "Field `TXACTIE` writer - TXACTIE"] pub type TxactieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXACTIE` reader - RXACTIE"] pub type RxactieR = crate :: BitReader ;
#[doc = "Field `RXACTIE` writer - RXACTIE"] pub type RxactieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFIFOHEIE` reader - TXFIFOHEIE"] pub type TxfifoheieR = crate :: BitReader ;
#[doc = "Field `TXFIFOHEIE` writer - TXFIFOHEIE"] pub type TxfifoheieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFIFOHFIE` reader - RXFIFOHFIE"] pub type RxfifohfieR = crate :: BitReader ;
#[doc = "Field `RXFIFOHFIE` writer - RXFIFOHFIE"] pub type RxfifohfieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFIFOFIE` reader - TXFIFOFIE"] pub type TxfifofieR = crate :: BitReader ;
#[doc = "Field `TXFIFOFIE` writer - TXFIFOFIE"] pub type TxfifofieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFIFOFIE` reader - RXFIFOFIE"] pub type RxfifofieR = crate :: BitReader ;
#[doc = "Field `RXFIFOFIE` writer - RXFIFOFIE"] pub type RxfifofieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFIFOEIE` reader - TXFIFOEIE"] pub type TxfifoeieR = crate :: BitReader ;
#[doc = "Field `TXFIFOEIE` writer - TXFIFOEIE"] pub type TxfifoeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFIFOEIE` reader - RXFIFOEIE"] pub type RxfifoeieR = crate :: BitReader ;
#[doc = "Field `RXFIFOEIE` writer - RXFIFOEIE"] pub type RxfifoeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXDAVLIE` reader - TXDAVLIE"] pub type TxdavlieR = crate :: BitReader ;
#[doc = "Field `TXDAVLIE` writer - TXDAVLIE"] pub type TxdavlieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXDAVLIE` reader - RXDAVLIE"] pub type RxdavlieR = crate :: BitReader ;
#[doc = "Field `RXDAVLIE` writer - RXDAVLIE"] pub type RxdavlieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDIOITIE` reader - SDIOITIE"] pub type SdioitieR = crate :: BitReader ;
#[doc = "Field `SDIOITIE` writer - SDIOITIE"] pub type SdioitieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CEATENDIE` reader - CEATENDIE"] pub type CeatendieR = crate :: BitReader ;
#[doc = "Field `CEATENDIE` writer - CEATENDIE"] pub type CeatendieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - CCRCFAILIE"]
#[inline (always)] pub fn ccrcfailie (& self) -> CcrcfailieR { CcrcfailieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DCRCFAILIE"]
#[inline (always)] pub fn dcrcfailie (& self) -> DcrcfailieR { DcrcfailieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - CTIMEOUTIE"]
#[inline (always)] pub fn ctimeoutie (& self) -> CtimeoutieR { CtimeoutieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - DTIMEOUTIE"]
#[inline (always)] pub fn dtimeoutie (& self) -> DtimeoutieR { DtimeoutieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - TXUNDERRIE"]
#[inline (always)] pub fn txunderrie (& self) -> TxunderrieR { TxunderrieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXOVERRIE"]
#[inline (always)] pub fn rxoverrie (& self) -> RxoverrieR { RxoverrieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - CMDRENDIE"]
#[inline (always)] pub fn cmdrendie (& self) -> CmdrendieR { CmdrendieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - CMDSENTIE"]
#[inline (always)] pub fn cmdsentie (& self) -> CmdsentieR { CmdsentieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - DATAENDIE"]
#[inline (always)] pub fn dataendie (& self) -> DataendieR { DataendieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - STBITERRIE"]
#[inline (always)] pub fn stbiterrie (& self) -> StbiterrieR { StbiterrieR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - DBACKENDIE"]
#[inline (always)] pub fn dbackendie (& self) -> DbackendieR { DbackendieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - CMDACTIE"]
#[inline (always)] pub fn cmdactie (& self) -> CmdactieR { CmdactieR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - TXACTIE"]
#[inline (always)] pub fn txactie (& self) -> TxactieR { TxactieR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - RXACTIE"]
#[inline (always)] pub fn rxactie (& self) -> RxactieR { RxactieR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - TXFIFOHEIE"]
#[inline (always)] pub fn txfifoheie (& self) -> TxfifoheieR { TxfifoheieR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - RXFIFOHFIE"]
#[inline (always)] pub fn rxfifohfie (& self) -> RxfifohfieR { RxfifohfieR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - TXFIFOFIE"]
#[inline (always)] pub fn txfifofie (& self) -> TxfifofieR { TxfifofieR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - RXFIFOFIE"]
#[inline (always)] pub fn rxfifofie (& self) -> RxfifofieR { RxfifofieR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TXFIFOEIE"]
#[inline (always)] pub fn txfifoeie (& self) -> TxfifoeieR { TxfifoeieR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - RXFIFOEIE"]
#[inline (always)] pub fn rxfifoeie (& self) -> RxfifoeieR { RxfifoeieR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - TXDAVLIE"]
#[inline (always)] pub fn txdavlie (& self) -> TxdavlieR { TxdavlieR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - RXDAVLIE"]
#[inline (always)] pub fn rxdavlie (& self) -> RxdavlieR { RxdavlieR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - SDIOITIE"]
#[inline (always)] pub fn sdioitie (& self) -> SdioitieR { SdioitieR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - CEATENDIE"]
#[inline (always)] pub fn ceatendie (& self) -> CeatendieR { CeatendieR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - CCRCFAILIE"]
#[inline (always)] pub fn ccrcfailie (& mut self) -> CcrcfailieW < '_ , MaskSpec > { CcrcfailieW :: new (self , 0) }
#[doc = "Bit 1 - DCRCFAILIE"]
#[inline (always)] pub fn dcrcfailie (& mut self) -> DcrcfailieW < '_ , MaskSpec > { DcrcfailieW :: new (self , 1) }
#[doc = "Bit 2 - CTIMEOUTIE"]
#[inline (always)] pub fn ctimeoutie (& mut self) -> CtimeoutieW < '_ , MaskSpec > { CtimeoutieW :: new (self , 2) }
#[doc = "Bit 3 - DTIMEOUTIE"]
#[inline (always)] pub fn dtimeoutie (& mut self) -> DtimeoutieW < '_ , MaskSpec > { DtimeoutieW :: new (self , 3) }
#[doc = "Bit 4 - TXUNDERRIE"]
#[inline (always)] pub fn txunderrie (& mut self) -> TxunderrieW < '_ , MaskSpec > { TxunderrieW :: new (self , 4) }
#[doc = "Bit 5 - RXOVERRIE"]
#[inline (always)] pub fn rxoverrie (& mut self) -> RxoverrieW < '_ , MaskSpec > { RxoverrieW :: new (self , 5) }
#[doc = "Bit 6 - CMDRENDIE"]
#[inline (always)] pub fn cmdrendie (& mut self) -> CmdrendieW < '_ , MaskSpec > { CmdrendieW :: new (self , 6) }
#[doc = "Bit 7 - CMDSENTIE"]
#[inline (always)] pub fn cmdsentie (& mut self) -> CmdsentieW < '_ , MaskSpec > { CmdsentieW :: new (self , 7) }
#[doc = "Bit 8 - DATAENDIE"]
#[inline (always)] pub fn dataendie (& mut self) -> DataendieW < '_ , MaskSpec > { DataendieW :: new (self , 8) }
#[doc = "Bit 9 - STBITERRIE"]
#[inline (always)] pub fn stbiterrie (& mut self) -> StbiterrieW < '_ , MaskSpec > { StbiterrieW :: new (self , 9) }
#[doc = "Bit 10 - DBACKENDIE"]
#[inline (always)] pub fn dbackendie (& mut self) -> DbackendieW < '_ , MaskSpec > { DbackendieW :: new (self , 10) }
#[doc = "Bit 11 - CMDACTIE"]
#[inline (always)] pub fn cmdactie (& mut self) -> CmdactieW < '_ , MaskSpec > { CmdactieW :: new (self , 11) }
#[doc = "Bit 12 - TXACTIE"]
#[inline (always)] pub fn txactie (& mut self) -> TxactieW < '_ , MaskSpec > { TxactieW :: new (self , 12) }
#[doc = "Bit 13 - RXACTIE"]
#[inline (always)] pub fn rxactie (& mut self) -> RxactieW < '_ , MaskSpec > { RxactieW :: new (self , 13) }
#[doc = "Bit 14 - TXFIFOHEIE"]
#[inline (always)] pub fn txfifoheie (& mut self) -> TxfifoheieW < '_ , MaskSpec > { TxfifoheieW :: new (self , 14) }
#[doc = "Bit 15 - RXFIFOHFIE"]
#[inline (always)] pub fn rxfifohfie (& mut self) -> RxfifohfieW < '_ , MaskSpec > { RxfifohfieW :: new (self , 15) }
#[doc = "Bit 16 - TXFIFOFIE"]
#[inline (always)] pub fn txfifofie (& mut self) -> TxfifofieW < '_ , MaskSpec > { TxfifofieW :: new (self , 16) }
#[doc = "Bit 17 - RXFIFOFIE"]
#[inline (always)] pub fn rxfifofie (& mut self) -> RxfifofieW < '_ , MaskSpec > { RxfifofieW :: new (self , 17) }
#[doc = "Bit 18 - TXFIFOEIE"]
#[inline (always)] pub fn txfifoeie (& mut self) -> TxfifoeieW < '_ , MaskSpec > { TxfifoeieW :: new (self , 18) }
#[doc = "Bit 19 - RXFIFOEIE"]
#[inline (always)] pub fn rxfifoeie (& mut self) -> RxfifoeieW < '_ , MaskSpec > { RxfifoeieW :: new (self , 19) }
#[doc = "Bit 20 - TXDAVLIE"]
#[inline (always)] pub fn txdavlie (& mut self) -> TxdavlieW < '_ , MaskSpec > { TxdavlieW :: new (self , 20) }
#[doc = "Bit 21 - RXDAVLIE"]
#[inline (always)] pub fn rxdavlie (& mut self) -> RxdavlieW < '_ , MaskSpec > { RxdavlieW :: new (self , 21) }
#[doc = "Bit 22 - SDIOITIE"]
#[inline (always)] pub fn sdioitie (& mut self) -> SdioitieW < '_ , MaskSpec > { SdioitieW :: new (self , 22) }
#[doc = "Bit 23 - CEATENDIE"]
#[inline (always)] pub fn ceatendie (& mut self) -> CeatendieW < '_ , MaskSpec > { CeatendieW :: new (self , 23) } }
#[doc = "SDIO mask register (SDIO_MASK)\n\nYou can [`read`](crate::Reg::read) this register and get [`mask::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MaskSpec ; impl crate :: RegisterSpec for MaskSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mask::R`](R) reader structure"] impl crate :: Readable for MaskSpec { }
#[doc = "`write(|w| ..)` method takes [`mask::W`](W) writer structure"] impl crate :: Writable for MaskSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MASK to value 0"] impl crate :: Resettable for MaskSpec { } }
#[doc = "FIFOCNT (r) register accessor: Bits 23:0 = FIFOCOUNT: Remaining number of words to be written to or read from the FIFO\n\nYou can [`read`](crate::Reg::read) this register and get [`fifocnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifocnt`] module"]
#[doc (alias = "FIFOCNT")] pub type Fifocnt = crate :: Reg < fifocnt :: FifocntSpec > ;
#[doc = "Bits 23:0 = FIFOCOUNT: Remaining number of words to be written to or read from the FIFO"] pub mod fifocnt {
#[doc = "Register `FIFOCNT` reader"] pub type R = crate :: R < FifocntSpec > ;
#[doc = "Field `FIF0COUNT` reader - FIF0COUNT"] pub type Fif0countR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:23 - FIF0COUNT"]
#[inline (always)] pub fn fif0count (& self) -> Fif0countR { Fif0countR :: new (self . bits & 0x00ff_ffff) } }
#[doc = "Bits 23:0 = FIFOCOUNT: Remaining number of words to be written to or read from the FIFO\n\nYou can [`read`](crate::Reg::read) this register and get [`fifocnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FifocntSpec ; impl crate :: RegisterSpec for FifocntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fifocnt::R`](R) reader structure"] impl crate :: Readable for FifocntSpec { }
#[doc = "`reset()` method sets FIFOCNT to value 0"] impl crate :: Resettable for FifocntSpec { } }
#[doc = "FIFO (rw) register accessor: bits 31:0 = FIFOData: Receive and transmit FIFO data\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"]
#[doc (alias = "FIFO")] pub type Fifo = crate :: Reg < fifo :: FifoSpec > ;
#[doc = "bits 31:0 = FIFOData: Receive and transmit FIFO data"] pub mod fifo {
#[doc = "Register `FIFO` reader"] pub type R = crate :: R < FifoSpec > ;
#[doc = "Register `FIFO` writer"] pub type W = crate :: W < FifoSpec > ;
#[doc = "Field `FIFOData` reader - FIFOData"] pub type FifodataR = crate :: FieldReader < u32 > ;
#[doc = "Field `FIFOData` writer - FIFOData"] pub type FifodataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - FIFOData"]
#[inline (always)] pub fn fifodata (& self) -> FifodataR { FifodataR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - FIFOData"]
#[inline (always)] pub fn fifodata (& mut self) -> FifodataW < '_ , FifoSpec > { FifodataW :: new (self , 0) } }
#[doc = "bits 31:0 = FIFOData: Receive and transmit FIFO data\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FifoSpec ; impl crate :: RegisterSpec for FifoSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fifo::R`](R) reader structure"] impl crate :: Readable for FifoSpec { }
#[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"] impl crate :: Writable for FifoSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIFO to value 0"] impl crate :: Resettable for FifoSpec { } } }
#[doc = "Real time clock"] pub type Rtc = crate :: Periph < rtc :: RegisterBlock , 0x4000_2800 > ; impl core :: fmt :: Debug for Rtc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rtc") . finish () } }
#[doc = "Real time clock"] pub mod rtc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { crh : Crh , crl : Crl , prlh : Prlh , prll : Prll , divh : Divh , divl : Divl , cnth : Cnth , cntl : Cntl , alrh : Alrh , alrl : Alrl , } impl RegisterBlock {
#[doc = "0x00 - RTC Control Register High"]
#[inline (always)] pub const fn crh (& self) -> & Crh { & self . crh }
#[doc = "0x04 - RTC Control Register Low"]
#[inline (always)] pub const fn crl (& self) -> & Crl { & self . crl }
#[doc = "0x08 - RTC Prescaler Load Register High"]
#[inline (always)] pub const fn prlh (& self) -> & Prlh { & self . prlh }
#[doc = "0x0c - RTC Prescaler Load Register Low"]
#[inline (always)] pub const fn prll (& self) -> & Prll { & self . prll }
#[doc = "0x10 - RTC Prescaler Divider Register High"]
#[inline (always)] pub const fn divh (& self) -> & Divh { & self . divh }
#[doc = "0x14 - RTC Prescaler Divider Register Low"]
#[inline (always)] pub const fn divl (& self) -> & Divl { & self . divl }
#[doc = "0x18 - RTC Counter Register High"]
#[inline (always)] pub const fn cnth (& self) -> & Cnth { & self . cnth }
#[doc = "0x1c - RTC Counter Register Low"]
#[inline (always)] pub const fn cntl (& self) -> & Cntl { & self . cntl }
#[doc = "0x20 - RTC Alarm Register High"]
#[inline (always)] pub const fn alrh (& self) -> & Alrh { & self . alrh }
#[doc = "0x24 - RTC Alarm Register Low"]
#[inline (always)] pub const fn alrl (& self) -> & Alrl { & self . alrl } }
#[doc = "CRH (rw) register accessor: RTC Control Register High\n\nYou can [`read`](crate::Reg::read) this register and get [`crh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crh`] module"]
#[doc (alias = "CRH")] pub type Crh = crate :: Reg < crh :: CrhSpec > ;
#[doc = "RTC Control Register High"] pub mod crh {
#[doc = "Register `CRH` reader"] pub type R = crate :: R < CrhSpec > ;
#[doc = "Register `CRH` writer"] pub type W = crate :: W < CrhSpec > ;
#[doc = "Field `SECIE` reader - Second interrupt Enable"] pub type SecieR = crate :: BitReader ;
#[doc = "Field `SECIE` writer - Second interrupt Enable"] pub type SecieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALRIE` reader - Alarm interrupt Enable"] pub type AlrieR = crate :: BitReader ;
#[doc = "Field `ALRIE` writer - Alarm interrupt Enable"] pub type AlrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OWIE` reader - Overflow interrupt Enable"] pub type OwieR = crate :: BitReader ;
#[doc = "Field `OWIE` writer - Overflow interrupt Enable"] pub type OwieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Second interrupt Enable"]
#[inline (always)] pub fn secie (& self) -> SecieR { SecieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Alarm interrupt Enable"]
#[inline (always)] pub fn alrie (& self) -> AlrieR { AlrieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Overflow interrupt Enable"]
#[inline (always)] pub fn owie (& self) -> OwieR { OwieR :: new (((self . bits >> 2) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Second interrupt Enable"]
#[inline (always)] pub fn secie (& mut self) -> SecieW < '_ , CrhSpec > { SecieW :: new (self , 0) }
#[doc = "Bit 1 - Alarm interrupt Enable"]
#[inline (always)] pub fn alrie (& mut self) -> AlrieW < '_ , CrhSpec > { AlrieW :: new (self , 1) }
#[doc = "Bit 2 - Overflow interrupt Enable"]
#[inline (always)] pub fn owie (& mut self) -> OwieW < '_ , CrhSpec > { OwieW :: new (self , 2) } }
#[doc = "RTC Control Register High\n\nYou can [`read`](crate::Reg::read) this register and get [`crh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrhSpec ; impl crate :: RegisterSpec for CrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crh::R`](R) reader structure"] impl crate :: Readable for CrhSpec { }
#[doc = "`write(|w| ..)` method takes [`crh::W`](W) writer structure"] impl crate :: Writable for CrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRH to value 0"] impl crate :: Resettable for CrhSpec { } }
#[doc = "CRL (rw) register accessor: RTC Control Register Low\n\nYou can [`read`](crate::Reg::read) this register and get [`crl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crl`] module"]
#[doc (alias = "CRL")] pub type Crl = crate :: Reg < crl :: CrlSpec > ;
#[doc = "RTC Control Register Low"] pub mod crl {
#[doc = "Register `CRL` reader"] pub type R = crate :: R < CrlSpec > ;
#[doc = "Register `CRL` writer"] pub type W = crate :: W < CrlSpec > ;
#[doc = "Field `SECF` reader - Second Flag"] pub type SecfR = crate :: BitReader ;
#[doc = "Field `SECF` writer - Second Flag"] pub type SecfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALRF` reader - Alarm Flag"] pub type AlrfR = crate :: BitReader ;
#[doc = "Field `ALRF` writer - Alarm Flag"] pub type AlrfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OWF` reader - Overflow Flag"] pub type OwfR = crate :: BitReader ;
#[doc = "Field `OWF` writer - Overflow Flag"] pub type OwfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RSF` reader - Registers Synchronized Flag"] pub type RsfR = crate :: BitReader ;
#[doc = "Field `RSF` writer - Registers Synchronized Flag"] pub type RsfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNF` reader - Configuration Flag"] pub type CnfR = crate :: BitReader ;
#[doc = "Field `CNF` writer - Configuration Flag"] pub type CnfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTOFF` reader - RTC operation OFF"] pub type RtoffR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Second Flag"]
#[inline (always)] pub fn secf (& self) -> SecfR { SecfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Alarm Flag"]
#[inline (always)] pub fn alrf (& self) -> AlrfR { AlrfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Overflow Flag"]
#[inline (always)] pub fn owf (& self) -> OwfR { OwfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Registers Synchronized Flag"]
#[inline (always)] pub fn rsf (& self) -> RsfR { RsfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Configuration Flag"]
#[inline (always)] pub fn cnf (& self) -> CnfR { CnfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RTC operation OFF"]
#[inline (always)] pub fn rtoff (& self) -> RtoffR { RtoffR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Second Flag"]
#[inline (always)] pub fn secf (& mut self) -> SecfW < '_ , CrlSpec > { SecfW :: new (self , 0) }
#[doc = "Bit 1 - Alarm Flag"]
#[inline (always)] pub fn alrf (& mut self) -> AlrfW < '_ , CrlSpec > { AlrfW :: new (self , 1) }
#[doc = "Bit 2 - Overflow Flag"]
#[inline (always)] pub fn owf (& mut self) -> OwfW < '_ , CrlSpec > { OwfW :: new (self , 2) }
#[doc = "Bit 3 - Registers Synchronized Flag"]
#[inline (always)] pub fn rsf (& mut self) -> RsfW < '_ , CrlSpec > { RsfW :: new (self , 3) }
#[doc = "Bit 4 - Configuration Flag"]
#[inline (always)] pub fn cnf (& mut self) -> CnfW < '_ , CrlSpec > { CnfW :: new (self , 4) } }
#[doc = "RTC Control Register Low\n\nYou can [`read`](crate::Reg::read) this register and get [`crl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrlSpec ; impl crate :: RegisterSpec for CrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crl::R`](R) reader structure"] impl crate :: Readable for CrlSpec { }
#[doc = "`write(|w| ..)` method takes [`crl::W`](W) writer structure"] impl crate :: Writable for CrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRL to value 0x20"] impl crate :: Resettable for CrlSpec { const RESET_VALUE : u32 = 0x20 ; } }
#[doc = "PRLH (w) register accessor: RTC Prescaler Load Register High\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prlh::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prlh`] module"]
#[doc (alias = "PRLH")] pub type Prlh = crate :: Reg < prlh :: PrlhSpec > ;
#[doc = "RTC Prescaler Load Register High"] pub mod prlh {
#[doc = "Register `PRLH` writer"] pub type W = crate :: W < PrlhSpec > ;
#[doc = "Field `PRLH` writer - RTC Prescaler Load Register High"] pub type PrlhW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl W {
#[doc = "Bits 0:3 - RTC Prescaler Load Register High"]
#[inline (always)] pub fn prlh (& mut self) -> PrlhW < '_ , PrlhSpec > { PrlhW :: new (self , 0) } }
#[doc = "RTC Prescaler Load Register High\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prlh::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrlhSpec ; impl crate :: RegisterSpec for PrlhSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`prlh::W`](W) writer structure"] impl crate :: Writable for PrlhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PRLH to value 0"] impl crate :: Resettable for PrlhSpec { } }
#[doc = "PRLL (w) register accessor: RTC Prescaler Load Register Low\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prll::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prll`] module"]
#[doc (alias = "PRLL")] pub type Prll = crate :: Reg < prll :: PrllSpec > ;
#[doc = "RTC Prescaler Load Register Low"] pub mod prll {
#[doc = "Register `PRLL` writer"] pub type W = crate :: W < PrllSpec > ;
#[doc = "Field `PRLL` writer - RTC Prescaler Divider Register Low"] pub type PrllW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - RTC Prescaler Divider Register Low"]
#[inline (always)] pub fn prll (& mut self) -> PrllW < '_ , PrllSpec > { PrllW :: new (self , 0) } }
#[doc = "RTC Prescaler Load Register Low\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prll::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrllSpec ; impl crate :: RegisterSpec for PrllSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`prll::W`](W) writer structure"] impl crate :: Writable for PrllSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PRLL to value 0x8000"] impl crate :: Resettable for PrllSpec { const RESET_VALUE : u32 = 0x8000 ; } }
#[doc = "DIVH (r) register accessor: RTC Prescaler Divider Register High\n\nYou can [`read`](crate::Reg::read) this register and get [`divh::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@divh`] module"]
#[doc (alias = "DIVH")] pub type Divh = crate :: Reg < divh :: DivhSpec > ;
#[doc = "RTC Prescaler Divider Register High"] pub mod divh {
#[doc = "Register `DIVH` reader"] pub type R = crate :: R < DivhSpec > ;
#[doc = "Field `DIVH` reader - RTC prescaler divider register high"] pub type DivhR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - RTC prescaler divider register high"]
#[inline (always)] pub fn divh (& self) -> DivhR { DivhR :: new ((self . bits & 0x0f) as u8) } }
#[doc = "RTC Prescaler Divider Register High\n\nYou can [`read`](crate::Reg::read) this register and get [`divh::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DivhSpec ; impl crate :: RegisterSpec for DivhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`divh::R`](R) reader structure"] impl crate :: Readable for DivhSpec { }
#[doc = "`reset()` method sets DIVH to value 0"] impl crate :: Resettable for DivhSpec { } }
#[doc = "DIVL (r) register accessor: RTC Prescaler Divider Register Low\n\nYou can [`read`](crate::Reg::read) this register and get [`divl::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@divl`] module"]
#[doc (alias = "DIVL")] pub type Divl = crate :: Reg < divl :: DivlSpec > ;
#[doc = "RTC Prescaler Divider Register Low"] pub mod divl {
#[doc = "Register `DIVL` reader"] pub type R = crate :: R < DivlSpec > ;
#[doc = "Field `DIVL` reader - RTC prescaler divider register Low"] pub type DivlR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - RTC prescaler divider register Low"]
#[inline (always)] pub fn divl (& self) -> DivlR { DivlR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "RTC Prescaler Divider Register Low\n\nYou can [`read`](crate::Reg::read) this register and get [`divl::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DivlSpec ; impl crate :: RegisterSpec for DivlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`divl::R`](R) reader structure"] impl crate :: Readable for DivlSpec { }
#[doc = "`reset()` method sets DIVL to value 0x8000"] impl crate :: Resettable for DivlSpec { const RESET_VALUE : u32 = 0x8000 ; } }
#[doc = "CNTH (rw) register accessor: RTC Counter Register High\n\nYou can [`read`](crate::Reg::read) this register and get [`cnth::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnth::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnth`] module"]
#[doc (alias = "CNTH")] pub type Cnth = crate :: Reg < cnth :: CnthSpec > ;
#[doc = "RTC Counter Register High"] pub mod cnth {
#[doc = "Register `CNTH` reader"] pub type R = crate :: R < CnthSpec > ;
#[doc = "Register `CNTH` writer"] pub type W = crate :: W < CnthSpec > ;
#[doc = "Field `CNTH` reader - RTC counter register high"] pub type CnthR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNTH` writer - RTC counter register high"] pub type CnthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RTC counter register high"]
#[inline (always)] pub fn cnth (& self) -> CnthR { CnthR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - RTC counter register high"]
#[inline (always)] pub fn cnth (& mut self) -> CnthW < '_ , CnthSpec > { CnthW :: new (self , 0) } }
#[doc = "RTC Counter Register High\n\nYou can [`read`](crate::Reg::read) this register and get [`cnth::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnth::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CnthSpec ; impl crate :: RegisterSpec for CnthSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnth::R`](R) reader structure"] impl crate :: Readable for CnthSpec { }
#[doc = "`write(|w| ..)` method takes [`cnth::W`](W) writer structure"] impl crate :: Writable for CnthSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNTH to value 0"] impl crate :: Resettable for CnthSpec { } }
#[doc = "CNTL (rw) register accessor: RTC Counter Register Low\n\nYou can [`read`](crate::Reg::read) this register and get [`cntl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cntl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cntl`] module"]
#[doc (alias = "CNTL")] pub type Cntl = crate :: Reg < cntl :: CntlSpec > ;
#[doc = "RTC Counter Register Low"] pub mod cntl {
#[doc = "Register `CNTL` reader"] pub type R = crate :: R < CntlSpec > ;
#[doc = "Register `CNTL` writer"] pub type W = crate :: W < CntlSpec > ;
#[doc = "Field `CNTL` reader - RTC counter register Low"] pub type CntlR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNTL` writer - RTC counter register Low"] pub type CntlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RTC counter register Low"]
#[inline (always)] pub fn cntl (& self) -> CntlR { CntlR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - RTC counter register Low"]
#[inline (always)] pub fn cntl (& mut self) -> CntlW < '_ , CntlSpec > { CntlW :: new (self , 0) } }
#[doc = "RTC Counter Register Low\n\nYou can [`read`](crate::Reg::read) this register and get [`cntl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cntl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntlSpec ; impl crate :: RegisterSpec for CntlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cntl::R`](R) reader structure"] impl crate :: Readable for CntlSpec { }
#[doc = "`write(|w| ..)` method takes [`cntl::W`](W) writer structure"] impl crate :: Writable for CntlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNTL to value 0"] impl crate :: Resettable for CntlSpec { } }
#[doc = "ALRH (w) register accessor: RTC Alarm Register High\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrh::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@alrh`] module"]
#[doc (alias = "ALRH")] pub type Alrh = crate :: Reg < alrh :: AlrhSpec > ;
#[doc = "RTC Alarm Register High"] pub mod alrh {
#[doc = "Register `ALRH` writer"] pub type W = crate :: W < AlrhSpec > ;
#[doc = "Field `ALRH` writer - RTC alarm register high"] pub type AlrhW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - RTC alarm register high"]
#[inline (always)] pub fn alrh (& mut self) -> AlrhW < '_ , AlrhSpec > { AlrhW :: new (self , 0) } }
#[doc = "RTC Alarm Register High\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrh::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AlrhSpec ; impl crate :: RegisterSpec for AlrhSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`alrh::W`](W) writer structure"] impl crate :: Writable for AlrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ALRH to value 0xffff"] impl crate :: Resettable for AlrhSpec { const RESET_VALUE : u32 = 0xffff ; } }
#[doc = "ALRL (w) register accessor: RTC Alarm Register Low\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrl::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@alrl`] module"]
#[doc (alias = "ALRL")] pub type Alrl = crate :: Reg < alrl :: AlrlSpec > ;
#[doc = "RTC Alarm Register Low"] pub mod alrl {
#[doc = "Register `ALRL` writer"] pub type W = crate :: W < AlrlSpec > ;
#[doc = "Field `ALRL` writer - RTC alarm register low"] pub type AlrlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - RTC alarm register low"]
#[inline (always)] pub fn alrl (& mut self) -> AlrlW < '_ , AlrlSpec > { AlrlW :: new (self , 0) } }
#[doc = "RTC Alarm Register Low\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrl::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AlrlSpec ; impl crate :: RegisterSpec for AlrlSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`alrl::W`](W) writer structure"] impl crate :: Writable for AlrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ALRL to value 0xffff"] impl crate :: Resettable for AlrlSpec { const RESET_VALUE : u32 = 0xffff ; } } }
#[doc = "Backup registers"] pub type Bkp = crate :: Periph < bkp :: RegisterBlock , 0x4000_6c00 > ; impl core :: fmt :: Debug for Bkp { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Bkp") . finish () } }
#[doc = "Backup registers"] pub mod bkp {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { dr1 : Dr1 , dr2 : Dr2 , dr3 : Dr3 , dr4 : Dr4 , dr5 : Dr5 , dr6 : Dr6 , dr7 : Dr7 , dr8 : Dr8 , dr9 : Dr9 , dr10 : Dr10 , rtccr : Rtccr , cr : Cr , csr : Csr , _reserved13 : [u8 ; 0x08] , dr11 : Dr11 , dr12 : Dr12 , dr13 : Dr13 , dr14 : Dr14 , dr15 : Dr15 , dr16 : Dr16 , dr17 : Dr17 , dr18 : Dr18 , dr19 : Dr19 , dr20 : Dr20 , dr21 : Dr21 , dr22 : Dr22 , dr23 : Dr23 , dr24 : Dr24 , dr25 : Dr25 , dr26 : Dr26 , dr27 : Dr27 , dr28 : Dr28 , dr29 : Dr29 , dr30 : Dr30 , dr31 : Dr31 , dr32 : Dr32 , dr33 : Dr33 , dr34 : Dr34 , dr35 : Dr35 , dr36 : Dr36 , dr37 : Dr37 , dr38 : Dr38 , dr39 : Dr39 , dr40 : Dr40 , dr41 : Dr41 , dr42 : Dr42 , } impl RegisterBlock {
#[doc = "0x00 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr1 (& self) -> & Dr1 { & self . dr1 }
#[doc = "0x04 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr2 (& self) -> & Dr2 { & self . dr2 }
#[doc = "0x08 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr3 (& self) -> & Dr3 { & self . dr3 }
#[doc = "0x0c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr4 (& self) -> & Dr4 { & self . dr4 }
#[doc = "0x10 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr5 (& self) -> & Dr5 { & self . dr5 }
#[doc = "0x14 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr6 (& self) -> & Dr6 { & self . dr6 }
#[doc = "0x18 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr7 (& self) -> & Dr7 { & self . dr7 }
#[doc = "0x1c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr8 (& self) -> & Dr8 { & self . dr8 }
#[doc = "0x20 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr9 (& self) -> & Dr9 { & self . dr9 }
#[doc = "0x24 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr10 (& self) -> & Dr10 { & self . dr10 }
#[doc = "0x28 - RTC clock calibration register (BKP_RTCCR)"]
#[inline (always)] pub const fn rtccr (& self) -> & Rtccr { & self . rtccr }
#[doc = "0x2c - Backup control register (BKP_CR)"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x30 - BKP_CSR control/status register (BKP_CSR)"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr }
#[doc = "0x3c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr11 (& self) -> & Dr11 { & self . dr11 }
#[doc = "0x40 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr12 (& self) -> & Dr12 { & self . dr12 }
#[doc = "0x44 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr13 (& self) -> & Dr13 { & self . dr13 }
#[doc = "0x48 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr14 (& self) -> & Dr14 { & self . dr14 }
#[doc = "0x4c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr15 (& self) -> & Dr15 { & self . dr15 }
#[doc = "0x50 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr16 (& self) -> & Dr16 { & self . dr16 }
#[doc = "0x54 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr17 (& self) -> & Dr17 { & self . dr17 }
#[doc = "0x58 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr18 (& self) -> & Dr18 { & self . dr18 }
#[doc = "0x5c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr19 (& self) -> & Dr19 { & self . dr19 }
#[doc = "0x60 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr20 (& self) -> & Dr20 { & self . dr20 }
#[doc = "0x64 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr21 (& self) -> & Dr21 { & self . dr21 }
#[doc = "0x68 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr22 (& self) -> & Dr22 { & self . dr22 }
#[doc = "0x6c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr23 (& self) -> & Dr23 { & self . dr23 }
#[doc = "0x70 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr24 (& self) -> & Dr24 { & self . dr24 }
#[doc = "0x74 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr25 (& self) -> & Dr25 { & self . dr25 }
#[doc = "0x78 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr26 (& self) -> & Dr26 { & self . dr26 }
#[doc = "0x7c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr27 (& self) -> & Dr27 { & self . dr27 }
#[doc = "0x80 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr28 (& self) -> & Dr28 { & self . dr28 }
#[doc = "0x84 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr29 (& self) -> & Dr29 { & self . dr29 }
#[doc = "0x88 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr30 (& self) -> & Dr30 { & self . dr30 }
#[doc = "0x8c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr31 (& self) -> & Dr31 { & self . dr31 }
#[doc = "0x90 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr32 (& self) -> & Dr32 { & self . dr32 }
#[doc = "0x94 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr33 (& self) -> & Dr33 { & self . dr33 }
#[doc = "0x98 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr34 (& self) -> & Dr34 { & self . dr34 }
#[doc = "0x9c - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr35 (& self) -> & Dr35 { & self . dr35 }
#[doc = "0xa0 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr36 (& self) -> & Dr36 { & self . dr36 }
#[doc = "0xa4 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr37 (& self) -> & Dr37 { & self . dr37 }
#[doc = "0xa8 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr38 (& self) -> & Dr38 { & self . dr38 }
#[doc = "0xac - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr39 (& self) -> & Dr39 { & self . dr39 }
#[doc = "0xb0 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr40 (& self) -> & Dr40 { & self . dr40 }
#[doc = "0xb4 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr41 (& self) -> & Dr41 { & self . dr41 }
#[doc = "0xb8 - Backup data register (BKP_DR)"]
#[inline (always)] pub const fn dr42 (& self) -> & Dr42 { & self . dr42 } }
#[doc = "DR1 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr1`] module"]
#[doc (alias = "DR1")] pub type Dr1 = crate :: Reg < dr1 :: Dr1Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr1 {
#[doc = "Register `DR1` reader"] pub type R = crate :: R < Dr1Spec > ;
#[doc = "Register `DR1` writer"] pub type W = crate :: W < Dr1Spec > ;
#[doc = "Field `D1` reader - Backup data"] pub type D1R = crate :: FieldReader < u16 > ;
#[doc = "Field `D1` writer - Backup data"] pub type D1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d1 (& self) -> D1R { D1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d1 (& mut self) -> D1W < '_ , Dr1Spec > { D1W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr1Spec ; impl crate :: RegisterSpec for Dr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr1::R`](R) reader structure"] impl crate :: Readable for Dr1Spec { }
#[doc = "`write(|w| ..)` method takes [`dr1::W`](W) writer structure"] impl crate :: Writable for Dr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR1 to value 0"] impl crate :: Resettable for Dr1Spec { } }
#[doc = "DR2 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr2`] module"]
#[doc (alias = "DR2")] pub type Dr2 = crate :: Reg < dr2 :: Dr2Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr2 {
#[doc = "Register `DR2` reader"] pub type R = crate :: R < Dr2Spec > ;
#[doc = "Register `DR2` writer"] pub type W = crate :: W < Dr2Spec > ;
#[doc = "Field `D2` reader - Backup data"] pub type D2R = crate :: FieldReader < u16 > ;
#[doc = "Field `D2` writer - Backup data"] pub type D2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d2 (& self) -> D2R { D2R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d2 (& mut self) -> D2W < '_ , Dr2Spec > { D2W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr2Spec ; impl crate :: RegisterSpec for Dr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr2::R`](R) reader structure"] impl crate :: Readable for Dr2Spec { }
#[doc = "`write(|w| ..)` method takes [`dr2::W`](W) writer structure"] impl crate :: Writable for Dr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR2 to value 0"] impl crate :: Resettable for Dr2Spec { } }
#[doc = "DR3 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr3`] module"]
#[doc (alias = "DR3")] pub type Dr3 = crate :: Reg < dr3 :: Dr3Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr3 {
#[doc = "Register `DR3` reader"] pub type R = crate :: R < Dr3Spec > ;
#[doc = "Register `DR3` writer"] pub type W = crate :: W < Dr3Spec > ;
#[doc = "Field `D3` reader - Backup data"] pub type D3R = crate :: FieldReader < u16 > ;
#[doc = "Field `D3` writer - Backup data"] pub type D3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d3 (& self) -> D3R { D3R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d3 (& mut self) -> D3W < '_ , Dr3Spec > { D3W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr3Spec ; impl crate :: RegisterSpec for Dr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr3::R`](R) reader structure"] impl crate :: Readable for Dr3Spec { }
#[doc = "`write(|w| ..)` method takes [`dr3::W`](W) writer structure"] impl crate :: Writable for Dr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR3 to value 0"] impl crate :: Resettable for Dr3Spec { } }
#[doc = "DR4 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr4`] module"]
#[doc (alias = "DR4")] pub type Dr4 = crate :: Reg < dr4 :: Dr4Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr4 {
#[doc = "Register `DR4` reader"] pub type R = crate :: R < Dr4Spec > ;
#[doc = "Register `DR4` writer"] pub type W = crate :: W < Dr4Spec > ;
#[doc = "Field `D4` reader - Backup data"] pub type D4R = crate :: FieldReader < u16 > ;
#[doc = "Field `D4` writer - Backup data"] pub type D4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d4 (& self) -> D4R { D4R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d4 (& mut self) -> D4W < '_ , Dr4Spec > { D4W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr4Spec ; impl crate :: RegisterSpec for Dr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr4::R`](R) reader structure"] impl crate :: Readable for Dr4Spec { }
#[doc = "`write(|w| ..)` method takes [`dr4::W`](W) writer structure"] impl crate :: Writable for Dr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR4 to value 0"] impl crate :: Resettable for Dr4Spec { } }
#[doc = "DR5 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr5`] module"]
#[doc (alias = "DR5")] pub type Dr5 = crate :: Reg < dr5 :: Dr5Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr5 {
#[doc = "Register `DR5` reader"] pub type R = crate :: R < Dr5Spec > ;
#[doc = "Register `DR5` writer"] pub type W = crate :: W < Dr5Spec > ;
#[doc = "Field `D5` reader - Backup data"] pub type D5R = crate :: FieldReader < u16 > ;
#[doc = "Field `D5` writer - Backup data"] pub type D5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d5 (& self) -> D5R { D5R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d5 (& mut self) -> D5W < '_ , Dr5Spec > { D5W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr5Spec ; impl crate :: RegisterSpec for Dr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr5::R`](R) reader structure"] impl crate :: Readable for Dr5Spec { }
#[doc = "`write(|w| ..)` method takes [`dr5::W`](W) writer structure"] impl crate :: Writable for Dr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR5 to value 0"] impl crate :: Resettable for Dr5Spec { } }
#[doc = "DR6 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr6`] module"]
#[doc (alias = "DR6")] pub type Dr6 = crate :: Reg < dr6 :: Dr6Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr6 {
#[doc = "Register `DR6` reader"] pub type R = crate :: R < Dr6Spec > ;
#[doc = "Register `DR6` writer"] pub type W = crate :: W < Dr6Spec > ;
#[doc = "Field `D6` reader - Backup data"] pub type D6R = crate :: FieldReader < u16 > ;
#[doc = "Field `D6` writer - Backup data"] pub type D6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d6 (& self) -> D6R { D6R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d6 (& mut self) -> D6W < '_ , Dr6Spec > { D6W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr6Spec ; impl crate :: RegisterSpec for Dr6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr6::R`](R) reader structure"] impl crate :: Readable for Dr6Spec { }
#[doc = "`write(|w| ..)` method takes [`dr6::W`](W) writer structure"] impl crate :: Writable for Dr6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR6 to value 0"] impl crate :: Resettable for Dr6Spec { } }
#[doc = "DR7 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr7`] module"]
#[doc (alias = "DR7")] pub type Dr7 = crate :: Reg < dr7 :: Dr7Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr7 {
#[doc = "Register `DR7` reader"] pub type R = crate :: R < Dr7Spec > ;
#[doc = "Register `DR7` writer"] pub type W = crate :: W < Dr7Spec > ;
#[doc = "Field `D7` reader - Backup data"] pub type D7R = crate :: FieldReader < u16 > ;
#[doc = "Field `D7` writer - Backup data"] pub type D7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d7 (& self) -> D7R { D7R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d7 (& mut self) -> D7W < '_ , Dr7Spec > { D7W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr7Spec ; impl crate :: RegisterSpec for Dr7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr7::R`](R) reader structure"] impl crate :: Readable for Dr7Spec { }
#[doc = "`write(|w| ..)` method takes [`dr7::W`](W) writer structure"] impl crate :: Writable for Dr7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR7 to value 0"] impl crate :: Resettable for Dr7Spec { } }
#[doc = "DR8 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr8::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr8::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr8`] module"]
#[doc (alias = "DR8")] pub type Dr8 = crate :: Reg < dr8 :: Dr8Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr8 {
#[doc = "Register `DR8` reader"] pub type R = crate :: R < Dr8Spec > ;
#[doc = "Register `DR8` writer"] pub type W = crate :: W < Dr8Spec > ;
#[doc = "Field `D8` reader - Backup data"] pub type D8R = crate :: FieldReader < u16 > ;
#[doc = "Field `D8` writer - Backup data"] pub type D8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d8 (& self) -> D8R { D8R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d8 (& mut self) -> D8W < '_ , Dr8Spec > { D8W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr8::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr8::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr8Spec ; impl crate :: RegisterSpec for Dr8Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr8::R`](R) reader structure"] impl crate :: Readable for Dr8Spec { }
#[doc = "`write(|w| ..)` method takes [`dr8::W`](W) writer structure"] impl crate :: Writable for Dr8Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR8 to value 0"] impl crate :: Resettable for Dr8Spec { } }
#[doc = "DR9 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr9::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr9::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr9`] module"]
#[doc (alias = "DR9")] pub type Dr9 = crate :: Reg < dr9 :: Dr9Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr9 {
#[doc = "Register `DR9` reader"] pub type R = crate :: R < Dr9Spec > ;
#[doc = "Register `DR9` writer"] pub type W = crate :: W < Dr9Spec > ;
#[doc = "Field `D9` reader - Backup data"] pub type D9R = crate :: FieldReader < u16 > ;
#[doc = "Field `D9` writer - Backup data"] pub type D9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d9 (& self) -> D9R { D9R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d9 (& mut self) -> D9W < '_ , Dr9Spec > { D9W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr9::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr9::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr9Spec ; impl crate :: RegisterSpec for Dr9Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr9::R`](R) reader structure"] impl crate :: Readable for Dr9Spec { }
#[doc = "`write(|w| ..)` method takes [`dr9::W`](W) writer structure"] impl crate :: Writable for Dr9Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR9 to value 0"] impl crate :: Resettable for Dr9Spec { } }
#[doc = "DR10 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr10::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr10::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr10`] module"]
#[doc (alias = "DR10")] pub type Dr10 = crate :: Reg < dr10 :: Dr10Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr10 {
#[doc = "Register `DR10` reader"] pub type R = crate :: R < Dr10Spec > ;
#[doc = "Register `DR10` writer"] pub type W = crate :: W < Dr10Spec > ;
#[doc = "Field `D10` reader - Backup data"] pub type D10R = crate :: FieldReader < u16 > ;
#[doc = "Field `D10` writer - Backup data"] pub type D10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d10 (& self) -> D10R { D10R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d10 (& mut self) -> D10W < '_ , Dr10Spec > { D10W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr10::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr10::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr10Spec ; impl crate :: RegisterSpec for Dr10Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr10::R`](R) reader structure"] impl crate :: Readable for Dr10Spec { }
#[doc = "`write(|w| ..)` method takes [`dr10::W`](W) writer structure"] impl crate :: Writable for Dr10Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR10 to value 0"] impl crate :: Resettable for Dr10Spec { } }
#[doc = "DR11 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr11::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr11::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr11`] module"]
#[doc (alias = "DR11")] pub type Dr11 = crate :: Reg < dr11 :: Dr11Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr11 {
#[doc = "Register `DR11` reader"] pub type R = crate :: R < Dr11Spec > ;
#[doc = "Register `DR11` writer"] pub type W = crate :: W < Dr11Spec > ;
#[doc = "Field `DR11` reader - Backup data"] pub type Dr11R = crate :: FieldReader < u16 > ;
#[doc = "Field `DR11` writer - Backup data"] pub type Dr11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn dr11 (& self) -> Dr11R { Dr11R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn dr11 (& mut self) -> Dr11W < '_ , Dr11Spec > { Dr11W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr11::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr11::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr11Spec ; impl crate :: RegisterSpec for Dr11Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr11::R`](R) reader structure"] impl crate :: Readable for Dr11Spec { }
#[doc = "`write(|w| ..)` method takes [`dr11::W`](W) writer structure"] impl crate :: Writable for Dr11Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR11 to value 0"] impl crate :: Resettable for Dr11Spec { } }
#[doc = "DR12 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr12::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr12::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr12`] module"]
#[doc (alias = "DR12")] pub type Dr12 = crate :: Reg < dr12 :: Dr12Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr12 {
#[doc = "Register `DR12` reader"] pub type R = crate :: R < Dr12Spec > ;
#[doc = "Register `DR12` writer"] pub type W = crate :: W < Dr12Spec > ;
#[doc = "Field `DR12` reader - Backup data"] pub type Dr12R = crate :: FieldReader < u16 > ;
#[doc = "Field `DR12` writer - Backup data"] pub type Dr12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn dr12 (& self) -> Dr12R { Dr12R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn dr12 (& mut self) -> Dr12W < '_ , Dr12Spec > { Dr12W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr12::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr12::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr12Spec ; impl crate :: RegisterSpec for Dr12Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr12::R`](R) reader structure"] impl crate :: Readable for Dr12Spec { }
#[doc = "`write(|w| ..)` method takes [`dr12::W`](W) writer structure"] impl crate :: Writable for Dr12Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR12 to value 0"] impl crate :: Resettable for Dr12Spec { } }
#[doc = "DR13 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr13::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr13::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr13`] module"]
#[doc (alias = "DR13")] pub type Dr13 = crate :: Reg < dr13 :: Dr13Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr13 {
#[doc = "Register `DR13` reader"] pub type R = crate :: R < Dr13Spec > ;
#[doc = "Register `DR13` writer"] pub type W = crate :: W < Dr13Spec > ;
#[doc = "Field `DR13` reader - Backup data"] pub type Dr13R = crate :: FieldReader < u16 > ;
#[doc = "Field `DR13` writer - Backup data"] pub type Dr13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn dr13 (& self) -> Dr13R { Dr13R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn dr13 (& mut self) -> Dr13W < '_ , Dr13Spec > { Dr13W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr13::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr13::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr13Spec ; impl crate :: RegisterSpec for Dr13Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr13::R`](R) reader structure"] impl crate :: Readable for Dr13Spec { }
#[doc = "`write(|w| ..)` method takes [`dr13::W`](W) writer structure"] impl crate :: Writable for Dr13Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR13 to value 0"] impl crate :: Resettable for Dr13Spec { } }
#[doc = "DR14 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr14::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr14::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr14`] module"]
#[doc (alias = "DR14")] pub type Dr14 = crate :: Reg < dr14 :: Dr14Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr14 {
#[doc = "Register `DR14` reader"] pub type R = crate :: R < Dr14Spec > ;
#[doc = "Register `DR14` writer"] pub type W = crate :: W < Dr14Spec > ;
#[doc = "Field `D14` reader - Backup data"] pub type D14R = crate :: FieldReader < u16 > ;
#[doc = "Field `D14` writer - Backup data"] pub type D14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d14 (& self) -> D14R { D14R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d14 (& mut self) -> D14W < '_ , Dr14Spec > { D14W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr14::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr14::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr14Spec ; impl crate :: RegisterSpec for Dr14Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr14::R`](R) reader structure"] impl crate :: Readable for Dr14Spec { }
#[doc = "`write(|w| ..)` method takes [`dr14::W`](W) writer structure"] impl crate :: Writable for Dr14Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR14 to value 0"] impl crate :: Resettable for Dr14Spec { } }
#[doc = "DR15 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr15::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr15::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr15`] module"]
#[doc (alias = "DR15")] pub type Dr15 = crate :: Reg < dr15 :: Dr15Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr15 {
#[doc = "Register `DR15` reader"] pub type R = crate :: R < Dr15Spec > ;
#[doc = "Register `DR15` writer"] pub type W = crate :: W < Dr15Spec > ;
#[doc = "Field `D15` reader - Backup data"] pub type D15R = crate :: FieldReader < u16 > ;
#[doc = "Field `D15` writer - Backup data"] pub type D15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d15 (& self) -> D15R { D15R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d15 (& mut self) -> D15W < '_ , Dr15Spec > { D15W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr15::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr15::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr15Spec ; impl crate :: RegisterSpec for Dr15Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr15::R`](R) reader structure"] impl crate :: Readable for Dr15Spec { }
#[doc = "`write(|w| ..)` method takes [`dr15::W`](W) writer structure"] impl crate :: Writable for Dr15Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR15 to value 0"] impl crate :: Resettable for Dr15Spec { } }
#[doc = "DR16 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr16::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr16::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr16`] module"]
#[doc (alias = "DR16")] pub type Dr16 = crate :: Reg < dr16 :: Dr16Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr16 {
#[doc = "Register `DR16` reader"] pub type R = crate :: R < Dr16Spec > ;
#[doc = "Register `DR16` writer"] pub type W = crate :: W < Dr16Spec > ;
#[doc = "Field `D16` reader - Backup data"] pub type D16R = crate :: FieldReader < u16 > ;
#[doc = "Field `D16` writer - Backup data"] pub type D16W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d16 (& self) -> D16R { D16R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d16 (& mut self) -> D16W < '_ , Dr16Spec > { D16W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr16::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr16::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr16Spec ; impl crate :: RegisterSpec for Dr16Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr16::R`](R) reader structure"] impl crate :: Readable for Dr16Spec { }
#[doc = "`write(|w| ..)` method takes [`dr16::W`](W) writer structure"] impl crate :: Writable for Dr16Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR16 to value 0"] impl crate :: Resettable for Dr16Spec { } }
#[doc = "DR17 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr17::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr17::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr17`] module"]
#[doc (alias = "DR17")] pub type Dr17 = crate :: Reg < dr17 :: Dr17Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr17 {
#[doc = "Register `DR17` reader"] pub type R = crate :: R < Dr17Spec > ;
#[doc = "Register `DR17` writer"] pub type W = crate :: W < Dr17Spec > ;
#[doc = "Field `D17` reader - Backup data"] pub type D17R = crate :: FieldReader < u16 > ;
#[doc = "Field `D17` writer - Backup data"] pub type D17W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d17 (& self) -> D17R { D17R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d17 (& mut self) -> D17W < '_ , Dr17Spec > { D17W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr17::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr17::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr17Spec ; impl crate :: RegisterSpec for Dr17Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr17::R`](R) reader structure"] impl crate :: Readable for Dr17Spec { }
#[doc = "`write(|w| ..)` method takes [`dr17::W`](W) writer structure"] impl crate :: Writable for Dr17Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR17 to value 0"] impl crate :: Resettable for Dr17Spec { } }
#[doc = "DR18 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr18::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr18::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr18`] module"]
#[doc (alias = "DR18")] pub type Dr18 = crate :: Reg < dr18 :: Dr18Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr18 {
#[doc = "Register `DR18` reader"] pub type R = crate :: R < Dr18Spec > ;
#[doc = "Register `DR18` writer"] pub type W = crate :: W < Dr18Spec > ;
#[doc = "Field `D18` reader - Backup data"] pub type D18R = crate :: FieldReader < u16 > ;
#[doc = "Field `D18` writer - Backup data"] pub type D18W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d18 (& self) -> D18R { D18R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d18 (& mut self) -> D18W < '_ , Dr18Spec > { D18W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr18::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr18::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr18Spec ; impl crate :: RegisterSpec for Dr18Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr18::R`](R) reader structure"] impl crate :: Readable for Dr18Spec { }
#[doc = "`write(|w| ..)` method takes [`dr18::W`](W) writer structure"] impl crate :: Writable for Dr18Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR18 to value 0"] impl crate :: Resettable for Dr18Spec { } }
#[doc = "DR19 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr19::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr19::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr19`] module"]
#[doc (alias = "DR19")] pub type Dr19 = crate :: Reg < dr19 :: Dr19Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr19 {
#[doc = "Register `DR19` reader"] pub type R = crate :: R < Dr19Spec > ;
#[doc = "Register `DR19` writer"] pub type W = crate :: W < Dr19Spec > ;
#[doc = "Field `D19` reader - Backup data"] pub type D19R = crate :: FieldReader < u16 > ;
#[doc = "Field `D19` writer - Backup data"] pub type D19W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d19 (& self) -> D19R { D19R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d19 (& mut self) -> D19W < '_ , Dr19Spec > { D19W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr19::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr19::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr19Spec ; impl crate :: RegisterSpec for Dr19Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr19::R`](R) reader structure"] impl crate :: Readable for Dr19Spec { }
#[doc = "`write(|w| ..)` method takes [`dr19::W`](W) writer structure"] impl crate :: Writable for Dr19Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR19 to value 0"] impl crate :: Resettable for Dr19Spec { } }
#[doc = "DR20 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr20::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr20::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr20`] module"]
#[doc (alias = "DR20")] pub type Dr20 = crate :: Reg < dr20 :: Dr20Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr20 {
#[doc = "Register `DR20` reader"] pub type R = crate :: R < Dr20Spec > ;
#[doc = "Register `DR20` writer"] pub type W = crate :: W < Dr20Spec > ;
#[doc = "Field `D20` reader - Backup data"] pub type D20R = crate :: FieldReader < u16 > ;
#[doc = "Field `D20` writer - Backup data"] pub type D20W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d20 (& self) -> D20R { D20R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d20 (& mut self) -> D20W < '_ , Dr20Spec > { D20W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr20::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr20::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr20Spec ; impl crate :: RegisterSpec for Dr20Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr20::R`](R) reader structure"] impl crate :: Readable for Dr20Spec { }
#[doc = "`write(|w| ..)` method takes [`dr20::W`](W) writer structure"] impl crate :: Writable for Dr20Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR20 to value 0"] impl crate :: Resettable for Dr20Spec { } }
#[doc = "DR21 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr21::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr21::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr21`] module"]
#[doc (alias = "DR21")] pub type Dr21 = crate :: Reg < dr21 :: Dr21Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr21 {
#[doc = "Register `DR21` reader"] pub type R = crate :: R < Dr21Spec > ;
#[doc = "Register `DR21` writer"] pub type W = crate :: W < Dr21Spec > ;
#[doc = "Field `D21` reader - Backup data"] pub type D21R = crate :: FieldReader < u16 > ;
#[doc = "Field `D21` writer - Backup data"] pub type D21W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d21 (& self) -> D21R { D21R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d21 (& mut self) -> D21W < '_ , Dr21Spec > { D21W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr21::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr21::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr21Spec ; impl crate :: RegisterSpec for Dr21Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr21::R`](R) reader structure"] impl crate :: Readable for Dr21Spec { }
#[doc = "`write(|w| ..)` method takes [`dr21::W`](W) writer structure"] impl crate :: Writable for Dr21Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR21 to value 0"] impl crate :: Resettable for Dr21Spec { } }
#[doc = "DR22 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr22::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr22::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr22`] module"]
#[doc (alias = "DR22")] pub type Dr22 = crate :: Reg < dr22 :: Dr22Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr22 {
#[doc = "Register `DR22` reader"] pub type R = crate :: R < Dr22Spec > ;
#[doc = "Register `DR22` writer"] pub type W = crate :: W < Dr22Spec > ;
#[doc = "Field `D22` reader - Backup data"] pub type D22R = crate :: FieldReader < u16 > ;
#[doc = "Field `D22` writer - Backup data"] pub type D22W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d22 (& self) -> D22R { D22R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d22 (& mut self) -> D22W < '_ , Dr22Spec > { D22W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr22::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr22::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr22Spec ; impl crate :: RegisterSpec for Dr22Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr22::R`](R) reader structure"] impl crate :: Readable for Dr22Spec { }
#[doc = "`write(|w| ..)` method takes [`dr22::W`](W) writer structure"] impl crate :: Writable for Dr22Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR22 to value 0"] impl crate :: Resettable for Dr22Spec { } }
#[doc = "DR23 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr23::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr23::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr23`] module"]
#[doc (alias = "DR23")] pub type Dr23 = crate :: Reg < dr23 :: Dr23Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr23 {
#[doc = "Register `DR23` reader"] pub type R = crate :: R < Dr23Spec > ;
#[doc = "Register `DR23` writer"] pub type W = crate :: W < Dr23Spec > ;
#[doc = "Field `D23` reader - Backup data"] pub type D23R = crate :: FieldReader < u16 > ;
#[doc = "Field `D23` writer - Backup data"] pub type D23W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d23 (& self) -> D23R { D23R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d23 (& mut self) -> D23W < '_ , Dr23Spec > { D23W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr23::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr23::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr23Spec ; impl crate :: RegisterSpec for Dr23Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr23::R`](R) reader structure"] impl crate :: Readable for Dr23Spec { }
#[doc = "`write(|w| ..)` method takes [`dr23::W`](W) writer structure"] impl crate :: Writable for Dr23Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR23 to value 0"] impl crate :: Resettable for Dr23Spec { } }
#[doc = "DR24 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr24::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr24::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr24`] module"]
#[doc (alias = "DR24")] pub type Dr24 = crate :: Reg < dr24 :: Dr24Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr24 {
#[doc = "Register `DR24` reader"] pub type R = crate :: R < Dr24Spec > ;
#[doc = "Register `DR24` writer"] pub type W = crate :: W < Dr24Spec > ;
#[doc = "Field `D24` reader - Backup data"] pub type D24R = crate :: FieldReader < u16 > ;
#[doc = "Field `D24` writer - Backup data"] pub type D24W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d24 (& self) -> D24R { D24R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d24 (& mut self) -> D24W < '_ , Dr24Spec > { D24W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr24::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr24::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr24Spec ; impl crate :: RegisterSpec for Dr24Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr24::R`](R) reader structure"] impl crate :: Readable for Dr24Spec { }
#[doc = "`write(|w| ..)` method takes [`dr24::W`](W) writer structure"] impl crate :: Writable for Dr24Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR24 to value 0"] impl crate :: Resettable for Dr24Spec { } }
#[doc = "DR25 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr25::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr25::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr25`] module"]
#[doc (alias = "DR25")] pub type Dr25 = crate :: Reg < dr25 :: Dr25Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr25 {
#[doc = "Register `DR25` reader"] pub type R = crate :: R < Dr25Spec > ;
#[doc = "Register `DR25` writer"] pub type W = crate :: W < Dr25Spec > ;
#[doc = "Field `D25` reader - Backup data"] pub type D25R = crate :: FieldReader < u16 > ;
#[doc = "Field `D25` writer - Backup data"] pub type D25W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d25 (& self) -> D25R { D25R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d25 (& mut self) -> D25W < '_ , Dr25Spec > { D25W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr25::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr25::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr25Spec ; impl crate :: RegisterSpec for Dr25Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr25::R`](R) reader structure"] impl crate :: Readable for Dr25Spec { }
#[doc = "`write(|w| ..)` method takes [`dr25::W`](W) writer structure"] impl crate :: Writable for Dr25Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR25 to value 0"] impl crate :: Resettable for Dr25Spec { } }
#[doc = "DR26 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr26::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr26::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr26`] module"]
#[doc (alias = "DR26")] pub type Dr26 = crate :: Reg < dr26 :: Dr26Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr26 {
#[doc = "Register `DR26` reader"] pub type R = crate :: R < Dr26Spec > ;
#[doc = "Register `DR26` writer"] pub type W = crate :: W < Dr26Spec > ;
#[doc = "Field `D26` reader - Backup data"] pub type D26R = crate :: FieldReader < u16 > ;
#[doc = "Field `D26` writer - Backup data"] pub type D26W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d26 (& self) -> D26R { D26R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d26 (& mut self) -> D26W < '_ , Dr26Spec > { D26W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr26::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr26::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr26Spec ; impl crate :: RegisterSpec for Dr26Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr26::R`](R) reader structure"] impl crate :: Readable for Dr26Spec { }
#[doc = "`write(|w| ..)` method takes [`dr26::W`](W) writer structure"] impl crate :: Writable for Dr26Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR26 to value 0"] impl crate :: Resettable for Dr26Spec { } }
#[doc = "DR27 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr27::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr27::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr27`] module"]
#[doc (alias = "DR27")] pub type Dr27 = crate :: Reg < dr27 :: Dr27Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr27 {
#[doc = "Register `DR27` reader"] pub type R = crate :: R < Dr27Spec > ;
#[doc = "Register `DR27` writer"] pub type W = crate :: W < Dr27Spec > ;
#[doc = "Field `D27` reader - Backup data"] pub type D27R = crate :: FieldReader < u16 > ;
#[doc = "Field `D27` writer - Backup data"] pub type D27W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d27 (& self) -> D27R { D27R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d27 (& mut self) -> D27W < '_ , Dr27Spec > { D27W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr27::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr27::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr27Spec ; impl crate :: RegisterSpec for Dr27Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr27::R`](R) reader structure"] impl crate :: Readable for Dr27Spec { }
#[doc = "`write(|w| ..)` method takes [`dr27::W`](W) writer structure"] impl crate :: Writable for Dr27Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR27 to value 0"] impl crate :: Resettable for Dr27Spec { } }
#[doc = "DR28 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr28::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr28::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr28`] module"]
#[doc (alias = "DR28")] pub type Dr28 = crate :: Reg < dr28 :: Dr28Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr28 {
#[doc = "Register `DR28` reader"] pub type R = crate :: R < Dr28Spec > ;
#[doc = "Register `DR28` writer"] pub type W = crate :: W < Dr28Spec > ;
#[doc = "Field `D28` reader - Backup data"] pub type D28R = crate :: FieldReader < u16 > ;
#[doc = "Field `D28` writer - Backup data"] pub type D28W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d28 (& self) -> D28R { D28R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d28 (& mut self) -> D28W < '_ , Dr28Spec > { D28W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr28::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr28::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr28Spec ; impl crate :: RegisterSpec for Dr28Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr28::R`](R) reader structure"] impl crate :: Readable for Dr28Spec { }
#[doc = "`write(|w| ..)` method takes [`dr28::W`](W) writer structure"] impl crate :: Writable for Dr28Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR28 to value 0"] impl crate :: Resettable for Dr28Spec { } }
#[doc = "DR29 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr29::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr29::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr29`] module"]
#[doc (alias = "DR29")] pub type Dr29 = crate :: Reg < dr29 :: Dr29Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr29 {
#[doc = "Register `DR29` reader"] pub type R = crate :: R < Dr29Spec > ;
#[doc = "Register `DR29` writer"] pub type W = crate :: W < Dr29Spec > ;
#[doc = "Field `D29` reader - Backup data"] pub type D29R = crate :: FieldReader < u16 > ;
#[doc = "Field `D29` writer - Backup data"] pub type D29W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d29 (& self) -> D29R { D29R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d29 (& mut self) -> D29W < '_ , Dr29Spec > { D29W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr29::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr29::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr29Spec ; impl crate :: RegisterSpec for Dr29Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr29::R`](R) reader structure"] impl crate :: Readable for Dr29Spec { }
#[doc = "`write(|w| ..)` method takes [`dr29::W`](W) writer structure"] impl crate :: Writable for Dr29Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR29 to value 0"] impl crate :: Resettable for Dr29Spec { } }
#[doc = "DR30 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr30::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr30::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr30`] module"]
#[doc (alias = "DR30")] pub type Dr30 = crate :: Reg < dr30 :: Dr30Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr30 {
#[doc = "Register `DR30` reader"] pub type R = crate :: R < Dr30Spec > ;
#[doc = "Register `DR30` writer"] pub type W = crate :: W < Dr30Spec > ;
#[doc = "Field `D30` reader - Backup data"] pub type D30R = crate :: FieldReader < u16 > ;
#[doc = "Field `D30` writer - Backup data"] pub type D30W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d30 (& self) -> D30R { D30R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d30 (& mut self) -> D30W < '_ , Dr30Spec > { D30W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr30::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr30::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr30Spec ; impl crate :: RegisterSpec for Dr30Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr30::R`](R) reader structure"] impl crate :: Readable for Dr30Spec { }
#[doc = "`write(|w| ..)` method takes [`dr30::W`](W) writer structure"] impl crate :: Writable for Dr30Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR30 to value 0"] impl crate :: Resettable for Dr30Spec { } }
#[doc = "DR31 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr31::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr31::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr31`] module"]
#[doc (alias = "DR31")] pub type Dr31 = crate :: Reg < dr31 :: Dr31Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr31 {
#[doc = "Register `DR31` reader"] pub type R = crate :: R < Dr31Spec > ;
#[doc = "Register `DR31` writer"] pub type W = crate :: W < Dr31Spec > ;
#[doc = "Field `D31` reader - Backup data"] pub type D31R = crate :: FieldReader < u16 > ;
#[doc = "Field `D31` writer - Backup data"] pub type D31W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d31 (& self) -> D31R { D31R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d31 (& mut self) -> D31W < '_ , Dr31Spec > { D31W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr31::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr31::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr31Spec ; impl crate :: RegisterSpec for Dr31Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr31::R`](R) reader structure"] impl crate :: Readable for Dr31Spec { }
#[doc = "`write(|w| ..)` method takes [`dr31::W`](W) writer structure"] impl crate :: Writable for Dr31Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR31 to value 0"] impl crate :: Resettable for Dr31Spec { } }
#[doc = "DR32 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr32::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr32::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr32`] module"]
#[doc (alias = "DR32")] pub type Dr32 = crate :: Reg < dr32 :: Dr32Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr32 {
#[doc = "Register `DR32` reader"] pub type R = crate :: R < Dr32Spec > ;
#[doc = "Register `DR32` writer"] pub type W = crate :: W < Dr32Spec > ;
#[doc = "Field `D32` reader - Backup data"] pub type D32R = crate :: FieldReader < u16 > ;
#[doc = "Field `D32` writer - Backup data"] pub type D32W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d32 (& self) -> D32R { D32R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d32 (& mut self) -> D32W < '_ , Dr32Spec > { D32W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr32::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr32::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr32Spec ; impl crate :: RegisterSpec for Dr32Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr32::R`](R) reader structure"] impl crate :: Readable for Dr32Spec { }
#[doc = "`write(|w| ..)` method takes [`dr32::W`](W) writer structure"] impl crate :: Writable for Dr32Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR32 to value 0"] impl crate :: Resettable for Dr32Spec { } }
#[doc = "DR33 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr33::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr33::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr33`] module"]
#[doc (alias = "DR33")] pub type Dr33 = crate :: Reg < dr33 :: Dr33Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr33 {
#[doc = "Register `DR33` reader"] pub type R = crate :: R < Dr33Spec > ;
#[doc = "Register `DR33` writer"] pub type W = crate :: W < Dr33Spec > ;
#[doc = "Field `D33` reader - Backup data"] pub type D33R = crate :: FieldReader < u16 > ;
#[doc = "Field `D33` writer - Backup data"] pub type D33W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d33 (& self) -> D33R { D33R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d33 (& mut self) -> D33W < '_ , Dr33Spec > { D33W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr33::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr33::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr33Spec ; impl crate :: RegisterSpec for Dr33Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr33::R`](R) reader structure"] impl crate :: Readable for Dr33Spec { }
#[doc = "`write(|w| ..)` method takes [`dr33::W`](W) writer structure"] impl crate :: Writable for Dr33Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR33 to value 0"] impl crate :: Resettable for Dr33Spec { } }
#[doc = "DR34 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr34::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr34::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr34`] module"]
#[doc (alias = "DR34")] pub type Dr34 = crate :: Reg < dr34 :: Dr34Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr34 {
#[doc = "Register `DR34` reader"] pub type R = crate :: R < Dr34Spec > ;
#[doc = "Register `DR34` writer"] pub type W = crate :: W < Dr34Spec > ;
#[doc = "Field `D34` reader - Backup data"] pub type D34R = crate :: FieldReader < u16 > ;
#[doc = "Field `D34` writer - Backup data"] pub type D34W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d34 (& self) -> D34R { D34R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d34 (& mut self) -> D34W < '_ , Dr34Spec > { D34W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr34::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr34::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr34Spec ; impl crate :: RegisterSpec for Dr34Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr34::R`](R) reader structure"] impl crate :: Readable for Dr34Spec { }
#[doc = "`write(|w| ..)` method takes [`dr34::W`](W) writer structure"] impl crate :: Writable for Dr34Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR34 to value 0"] impl crate :: Resettable for Dr34Spec { } }
#[doc = "DR35 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr35::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr35::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr35`] module"]
#[doc (alias = "DR35")] pub type Dr35 = crate :: Reg < dr35 :: Dr35Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr35 {
#[doc = "Register `DR35` reader"] pub type R = crate :: R < Dr35Spec > ;
#[doc = "Register `DR35` writer"] pub type W = crate :: W < Dr35Spec > ;
#[doc = "Field `D35` reader - Backup data"] pub type D35R = crate :: FieldReader < u16 > ;
#[doc = "Field `D35` writer - Backup data"] pub type D35W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d35 (& self) -> D35R { D35R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d35 (& mut self) -> D35W < '_ , Dr35Spec > { D35W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr35::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr35::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr35Spec ; impl crate :: RegisterSpec for Dr35Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr35::R`](R) reader structure"] impl crate :: Readable for Dr35Spec { }
#[doc = "`write(|w| ..)` method takes [`dr35::W`](W) writer structure"] impl crate :: Writable for Dr35Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR35 to value 0"] impl crate :: Resettable for Dr35Spec { } }
#[doc = "DR36 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr36::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr36::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr36`] module"]
#[doc (alias = "DR36")] pub type Dr36 = crate :: Reg < dr36 :: Dr36Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr36 {
#[doc = "Register `DR36` reader"] pub type R = crate :: R < Dr36Spec > ;
#[doc = "Register `DR36` writer"] pub type W = crate :: W < Dr36Spec > ;
#[doc = "Field `D36` reader - Backup data"] pub type D36R = crate :: FieldReader < u16 > ;
#[doc = "Field `D36` writer - Backup data"] pub type D36W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d36 (& self) -> D36R { D36R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d36 (& mut self) -> D36W < '_ , Dr36Spec > { D36W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr36::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr36::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr36Spec ; impl crate :: RegisterSpec for Dr36Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr36::R`](R) reader structure"] impl crate :: Readable for Dr36Spec { }
#[doc = "`write(|w| ..)` method takes [`dr36::W`](W) writer structure"] impl crate :: Writable for Dr36Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR36 to value 0"] impl crate :: Resettable for Dr36Spec { } }
#[doc = "DR37 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr37::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr37::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr37`] module"]
#[doc (alias = "DR37")] pub type Dr37 = crate :: Reg < dr37 :: Dr37Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr37 {
#[doc = "Register `DR37` reader"] pub type R = crate :: R < Dr37Spec > ;
#[doc = "Register `DR37` writer"] pub type W = crate :: W < Dr37Spec > ;
#[doc = "Field `D37` reader - Backup data"] pub type D37R = crate :: FieldReader < u16 > ;
#[doc = "Field `D37` writer - Backup data"] pub type D37W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d37 (& self) -> D37R { D37R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d37 (& mut self) -> D37W < '_ , Dr37Spec > { D37W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr37::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr37::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr37Spec ; impl crate :: RegisterSpec for Dr37Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr37::R`](R) reader structure"] impl crate :: Readable for Dr37Spec { }
#[doc = "`write(|w| ..)` method takes [`dr37::W`](W) writer structure"] impl crate :: Writable for Dr37Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR37 to value 0"] impl crate :: Resettable for Dr37Spec { } }
#[doc = "DR38 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr38::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr38::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr38`] module"]
#[doc (alias = "DR38")] pub type Dr38 = crate :: Reg < dr38 :: Dr38Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr38 {
#[doc = "Register `DR38` reader"] pub type R = crate :: R < Dr38Spec > ;
#[doc = "Register `DR38` writer"] pub type W = crate :: W < Dr38Spec > ;
#[doc = "Field `D38` reader - Backup data"] pub type D38R = crate :: FieldReader < u16 > ;
#[doc = "Field `D38` writer - Backup data"] pub type D38W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d38 (& self) -> D38R { D38R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d38 (& mut self) -> D38W < '_ , Dr38Spec > { D38W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr38::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr38::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr38Spec ; impl crate :: RegisterSpec for Dr38Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr38::R`](R) reader structure"] impl crate :: Readable for Dr38Spec { }
#[doc = "`write(|w| ..)` method takes [`dr38::W`](W) writer structure"] impl crate :: Writable for Dr38Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR38 to value 0"] impl crate :: Resettable for Dr38Spec { } }
#[doc = "DR39 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr39::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr39::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr39`] module"]
#[doc (alias = "DR39")] pub type Dr39 = crate :: Reg < dr39 :: Dr39Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr39 {
#[doc = "Register `DR39` reader"] pub type R = crate :: R < Dr39Spec > ;
#[doc = "Register `DR39` writer"] pub type W = crate :: W < Dr39Spec > ;
#[doc = "Field `D39` reader - Backup data"] pub type D39R = crate :: FieldReader < u16 > ;
#[doc = "Field `D39` writer - Backup data"] pub type D39W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d39 (& self) -> D39R { D39R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d39 (& mut self) -> D39W < '_ , Dr39Spec > { D39W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr39::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr39::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr39Spec ; impl crate :: RegisterSpec for Dr39Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr39::R`](R) reader structure"] impl crate :: Readable for Dr39Spec { }
#[doc = "`write(|w| ..)` method takes [`dr39::W`](W) writer structure"] impl crate :: Writable for Dr39Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR39 to value 0"] impl crate :: Resettable for Dr39Spec { } }
#[doc = "DR40 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr40::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr40::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr40`] module"]
#[doc (alias = "DR40")] pub type Dr40 = crate :: Reg < dr40 :: Dr40Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr40 {
#[doc = "Register `DR40` reader"] pub type R = crate :: R < Dr40Spec > ;
#[doc = "Register `DR40` writer"] pub type W = crate :: W < Dr40Spec > ;
#[doc = "Field `D40` reader - Backup data"] pub type D40R = crate :: FieldReader < u16 > ;
#[doc = "Field `D40` writer - Backup data"] pub type D40W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d40 (& self) -> D40R { D40R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d40 (& mut self) -> D40W < '_ , Dr40Spec > { D40W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr40::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr40::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr40Spec ; impl crate :: RegisterSpec for Dr40Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr40::R`](R) reader structure"] impl crate :: Readable for Dr40Spec { }
#[doc = "`write(|w| ..)` method takes [`dr40::W`](W) writer structure"] impl crate :: Writable for Dr40Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR40 to value 0"] impl crate :: Resettable for Dr40Spec { } }
#[doc = "DR41 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr41::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr41::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr41`] module"]
#[doc (alias = "DR41")] pub type Dr41 = crate :: Reg < dr41 :: Dr41Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr41 {
#[doc = "Register `DR41` reader"] pub type R = crate :: R < Dr41Spec > ;
#[doc = "Register `DR41` writer"] pub type W = crate :: W < Dr41Spec > ;
#[doc = "Field `D41` reader - Backup data"] pub type D41R = crate :: FieldReader < u16 > ;
#[doc = "Field `D41` writer - Backup data"] pub type D41W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d41 (& self) -> D41R { D41R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d41 (& mut self) -> D41W < '_ , Dr41Spec > { D41W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr41::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr41::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr41Spec ; impl crate :: RegisterSpec for Dr41Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr41::R`](R) reader structure"] impl crate :: Readable for Dr41Spec { }
#[doc = "`write(|w| ..)` method takes [`dr41::W`](W) writer structure"] impl crate :: Writable for Dr41Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR41 to value 0"] impl crate :: Resettable for Dr41Spec { } }
#[doc = "DR42 (rw) register accessor: Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr42::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr42::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr42`] module"]
#[doc (alias = "DR42")] pub type Dr42 = crate :: Reg < dr42 :: Dr42Spec > ;
#[doc = "Backup data register (BKP_DR)"] pub mod dr42 {
#[doc = "Register `DR42` reader"] pub type R = crate :: R < Dr42Spec > ;
#[doc = "Register `DR42` writer"] pub type W = crate :: W < Dr42Spec > ;
#[doc = "Field `D42` reader - Backup data"] pub type D42R = crate :: FieldReader < u16 > ;
#[doc = "Field `D42` writer - Backup data"] pub type D42W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d42 (& self) -> D42R { D42R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Backup data"]
#[inline (always)] pub fn d42 (& mut self) -> D42W < '_ , Dr42Spec > { D42W :: new (self , 0) } }
#[doc = "Backup data register (BKP_DR)\n\nYou can [`read`](crate::Reg::read) this register and get [`dr42::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr42::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dr42Spec ; impl crate :: RegisterSpec for Dr42Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr42::R`](R) reader structure"] impl crate :: Readable for Dr42Spec { }
#[doc = "`write(|w| ..)` method takes [`dr42::W`](W) writer structure"] impl crate :: Writable for Dr42Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR42 to value 0"] impl crate :: Resettable for Dr42Spec { } }
#[doc = "RTCCR (rw) register accessor: RTC clock calibration register (BKP_RTCCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`rtccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtccr`] module"]
#[doc (alias = "RTCCR")] pub type Rtccr = crate :: Reg < rtccr :: RtccrSpec > ;
#[doc = "RTC clock calibration register (BKP_RTCCR)"] pub mod rtccr {
#[doc = "Register `RTCCR` reader"] pub type R = crate :: R < RtccrSpec > ;
#[doc = "Register `RTCCR` writer"] pub type W = crate :: W < RtccrSpec > ;
#[doc = "Field `CAL` reader - Calibration value"] pub type CalR = crate :: FieldReader ;
#[doc = "Field `CAL` writer - Calibration value"] pub type CalW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `CCO` reader - Calibration Clock Output"] pub type CcoR = crate :: BitReader ;
#[doc = "Field `CCO` writer - Calibration Clock Output"] pub type CcoW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ASOE` reader - Alarm or second output enable"] pub type AsoeR = crate :: BitReader ;
#[doc = "Field `ASOE` writer - Alarm or second output enable"] pub type AsoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ASOS` reader - Alarm or second output selection"] pub type AsosR = crate :: BitReader ;
#[doc = "Field `ASOS` writer - Alarm or second output selection"] pub type AsosW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - Calibration value"]
#[inline (always)] pub fn cal (& self) -> CalR { CalR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bit 7 - Calibration Clock Output"]
#[inline (always)] pub fn cco (& self) -> CcoR { CcoR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Alarm or second output enable"]
#[inline (always)] pub fn asoe (& self) -> AsoeR { AsoeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Alarm or second output selection"]
#[inline (always)] pub fn asos (& self) -> AsosR { AsosR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - Calibration value"]
#[inline (always)] pub fn cal (& mut self) -> CalW < '_ , RtccrSpec > { CalW :: new (self , 0) }
#[doc = "Bit 7 - Calibration Clock Output"]
#[inline (always)] pub fn cco (& mut self) -> CcoW < '_ , RtccrSpec > { CcoW :: new (self , 7) }
#[doc = "Bit 8 - Alarm or second output enable"]
#[inline (always)] pub fn asoe (& mut self) -> AsoeW < '_ , RtccrSpec > { AsoeW :: new (self , 8) }
#[doc = "Bit 9 - Alarm or second output selection"]
#[inline (always)] pub fn asos (& mut self) -> AsosW < '_ , RtccrSpec > { AsosW :: new (self , 9) } }
#[doc = "RTC clock calibration register (BKP_RTCCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`rtccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RtccrSpec ; impl crate :: RegisterSpec for RtccrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rtccr::R`](R) reader structure"] impl crate :: Readable for RtccrSpec { }
#[doc = "`write(|w| ..)` method takes [`rtccr::W`](W) writer structure"] impl crate :: Writable for RtccrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTCCR to value 0"] impl crate :: Resettable for RtccrSpec { } }
#[doc = "CR (rw) register accessor: Backup control register (BKP_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Backup control register (BKP_CR)"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `TPE` reader - Tamper pin enable"] pub type TpeR = crate :: BitReader ;
#[doc = "Field `TPE` writer - Tamper pin enable"] pub type TpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TPAL` reader - Tamper pin active level"] pub type TpalR = crate :: BitReader ;
#[doc = "Field `TPAL` writer - Tamper pin active level"] pub type TpalW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Tamper pin enable"]
#[inline (always)] pub fn tpe (& self) -> TpeR { TpeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Tamper pin active level"]
#[inline (always)] pub fn tpal (& self) -> TpalR { TpalR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Tamper pin enable"]
#[inline (always)] pub fn tpe (& mut self) -> TpeW < '_ , CrSpec > { TpeW :: new (self , 0) }
#[doc = "Bit 1 - Tamper pin active level"]
#[inline (always)] pub fn tpal (& mut self) -> TpalW < '_ , CrSpec > { TpalW :: new (self , 1) } }
#[doc = "Backup control register (BKP_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "CSR (rw) register accessor: BKP_CSR control/status register (BKP_CSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "BKP_CSR control/status register (BKP_CSR)"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Register `CSR` writer"] pub type W = crate :: W < CsrSpec > ;
#[doc = "Field `CTE` writer - Clear Tamper event"] pub type CteW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTI` writer - Clear Tamper Interrupt"] pub type CtiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TPIE` reader - Tamper Pin interrupt enable"] pub type TpieR = crate :: BitReader ;
#[doc = "Field `TPIE` writer - Tamper Pin interrupt enable"] pub type TpieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEF` reader - Tamper Event Flag"] pub type TefR = crate :: BitReader ;
#[doc = "Field `TIF` reader - Tamper Interrupt Flag"] pub type TifR = crate :: BitReader ; impl R {
#[doc = "Bit 2 - Tamper Pin interrupt enable"]
#[inline (always)] pub fn tpie (& self) -> TpieR { TpieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 8 - Tamper Event Flag"]
#[inline (always)] pub fn tef (& self) -> TefR { TefR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Tamper Interrupt Flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Clear Tamper event"]
#[inline (always)] pub fn cte (& mut self) -> CteW < '_ , CsrSpec > { CteW :: new (self , 0) }
#[doc = "Bit 1 - Clear Tamper Interrupt"]
#[inline (always)] pub fn cti (& mut self) -> CtiW < '_ , CsrSpec > { CtiW :: new (self , 1) }
#[doc = "Bit 2 - Tamper Pin interrupt enable"]
#[inline (always)] pub fn tpie (& mut self) -> TpieW < '_ , CsrSpec > { TpieW :: new (self , 2) } }
#[doc = "BKP_CSR control/status register (BKP_CSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"] impl crate :: Writable for CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CSR to value 0"] impl crate :: Resettable for CsrSpec { } } }
#[doc = "Independent watchdog"] pub type Iwdg = crate :: Periph < iwdg :: RegisterBlock , 0x4000_3000 > ; impl core :: fmt :: Debug for Iwdg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Iwdg") . finish () } }
#[doc = "Independent watchdog"] pub mod iwdg {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { kr : Kr , pr : Pr , rlr : Rlr , sr : Sr , } impl RegisterBlock {
#[doc = "0x00 - Key register (IWDG_KR)"]
#[inline (always)] pub const fn kr (& self) -> & Kr { & self . kr }
#[doc = "0x04 - Prescaler register (IWDG_PR)"]
#[inline (always)] pub const fn pr (& self) -> & Pr { & self . pr }
#[doc = "0x08 - Reload register (IWDG_RLR)"]
#[inline (always)] pub const fn rlr (& self) -> & Rlr { & self . rlr }
#[doc = "0x0c - Status register (IWDG_SR)"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr } }
#[doc = "KR (w) register accessor: Key register (IWDG_KR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`kr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@kr`] module"]
#[doc (alias = "KR")] pub type Kr = crate :: Reg < kr :: KrSpec > ;
#[doc = "Key register (IWDG_KR)"] pub mod kr {
#[doc = "Register `KR` writer"] pub type W = crate :: W < KrSpec > ;
#[doc = "Field `KEY` writer - Key value"] pub type KeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - Key value"]
#[inline (always)] pub fn key (& mut self) -> KeyW < '_ , KrSpec > { KeyW :: new (self , 0) } }
#[doc = "Key register (IWDG_KR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`kr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct KrSpec ; impl crate :: RegisterSpec for KrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`kr::W`](W) writer structure"] impl crate :: Writable for KrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KR to value 0"] impl crate :: Resettable for KrSpec { } }
#[doc = "PR (rw) register accessor: Prescaler register (IWDG_PR)\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pr`] module"]
#[doc (alias = "PR")] pub type Pr = crate :: Reg < pr :: PrSpec > ;
#[doc = "Prescaler register (IWDG_PR)"] pub mod pr {
#[doc = "Register `PR` reader"] pub type R = crate :: R < PrSpec > ;
#[doc = "Register `PR` writer"] pub type W = crate :: W < PrSpec > ;
#[doc = "Field `PR` reader - Prescaler divider"] pub type PrR = crate :: FieldReader ;
#[doc = "Field `PR` writer - Prescaler divider"] pub type PrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Prescaler divider"]
#[inline (always)] pub fn pr (& self) -> PrR { PrR :: new ((self . bits & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Prescaler divider"]
#[inline (always)] pub fn pr (& mut self) -> PrW < '_ , PrSpec > { PrW :: new (self , 0) } }
#[doc = "Prescaler register (IWDG_PR)\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrSpec ; impl crate :: RegisterSpec for PrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pr::R`](R) reader structure"] impl crate :: Readable for PrSpec { }
#[doc = "`write(|w| ..)` method takes [`pr::W`](W) writer structure"] impl crate :: Writable for PrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PR to value 0"] impl crate :: Resettable for PrSpec { } }
#[doc = "RLR (rw) register accessor: Reload register (IWDG_RLR)\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr`] module"]
#[doc (alias = "RLR")] pub type Rlr = crate :: Reg < rlr :: RlrSpec > ;
#[doc = "Reload register (IWDG_RLR)"] pub mod rlr {
#[doc = "Register `RLR` reader"] pub type R = crate :: R < RlrSpec > ;
#[doc = "Register `RLR` writer"] pub type W = crate :: W < RlrSpec > ;
#[doc = "Field `RL` reader - Watchdog counter reload value"] pub type RlR = crate :: FieldReader < u16 > ;
#[doc = "Field `RL` writer - Watchdog counter reload value"] pub type RlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Watchdog counter reload value"]
#[inline (always)] pub fn rl (& self) -> RlR { RlR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Watchdog counter reload value"]
#[inline (always)] pub fn rl (& mut self) -> RlW < '_ , RlrSpec > { RlW :: new (self , 0) } }
#[doc = "Reload register (IWDG_RLR)\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RlrSpec ; impl crate :: RegisterSpec for RlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr::R`](R) reader structure"] impl crate :: Readable for RlrSpec { }
#[doc = "`write(|w| ..)` method takes [`rlr::W`](W) writer structure"] impl crate :: Writable for RlrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RLR to value 0x0fff"] impl crate :: Resettable for RlrSpec { const RESET_VALUE : u32 = 0x0fff ; } }
#[doc = "SR (r) register accessor: Status register (IWDG_SR)\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register (IWDG_SR)"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `PVU` reader - Watchdog prescaler value update"] pub type PvuR = crate :: BitReader ;
#[doc = "Field `RVU` reader - Watchdog counter reload value update"] pub type RvuR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Watchdog prescaler value update"]
#[inline (always)] pub fn pvu (& self) -> PvuR { PvuR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Watchdog counter reload value update"]
#[inline (always)] pub fn rvu (& self) -> RvuR { RvuR :: new (((self . bits >> 1) & 1) != 0) } }
#[doc = "Status register (IWDG_SR)\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } } }
#[doc = "Window watchdog"] pub type Wwdg = crate :: Periph < wwdg :: RegisterBlock , 0x4000_2c00 > ; impl core :: fmt :: Debug for Wwdg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Wwdg") . finish () } }
#[doc = "Window watchdog"] pub mod wwdg {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , cfr : Cfr , sr : Sr , } impl RegisterBlock {
#[doc = "0x00 - Control register (WWDG_CR)"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - Configuration register (WWDG_CFR)"]
#[inline (always)] pub const fn cfr (& self) -> & Cfr { & self . cfr }
#[doc = "0x08 - Status register (WWDG_SR)"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr } }
#[doc = "CR (rw) register accessor: Control register (WWDG_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register (WWDG_CR)"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `T` reader - 7-bit counter (MSB to LSB)"] pub type TR = crate :: FieldReader ;
#[doc = "Field `T` writer - 7-bit counter (MSB to LSB)"] pub type TW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `WDGA` reader - Activation bit"] pub type WdgaR = crate :: BitReader ;
#[doc = "Field `WDGA` writer - Activation bit"] pub type WdgaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
#[inline (always)] pub fn t (& self) -> TR { TR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bit 7 - Activation bit"]
#[inline (always)] pub fn wdga (& self) -> WdgaR { WdgaR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
#[inline (always)] pub fn t (& mut self) -> TW < '_ , CrSpec > { TW :: new (self , 0) }
#[doc = "Bit 7 - Activation bit"]
#[inline (always)] pub fn wdga (& mut self) -> WdgaW < '_ , CrSpec > { WdgaW :: new (self , 7) } }
#[doc = "Control register (WWDG_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x7f"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x7f ; } }
#[doc = "CFR (rw) register accessor: Configuration register (WWDG_CFR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cfr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfr`] module"]
#[doc (alias = "CFR")] pub type Cfr = crate :: Reg < cfr :: CfrSpec > ;
#[doc = "Configuration register (WWDG_CFR)"] pub mod cfr {
#[doc = "Register `CFR` reader"] pub type R = crate :: R < CfrSpec > ;
#[doc = "Register `CFR` writer"] pub type W = crate :: W < CfrSpec > ;
#[doc = "Field `W` reader - 7-bit window value"] pub type WR = crate :: FieldReader ;
#[doc = "Field `W` writer - 7-bit window value"] pub type WW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `WDGTB` reader - Timer Base"] pub type WdgtbR = crate :: FieldReader ;
#[doc = "Field `WDGTB` writer - Timer Base"] pub type WdgtbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `EWI` reader - Early Wakeup Interrupt"] pub type EwiR = crate :: BitReader ;
#[doc = "Field `EWI` writer - Early Wakeup Interrupt"] pub type EwiW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - 7-bit window value"]
#[inline (always)] pub fn w (& self) -> WR { WR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bits 7:8 - Timer Base"]
#[inline (always)] pub fn wdgtb (& self) -> WdgtbR { WdgtbR :: new (((self . bits >> 7) & 3) as u8) }
#[doc = "Bit 9 - Early Wakeup Interrupt"]
#[inline (always)] pub fn ewi (& self) -> EwiR { EwiR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - 7-bit window value"]
#[inline (always)] pub fn w (& mut self) -> WW < '_ , CfrSpec > { WW :: new (self , 0) }
#[doc = "Bits 7:8 - Timer Base"]
#[inline (always)] pub fn wdgtb (& mut self) -> WdgtbW < '_ , CfrSpec > { WdgtbW :: new (self , 7) }
#[doc = "Bit 9 - Early Wakeup Interrupt"]
#[inline (always)] pub fn ewi (& mut self) -> EwiW < '_ , CfrSpec > { EwiW :: new (self , 9) } }
#[doc = "Configuration register (WWDG_CFR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cfr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfrSpec ; impl crate :: RegisterSpec for CfrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfr::R`](R) reader structure"] impl crate :: Readable for CfrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfr::W`](W) writer structure"] impl crate :: Writable for CfrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFR to value 0x7f"] impl crate :: Resettable for CfrSpec { const RESET_VALUE : u32 = 0x7f ; } }
#[doc = "SR (rw) register accessor: Status register (WWDG_SR)\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register (WWDG_SR)"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `EWI` reader - Early Wakeup Interrupt"] pub type EwiR = crate :: BitReader ;
#[doc = "Field `EWI` writer - Early Wakeup Interrupt"] pub type EwiW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Early Wakeup Interrupt"]
#[inline (always)] pub fn ewi (& self) -> EwiR { EwiR :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - Early Wakeup Interrupt"]
#[inline (always)] pub fn ewi (& mut self) -> EwiW < '_ , SrSpec > { EwiW :: new (self , 0) } }
#[doc = "Status register (WWDG_SR)\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } } }
#[doc = "Advanced timer"] pub type Tim1 = crate :: Periph < tim1 :: RegisterBlock , 0x4001_2c00 > ; impl core :: fmt :: Debug for Tim1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim1") . finish () } }
#[doc = "Advanced timer"] pub mod tim1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , smcr : Smcr , dier : Dier , sr : Sr , egr : Egr , _reserved_6_ccmr1 : [u8 ; 0x04] , _reserved_7_ccmr2 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , rcr : Rcr , ccr1 : Ccr1 , ccr2 : Ccr2 , ccr3 : Ccr3 , ccr4 : Ccr4 , bdtr : Bdtr , dcr : Dcr , dmar : Dmar , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - slave mode control register"]
#[inline (always)] pub const fn smcr (& self) -> & Smcr { & self . smcr }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (input mode)"]
#[inline (always)] pub const fn ccmr2_input (& self) -> & Ccmr2Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - capture/compare mode register (output mode)"]
#[inline (always)] pub const fn ccmr2_output (& self) -> & Ccmr2Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x30 - repetition counter register"]
#[inline (always)] pub const fn rcr (& self) -> & Rcr { & self . rcr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x38 - capture/compare register 2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x3c - capture/compare register 3"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x40 - capture/compare register 4"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x44 - break and dead-time register"]
#[inline (always)] pub const fn bdtr (& self) -> & Bdtr { & self . bdtr }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMS` reader - Center-aligned mode selection"] pub type CmsR = crate :: FieldReader ;
#[doc = "Field `CMS` writer - Center-aligned mode selection"] pub type CmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& self) -> CmsR { CmsR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Cr1Spec > { DirW :: new (self , 4) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& mut self) -> CmsW < '_ , Cr1Spec > { CmsW :: new (self , 5) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCPC` reader - Capture/compare preloaded control"] pub type CcpcR = crate :: BitReader ;
#[doc = "Field `CCPC` writer - Capture/compare preloaded control"] pub type CcpcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCUS` reader - Capture/compare control update selection"] pub type CcusR = crate :: BitReader ;
#[doc = "Field `CCUS` writer - Capture/compare control update selection"] pub type CcusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCDS` reader - Capture/compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TI1S` reader - TI1 selection"] pub type Ti1sR = crate :: BitReader ;
#[doc = "Field `TI1S` writer - TI1 selection"] pub type Ti1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1` reader - Output Idle state 1"] pub type Ois1R = crate :: BitReader ;
#[doc = "Field `OIS1` writer - Output Idle state 1"] pub type Ois1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1N` reader - Output Idle state 1"] pub type Ois1nR = crate :: BitReader ;
#[doc = "Field `OIS1N` writer - Output Idle state 1"] pub type Ois1nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS2` reader - Output Idle state 2"] pub type Ois2R = crate :: BitReader ;
#[doc = "Field `OIS2` writer - Output Idle state 2"] pub type Ois2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS2N` reader - Output Idle state 2"] pub type Ois2nR = crate :: BitReader ;
#[doc = "Field `OIS2N` writer - Output Idle state 2"] pub type Ois2nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS3` reader - Output Idle state 3"] pub type Ois3R = crate :: BitReader ;
#[doc = "Field `OIS3` writer - Output Idle state 3"] pub type Ois3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS3N` reader - Output Idle state 3"] pub type Ois3nR = crate :: BitReader ;
#[doc = "Field `OIS3N` writer - Output Idle state 3"] pub type Ois3nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS4` reader - Output Idle state 4"] pub type Ois4R = crate :: BitReader ;
#[doc = "Field `OIS4` writer - Output Idle state 4"] pub type Ois4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& self) -> CcpcR { CcpcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& self) -> CcusR { CcusR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& self) -> Ti1sR { Ti1sR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& self) -> Ois1R { Ois1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& self) -> Ois1nR { Ois1nR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Output Idle state 2"]
#[inline (always)] pub fn ois2 (& self) -> Ois2R { Ois2R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output Idle state 2"]
#[inline (always)] pub fn ois2n (& self) -> Ois2nR { Ois2nR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Output Idle state 3"]
#[inline (always)] pub fn ois3 (& self) -> Ois3R { Ois3R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Output Idle state 3"]
#[inline (always)] pub fn ois3n (& self) -> Ois3nR { Ois3nR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Output Idle state 4"]
#[inline (always)] pub fn ois4 (& self) -> Ois4R { Ois4R :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& mut self) -> CcpcW < '_ , Cr2Spec > { CcpcW :: new (self , 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& mut self) -> CcusW < '_ , Cr2Spec > { CcusW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& mut self) -> Ti1sW < '_ , Cr2Spec > { Ti1sW :: new (self , 7) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& mut self) -> Ois1W < '_ , Cr2Spec > { Ois1W :: new (self , 8) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& mut self) -> Ois1nW < '_ , Cr2Spec > { Ois1nW :: new (self , 9) }
#[doc = "Bit 10 - Output Idle state 2"]
#[inline (always)] pub fn ois2 (& mut self) -> Ois2W < '_ , Cr2Spec > { Ois2W :: new (self , 10) }
#[doc = "Bit 11 - Output Idle state 2"]
#[inline (always)] pub fn ois2n (& mut self) -> Ois2nW < '_ , Cr2Spec > { Ois2nW :: new (self , 11) }
#[doc = "Bit 12 - Output Idle state 3"]
#[inline (always)] pub fn ois3 (& mut self) -> Ois3W < '_ , Cr2Spec > { Ois3W :: new (self , 12) }
#[doc = "Bit 13 - Output Idle state 3"]
#[inline (always)] pub fn ois3n (& mut self) -> Ois3nW < '_ , Cr2Spec > { Ois3nW :: new (self , 13) }
#[doc = "Bit 14 - Output Idle state 4"]
#[inline (always)] pub fn ois4 (& mut self) -> Ois4W < '_ , Cr2Spec > { Ois4W :: new (self , 14) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMCR (rw) register accessor: slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smcr`] module"]
#[doc (alias = "SMCR")] pub type Smcr = crate :: Reg < smcr :: SmcrSpec > ;
#[doc = "slave mode control register"] pub mod smcr {
#[doc = "Register `SMCR` reader"] pub type R = crate :: R < SmcrSpec > ;
#[doc = "Register `SMCR` writer"] pub type W = crate :: W < SmcrSpec > ;
#[doc = "Field `SMS` reader - Slave mode selection"] pub type SmsR = crate :: FieldReader ;
#[doc = "Field `SMS` writer - Slave mode selection"] pub type SmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TS` reader - Trigger selection"] pub type TsR = crate :: FieldReader ;
#[doc = "Field `TS` writer - Trigger selection"] pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSM` reader - Master/Slave mode"] pub type MsmR = crate :: BitReader ;
#[doc = "Field `MSM` writer - Master/Slave mode"] pub type MsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETF` reader - External trigger filter"] pub type EtfR = crate :: FieldReader ;
#[doc = "Field `ETF` writer - External trigger filter"] pub type EtfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ETPS` reader - External trigger prescaler"] pub type EtpsR = crate :: FieldReader ;
#[doc = "Field `ETPS` writer - External trigger prescaler"] pub type EtpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECE` reader - External clock enable"] pub type EceR = crate :: BitReader ;
#[doc = "Field `ECE` writer - External clock enable"] pub type EceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETP` reader - External trigger polarity"] pub type EtpR = crate :: BitReader ;
#[doc = "Field `ETP` writer - External trigger polarity"] pub type EtpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& self) -> SmsR { SmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& self) -> MsmR { MsmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& self) -> EtfR { EtfR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& self) -> EtpsR { EtpsR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& self) -> EceR { EceR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& self) -> EtpR { EtpR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& mut self) -> SmsW < '_ , SmcrSpec > { SmsW :: new (self , 0) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , SmcrSpec > { TsW :: new (self , 4) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& mut self) -> MsmW < '_ , SmcrSpec > { MsmW :: new (self , 7) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& mut self) -> EtfW < '_ , SmcrSpec > { EtfW :: new (self , 8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& mut self) -> EtpsW < '_ , SmcrSpec > { EtpsW :: new (self , 12) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& mut self) -> EceW < '_ , SmcrSpec > { EceW :: new (self , 14) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& mut self) -> EtpW < '_ , SmcrSpec > { EtpW :: new (self , 15) } }
#[doc = "slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmcrSpec ; impl crate :: RegisterSpec for SmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smcr::R`](R) reader structure"] impl crate :: Readable for SmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`smcr::W`](W) writer structure"] impl crate :: Writable for SmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMCR to value 0"] impl crate :: Resettable for SmcrSpec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IE` reader - Capture/Compare 2 interrupt enable"] pub type Cc2ieR = crate :: BitReader ;
#[doc = "Field `CC2IE` writer - Capture/Compare 2 interrupt enable"] pub type Cc2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IE` reader - Capture/Compare 3 interrupt enable"] pub type Cc3ieR = crate :: BitReader ;
#[doc = "Field `CC3IE` writer - Capture/Compare 3 interrupt enable"] pub type Cc3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IE` reader - Capture/Compare 4 interrupt enable"] pub type Cc4ieR = crate :: BitReader ;
#[doc = "Field `CC4IE` writer - Capture/Compare 4 interrupt enable"] pub type Cc4ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIE` reader - COM interrupt enable"] pub type ComieR = crate :: BitReader ;
#[doc = "Field `COMIE` writer - COM interrupt enable"] pub type ComieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIE` reader - Trigger interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Trigger interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIE` reader - Break interrupt enable"] pub type BieR = crate :: BitReader ;
#[doc = "Field `BIE` writer - Break interrupt enable"] pub type BieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2DE` reader - Capture/Compare 2 DMA request enable"] pub type Cc2deR = crate :: BitReader ;
#[doc = "Field `CC2DE` writer - Capture/Compare 2 DMA request enable"] pub type Cc2deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3DE` reader - Capture/Compare 3 DMA request enable"] pub type Cc3deR = crate :: BitReader ;
#[doc = "Field `CC3DE` writer - Capture/Compare 3 DMA request enable"] pub type Cc3deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4DE` reader - Capture/Compare 4 DMA request enable"] pub type Cc4deR = crate :: BitReader ;
#[doc = "Field `CC4DE` writer - Capture/Compare 4 DMA request enable"] pub type Cc4deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMDE` reader - COM DMA request enable"] pub type ComdeR = crate :: BitReader ;
#[doc = "Field `COMDE` writer - COM DMA request enable"] pub type ComdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TDE` reader - Trigger DMA request enable"] pub type TdeR = crate :: BitReader ;
#[doc = "Field `TDE` writer - Trigger DMA request enable"] pub type TdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& self) -> Cc2ieR { Cc2ieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& self) -> Cc3ieR { Cc3ieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& self) -> Cc4ieR { Cc4ieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& self) -> ComieR { ComieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& self) -> BieR { BieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& self) -> Cc2deR { Cc2deR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& self) -> Cc3deR { Cc3deR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& self) -> Cc4deR { Cc4deR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - COM DMA request enable"]
#[inline (always)] pub fn comde (& self) -> ComdeR { ComdeR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& self) -> TdeR { TdeR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& mut self) -> Cc2ieW < '_ , DierSpec > { Cc2ieW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& mut self) -> Cc3ieW < '_ , DierSpec > { Cc3ieW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& mut self) -> Cc4ieW < '_ , DierSpec > { Cc4ieW :: new (self , 4) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& mut self) -> ComieW < '_ , DierSpec > { ComieW :: new (self , 5) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DierSpec > { TieW :: new (self , 6) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& mut self) -> BieW < '_ , DierSpec > { BieW :: new (self , 7) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& mut self) -> Cc2deW < '_ , DierSpec > { Cc2deW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& mut self) -> Cc3deW < '_ , DierSpec > { Cc3deW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& mut self) -> Cc4deW < '_ , DierSpec > { Cc4deW :: new (self , 12) }
#[doc = "Bit 13 - COM DMA request enable"]
#[inline (always)] pub fn comde (& mut self) -> ComdeW < '_ , DierSpec > { ComdeW :: new (self , 13) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& mut self) -> TdeW < '_ , DierSpec > { TdeW :: new (self , 14) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IF` reader - Capture/Compare 2 interrupt flag"] pub type Cc2ifR = crate :: BitReader ;
#[doc = "Field `CC2IF` writer - Capture/Compare 2 interrupt flag"] pub type Cc2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IF` reader - Capture/Compare 3 interrupt flag"] pub type Cc3ifR = crate :: BitReader ;
#[doc = "Field `CC3IF` writer - Capture/Compare 3 interrupt flag"] pub type Cc3ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IF` reader - Capture/Compare 4 interrupt flag"] pub type Cc4ifR = crate :: BitReader ;
#[doc = "Field `CC4IF` writer - Capture/Compare 4 interrupt flag"] pub type Cc4ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIF` reader - COM interrupt flag"] pub type ComifR = crate :: BitReader ;
#[doc = "Field `COMIF` writer - COM interrupt flag"] pub type ComifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIF` reader - Trigger interrupt flag"] pub type TifR = crate :: BitReader ;
#[doc = "Field `TIF` writer - Trigger interrupt flag"] pub type TifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIF` reader - Break interrupt flag"] pub type BifR = crate :: BitReader ;
#[doc = "Field `BIF` writer - Break interrupt flag"] pub type BifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2OF` reader - Capture/compare 2 overcapture flag"] pub type Cc2ofR = crate :: BitReader ;
#[doc = "Field `CC2OF` writer - Capture/compare 2 overcapture flag"] pub type Cc2ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3OF` reader - Capture/Compare 3 overcapture flag"] pub type Cc3ofR = crate :: BitReader ;
#[doc = "Field `CC3OF` writer - Capture/Compare 3 overcapture flag"] pub type Cc3ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4OF` reader - Capture/Compare 4 overcapture flag"] pub type Cc4ofR = crate :: BitReader ;
#[doc = "Field `CC4OF` writer - Capture/Compare 4 overcapture flag"] pub type Cc4ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& self) -> Cc2ifR { Cc2ifR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& self) -> Cc3ifR { Cc3ifR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& self) -> Cc4ifR { Cc4ifR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& self) -> ComifR { ComifR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& self) -> BifR { BifR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& self) -> Cc2ofR { Cc2ofR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& self) -> Cc3ofR { Cc3ofR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& self) -> Cc4ofR { Cc4ofR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& mut self) -> Cc2ifW < '_ , SrSpec > { Cc2ifW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& mut self) -> Cc3ifW < '_ , SrSpec > { Cc3ifW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& mut self) -> Cc4ifW < '_ , SrSpec > { Cc4ifW :: new (self , 4) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& mut self) -> ComifW < '_ , SrSpec > { ComifW :: new (self , 5) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& mut self) -> TifW < '_ , SrSpec > { TifW :: new (self , 6) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& mut self) -> BifW < '_ , SrSpec > { BifW :: new (self , 7) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& mut self) -> Cc2ofW < '_ , SrSpec > { Cc2ofW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& mut self) -> Cc3ofW < '_ , SrSpec > { Cc3ofW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& mut self) -> Cc4ofW < '_ , SrSpec > { Cc4ofW :: new (self , 12) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2G` writer - Capture/compare 2 generation"] pub type Cc2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3G` writer - Capture/compare 3 generation"] pub type Cc3gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4G` writer - Capture/compare 4 generation"] pub type Cc4gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMG` writer - Capture/Compare control update generation"] pub type ComgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TG` writer - Trigger generation"] pub type TgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BG` writer - Break generation"] pub type BgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 2 - Capture/compare 2 generation"]
#[inline (always)] pub fn cc2g (& mut self) -> Cc2gW < '_ , EgrSpec > { Cc2gW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare 3 generation"]
#[inline (always)] pub fn cc3g (& mut self) -> Cc3gW < '_ , EgrSpec > { Cc3gW :: new (self , 3) }
#[doc = "Bit 4 - Capture/compare 4 generation"]
#[inline (always)] pub fn cc4g (& mut self) -> Cc4gW < '_ , EgrSpec > { Cc4gW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare control update generation"]
#[inline (always)] pub fn comg (& mut self) -> ComgW < '_ , EgrSpec > { ComgW :: new (self , 5) }
#[doc = "Bit 6 - Trigger generation"]
#[inline (always)] pub fn tg (& mut self) -> TgW < '_ , EgrSpec > { TgW :: new (self , 6) }
#[doc = "Bit 7 - Break generation"]
#[inline (always)] pub fn bg (& mut self) -> BgW < '_ , EgrSpec > { BgW :: new (self , 7) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output Compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output Compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output Compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output Compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output Compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output Compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1CE` reader - Output Compare 1 clear enable"] pub type Oc1ceR = crate :: BitReader ;
#[doc = "Field `OC1CE` writer - Output Compare 1 clear enable"] pub type Oc1ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC2FE` reader - Output Compare 2 fast enable"] pub type Oc2feR = crate :: BitReader ;
#[doc = "Field `OC2FE` writer - Output Compare 2 fast enable"] pub type Oc2feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2PE` reader - Output Compare 2 preload enable"] pub type Oc2peR = crate :: BitReader ;
#[doc = "Field `OC2PE` writer - Output Compare 2 preload enable"] pub type Oc2peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M` reader - Output Compare 2 mode"] pub type Oc2mR = crate :: FieldReader ;
#[doc = "Field `OC2M` writer - Output Compare 2 mode"] pub type Oc2mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC2CE` reader - Output Compare 2 clear enable"] pub type Oc2ceR = crate :: BitReader ;
#[doc = "Field `OC2CE` writer - Output Compare 2 clear enable"] pub type Oc2ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output Compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& self) -> Oc1ceR { Oc1ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output Compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& self) -> Oc2feR { Oc2feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output Compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& self) -> Oc2peR { Oc2peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output Compare 2 mode"]
#[inline (always)] pub fn oc2m (& self) -> Oc2mR { Oc2mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output Compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& self) -> Oc2ceR { Oc2ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 7 - Output Compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& mut self) -> Oc1ceW < '_ , Ccmr1OutputSpec > { Oc1ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1OutputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bit 10 - Output Compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& mut self) -> Oc2feW < '_ , Ccmr1OutputSpec > { Oc2feW :: new (self , 10) }
#[doc = "Bit 11 - Output Compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& mut self) -> Oc2peW < '_ , Ccmr1OutputSpec > { Oc2peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output Compare 2 mode"]
#[inline (always)] pub fn oc2m (& mut self) -> Oc2mW < '_ , Ccmr1OutputSpec > { Oc2mW :: new (self , 12) }
#[doc = "Bit 15 - Output Compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& mut self) -> Oc2ceW < '_ , Ccmr1OutputSpec > { Oc2ceW :: new (self , 15) } }
#[doc = "capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ICPCS` reader - Input capture 1 prescaler"] pub type IcpcsR = crate :: FieldReader ;
#[doc = "Field `ICPCS` writer - Input capture 1 prescaler"] pub type IcpcsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2PCS` reader - Input capture 2 prescaler"] pub type Ic2pcsR = crate :: FieldReader ;
#[doc = "Field `IC2PCS` writer - Input capture 2 prescaler"] pub type Ic2pcsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2F` reader - Input capture 2 filter"] pub type Ic2fR = crate :: FieldReader ;
#[doc = "Field `IC2F` writer - Input capture 2 filter"] pub type Ic2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn icpcs (& self) -> IcpcsR { IcpcsR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2pcs (& self) -> Ic2pcsR { Ic2pcsR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& self) -> Ic2fR { Ic2fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn icpcs (& mut self) -> IcpcsW < '_ , Ccmr1InputSpec > { IcpcsW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1InputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2pcs (& mut self) -> Ic2pcsW < '_ , Ccmr1InputSpec > { Ic2pcsW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& mut self) -> Ic2fW < '_ , Ccmr1InputSpec > { Ic2fW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCMR2_Output (rw) register accessor: capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_output`] module"]
#[doc (alias = "CCMR2_Output")] pub type Ccmr2Output = crate :: Reg < ccmr2_output :: Ccmr2OutputSpec > ;
#[doc = "capture/compare mode register (output mode)"] pub mod ccmr2_output {
#[doc = "Register `CCMR2_Output` reader"] pub type R = crate :: R < Ccmr2OutputSpec > ;
#[doc = "Register `CCMR2_Output` writer"] pub type W = crate :: W < Ccmr2OutputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC3FE` reader - Output compare 3 fast enable"] pub type Oc3feR = crate :: BitReader ;
#[doc = "Field `OC3FE` writer - Output compare 3 fast enable"] pub type Oc3feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3PE` reader - Output compare 3 preload enable"] pub type Oc3peR = crate :: BitReader ;
#[doc = "Field `OC3PE` writer - Output compare 3 preload enable"] pub type Oc3peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M` reader - Output compare 3 mode"] pub type Oc3mR = crate :: FieldReader ;
#[doc = "Field `OC3M` writer - Output compare 3 mode"] pub type Oc3mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC3CE` reader - Output compare 3 clear enable"] pub type Oc3ceR = crate :: BitReader ;
#[doc = "Field `OC3CE` writer - Output compare 3 clear enable"] pub type Oc3ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC4FE` reader - Output compare 4 fast enable"] pub type Oc4feR = crate :: BitReader ;
#[doc = "Field `OC4FE` writer - Output compare 4 fast enable"] pub type Oc4feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4PE` reader - Output compare 4 preload enable"] pub type Oc4peR = crate :: BitReader ;
#[doc = "Field `OC4PE` writer - Output compare 4 preload enable"] pub type Oc4peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M` reader - Output compare 4 mode"] pub type Oc4mR = crate :: FieldReader ;
#[doc = "Field `OC4M` writer - Output compare 4 mode"] pub type Oc4mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC4CE` reader - Output compare 4 clear enable"] pub type Oc4ceR = crate :: BitReader ;
#[doc = "Field `OC4CE` writer - Output compare 4 clear enable"] pub type Oc4ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& self) -> Oc3feR { Oc3feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& self) -> Oc3peR { Oc3peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& self) -> Oc3mR { Oc3mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& self) -> Oc3ceR { Oc3ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& self) -> Oc4feR { Oc4feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& self) -> Oc4peR { Oc4peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& self) -> Oc4mR { Oc4mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& self) -> Oc4ceR { Oc4ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2OutputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& mut self) -> Oc3feW < '_ , Ccmr2OutputSpec > { Oc3feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& mut self) -> Oc3peW < '_ , Ccmr2OutputSpec > { Oc3peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& mut self) -> Oc3mW < '_ , Ccmr2OutputSpec > { Oc3mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& mut self) -> Oc3ceW < '_ , Ccmr2OutputSpec > { Oc3ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2OutputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& mut self) -> Oc4feW < '_ , Ccmr2OutputSpec > { Oc4feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& mut self) -> Oc4peW < '_ , Ccmr2OutputSpec > { Oc4peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& mut self) -> Oc4mW < '_ , Ccmr2OutputSpec > { Oc4mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& mut self) -> Oc4ceW < '_ , Ccmr2OutputSpec > { Oc4ceW :: new (self , 15) } }
#[doc = "capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2OutputSpec ; impl crate :: RegisterSpec for Ccmr2OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_output::R`](R) reader structure"] impl crate :: Readable for Ccmr2OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_output::W`](W) writer structure"] impl crate :: Writable for Ccmr2OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Output to value 0"] impl crate :: Resettable for Ccmr2OutputSpec { } }
#[doc = "CCMR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_input`] module"]
#[doc (alias = "CCMR2_Input")] pub type Ccmr2Input = crate :: Reg < ccmr2_input :: Ccmr2InputSpec > ;
#[doc = "capture/compare mode register 2 (input mode)"] pub mod ccmr2_input {
#[doc = "Register `CCMR2_Input` reader"] pub type R = crate :: R < Ccmr2InputSpec > ;
#[doc = "Register `CCMR2_Input` writer"] pub type W = crate :: W < Ccmr2InputSpec > ;
#[doc = "Field `CC3S` reader - Capture/compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3PSC` reader - Input capture 3 prescaler"] pub type Ic3pscR = crate :: FieldReader ;
#[doc = "Field `IC3PSC` writer - Input capture 3 prescaler"] pub type Ic3pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3F` reader - Input capture 3 filter"] pub type Ic3fR = crate :: FieldReader ;
#[doc = "Field `IC3F` writer - Input capture 3 filter"] pub type Ic3fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4PSC` reader - Input capture 4 prescaler"] pub type Ic4pscR = crate :: FieldReader ;
#[doc = "Field `IC4PSC` writer - Input capture 4 prescaler"] pub type Ic4pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4F` reader - Input capture 4 filter"] pub type Ic4fR = crate :: FieldReader ;
#[doc = "Field `IC4F` writer - Input capture 4 filter"] pub type Ic4fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& self) -> Ic3pscR { Ic3pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& self) -> Ic3fR { Ic3fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& self) -> Ic4pscR { Ic4pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& self) -> Ic4fR { Ic4fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2InputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& mut self) -> Ic3pscW < '_ , Ccmr2InputSpec > { Ic3pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& mut self) -> Ic3fW < '_ , Ccmr2InputSpec > { Ic3fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2InputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& mut self) -> Ic4pscW < '_ , Ccmr2InputSpec > { Ic4pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& mut self) -> Ic4fW < '_ , Ccmr2InputSpec > { Ic4fW :: new (self , 12) } }
#[doc = "capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2InputSpec ; impl crate :: RegisterSpec for Ccmr2InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_input::R`](R) reader structure"] impl crate :: Readable for Ccmr2InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_input::W`](W) writer structure"] impl crate :: Writable for Ccmr2InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Input to value 0"] impl crate :: Resettable for Ccmr2InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output Polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output Polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NE` reader - Capture/Compare 1 complementary output enable"] pub type Cc1neR = crate :: BitReader ;
#[doc = "Field `CC1NE` writer - Capture/Compare 1 complementary output enable"] pub type Cc1neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 output Polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 output Polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2E` reader - Capture/Compare 2 output enable"] pub type Cc2eR = crate :: BitReader ;
#[doc = "Field `CC2E` writer - Capture/Compare 2 output enable"] pub type Cc2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2P` reader - Capture/Compare 2 output Polarity"] pub type Cc2pR = crate :: BitReader ;
#[doc = "Field `CC2P` writer - Capture/Compare 2 output Polarity"] pub type Cc2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2NE` reader - Capture/Compare 2 complementary output enable"] pub type Cc2neR = crate :: BitReader ;
#[doc = "Field `CC2NE` writer - Capture/Compare 2 complementary output enable"] pub type Cc2neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2NP` reader - Capture/Compare 2 output Polarity"] pub type Cc2npR = crate :: BitReader ;
#[doc = "Field `CC2NP` writer - Capture/Compare 2 output Polarity"] pub type Cc2npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3E` reader - Capture/Compare 3 output enable"] pub type Cc3eR = crate :: BitReader ;
#[doc = "Field `CC3E` writer - Capture/Compare 3 output enable"] pub type Cc3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3P` reader - Capture/Compare 3 output Polarity"] pub type Cc3pR = crate :: BitReader ;
#[doc = "Field `CC3P` writer - Capture/Compare 3 output Polarity"] pub type Cc3pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3NE` reader - Capture/Compare 3 complementary output enable"] pub type Cc3neR = crate :: BitReader ;
#[doc = "Field `CC3NE` writer - Capture/Compare 3 complementary output enable"] pub type Cc3neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3NP` reader - Capture/Compare 3 output Polarity"] pub type Cc3npR = crate :: BitReader ;
#[doc = "Field `CC3NP` writer - Capture/Compare 3 output Polarity"] pub type Cc3npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4E` reader - Capture/Compare 4 output enable"] pub type Cc4eR = crate :: BitReader ;
#[doc = "Field `CC4E` writer - Capture/Compare 4 output enable"] pub type Cc4eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4P` reader - Capture/Compare 3 output Polarity"] pub type Cc4pR = crate :: BitReader ;
#[doc = "Field `CC4P` writer - Capture/Compare 3 output Polarity"] pub type Cc4pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& self) -> Cc1neR { Cc1neR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& self) -> Cc2eR { Cc2eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& self) -> Cc2pR { Cc2pR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
#[inline (always)] pub fn cc2ne (& self) -> Cc2neR { Cc2neR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2np (& self) -> Cc2npR { Cc2npR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& self) -> Cc3eR { Cc3eR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3p (& self) -> Cc3pR { Cc3pR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
#[inline (always)] pub fn cc3ne (& self) -> Cc3neR { Cc3neR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3np (& self) -> Cc3npR { Cc3npR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& self) -> Cc4eR { Cc4eR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc4p (& self) -> Cc4pR { Cc4pR :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& mut self) -> Cc1neW < '_ , CcerSpec > { Cc1neW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& mut self) -> Cc2eW < '_ , CcerSpec > { Cc2eW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& mut self) -> Cc2pW < '_ , CcerSpec > { Cc2pW :: new (self , 5) }
#[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
#[inline (always)] pub fn cc2ne (& mut self) -> Cc2neW < '_ , CcerSpec > { Cc2neW :: new (self , 6) }
#[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2np (& mut self) -> Cc2npW < '_ , CcerSpec > { Cc2npW :: new (self , 7) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& mut self) -> Cc3eW < '_ , CcerSpec > { Cc3eW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3p (& mut self) -> Cc3pW < '_ , CcerSpec > { Cc3pW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
#[inline (always)] pub fn cc3ne (& mut self) -> Cc3neW < '_ , CcerSpec > { Cc3neW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3np (& mut self) -> Cc3npW < '_ , CcerSpec > { Cc3npW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& mut self) -> Cc4eW < '_ , CcerSpec > { Cc4eW :: new (self , 12) }
#[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc4p (& mut self) -> Cc4pW < '_ , CcerSpec > { Cc4pW :: new (self , 13) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "capture/compare register 2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `CCR2` reader - Capture/Compare 2 value"] pub type Ccr2R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR2` writer - Capture/Compare 2 value"] pub type Ccr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& self) -> Ccr2R { Ccr2R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& mut self) -> Ccr2W < '_ , Ccr2Spec > { Ccr2W :: new (self , 0) } }
#[doc = "capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CCR3 (rw) register accessor: capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "capture/compare register 3"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `CCR3` reader - Capture/Compare value"] pub type Ccr3R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR3` writer - Capture/Compare value"] pub type Ccr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr3 (& self) -> Ccr3R { Ccr3R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr3 (& mut self) -> Ccr3W < '_ , Ccr3Spec > { Ccr3W :: new (self , 0) } }
#[doc = "capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CCR4 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `CCR4` reader - Capture/Compare value"] pub type Ccr4R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR4` writer - Capture/Compare value"] pub type Ccr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr4 (& self) -> Ccr4R { Ccr4R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr4 (& mut self) -> Ccr4W < '_ , Ccr4Spec > { Ccr4W :: new (self , 0) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "DCR (rw) register accessor: DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` reader"] pub type R = crate :: R < DcrSpec > ;
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` reader - DMA base address"] pub type DbaR = crate :: FieldReader ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` reader - DMA burst length"] pub type DblR = crate :: FieldReader ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& self) -> DbaR { DbaR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& self) -> DblR { DblR :: new (((self . bits >> 8) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcr::R`](R) reader structure"] impl crate :: Readable for DcrSpec { }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` reader"] pub type R = crate :: R < DmarSpec > ;
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` reader - DMA register for burst accesses"] pub type DmabR = crate :: FieldReader < u16 > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& self) -> DmabR { DmabR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmar::R`](R) reader structure"] impl crate :: Readable for DmarSpec { }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } }
#[doc = "RCR (rw) register accessor: repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rcr`] module"]
#[doc (alias = "RCR")] pub type Rcr = crate :: Reg < rcr :: RcrSpec > ;
#[doc = "repetition counter register"] pub mod rcr {
#[doc = "Register `RCR` reader"] pub type R = crate :: R < RcrSpec > ;
#[doc = "Register `RCR` writer"] pub type W = crate :: W < RcrSpec > ;
#[doc = "Field `REP` reader - Repetition counter value"] pub type RepR = crate :: FieldReader ;
#[doc = "Field `REP` writer - Repetition counter value"] pub type RepW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& self) -> RepR { RepR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& mut self) -> RepW < '_ , RcrSpec > { RepW :: new (self , 0) } }
#[doc = "repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RcrSpec ; impl crate :: RegisterSpec for RcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rcr::R`](R) reader structure"] impl crate :: Readable for RcrSpec { }
#[doc = "`write(|w| ..)` method takes [`rcr::W`](W) writer structure"] impl crate :: Writable for RcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RCR to value 0"] impl crate :: Resettable for RcrSpec { } }
#[doc = "BDTR (rw) register accessor: break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdtr`] module"]
#[doc (alias = "BDTR")] pub type Bdtr = crate :: Reg < bdtr :: BdtrSpec > ;
#[doc = "break and dead-time register"] pub mod bdtr {
#[doc = "Register `BDTR` reader"] pub type R = crate :: R < BdtrSpec > ;
#[doc = "Register `BDTR` writer"] pub type W = crate :: W < BdtrSpec > ;
#[doc = "Field `DTG` reader - Dead-time generator setup"] pub type DtgR = crate :: FieldReader ;
#[doc = "Field `DTG` writer - Dead-time generator setup"] pub type DtgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `LOCK` reader - Lock configuration"] pub type LockR = crate :: FieldReader ;
#[doc = "Field `LOCK` writer - Lock configuration"] pub type LockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSSI` reader - Off-state selection for Idle mode"] pub type OssiR = crate :: BitReader ;
#[doc = "Field `OSSI` writer - Off-state selection for Idle mode"] pub type OssiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSSR` reader - Off-state selection for Run mode"] pub type OssrR = crate :: BitReader ;
#[doc = "Field `OSSR` writer - Off-state selection for Run mode"] pub type OssrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKE` reader - Break enable"] pub type BkeR = crate :: BitReader ;
#[doc = "Field `BKE` writer - Break enable"] pub type BkeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKP` reader - Break polarity"] pub type BkpR = crate :: BitReader ;
#[doc = "Field `BKP` writer - Break polarity"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AOE` reader - Automatic output enable"] pub type AoeR = crate :: BitReader ;
#[doc = "Field `AOE` writer - Automatic output enable"] pub type AoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MOE` reader - Main output enable"] pub type MoeR = crate :: BitReader ;
#[doc = "Field `MOE` writer - Main output enable"] pub type MoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& self) -> DtgR { DtgR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& self) -> OssiR { OssiR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& self) -> OssrR { OssrR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& self) -> BkeR { BkeR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& self) -> AoeR { AoeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& self) -> MoeR { MoeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& mut self) -> DtgW < '_ , BdtrSpec > { DtgW :: new (self , 0) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , BdtrSpec > { LockW :: new (self , 8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& mut self) -> OssiW < '_ , BdtrSpec > { OssiW :: new (self , 10) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& mut self) -> OssrW < '_ , BdtrSpec > { OssrW :: new (self , 11) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& mut self) -> BkeW < '_ , BdtrSpec > { BkeW :: new (self , 12) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , BdtrSpec > { BkpW :: new (self , 13) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& mut self) -> AoeW < '_ , BdtrSpec > { AoeW :: new (self , 14) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& mut self) -> MoeW < '_ , BdtrSpec > { MoeW :: new (self , 15) } }
#[doc = "break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdtrSpec ; impl crate :: RegisterSpec for BdtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdtr::R`](R) reader structure"] impl crate :: Readable for BdtrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdtr::W`](W) writer structure"] impl crate :: Writable for BdtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDTR to value 0"] impl crate :: Resettable for BdtrSpec { } } }
#[doc = "Advanced timer"] pub type Tim8 = crate :: Periph < tim1 :: RegisterBlock , 0x4001_3400 > ; impl core :: fmt :: Debug for Tim8 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim8") . finish () } }
#[doc = "Advanced timer"] pub use self :: tim1 as tim8 ;
#[doc = "General purpose timer"] pub type Tim2 = crate :: Periph < tim2 :: RegisterBlock , 0x4000_0000 > ; impl core :: fmt :: Debug for Tim2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim2") . finish () } }
#[doc = "General purpose timer"] pub mod tim2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , smcr : Smcr , dier : Dier , sr : Sr , egr : Egr , _reserved_6_ccmr1 : [u8 ; 0x04] , _reserved_7_ccmr2 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , _reserved12 : [u8 ; 0x04] , ccr1 : Ccr1 , ccr2 : Ccr2 , ccr3 : Ccr3 , ccr4 : Ccr4 , _reserved16 : [u8 ; 0x04] , dcr : Dcr , dmar : Dmar , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - slave mode control register"]
#[inline (always)] pub const fn smcr (& self) -> & Smcr { & self . smcr }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (input mode)"]
#[inline (always)] pub const fn ccmr2_input (& self) -> & Ccmr2Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (output mode)"]
#[inline (always)] pub const fn ccmr2_output (& self) -> & Ccmr2Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x38 - capture/compare register 2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x3c - capture/compare register 3"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x40 - capture/compare register 4"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMS` reader - Center-aligned mode selection"] pub type CmsR = crate :: FieldReader ;
#[doc = "Field `CMS` writer - Center-aligned mode selection"] pub type CmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& self) -> CmsR { CmsR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Cr1Spec > { DirW :: new (self , 4) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& mut self) -> CmsW < '_ , Cr1Spec > { CmsW :: new (self , 5) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCDS` reader - Capture/compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TI1S` reader - TI1 selection"] pub type Ti1sR = crate :: BitReader ;
#[doc = "Field `TI1S` writer - TI1 selection"] pub type Ti1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& self) -> Ti1sR { Ti1sR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& mut self) -> Ti1sW < '_ , Cr2Spec > { Ti1sW :: new (self , 7) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMCR (rw) register accessor: slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smcr`] module"]
#[doc (alias = "SMCR")] pub type Smcr = crate :: Reg < smcr :: SmcrSpec > ;
#[doc = "slave mode control register"] pub mod smcr {
#[doc = "Register `SMCR` reader"] pub type R = crate :: R < SmcrSpec > ;
#[doc = "Register `SMCR` writer"] pub type W = crate :: W < SmcrSpec > ;
#[doc = "Field `SMS` reader - Slave mode selection"] pub type SmsR = crate :: FieldReader ;
#[doc = "Field `SMS` writer - Slave mode selection"] pub type SmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TS` reader - Trigger selection"] pub type TsR = crate :: FieldReader ;
#[doc = "Field `TS` writer - Trigger selection"] pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSM` reader - Master/Slave mode"] pub type MsmR = crate :: BitReader ;
#[doc = "Field `MSM` writer - Master/Slave mode"] pub type MsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETF` reader - External trigger filter"] pub type EtfR = crate :: FieldReader ;
#[doc = "Field `ETF` writer - External trigger filter"] pub type EtfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ETPS` reader - External trigger prescaler"] pub type EtpsR = crate :: FieldReader ;
#[doc = "Field `ETPS` writer - External trigger prescaler"] pub type EtpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECE` reader - External clock enable"] pub type EceR = crate :: BitReader ;
#[doc = "Field `ECE` writer - External clock enable"] pub type EceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETP` reader - External trigger polarity"] pub type EtpR = crate :: BitReader ;
#[doc = "Field `ETP` writer - External trigger polarity"] pub type EtpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& self) -> SmsR { SmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& self) -> MsmR { MsmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& self) -> EtfR { EtfR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& self) -> EtpsR { EtpsR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& self) -> EceR { EceR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& self) -> EtpR { EtpR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& mut self) -> SmsW < '_ , SmcrSpec > { SmsW :: new (self , 0) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , SmcrSpec > { TsW :: new (self , 4) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& mut self) -> MsmW < '_ , SmcrSpec > { MsmW :: new (self , 7) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& mut self) -> EtfW < '_ , SmcrSpec > { EtfW :: new (self , 8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& mut self) -> EtpsW < '_ , SmcrSpec > { EtpsW :: new (self , 12) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& mut self) -> EceW < '_ , SmcrSpec > { EceW :: new (self , 14) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& mut self) -> EtpW < '_ , SmcrSpec > { EtpW :: new (self , 15) } }
#[doc = "slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmcrSpec ; impl crate :: RegisterSpec for SmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smcr::R`](R) reader structure"] impl crate :: Readable for SmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`smcr::W`](W) writer structure"] impl crate :: Writable for SmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMCR to value 0"] impl crate :: Resettable for SmcrSpec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IE` reader - Capture/Compare 2 interrupt enable"] pub type Cc2ieR = crate :: BitReader ;
#[doc = "Field `CC2IE` writer - Capture/Compare 2 interrupt enable"] pub type Cc2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IE` reader - Capture/Compare 3 interrupt enable"] pub type Cc3ieR = crate :: BitReader ;
#[doc = "Field `CC3IE` writer - Capture/Compare 3 interrupt enable"] pub type Cc3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IE` reader - Capture/Compare 4 interrupt enable"] pub type Cc4ieR = crate :: BitReader ;
#[doc = "Field `CC4IE` writer - Capture/Compare 4 interrupt enable"] pub type Cc4ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIE` reader - Trigger interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Trigger interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2DE` reader - Capture/Compare 2 DMA request enable"] pub type Cc2deR = crate :: BitReader ;
#[doc = "Field `CC2DE` writer - Capture/Compare 2 DMA request enable"] pub type Cc2deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3DE` reader - Capture/Compare 3 DMA request enable"] pub type Cc3deR = crate :: BitReader ;
#[doc = "Field `CC3DE` writer - Capture/Compare 3 DMA request enable"] pub type Cc3deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4DE` reader - Capture/Compare 4 DMA request enable"] pub type Cc4deR = crate :: BitReader ;
#[doc = "Field `CC4DE` writer - Capture/Compare 4 DMA request enable"] pub type Cc4deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TDE` reader - Trigger DMA request enable"] pub type TdeR = crate :: BitReader ;
#[doc = "Field `TDE` writer - Trigger DMA request enable"] pub type TdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& self) -> Cc2ieR { Cc2ieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& self) -> Cc3ieR { Cc3ieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& self) -> Cc4ieR { Cc4ieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& self) -> Cc2deR { Cc2deR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& self) -> Cc3deR { Cc3deR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& self) -> Cc4deR { Cc4deR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& self) -> TdeR { TdeR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& mut self) -> Cc2ieW < '_ , DierSpec > { Cc2ieW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& mut self) -> Cc3ieW < '_ , DierSpec > { Cc3ieW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& mut self) -> Cc4ieW < '_ , DierSpec > { Cc4ieW :: new (self , 4) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DierSpec > { TieW :: new (self , 6) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& mut self) -> Cc2deW < '_ , DierSpec > { Cc2deW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& mut self) -> Cc3deW < '_ , DierSpec > { Cc3deW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& mut self) -> Cc4deW < '_ , DierSpec > { Cc4deW :: new (self , 12) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& mut self) -> TdeW < '_ , DierSpec > { TdeW :: new (self , 14) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IF` reader - Capture/Compare 2 interrupt flag"] pub type Cc2ifR = crate :: BitReader ;
#[doc = "Field `CC2IF` writer - Capture/Compare 2 interrupt flag"] pub type Cc2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IF` reader - Capture/Compare 3 interrupt flag"] pub type Cc3ifR = crate :: BitReader ;
#[doc = "Field `CC3IF` writer - Capture/Compare 3 interrupt flag"] pub type Cc3ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IF` reader - Capture/Compare 4 interrupt flag"] pub type Cc4ifR = crate :: BitReader ;
#[doc = "Field `CC4IF` writer - Capture/Compare 4 interrupt flag"] pub type Cc4ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIF` reader - Trigger interrupt flag"] pub type TifR = crate :: BitReader ;
#[doc = "Field `TIF` writer - Trigger interrupt flag"] pub type TifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2OF` reader - Capture/compare 2 overcapture flag"] pub type Cc2ofR = crate :: BitReader ;
#[doc = "Field `CC2OF` writer - Capture/compare 2 overcapture flag"] pub type Cc2ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3OF` reader - Capture/Compare 3 overcapture flag"] pub type Cc3ofR = crate :: BitReader ;
#[doc = "Field `CC3OF` writer - Capture/Compare 3 overcapture flag"] pub type Cc3ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4OF` reader - Capture/Compare 4 overcapture flag"] pub type Cc4ofR = crate :: BitReader ;
#[doc = "Field `CC4OF` writer - Capture/Compare 4 overcapture flag"] pub type Cc4ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& self) -> Cc2ifR { Cc2ifR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& self) -> Cc3ifR { Cc3ifR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& self) -> Cc4ifR { Cc4ifR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& self) -> Cc2ofR { Cc2ofR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& self) -> Cc3ofR { Cc3ofR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& self) -> Cc4ofR { Cc4ofR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& mut self) -> Cc2ifW < '_ , SrSpec > { Cc2ifW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& mut self) -> Cc3ifW < '_ , SrSpec > { Cc3ifW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& mut self) -> Cc4ifW < '_ , SrSpec > { Cc4ifW :: new (self , 4) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& mut self) -> TifW < '_ , SrSpec > { TifW :: new (self , 6) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& mut self) -> Cc2ofW < '_ , SrSpec > { Cc2ofW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& mut self) -> Cc3ofW < '_ , SrSpec > { Cc3ofW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& mut self) -> Cc4ofW < '_ , SrSpec > { Cc4ofW :: new (self , 12) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2G` writer - Capture/compare 2 generation"] pub type Cc2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3G` writer - Capture/compare 3 generation"] pub type Cc3gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4G` writer - Capture/compare 4 generation"] pub type Cc4gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TG` writer - Trigger generation"] pub type TgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 2 - Capture/compare 2 generation"]
#[inline (always)] pub fn cc2g (& mut self) -> Cc2gW < '_ , EgrSpec > { Cc2gW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare 3 generation"]
#[inline (always)] pub fn cc3g (& mut self) -> Cc3gW < '_ , EgrSpec > { Cc3gW :: new (self , 3) }
#[doc = "Bit 4 - Capture/compare 4 generation"]
#[inline (always)] pub fn cc4g (& mut self) -> Cc4gW < '_ , EgrSpec > { Cc4gW :: new (self , 4) }
#[doc = "Bit 6 - Trigger generation"]
#[inline (always)] pub fn tg (& mut self) -> TgW < '_ , EgrSpec > { TgW :: new (self , 6) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1CE` reader - Output compare 1 clear enable"] pub type Oc1ceR = crate :: BitReader ;
#[doc = "Field `OC1CE` writer - Output compare 1 clear enable"] pub type Oc1ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC2FE` reader - Output compare 2 fast enable"] pub type Oc2feR = crate :: BitReader ;
#[doc = "Field `OC2FE` writer - Output compare 2 fast enable"] pub type Oc2feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2PE` reader - Output compare 2 preload enable"] pub type Oc2peR = crate :: BitReader ;
#[doc = "Field `OC2PE` writer - Output compare 2 preload enable"] pub type Oc2peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M` reader - Output compare 2 mode"] pub type Oc2mR = crate :: FieldReader ;
#[doc = "Field `OC2M` writer - Output compare 2 mode"] pub type Oc2mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC2CE` reader - Output compare 2 clear enable"] pub type Oc2ceR = crate :: BitReader ;
#[doc = "Field `OC2CE` writer - Output compare 2 clear enable"] pub type Oc2ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& self) -> Oc1ceR { Oc1ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& self) -> Oc2feR { Oc2feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& self) -> Oc2peR { Oc2peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& self) -> Oc2mR { Oc2mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& self) -> Oc2ceR { Oc2ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& mut self) -> Oc1ceW < '_ , Ccmr1OutputSpec > { Oc1ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1OutputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& mut self) -> Oc2feW < '_ , Ccmr1OutputSpec > { Oc2feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& mut self) -> Oc2peW < '_ , Ccmr1OutputSpec > { Oc2peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& mut self) -> Oc2mW < '_ , Ccmr1OutputSpec > { Oc2mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& mut self) -> Oc2ceW < '_ , Ccmr1OutputSpec > { Oc2ceW :: new (self , 15) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC2S` reader - Capture/compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2PSC` reader - Input capture 2 prescaler"] pub type Ic2pscR = crate :: FieldReader ;
#[doc = "Field `IC2PSC` writer - Input capture 2 prescaler"] pub type Ic2pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2F` reader - Input capture 2 filter"] pub type Ic2fR = crate :: FieldReader ;
#[doc = "Field `IC2F` writer - Input capture 2 filter"] pub type Ic2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& self) -> Ic2pscR { Ic2pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& self) -> Ic2fR { Ic2fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1InputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& mut self) -> Ic2pscW < '_ , Ccmr1InputSpec > { Ic2pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& mut self) -> Ic2fW < '_ , Ccmr1InputSpec > { Ic2fW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCMR2_Output (rw) register accessor: capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_output`] module"]
#[doc (alias = "CCMR2_Output")] pub type Ccmr2Output = crate :: Reg < ccmr2_output :: Ccmr2OutputSpec > ;
#[doc = "capture/compare mode register 2 (output mode)"] pub mod ccmr2_output {
#[doc = "Register `CCMR2_Output` reader"] pub type R = crate :: R < Ccmr2OutputSpec > ;
#[doc = "Register `CCMR2_Output` writer"] pub type W = crate :: W < Ccmr2OutputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC3FE` reader - Output compare 3 fast enable"] pub type Oc3feR = crate :: BitReader ;
#[doc = "Field `OC3FE` writer - Output compare 3 fast enable"] pub type Oc3feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3PE` reader - Output compare 3 preload enable"] pub type Oc3peR = crate :: BitReader ;
#[doc = "Field `OC3PE` writer - Output compare 3 preload enable"] pub type Oc3peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M` reader - Output compare 3 mode"] pub type Oc3mR = crate :: FieldReader ;
#[doc = "Field `OC3M` writer - Output compare 3 mode"] pub type Oc3mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC3CE` reader - Output compare 3 clear enable"] pub type Oc3ceR = crate :: BitReader ;
#[doc = "Field `OC3CE` writer - Output compare 3 clear enable"] pub type Oc3ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC4FE` reader - Output compare 4 fast enable"] pub type Oc4feR = crate :: BitReader ;
#[doc = "Field `OC4FE` writer - Output compare 4 fast enable"] pub type Oc4feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4PE` reader - Output compare 4 preload enable"] pub type Oc4peR = crate :: BitReader ;
#[doc = "Field `OC4PE` writer - Output compare 4 preload enable"] pub type Oc4peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M` reader - Output compare 4 mode"] pub type Oc4mR = crate :: FieldReader ;
#[doc = "Field `OC4M` writer - Output compare 4 mode"] pub type Oc4mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `O24CE` reader - Output compare 4 clear enable"] pub type O24ceR = crate :: BitReader ;
#[doc = "Field `O24CE` writer - Output compare 4 clear enable"] pub type O24ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& self) -> Oc3feR { Oc3feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& self) -> Oc3peR { Oc3peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& self) -> Oc3mR { Oc3mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& self) -> Oc3ceR { Oc3ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& self) -> Oc4feR { Oc4feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& self) -> Oc4peR { Oc4peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& self) -> Oc4mR { Oc4mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn o24ce (& self) -> O24ceR { O24ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2OutputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& mut self) -> Oc3feW < '_ , Ccmr2OutputSpec > { Oc3feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& mut self) -> Oc3peW < '_ , Ccmr2OutputSpec > { Oc3peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& mut self) -> Oc3mW < '_ , Ccmr2OutputSpec > { Oc3mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& mut self) -> Oc3ceW < '_ , Ccmr2OutputSpec > { Oc3ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2OutputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& mut self) -> Oc4feW < '_ , Ccmr2OutputSpec > { Oc4feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& mut self) -> Oc4peW < '_ , Ccmr2OutputSpec > { Oc4peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& mut self) -> Oc4mW < '_ , Ccmr2OutputSpec > { Oc4mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn o24ce (& mut self) -> O24ceW < '_ , Ccmr2OutputSpec > { O24ceW :: new (self , 15) } }
#[doc = "capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2OutputSpec ; impl crate :: RegisterSpec for Ccmr2OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_output::R`](R) reader structure"] impl crate :: Readable for Ccmr2OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_output::W`](W) writer structure"] impl crate :: Writable for Ccmr2OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Output to value 0"] impl crate :: Resettable for Ccmr2OutputSpec { } }
#[doc = "CCMR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_input`] module"]
#[doc (alias = "CCMR2_Input")] pub type Ccmr2Input = crate :: Reg < ccmr2_input :: Ccmr2InputSpec > ;
#[doc = "capture/compare mode register 2 (input mode)"] pub mod ccmr2_input {
#[doc = "Register `CCMR2_Input` reader"] pub type R = crate :: R < Ccmr2InputSpec > ;
#[doc = "Register `CCMR2_Input` writer"] pub type W = crate :: W < Ccmr2InputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3PSC` reader - Input capture 3 prescaler"] pub type Ic3pscR = crate :: FieldReader ;
#[doc = "Field `IC3PSC` writer - Input capture 3 prescaler"] pub type Ic3pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3F` reader - Input capture 3 filter"] pub type Ic3fR = crate :: FieldReader ;
#[doc = "Field `IC3F` writer - Input capture 3 filter"] pub type Ic3fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4PSC` reader - Input capture 4 prescaler"] pub type Ic4pscR = crate :: FieldReader ;
#[doc = "Field `IC4PSC` writer - Input capture 4 prescaler"] pub type Ic4pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4F` reader - Input capture 4 filter"] pub type Ic4fR = crate :: FieldReader ;
#[doc = "Field `IC4F` writer - Input capture 4 filter"] pub type Ic4fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& self) -> Ic3pscR { Ic3pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& self) -> Ic3fR { Ic3fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& self) -> Ic4pscR { Ic4pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& self) -> Ic4fR { Ic4fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2InputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& mut self) -> Ic3pscW < '_ , Ccmr2InputSpec > { Ic3pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& mut self) -> Ic3fW < '_ , Ccmr2InputSpec > { Ic3fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2InputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& mut self) -> Ic4pscW < '_ , Ccmr2InputSpec > { Ic4pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& mut self) -> Ic4fW < '_ , Ccmr2InputSpec > { Ic4fW :: new (self , 12) } }
#[doc = "capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2InputSpec ; impl crate :: RegisterSpec for Ccmr2InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_input::R`](R) reader structure"] impl crate :: Readable for Ccmr2InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_input::W`](W) writer structure"] impl crate :: Writable for Ccmr2InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Input to value 0"] impl crate :: Resettable for Ccmr2InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output Polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output Polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2E` reader - Capture/Compare 2 output enable"] pub type Cc2eR = crate :: BitReader ;
#[doc = "Field `CC2E` writer - Capture/Compare 2 output enable"] pub type Cc2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2P` reader - Capture/Compare 2 output Polarity"] pub type Cc2pR = crate :: BitReader ;
#[doc = "Field `CC2P` writer - Capture/Compare 2 output Polarity"] pub type Cc2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3E` reader - Capture/Compare 3 output enable"] pub type Cc3eR = crate :: BitReader ;
#[doc = "Field `CC3E` writer - Capture/Compare 3 output enable"] pub type Cc3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3P` reader - Capture/Compare 3 output Polarity"] pub type Cc3pR = crate :: BitReader ;
#[doc = "Field `CC3P` writer - Capture/Compare 3 output Polarity"] pub type Cc3pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4E` reader - Capture/Compare 4 output enable"] pub type Cc4eR = crate :: BitReader ;
#[doc = "Field `CC4E` writer - Capture/Compare 4 output enable"] pub type Cc4eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4P` reader - Capture/Compare 3 output Polarity"] pub type Cc4pR = crate :: BitReader ;
#[doc = "Field `CC4P` writer - Capture/Compare 3 output Polarity"] pub type Cc4pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& self) -> Cc2eR { Cc2eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& self) -> Cc2pR { Cc2pR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& self) -> Cc3eR { Cc3eR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3p (& self) -> Cc3pR { Cc3pR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& self) -> Cc4eR { Cc4eR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc4p (& self) -> Cc4pR { Cc4pR :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& mut self) -> Cc2eW < '_ , CcerSpec > { Cc2eW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& mut self) -> Cc2pW < '_ , CcerSpec > { Cc2pW :: new (self , 5) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& mut self) -> Cc3eW < '_ , CcerSpec > { Cc3eW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc3p (& mut self) -> Cc3pW < '_ , CcerSpec > { Cc3pW :: new (self , 9) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& mut self) -> Cc4eW < '_ , CcerSpec > { Cc4eW :: new (self , 12) }
#[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
#[inline (always)] pub fn cc4p (& mut self) -> Cc4pW < '_ , CcerSpec > { Cc4pW :: new (self , 13) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "capture/compare register 2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `CCR2` reader - Capture/Compare 2 value"] pub type Ccr2R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR2` writer - Capture/Compare 2 value"] pub type Ccr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& self) -> Ccr2R { Ccr2R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& mut self) -> Ccr2W < '_ , Ccr2Spec > { Ccr2W :: new (self , 0) } }
#[doc = "capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CCR3 (rw) register accessor: capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "capture/compare register 3"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `CCR3` reader - Capture/Compare value"] pub type Ccr3R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR3` writer - Capture/Compare value"] pub type Ccr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr3 (& self) -> Ccr3R { Ccr3R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr3 (& mut self) -> Ccr3W < '_ , Ccr3Spec > { Ccr3W :: new (self , 0) } }
#[doc = "capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CCR4 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `CCR4` reader - Capture/Compare value"] pub type Ccr4R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR4` writer - Capture/Compare value"] pub type Ccr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr4 (& self) -> Ccr4R { Ccr4R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare value"]
#[inline (always)] pub fn ccr4 (& mut self) -> Ccr4W < '_ , Ccr4Spec > { Ccr4W :: new (self , 0) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "DCR (rw) register accessor: DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` reader"] pub type R = crate :: R < DcrSpec > ;
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` reader - DMA base address"] pub type DbaR = crate :: FieldReader ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` reader - DMA burst length"] pub type DblR = crate :: FieldReader ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& self) -> DbaR { DbaR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& self) -> DblR { DblR :: new (((self . bits >> 8) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dcr::R`](R) reader structure"] impl crate :: Readable for DcrSpec { }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (rw) register accessor: DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` reader"] pub type R = crate :: R < DmarSpec > ;
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` reader - DMA register for burst accesses"] pub type DmabR = crate :: FieldReader < u16 > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& self) -> DmabR { DmabR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`read`](crate::Reg::read) this register and get [`dmar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmar::R`](R) reader structure"] impl crate :: Readable for DmarSpec { }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } } }
#[doc = "General purpose timer"] pub type Tim3 = crate :: Periph < tim2 :: RegisterBlock , 0x4000_0400 > ; impl core :: fmt :: Debug for Tim3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim3") . finish () } }
#[doc = "General purpose timer"] pub use self :: tim2 as tim3 ;
#[doc = "General purpose timer"] pub type Tim4 = crate :: Periph < tim2 :: RegisterBlock , 0x4000_0800 > ; impl core :: fmt :: Debug for Tim4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim4") . finish () } }
#[doc = "General purpose timer"] pub use self :: tim2 as tim4 ;
#[doc = "General purpose timer"] pub type Tim5 = crate :: Periph < tim2 :: RegisterBlock , 0x4000_0c00 > ; impl core :: fmt :: Debug for Tim5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim5") . finish () } }
#[doc = "General purpose timer"] pub use self :: tim2 as tim5 ;
#[doc = "General purpose timer"] pub type Tim9 = crate :: Periph < tim9 :: RegisterBlock , 0x4001_4c00 > ; impl core :: fmt :: Debug for Tim9 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim9") . finish () } }
#[doc = "General purpose timer"] pub mod tim9 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , smcr : Smcr , dier : Dier , sr : Sr , egr : Egr , _reserved_6_ccmr1 : [u8 ; 0x04] , _reserved7 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , _reserved11 : [u8 ; 0x04] , ccr1 : Ccr1 , ccr2 : Ccr2 , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - slave mode control register"]
#[inline (always)] pub const fn smcr (& self) -> & Smcr { & self . smcr }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x38 - capture/compare register 2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) } } impl W {
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMCR (rw) register accessor: slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smcr`] module"]
#[doc (alias = "SMCR")] pub type Smcr = crate :: Reg < smcr :: SmcrSpec > ;
#[doc = "slave mode control register"] pub mod smcr {
#[doc = "Register `SMCR` reader"] pub type R = crate :: R < SmcrSpec > ;
#[doc = "Register `SMCR` writer"] pub type W = crate :: W < SmcrSpec > ;
#[doc = "Field `SMS` reader - Slave mode selection"] pub type SmsR = crate :: FieldReader ;
#[doc = "Field `SMS` writer - Slave mode selection"] pub type SmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TS` reader - Trigger selection"] pub type TsR = crate :: FieldReader ;
#[doc = "Field `TS` writer - Trigger selection"] pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSM` reader - Master/Slave mode"] pub type MsmR = crate :: BitReader ;
#[doc = "Field `MSM` writer - Master/Slave mode"] pub type MsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& self) -> SmsR { SmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& self) -> MsmR { MsmR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& mut self) -> SmsW < '_ , SmcrSpec > { SmsW :: new (self , 0) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , SmcrSpec > { TsW :: new (self , 4) }
#[doc = "Bit 7 - Master/Slave mode"]
#[inline (always)] pub fn msm (& mut self) -> MsmW < '_ , SmcrSpec > { MsmW :: new (self , 7) } }
#[doc = "slave mode control register\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmcrSpec ; impl crate :: RegisterSpec for SmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smcr::R`](R) reader structure"] impl crate :: Readable for SmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`smcr::W`](W) writer structure"] impl crate :: Writable for SmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMCR to value 0"] impl crate :: Resettable for SmcrSpec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IE` reader - Capture/Compare 2 interrupt enable"] pub type Cc2ieR = crate :: BitReader ;
#[doc = "Field `CC2IE` writer - Capture/Compare 2 interrupt enable"] pub type Cc2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIE` reader - Trigger interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Trigger interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& self) -> Cc2ieR { Cc2ieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& mut self) -> Cc2ieW < '_ , DierSpec > { Cc2ieW :: new (self , 2) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DierSpec > { TieW :: new (self , 6) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IF` reader - Capture/Compare 2 interrupt flag"] pub type Cc2ifR = crate :: BitReader ;
#[doc = "Field `CC2IF` writer - Capture/Compare 2 interrupt flag"] pub type Cc2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIF` reader - Trigger interrupt flag"] pub type TifR = crate :: BitReader ;
#[doc = "Field `TIF` writer - Trigger interrupt flag"] pub type TifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2OF` reader - Capture/compare 2 overcapture flag"] pub type Cc2ofR = crate :: BitReader ;
#[doc = "Field `CC2OF` writer - Capture/compare 2 overcapture flag"] pub type Cc2ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& self) -> Cc2ifR { Cc2ifR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& self) -> Cc2ofR { Cc2ofR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& mut self) -> Cc2ifW < '_ , SrSpec > { Cc2ifW :: new (self , 2) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& mut self) -> TifW < '_ , SrSpec > { TifW :: new (self , 6) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) }
#[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& mut self) -> Cc2ofW < '_ , SrSpec > { Cc2ofW :: new (self , 10) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2G` writer - Capture/compare 2 generation"] pub type Cc2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TG` writer - Trigger generation"] pub type TgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 2 - Capture/compare 2 generation"]
#[inline (always)] pub fn cc2g (& mut self) -> Cc2gW < '_ , EgrSpec > { Cc2gW :: new (self , 2) }
#[doc = "Bit 6 - Trigger generation"]
#[inline (always)] pub fn tg (& mut self) -> TgW < '_ , EgrSpec > { TgW :: new (self , 6) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output Compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output Compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output Compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output Compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output Compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output Compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC2FE` reader - Output Compare 2 fast enable"] pub type Oc2feR = crate :: BitReader ;
#[doc = "Field `OC2FE` writer - Output Compare 2 fast enable"] pub type Oc2feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2PE` reader - Output Compare 2 preload enable"] pub type Oc2peR = crate :: BitReader ;
#[doc = "Field `OC2PE` writer - Output Compare 2 preload enable"] pub type Oc2peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M` reader - Output Compare 2 mode"] pub type Oc2mR = crate :: FieldReader ;
#[doc = "Field `OC2M` writer - Output Compare 2 mode"] pub type Oc2mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output Compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& self) -> Oc2feR { Oc2feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output Compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& self) -> Oc2peR { Oc2peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output Compare 2 mode"]
#[inline (always)] pub fn oc2m (& self) -> Oc2mR { Oc2mR :: new (((self . bits >> 12) & 7) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output Compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1OutputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bit 10 - Output Compare 2 fast enable"]
#[inline (always)] pub fn oc2fe (& mut self) -> Oc2feW < '_ , Ccmr1OutputSpec > { Oc2feW :: new (self , 10) }
#[doc = "Bit 11 - Output Compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& mut self) -> Oc2peW < '_ , Ccmr1OutputSpec > { Oc2peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output Compare 2 mode"]
#[inline (always)] pub fn oc2m (& mut self) -> Oc2mW < '_ , Ccmr1OutputSpec > { Oc2mW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2PSC` reader - Input capture 2 prescaler"] pub type Ic2pscR = crate :: FieldReader ;
#[doc = "Field `IC2PSC` writer - Input capture 2 prescaler"] pub type Ic2pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2F` reader - Input capture 2 filter"] pub type Ic2fR = crate :: FieldReader ;
#[doc = "Field `IC2F` writer - Input capture 2 filter"] pub type Ic2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& self) -> Ic2pscR { Ic2pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& self) -> Ic2fR { Ic2fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1InputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& mut self) -> Ic2pscW < '_ , Ccmr1InputSpec > { Ic2pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& mut self) -> Ic2fW < '_ , Ccmr1InputSpec > { Ic2fW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output Polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output Polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 output Polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 output Polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2E` reader - Capture/Compare 2 output enable"] pub type Cc2eR = crate :: BitReader ;
#[doc = "Field `CC2E` writer - Capture/Compare 2 output enable"] pub type Cc2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2P` reader - Capture/Compare 2 output Polarity"] pub type Cc2pR = crate :: BitReader ;
#[doc = "Field `CC2P` writer - Capture/Compare 2 output Polarity"] pub type Cc2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2NP` reader - Capture/Compare 2 output Polarity"] pub type Cc2npR = crate :: BitReader ;
#[doc = "Field `CC2NP` writer - Capture/Compare 2 output Polarity"] pub type Cc2npW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& self) -> Cc2eR { Cc2eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& self) -> Cc2pR { Cc2pR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2np (& self) -> Cc2npR { Cc2npR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& mut self) -> Cc2eW < '_ , CcerSpec > { Cc2eW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2p (& mut self) -> Cc2pW < '_ , CcerSpec > { Cc2pW :: new (self , 5) }
#[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
#[inline (always)] pub fn cc2np (& mut self) -> Cc2npW < '_ , CcerSpec > { Cc2npW :: new (self , 7) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "capture/compare register 2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `CCR2` reader - Capture/Compare 2 value"] pub type Ccr2R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR2` writer - Capture/Compare 2 value"] pub type Ccr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& self) -> Ccr2R { Ccr2R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& mut self) -> Ccr2W < '_ , Ccr2Spec > { Ccr2W :: new (self , 0) } }
#[doc = "capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } } }
#[doc = "General purpose timer"] pub type Tim12 = crate :: Periph < tim9 :: RegisterBlock , 0x4000_1800 > ; impl core :: fmt :: Debug for Tim12 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim12") . finish () } }
#[doc = "General purpose timer"] pub use self :: tim9 as tim12 ;
#[doc = "General purpose timer"] pub type Tim10 = crate :: Periph < tim10 :: RegisterBlock , 0x4001_5000 > ; impl core :: fmt :: Debug for Tim10 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim10") . finish () } }
#[doc = "General purpose timer"] pub mod tim10 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , _reserved2 : [u8 ; 0x04] , dier : Dier , sr : Sr , egr : Egr , _reserved_5_ccmr1 : [u8 ; 0x04] , _reserved6 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , _reserved10 : [u8 ; 0x04] , ccr1 : Ccr1 , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) } } impl W {
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1PE` reader - Output Compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output Compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output Compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output Compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 3 - Output Compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output Compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) } }
#[doc = "capture/compare mode register (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) } }
#[doc = "capture/compare mode register (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output Polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output Polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 output Polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 output Polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } } }
#[doc = "General purpose timer"] pub type Tim11 = crate :: Periph < tim10 :: RegisterBlock , 0x4001_5400 > ; impl core :: fmt :: Debug for Tim11 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim11") . finish () } }
#[doc = "General purpose timer"] pub use self :: tim10 as tim11 ;
#[doc = "General purpose timer"] pub type Tim13 = crate :: Periph < tim10 :: RegisterBlock , 0x4000_1c00 > ; impl core :: fmt :: Debug for Tim13 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim13") . finish () } }
#[doc = "General purpose timer"] pub use self :: tim10 as tim13 ;
#[doc = "General purpose timer"] pub type Tim14 = crate :: Periph < tim10 :: RegisterBlock , 0x4000_2000 > ; impl core :: fmt :: Debug for Tim14 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim14") . finish () } }
#[doc = "General purpose timer"] pub use self :: tim10 as tim14 ;
#[doc = "Basic timer"] pub type Tim6 = crate :: Periph < tim6 :: RegisterBlock , 0x4000_1000 > ; impl core :: fmt :: Debug for Tim6 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim6") . finish () } }
#[doc = "Basic timer"] pub mod tim6 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , _reserved2 : [u8 ; 0x04] , dier : Dier , sr : Sr , egr : Egr , _reserved5 : [u8 ; 0x0c] , cnt : Cnt , psc : Psc , arr : Arr , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One-pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) } } impl W {
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - Low counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - Low counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Low counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Low counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Low Auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Low Auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Low Auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Low Auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } } }
#[doc = "Basic timer"] pub type Tim7 = crate :: Periph < tim6 :: RegisterBlock , 0x4000_1400 > ; impl core :: fmt :: Debug for Tim7 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim7") . finish () } }
#[doc = "Basic timer"] pub use self :: tim6 as tim7 ;
#[doc = "Inter integrated circuit"] pub type I2c1 = crate :: Periph < i2c1 :: RegisterBlock , 0x4000_5400 > ; impl core :: fmt :: Debug for I2c1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c1") . finish () } }
#[doc = "Inter integrated circuit"] pub mod i2c1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , oar1 : Oar1 , oar2 : Oar2 , dr : Dr , sr1 : Sr1 , sr2 : Sr2 , ccr : Ccr , trise : Trise , } impl RegisterBlock {
#[doc = "0x00 - Control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - Control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - Own address register 1"]
#[inline (always)] pub const fn oar1 (& self) -> & Oar1 { & self . oar1 }
#[doc = "0x0c - Own address register 2"]
#[inline (always)] pub const fn oar2 (& self) -> & Oar2 { & self . oar2 }
#[doc = "0x10 - Data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x14 - Status register 1"]
#[inline (always)] pub const fn sr1 (& self) -> & Sr1 { & self . sr1 }
#[doc = "0x18 - Status register 2"]
#[inline (always)] pub const fn sr2 (& self) -> & Sr2 { & self . sr2 }
#[doc = "0x1c - Clock control register"]
#[inline (always)] pub const fn ccr (& self) -> & Ccr { & self . ccr }
#[doc = "0x20 - TRISE register"]
#[inline (always)] pub const fn trise (& self) -> & Trise { & self . trise } }
#[doc = "CR1 (rw) register accessor: Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "Control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `PE` reader - Peripheral enable"] pub type PeR = crate :: BitReader ;
#[doc = "Field `PE` writer - Peripheral enable"] pub type PeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMBUS` reader - SMBus mode"] pub type SmbusR = crate :: BitReader ;
#[doc = "Field `SMBUS` writer - SMBus mode"] pub type SmbusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMBTYPE` reader - SMBus type"] pub type SmbtypeR = crate :: BitReader ;
#[doc = "Field `SMBTYPE` writer - SMBus type"] pub type SmbtypeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENARP` reader - ARP enable"] pub type EnarpR = crate :: BitReader ;
#[doc = "Field `ENARP` writer - ARP enable"] pub type EnarpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENPEC` reader - PEC enable"] pub type EnpecR = crate :: BitReader ;
#[doc = "Field `ENPEC` writer - PEC enable"] pub type EnpecW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENGC` reader - General call enable"] pub type EngcR = crate :: BitReader ;
#[doc = "Field `ENGC` writer - General call enable"] pub type EngcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NOSTRETCH` reader - Clock stretching disable (Slave mode)"] pub type NostretchR = crate :: BitReader ;
#[doc = "Field `NOSTRETCH` writer - Clock stretching disable (Slave mode)"] pub type NostretchW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `START` reader - Start generation"] pub type StartR = crate :: BitReader ;
#[doc = "Field `START` writer - Start generation"] pub type StartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOP` reader - Stop generation"] pub type StopR = crate :: BitReader ;
#[doc = "Field `STOP` writer - Stop generation"] pub type StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - Acknowledge enable"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - Acknowledge enable"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `POS` reader - Acknowledge/PEC Position (for data reception)"] pub type PosR = crate :: BitReader ;
#[doc = "Field `POS` writer - Acknowledge/PEC Position (for data reception)"] pub type PosW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PEC` reader - Packet error checking"] pub type PecR = crate :: BitReader ;
#[doc = "Field `PEC` writer - Packet error checking"] pub type PecW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALERT` reader - SMBus alert"] pub type AlertR = crate :: BitReader ;
#[doc = "Field `ALERT` writer - SMBus alert"] pub type AlertW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWRST` reader - Software reset"] pub type SwrstR = crate :: BitReader ;
#[doc = "Field `SWRST` writer - Software reset"] pub type SwrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Peripheral enable"]
#[inline (always)] pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - SMBus mode"]
#[inline (always)] pub fn smbus (& self) -> SmbusR { SmbusR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - SMBus type"]
#[inline (always)] pub fn smbtype (& self) -> SmbtypeR { SmbtypeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ARP enable"]
#[inline (always)] pub fn enarp (& self) -> EnarpR { EnarpR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - PEC enable"]
#[inline (always)] pub fn enpec (& self) -> EnpecR { EnpecR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - General call enable"]
#[inline (always)] pub fn engc (& self) -> EngcR { EngcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Clock stretching disable (Slave mode)"]
#[inline (always)] pub fn nostretch (& self) -> NostretchR { NostretchR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Start generation"]
#[inline (always)] pub fn start (& self) -> StartR { StartR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Stop generation"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Acknowledge enable"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Acknowledge/PEC Position (for data reception)"]
#[inline (always)] pub fn pos (& self) -> PosR { PosR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Packet error checking"]
#[inline (always)] pub fn pec (& self) -> PecR { PecR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - SMBus alert"]
#[inline (always)] pub fn alert (& self) -> AlertR { AlertR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 15 - Software reset"]
#[inline (always)] pub fn swrst (& self) -> SwrstR { SwrstR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Peripheral enable"]
#[inline (always)] pub fn pe (& mut self) -> PeW < '_ , Cr1Spec > { PeW :: new (self , 0) }
#[doc = "Bit 1 - SMBus mode"]
#[inline (always)] pub fn smbus (& mut self) -> SmbusW < '_ , Cr1Spec > { SmbusW :: new (self , 1) }
#[doc = "Bit 3 - SMBus type"]
#[inline (always)] pub fn smbtype (& mut self) -> SmbtypeW < '_ , Cr1Spec > { SmbtypeW :: new (self , 3) }
#[doc = "Bit 4 - ARP enable"]
#[inline (always)] pub fn enarp (& mut self) -> EnarpW < '_ , Cr1Spec > { EnarpW :: new (self , 4) }
#[doc = "Bit 5 - PEC enable"]
#[inline (always)] pub fn enpec (& mut self) -> EnpecW < '_ , Cr1Spec > { EnpecW :: new (self , 5) }
#[doc = "Bit 6 - General call enable"]
#[inline (always)] pub fn engc (& mut self) -> EngcW < '_ , Cr1Spec > { EngcW :: new (self , 6) }
#[doc = "Bit 7 - Clock stretching disable (Slave mode)"]
#[inline (always)] pub fn nostretch (& mut self) -> NostretchW < '_ , Cr1Spec > { NostretchW :: new (self , 7) }
#[doc = "Bit 8 - Start generation"]
#[inline (always)] pub fn start (& mut self) -> StartW < '_ , Cr1Spec > { StartW :: new (self , 8) }
#[doc = "Bit 9 - Stop generation"]
#[inline (always)] pub fn stop (& mut self) -> StopW < '_ , Cr1Spec > { StopW :: new (self , 9) }
#[doc = "Bit 10 - Acknowledge enable"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , Cr1Spec > { AckW :: new (self , 10) }
#[doc = "Bit 11 - Acknowledge/PEC Position (for data reception)"]
#[inline (always)] pub fn pos (& mut self) -> PosW < '_ , Cr1Spec > { PosW :: new (self , 11) }
#[doc = "Bit 12 - Packet error checking"]
#[inline (always)] pub fn pec (& mut self) -> PecW < '_ , Cr1Spec > { PecW :: new (self , 12) }
#[doc = "Bit 13 - SMBus alert"]
#[inline (always)] pub fn alert (& mut self) -> AlertW < '_ , Cr1Spec > { AlertW :: new (self , 13) }
#[doc = "Bit 15 - Software reset"]
#[inline (always)] pub fn swrst (& mut self) -> SwrstW < '_ , Cr1Spec > { SwrstW :: new (self , 15) } }
#[doc = "Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "Control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `FREQ` reader - Peripheral clock frequency"] pub type FreqR = crate :: FieldReader ;
#[doc = "Field `FREQ` writer - Peripheral clock frequency"] pub type FreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `ITERREN` reader - Error interrupt enable"] pub type IterrenR = crate :: BitReader ;
#[doc = "Field `ITERREN` writer - Error interrupt enable"] pub type IterrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITEVTEN` reader - Event interrupt enable"] pub type ItevtenR = crate :: BitReader ;
#[doc = "Field `ITEVTEN` writer - Event interrupt enable"] pub type ItevtenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITBUFEN` reader - Buffer interrupt enable"] pub type ItbufenR = crate :: BitReader ;
#[doc = "Field `ITBUFEN` writer - Buffer interrupt enable"] pub type ItbufenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAEN` reader - DMA requests enable"] pub type DmaenR = crate :: BitReader ;
#[doc = "Field `DMAEN` writer - DMA requests enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LAST` reader - DMA last transfer"] pub type LastR = crate :: BitReader ;
#[doc = "Field `LAST` writer - DMA last transfer"] pub type LastW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:5 - Peripheral clock frequency"]
#[inline (always)] pub fn freq (& self) -> FreqR { FreqR :: new ((self . bits & 0x3f) as u8) }
#[doc = "Bit 8 - Error interrupt enable"]
#[inline (always)] pub fn iterren (& self) -> IterrenR { IterrenR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event interrupt enable"]
#[inline (always)] pub fn itevten (& self) -> ItevtenR { ItevtenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Buffer interrupt enable"]
#[inline (always)] pub fn itbufen (& self) -> ItbufenR { ItbufenR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - DMA requests enable"]
#[inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - DMA last transfer"]
#[inline (always)] pub fn last (& self) -> LastR { LastR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bits 0:5 - Peripheral clock frequency"]
#[inline (always)] pub fn freq (& mut self) -> FreqW < '_ , Cr2Spec > { FreqW :: new (self , 0) }
#[doc = "Bit 8 - Error interrupt enable"]
#[inline (always)] pub fn iterren (& mut self) -> IterrenW < '_ , Cr2Spec > { IterrenW :: new (self , 8) }
#[doc = "Bit 9 - Event interrupt enable"]
#[inline (always)] pub fn itevten (& mut self) -> ItevtenW < '_ , Cr2Spec > { ItevtenW :: new (self , 9) }
#[doc = "Bit 10 - Buffer interrupt enable"]
#[inline (always)] pub fn itbufen (& mut self) -> ItbufenW < '_ , Cr2Spec > { ItbufenW :: new (self , 10) }
#[doc = "Bit 11 - DMA requests enable"]
#[inline (always)] pub fn dmaen (& mut self) -> DmaenW < '_ , Cr2Spec > { DmaenW :: new (self , 11) }
#[doc = "Bit 12 - DMA last transfer"]
#[inline (always)] pub fn last (& mut self) -> LastW < '_ , Cr2Spec > { LastW :: new (self , 12) } }
#[doc = "Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "OAR1 (rw) register accessor: Own address register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oar1`] module"]
#[doc (alias = "OAR1")] pub type Oar1 = crate :: Reg < oar1 :: Oar1Spec > ;
#[doc = "Own address register 1"] pub mod oar1 {
#[doc = "Register `OAR1` reader"] pub type R = crate :: R < Oar1Spec > ;
#[doc = "Register `OAR1` writer"] pub type W = crate :: W < Oar1Spec > ;
#[doc = "Field `ADD0` reader - Interface address"] pub type Add0R = crate :: BitReader ;
#[doc = "Field `ADD0` writer - Interface address"] pub type Add0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADD7` reader - Interface address"] pub type Add7R = crate :: FieldReader ;
#[doc = "Field `ADD7` writer - Interface address"] pub type Add7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ADD10` reader - Interface address"] pub type Add10R = crate :: FieldReader ;
#[doc = "Field `ADD10` writer - Interface address"] pub type Add10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ADDMODE` reader - Addressing mode (slave mode)"] pub type AddmodeR = crate :: BitReader ;
#[doc = "Field `ADDMODE` writer - Addressing mode (slave mode)"] pub type AddmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Interface address"]
#[inline (always)] pub fn add0 (& self) -> Add0R { Add0R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:7 - Interface address"]
#[inline (always)] pub fn add7 (& self) -> Add7R { Add7R :: new (((self . bits >> 1) & 0x7f) as u8) }
#[doc = "Bits 8:9 - Interface address"]
#[inline (always)] pub fn add10 (& self) -> Add10R { Add10R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 15 - Addressing mode (slave mode)"]
#[inline (always)] pub fn addmode (& self) -> AddmodeR { AddmodeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Interface address"]
#[inline (always)] pub fn add0 (& mut self) -> Add0W < '_ , Oar1Spec > { Add0W :: new (self , 0) }
#[doc = "Bits 1:7 - Interface address"]
#[inline (always)] pub fn add7 (& mut self) -> Add7W < '_ , Oar1Spec > { Add7W :: new (self , 1) }
#[doc = "Bits 8:9 - Interface address"]
#[inline (always)] pub fn add10 (& mut self) -> Add10W < '_ , Oar1Spec > { Add10W :: new (self , 8) }
#[doc = "Bit 15 - Addressing mode (slave mode)"]
#[inline (always)] pub fn addmode (& mut self) -> AddmodeW < '_ , Oar1Spec > { AddmodeW :: new (self , 15) } }
#[doc = "Own address register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Oar1Spec ; impl crate :: RegisterSpec for Oar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`oar1::R`](R) reader structure"] impl crate :: Readable for Oar1Spec { }
#[doc = "`write(|w| ..)` method takes [`oar1::W`](W) writer structure"] impl crate :: Writable for Oar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OAR1 to value 0"] impl crate :: Resettable for Oar1Spec { } }
#[doc = "OAR2 (rw) register accessor: Own address register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oar2`] module"]
#[doc (alias = "OAR2")] pub type Oar2 = crate :: Reg < oar2 :: Oar2Spec > ;
#[doc = "Own address register 2"] pub mod oar2 {
#[doc = "Register `OAR2` reader"] pub type R = crate :: R < Oar2Spec > ;
#[doc = "Register `OAR2` writer"] pub type W = crate :: W < Oar2Spec > ;
#[doc = "Field `ENDUAL` reader - Dual addressing mode enable"] pub type EndualR = crate :: BitReader ;
#[doc = "Field `ENDUAL` writer - Dual addressing mode enable"] pub type EndualW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADD2` reader - Interface address"] pub type Add2R = crate :: FieldReader ;
#[doc = "Field `ADD2` writer - Interface address"] pub type Add2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; impl R {
#[doc = "Bit 0 - Dual addressing mode enable"]
#[inline (always)] pub fn endual (& self) -> EndualR { EndualR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:7 - Interface address"]
#[inline (always)] pub fn add2 (& self) -> Add2R { Add2R :: new (((self . bits >> 1) & 0x7f) as u8) } } impl W {
#[doc = "Bit 0 - Dual addressing mode enable"]
#[inline (always)] pub fn endual (& mut self) -> EndualW < '_ , Oar2Spec > { EndualW :: new (self , 0) }
#[doc = "Bits 1:7 - Interface address"]
#[inline (always)] pub fn add2 (& mut self) -> Add2W < '_ , Oar2Spec > { Add2W :: new (self , 1) } }
#[doc = "Own address register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Oar2Spec ; impl crate :: RegisterSpec for Oar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`oar2::R`](R) reader structure"] impl crate :: Readable for Oar2Spec { }
#[doc = "`write(|w| ..)` method takes [`oar2::W`](W) writer structure"] impl crate :: Writable for Oar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OAR2 to value 0"] impl crate :: Resettable for Oar2Spec { } }
#[doc = "DR (rw) register accessor: Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "Data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - 8-bit data register"] pub type DrR = crate :: FieldReader ;
#[doc = "Field `DR` writer - 8-bit data register"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - 8-bit data register"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - 8-bit data register"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "SR1 (rw) register accessor: Status register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr1`] module"]
#[doc (alias = "SR1")] pub type Sr1 = crate :: Reg < sr1 :: Sr1Spec > ;
#[doc = "Status register 1"] pub mod sr1 {
#[doc = "Register `SR1` reader"] pub type R = crate :: R < Sr1Spec > ;
#[doc = "Register `SR1` writer"] pub type W = crate :: W < Sr1Spec > ;
#[doc = "Field `SB` reader - Start bit (Master mode)"] pub type SbR = crate :: BitReader ;
#[doc = "Field `ADDR` reader - Address sent (master mode)/matched (slave mode)"] pub type AddrR = crate :: BitReader ;
#[doc = "Field `BTF` reader - Byte transfer finished"] pub type BtfR = crate :: BitReader ;
#[doc = "Field `ADD10` reader - 10-bit header sent (Master mode)"] pub type Add10R = crate :: BitReader ;
#[doc = "Field `STOPF` reader - Stop detection (slave mode)"] pub type StopfR = crate :: BitReader ;
#[doc = "Field `RxNE` reader - Data register not empty (receivers)"] pub type RxNeR = crate :: BitReader ;
#[doc = "Field `TxE` reader - Data register empty (transmitters)"] pub type TxER = crate :: BitReader ;
#[doc = "Field `BERR` reader - Bus error"] pub type BerrR = crate :: BitReader ;
#[doc = "Field `BERR` writer - Bus error"] pub type BerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARLO` reader - Arbitration lost (master mode)"] pub type ArloR = crate :: BitReader ;
#[doc = "Field `ARLO` writer - Arbitration lost (master mode)"] pub type ArloW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AF` reader - Acknowledge failure"] pub type AfR = crate :: BitReader ;
#[doc = "Field `AF` writer - Acknowledge failure"] pub type AfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OVR` reader - Overrun/Underrun"] pub type OvrR = crate :: BitReader ;
#[doc = "Field `OVR` writer - Overrun/Underrun"] pub type OvrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PECERR` reader - PEC Error in reception"] pub type PecerrR = crate :: BitReader ;
#[doc = "Field `PECERR` writer - PEC Error in reception"] pub type PecerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIMEOUT` reader - Timeout or Tlow error"] pub type TimeoutR = crate :: BitReader ;
#[doc = "Field `TIMEOUT` writer - Timeout or Tlow error"] pub type TimeoutW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMBALERT` reader - SMBus alert"] pub type SmbalertR = crate :: BitReader ;
#[doc = "Field `SMBALERT` writer - SMBus alert"] pub type SmbalertW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Start bit (Master mode)"]
#[inline (always)] pub fn sb (& self) -> SbR { SbR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Address sent (master mode)/matched (slave mode)"]
#[inline (always)] pub fn addr (& self) -> AddrR { AddrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Byte transfer finished"]
#[inline (always)] pub fn btf (& self) -> BtfR { BtfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - 10-bit header sent (Master mode)"]
#[inline (always)] pub fn add10 (& self) -> Add10R { Add10R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Stop detection (slave mode)"]
#[inline (always)] pub fn stopf (& self) -> StopfR { StopfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Data register not empty (receivers)"]
#[inline (always)] pub fn rx_ne (& self) -> RxNeR { RxNeR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Data register empty (transmitters)"]
#[inline (always)] pub fn tx_e (& self) -> TxER { TxER :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Bus error"]
#[inline (always)] pub fn berr (& self) -> BerrR { BerrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Arbitration lost (master mode)"]
#[inline (always)] pub fn arlo (& self) -> ArloR { ArloR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Acknowledge failure"]
#[inline (always)] pub fn af (& self) -> AfR { AfR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Overrun/Underrun"]
#[inline (always)] pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - PEC Error in reception"]
#[inline (always)] pub fn pecerr (& self) -> PecerrR { PecerrR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - Timeout or Tlow error"]
#[inline (always)] pub fn timeout (& self) -> TimeoutR { TimeoutR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - SMBus alert"]
#[inline (always)] pub fn smbalert (& self) -> SmbalertR { SmbalertR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 8 - Bus error"]
#[inline (always)] pub fn berr (& mut self) -> BerrW < '_ , Sr1Spec > { BerrW :: new (self , 8) }
#[doc = "Bit 9 - Arbitration lost (master mode)"]
#[inline (always)] pub fn arlo (& mut self) -> ArloW < '_ , Sr1Spec > { ArloW :: new (self , 9) }
#[doc = "Bit 10 - Acknowledge failure"]
#[inline (always)] pub fn af (& mut self) -> AfW < '_ , Sr1Spec > { AfW :: new (self , 10) }
#[doc = "Bit 11 - Overrun/Underrun"]
#[inline (always)] pub fn ovr (& mut self) -> OvrW < '_ , Sr1Spec > { OvrW :: new (self , 11) }
#[doc = "Bit 12 - PEC Error in reception"]
#[inline (always)] pub fn pecerr (& mut self) -> PecerrW < '_ , Sr1Spec > { PecerrW :: new (self , 12) }
#[doc = "Bit 14 - Timeout or Tlow error"]
#[inline (always)] pub fn timeout (& mut self) -> TimeoutW < '_ , Sr1Spec > { TimeoutW :: new (self , 14) }
#[doc = "Bit 15 - SMBus alert"]
#[inline (always)] pub fn smbalert (& mut self) -> SmbalertW < '_ , Sr1Spec > { SmbalertW :: new (self , 15) } }
#[doc = "Status register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sr1Spec ; impl crate :: RegisterSpec for Sr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr1::R`](R) reader structure"] impl crate :: Readable for Sr1Spec { }
#[doc = "`write(|w| ..)` method takes [`sr1::W`](W) writer structure"] impl crate :: Writable for Sr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR1 to value 0"] impl crate :: Resettable for Sr1Spec { } }
#[doc = "SR2 (r) register accessor: Status register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr2`] module"]
#[doc (alias = "SR2")] pub type Sr2 = crate :: Reg < sr2 :: Sr2Spec > ;
#[doc = "Status register 2"] pub mod sr2 {
#[doc = "Register `SR2` reader"] pub type R = crate :: R < Sr2Spec > ;
#[doc = "Field `MSL` reader - Master/slave"] pub type MslR = crate :: BitReader ;
#[doc = "Field `BUSY` reader - Bus busy"] pub type BusyR = crate :: BitReader ;
#[doc = "Field `TRA` reader - Transmitter/receiver"] pub type TraR = crate :: BitReader ;
#[doc = "Field `GENCALL` reader - General call address (Slave mode)"] pub type GencallR = crate :: BitReader ;
#[doc = "Field `SMBDEFAULT` reader - SMBus device default address (Slave mode)"] pub type SmbdefaultR = crate :: BitReader ;
#[doc = "Field `SMBHOST` reader - SMBus host header (Slave mode)"] pub type SmbhostR = crate :: BitReader ;
#[doc = "Field `DUALF` reader - Dual flag (Slave mode)"] pub type DualfR = crate :: BitReader ;
#[doc = "Field `PEC` reader - acket error checking register"] pub type PecR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Master/slave"]
#[inline (always)] pub fn msl (& self) -> MslR { MslR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Bus busy"]
#[inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmitter/receiver"]
#[inline (always)] pub fn tra (& self) -> TraR { TraR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - General call address (Slave mode)"]
#[inline (always)] pub fn gencall (& self) -> GencallR { GencallR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - SMBus device default address (Slave mode)"]
#[inline (always)] pub fn smbdefault (& self) -> SmbdefaultR { SmbdefaultR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - SMBus host header (Slave mode)"]
#[inline (always)] pub fn smbhost (& self) -> SmbhostR { SmbhostR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Dual flag (Slave mode)"]
#[inline (always)] pub fn dualf (& self) -> DualfR { DualfR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:15 - acket error checking register"]
#[inline (always)] pub fn pec (& self) -> PecR { PecR :: new (((self . bits >> 8) & 0xff) as u8) } }
#[doc = "Status register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sr2Spec ; impl crate :: RegisterSpec for Sr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr2::R`](R) reader structure"] impl crate :: Readable for Sr2Spec { }
#[doc = "`reset()` method sets SR2 to value 0"] impl crate :: Resettable for Sr2Spec { } }
#[doc = "CCR (rw) register accessor: Clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr`] module"]
#[doc (alias = "CCR")] pub type Ccr = crate :: Reg < ccr :: CcrSpec > ;
#[doc = "Clock control register"] pub mod ccr {
#[doc = "Register `CCR` reader"] pub type R = crate :: R < CcrSpec > ;
#[doc = "Register `CCR` writer"] pub type W = crate :: W < CcrSpec > ;
#[doc = "Field `CCR` reader - Clock control register in Fast/Standard mode (Master mode)"] pub type CcrR = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR` writer - Clock control register in Fast/Standard mode (Master mode)"] pub type CcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `DUTY` reader - Fast mode duty cycle"] pub type DutyR = crate :: BitReader ;
#[doc = "Field `DUTY` writer - Fast mode duty cycle"] pub type DutyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_S` reader - I2C master mode selection"] pub type FSR = crate :: BitReader ;
#[doc = "Field `F_S` writer - I2C master mode selection"] pub type FSW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)"]
#[inline (always)] pub fn ccr (& self) -> CcrR { CcrR :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bit 14 - Fast mode duty cycle"]
#[inline (always)] pub fn duty (& self) -> DutyR { DutyR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - I2C master mode selection"]
#[inline (always)] pub fn f_s (& self) -> FSR { FSR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)"]
#[inline (always)] pub fn ccr (& mut self) -> CcrW < '_ , CcrSpec > { CcrW :: new (self , 0) }
#[doc = "Bit 14 - Fast mode duty cycle"]
#[inline (always)] pub fn duty (& mut self) -> DutyW < '_ , CcrSpec > { DutyW :: new (self , 14) }
#[doc = "Bit 15 - I2C master mode selection"]
#[inline (always)] pub fn f_s (& mut self) -> FSW < '_ , CcrSpec > { FSW :: new (self , 15) } }
#[doc = "Clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcrSpec ; impl crate :: RegisterSpec for CcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr::R`](R) reader structure"] impl crate :: Readable for CcrSpec { }
#[doc = "`write(|w| ..)` method takes [`ccr::W`](W) writer structure"] impl crate :: Writable for CcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR to value 0"] impl crate :: Resettable for CcrSpec { } }
#[doc = "TRISE (rw) register accessor: TRISE register\n\nYou can [`read`](crate::Reg::read) this register and get [`trise::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`trise::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@trise`] module"]
#[doc (alias = "TRISE")] pub type Trise = crate :: Reg < trise :: TriseSpec > ;
#[doc = "TRISE register"] pub mod trise {
#[doc = "Register `TRISE` reader"] pub type R = crate :: R < TriseSpec > ;
#[doc = "Register `TRISE` writer"] pub type W = crate :: W < TriseSpec > ;
#[doc = "Field `TRISE` reader - Maximum rise time in Fast/Standard mode (Master mode)"] pub type TriseR = crate :: FieldReader ;
#[doc = "Field `TRISE` writer - Maximum rise time in Fast/Standard mode (Master mode)"] pub type TriseW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ; impl R {
#[doc = "Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)"]
#[inline (always)] pub fn trise (& self) -> TriseR { TriseR :: new ((self . bits & 0x3f) as u8) } } impl W {
#[doc = "Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)"]
#[inline (always)] pub fn trise (& mut self) -> TriseW < '_ , TriseSpec > { TriseW :: new (self , 0) } }
#[doc = "TRISE register\n\nYou can [`read`](crate::Reg::read) this register and get [`trise::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`trise::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TriseSpec ; impl crate :: RegisterSpec for TriseSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`trise::R`](R) reader structure"] impl crate :: Readable for TriseSpec { }
#[doc = "`write(|w| ..)` method takes [`trise::W`](W) writer structure"] impl crate :: Writable for TriseSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TRISE to value 0x02"] impl crate :: Resettable for TriseSpec { const RESET_VALUE : u32 = 0x02 ; } } }
#[doc = "Inter integrated circuit"] pub type I2c2 = crate :: Periph < i2c1 :: RegisterBlock , 0x4000_5800 > ; impl core :: fmt :: Debug for I2c2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c2") . finish () } }
#[doc = "Inter integrated circuit"] pub use self :: i2c1 as i2c2 ;
#[doc = "Serial peripheral interface"] pub type Spi1 = crate :: Periph < spi1 :: RegisterBlock , 0x4001_3000 > ; impl core :: fmt :: Debug for Spi1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi1") . finish () } }
#[doc = "Serial peripheral interface"] pub mod spi1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , sr : Sr , dr : Dr , crcpr : Crcpr , rxcrcr : Rxcrcr , txcrcr : Txcrcr , i2scfgr : I2scfgr , i2spr : I2spr , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x0c - data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x10 - CRC polynomial register"]
#[inline (always)] pub const fn crcpr (& self) -> & Crcpr { & self . crcpr }
#[doc = "0x14 - RX CRC register"]
#[inline (always)] pub const fn rxcrcr (& self) -> & Rxcrcr { & self . rxcrcr }
#[doc = "0x18 - TX CRC register"]
#[inline (always)] pub const fn txcrcr (& self) -> & Txcrcr { & self . txcrcr }
#[doc = "0x1c - I2S configuration register"]
#[inline (always)] pub const fn i2scfgr (& self) -> & I2scfgr { & self . i2scfgr }
#[doc = "0x20 - I2S prescaler register"]
#[inline (always)] pub const fn i2spr (& self) -> & I2spr { & self . i2spr } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CPHA` reader - Clock phase"] pub type CphaR = crate :: BitReader ;
#[doc = "Field `CPHA` writer - Clock phase"] pub type CphaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPOL` reader - Clock polarity"] pub type CpolR = crate :: BitReader ;
#[doc = "Field `CPOL` writer - Clock polarity"] pub type CpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSTR` reader - Master selection"] pub type MstrR = crate :: BitReader ;
#[doc = "Field `MSTR` writer - Master selection"] pub type MstrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR` reader - Baud rate control"] pub type BrR = crate :: FieldReader ;
#[doc = "Field `BR` writer - Baud rate control"] pub type BrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SPE` reader - SPI enable"] pub type SpeR = crate :: BitReader ;
#[doc = "Field `SPE` writer - SPI enable"] pub type SpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSBFIRST` reader - Frame format"] pub type LsbfirstR = crate :: BitReader ;
#[doc = "Field `LSBFIRST` writer - Frame format"] pub type LsbfirstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSI` reader - Internal slave select"] pub type SsiR = crate :: BitReader ;
#[doc = "Field `SSI` writer - Internal slave select"] pub type SsiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSM` reader - Software slave management"] pub type SsmR = crate :: BitReader ;
#[doc = "Field `SSM` writer - Software slave management"] pub type SsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXONLY` reader - Receive only"] pub type RxonlyR = crate :: BitReader ;
#[doc = "Field `RXONLY` writer - Receive only"] pub type RxonlyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DFF` reader - Data frame format"] pub type DffR = crate :: BitReader ;
#[doc = "Field `DFF` writer - Data frame format"] pub type DffW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCNEXT` reader - CRC transfer next"] pub type CrcnextR = crate :: BitReader ;
#[doc = "Field `CRCNEXT` writer - CRC transfer next"] pub type CrcnextW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRCEN` reader - Hardware CRC calculation enable"] pub type CrcenR = crate :: BitReader ;
#[doc = "Field `CRCEN` writer - Hardware CRC calculation enable"] pub type CrcenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIDIOE` reader - Output enable in bidirectional mode"] pub type BidioeR = crate :: BitReader ;
#[doc = "Field `BIDIOE` writer - Output enable in bidirectional mode"] pub type BidioeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIDIMODE` reader - Bidirectional data mode enable"] pub type BidimodeR = crate :: BitReader ;
#[doc = "Field `BIDIMODE` writer - Bidirectional data mode enable"] pub type BidimodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Clock phase"]
#[inline (always)] pub fn cpha (& self) -> CphaR { CphaR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Clock polarity"]
#[inline (always)] pub fn cpol (& self) -> CpolR { CpolR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Master selection"]
#[inline (always)] pub fn mstr (& self) -> MstrR { MstrR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:5 - Baud rate control"]
#[inline (always)] pub fn br (& self) -> BrR { BrR :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bit 6 - SPI enable"]
#[inline (always)] pub fn spe (& self) -> SpeR { SpeR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Frame format"]
#[inline (always)] pub fn lsbfirst (& self) -> LsbfirstR { LsbfirstR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Internal slave select"]
#[inline (always)] pub fn ssi (& self) -> SsiR { SsiR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Software slave management"]
#[inline (always)] pub fn ssm (& self) -> SsmR { SsmR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Receive only"]
#[inline (always)] pub fn rxonly (& self) -> RxonlyR { RxonlyR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Data frame format"]
#[inline (always)] pub fn dff (& self) -> DffR { DffR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - CRC transfer next"]
#[inline (always)] pub fn crcnext (& self) -> CrcnextR { CrcnextR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Hardware CRC calculation enable"]
#[inline (always)] pub fn crcen (& self) -> CrcenR { CrcenR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Output enable in bidirectional mode"]
#[inline (always)] pub fn bidioe (& self) -> BidioeR { BidioeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Bidirectional data mode enable"]
#[inline (always)] pub fn bidimode (& self) -> BidimodeR { BidimodeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Clock phase"]
#[inline (always)] pub fn cpha (& mut self) -> CphaW < '_ , Cr1Spec > { CphaW :: new (self , 0) }
#[doc = "Bit 1 - Clock polarity"]
#[inline (always)] pub fn cpol (& mut self) -> CpolW < '_ , Cr1Spec > { CpolW :: new (self , 1) }
#[doc = "Bit 2 - Master selection"]
#[inline (always)] pub fn mstr (& mut self) -> MstrW < '_ , Cr1Spec > { MstrW :: new (self , 2) }
#[doc = "Bits 3:5 - Baud rate control"]
#[inline (always)] pub fn br (& mut self) -> BrW < '_ , Cr1Spec > { BrW :: new (self , 3) }
#[doc = "Bit 6 - SPI enable"]
#[inline (always)] pub fn spe (& mut self) -> SpeW < '_ , Cr1Spec > { SpeW :: new (self , 6) }
#[doc = "Bit 7 - Frame format"]
#[inline (always)] pub fn lsbfirst (& mut self) -> LsbfirstW < '_ , Cr1Spec > { LsbfirstW :: new (self , 7) }
#[doc = "Bit 8 - Internal slave select"]
#[inline (always)] pub fn ssi (& mut self) -> SsiW < '_ , Cr1Spec > { SsiW :: new (self , 8) }
#[doc = "Bit 9 - Software slave management"]
#[inline (always)] pub fn ssm (& mut self) -> SsmW < '_ , Cr1Spec > { SsmW :: new (self , 9) }
#[doc = "Bit 10 - Receive only"]
#[inline (always)] pub fn rxonly (& mut self) -> RxonlyW < '_ , Cr1Spec > { RxonlyW :: new (self , 10) }
#[doc = "Bit 11 - Data frame format"]
#[inline (always)] pub fn dff (& mut self) -> DffW < '_ , Cr1Spec > { DffW :: new (self , 11) }
#[doc = "Bit 12 - CRC transfer next"]
#[inline (always)] pub fn crcnext (& mut self) -> CrcnextW < '_ , Cr1Spec > { CrcnextW :: new (self , 12) }
#[doc = "Bit 13 - Hardware CRC calculation enable"]
#[inline (always)] pub fn crcen (& mut self) -> CrcenW < '_ , Cr1Spec > { CrcenW :: new (self , 13) }
#[doc = "Bit 14 - Output enable in bidirectional mode"]
#[inline (always)] pub fn bidioe (& mut self) -> BidioeW < '_ , Cr1Spec > { BidioeW :: new (self , 14) }
#[doc = "Bit 15 - Bidirectional data mode enable"]
#[inline (always)] pub fn bidimode (& mut self) -> BidimodeW < '_ , Cr1Spec > { BidimodeW :: new (self , 15) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `RXDMAEN` reader - Rx buffer DMA enable"] pub type RxdmaenR = crate :: BitReader ;
#[doc = "Field `RXDMAEN` writer - Rx buffer DMA enable"] pub type RxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXDMAEN` reader - Tx buffer DMA enable"] pub type TxdmaenR = crate :: BitReader ;
#[doc = "Field `TXDMAEN` writer - Tx buffer DMA enable"] pub type TxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SSOE` reader - SS output enable"] pub type SsoeR = crate :: BitReader ;
#[doc = "Field `SSOE` writer - SS output enable"] pub type SsoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXNEIE` reader - RX buffer not empty interrupt enable"] pub type RxneieR = crate :: BitReader ;
#[doc = "Field `RXNEIE` writer - RX buffer not empty interrupt enable"] pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEIE` reader - Tx buffer empty interrupt enable"] pub type TxeieR = crate :: BitReader ;
#[doc = "Field `TXEIE` writer - Tx buffer empty interrupt enable"] pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Rx buffer DMA enable"]
#[inline (always)] pub fn rxdmaen (& self) -> RxdmaenR { RxdmaenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Tx buffer DMA enable"]
#[inline (always)] pub fn txdmaen (& self) -> TxdmaenR { TxdmaenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - SS output enable"]
#[inline (always)] pub fn ssoe (& self) -> SsoeR { SsoeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 5 - Error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RX buffer not empty interrupt enable"]
#[inline (always)] pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Tx buffer empty interrupt enable"]
#[inline (always)] pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Rx buffer DMA enable"]
#[inline (always)] pub fn rxdmaen (& mut self) -> RxdmaenW < '_ , Cr2Spec > { RxdmaenW :: new (self , 0) }
#[doc = "Bit 1 - Tx buffer DMA enable"]
#[inline (always)] pub fn txdmaen (& mut self) -> TxdmaenW < '_ , Cr2Spec > { TxdmaenW :: new (self , 1) }
#[doc = "Bit 2 - SS output enable"]
#[inline (always)] pub fn ssoe (& mut self) -> SsoeW < '_ , Cr2Spec > { SsoeW :: new (self , 2) }
#[doc = "Bit 5 - Error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , Cr2Spec > { ErrieW :: new (self , 5) }
#[doc = "Bit 6 - RX buffer not empty interrupt enable"]
#[inline (always)] pub fn rxneie (& mut self) -> RxneieW < '_ , Cr2Spec > { RxneieW :: new (self , 6) }
#[doc = "Bit 7 - Tx buffer empty interrupt enable"]
#[inline (always)] pub fn txeie (& mut self) -> TxeieW < '_ , Cr2Spec > { TxeieW :: new (self , 7) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `RXNE` reader - Receive buffer not empty"] pub type RxneR = crate :: BitReader ;
#[doc = "Field `TXE` reader - Transmit buffer empty"] pub type TxeR = crate :: BitReader ;
#[doc = "Field `CHSIDE` reader - Channel side"] pub type ChsideR = crate :: BitReader ;
#[doc = "Field `UDR` reader - Underrun flag"] pub type UdrR = crate :: BitReader ;
#[doc = "Field `CRCERR` reader - CRC error flag"] pub type CrcerrR = crate :: BitReader ;
#[doc = "Field `CRCERR` writer - CRC error flag"] pub type CrcerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MODF` reader - Mode fault"] pub type ModfR = crate :: BitReader ;
#[doc = "Field `OVR` reader - Overrun flag"] pub type OvrR = crate :: BitReader ;
#[doc = "Field `BSY` reader - Busy flag"] pub type BsyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Receive buffer not empty"]
#[inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transmit buffer empty"]
#[inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Channel side"]
#[inline (always)] pub fn chside (& self) -> ChsideR { ChsideR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Underrun flag"]
#[inline (always)] pub fn udr (& self) -> UdrR { UdrR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - CRC error flag"]
#[inline (always)] pub fn crcerr (& self) -> CrcerrR { CrcerrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Mode fault"]
#[inline (always)] pub fn modf (& self) -> ModfR { ModfR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Overrun flag"]
#[inline (always)] pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Busy flag"]
#[inline (always)] pub fn bsy (& self) -> BsyR { BsyR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 4 - CRC error flag"]
#[inline (always)] pub fn crcerr (& mut self) -> CrcerrW < '_ , SrSpec > { CrcerrW :: new (self , 4) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0x02"] impl crate :: Resettable for SrSpec { const RESET_VALUE : u32 = 0x02 ; } }
#[doc = "DR (rw) register accessor: data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - Data register"] pub type DrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DR` writer - Data register"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Data register"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Data register"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "CRCPR (rw) register accessor: CRC polynomial register\n\nYou can [`read`](crate::Reg::read) this register and get [`crcpr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crcpr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crcpr`] module"]
#[doc (alias = "CRCPR")] pub type Crcpr = crate :: Reg < crcpr :: CrcprSpec > ;
#[doc = "CRC polynomial register"] pub mod crcpr {
#[doc = "Register `CRCPR` reader"] pub type R = crate :: R < CrcprSpec > ;
#[doc = "Register `CRCPR` writer"] pub type W = crate :: W < CrcprSpec > ;
#[doc = "Field `CRCPOLY` reader - CRC polynomial register"] pub type CrcpolyR = crate :: FieldReader < u16 > ;
#[doc = "Field `CRCPOLY` writer - CRC polynomial register"] pub type CrcpolyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - CRC polynomial register"]
#[inline (always)] pub fn crcpoly (& self) -> CrcpolyR { CrcpolyR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - CRC polynomial register"]
#[inline (always)] pub fn crcpoly (& mut self) -> CrcpolyW < '_ , CrcprSpec > { CrcpolyW :: new (self , 0) } }
#[doc = "CRC polynomial register\n\nYou can [`read`](crate::Reg::read) this register and get [`crcpr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crcpr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrcprSpec ; impl crate :: RegisterSpec for CrcprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crcpr::R`](R) reader structure"] impl crate :: Readable for CrcprSpec { }
#[doc = "`write(|w| ..)` method takes [`crcpr::W`](W) writer structure"] impl crate :: Writable for CrcprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRCPR to value 0x07"] impl crate :: Resettable for CrcprSpec { const RESET_VALUE : u32 = 0x07 ; } }
#[doc = "RXCRCR (r) register accessor: RX CRC register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxcrcr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxcrcr`] module"]
#[doc (alias = "RXCRCR")] pub type Rxcrcr = crate :: Reg < rxcrcr :: RxcrcrSpec > ;
#[doc = "RX CRC register"] pub mod rxcrcr {
#[doc = "Register `RXCRCR` reader"] pub type R = crate :: R < RxcrcrSpec > ;
#[doc = "Field `RxCRC` reader - Rx CRC register"] pub type RxCrcR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Rx CRC register"]
#[inline (always)] pub fn rx_crc (& self) -> RxCrcR { RxCrcR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "RX CRC register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxcrcr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxcrcrSpec ; impl crate :: RegisterSpec for RxcrcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxcrcr::R`](R) reader structure"] impl crate :: Readable for RxcrcrSpec { }
#[doc = "`reset()` method sets RXCRCR to value 0"] impl crate :: Resettable for RxcrcrSpec { } }
#[doc = "TXCRCR (r) register accessor: TX CRC register\n\nYou can [`read`](crate::Reg::read) this register and get [`txcrcr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txcrcr`] module"]
#[doc (alias = "TXCRCR")] pub type Txcrcr = crate :: Reg < txcrcr :: TxcrcrSpec > ;
#[doc = "TX CRC register"] pub mod txcrcr {
#[doc = "Register `TXCRCR` reader"] pub type R = crate :: R < TxcrcrSpec > ;
#[doc = "Field `TxCRC` reader - Tx CRC register"] pub type TxCrcR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Tx CRC register"]
#[inline (always)] pub fn tx_crc (& self) -> TxCrcR { TxCrcR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "TX CRC register\n\nYou can [`read`](crate::Reg::read) this register and get [`txcrcr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TxcrcrSpec ; impl crate :: RegisterSpec for TxcrcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`txcrcr::R`](R) reader structure"] impl crate :: Readable for TxcrcrSpec { }
#[doc = "`reset()` method sets TXCRCR to value 0"] impl crate :: Resettable for TxcrcrSpec { } }
#[doc = "I2SCFGR (rw) register accessor: I2S configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`i2scfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i2scfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2scfgr`] module"]
#[doc (alias = "I2SCFGR")] pub type I2scfgr = crate :: Reg < i2scfgr :: I2scfgrSpec > ;
#[doc = "I2S configuration register"] pub mod i2scfgr {
#[doc = "Register `I2SCFGR` reader"] pub type R = crate :: R < I2scfgrSpec > ;
#[doc = "Register `I2SCFGR` writer"] pub type W = crate :: W < I2scfgrSpec > ;
#[doc = "Field `CHLEN` reader - Channel length (number of bits per audio channel)"] pub type ChlenR = crate :: BitReader ;
#[doc = "Field `CHLEN` writer - Channel length (number of bits per audio channel)"] pub type ChlenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DATLEN` reader - Data length to be transferred"] pub type DatlenR = crate :: FieldReader ;
#[doc = "Field `DATLEN` writer - Data length to be transferred"] pub type DatlenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CKPOL` reader - Steady state clock polarity"] pub type CkpolR = crate :: BitReader ;
#[doc = "Field `CKPOL` writer - Steady state clock polarity"] pub type CkpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2SSTD` reader - I2S standard selection"] pub type I2sstdR = crate :: FieldReader ;
#[doc = "Field `I2SSTD` writer - I2S standard selection"] pub type I2sstdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PCMSYNC` reader - PCM frame synchronization"] pub type PcmsyncR = crate :: BitReader ;
#[doc = "Field `PCMSYNC` writer - PCM frame synchronization"] pub type PcmsyncW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2SCFG` reader - I2S configuration mode"] pub type I2scfgR = crate :: FieldReader ;
#[doc = "Field `I2SCFG` writer - I2S configuration mode"] pub type I2scfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `I2SE` reader - I2S Enable"] pub type I2seR = crate :: BitReader ;
#[doc = "Field `I2SE` writer - I2S Enable"] pub type I2seW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2SMOD` reader - I2S mode selection"] pub type I2smodR = crate :: BitReader ;
#[doc = "Field `I2SMOD` writer - I2S mode selection"] pub type I2smodW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel length (number of bits per audio channel)"]
#[inline (always)] pub fn chlen (& self) -> ChlenR { ChlenR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:2 - Data length to be transferred"]
#[inline (always)] pub fn datlen (& self) -> DatlenR { DatlenR :: new (((self . bits >> 1) & 3) as u8) }
#[doc = "Bit 3 - Steady state clock polarity"]
#[inline (always)] pub fn ckpol (& self) -> CkpolR { CkpolR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - I2S standard selection"]
#[inline (always)] pub fn i2sstd (& self) -> I2sstdR { I2sstdR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 7 - PCM frame synchronization"]
#[inline (always)] pub fn pcmsync (& self) -> PcmsyncR { PcmsyncR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - I2S configuration mode"]
#[inline (always)] pub fn i2scfg (& self) -> I2scfgR { I2scfgR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - I2S Enable"]
#[inline (always)] pub fn i2se (& self) -> I2seR { I2seR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - I2S mode selection"]
#[inline (always)] pub fn i2smod (& self) -> I2smodR { I2smodR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel length (number of bits per audio channel)"]
#[inline (always)] pub fn chlen (& mut self) -> ChlenW < '_ , I2scfgrSpec > { ChlenW :: new (self , 0) }
#[doc = "Bits 1:2 - Data length to be transferred"]
#[inline (always)] pub fn datlen (& mut self) -> DatlenW < '_ , I2scfgrSpec > { DatlenW :: new (self , 1) }
#[doc = "Bit 3 - Steady state clock polarity"]
#[inline (always)] pub fn ckpol (& mut self) -> CkpolW < '_ , I2scfgrSpec > { CkpolW :: new (self , 3) }
#[doc = "Bits 4:5 - I2S standard selection"]
#[inline (always)] pub fn i2sstd (& mut self) -> I2sstdW < '_ , I2scfgrSpec > { I2sstdW :: new (self , 4) }
#[doc = "Bit 7 - PCM frame synchronization"]
#[inline (always)] pub fn pcmsync (& mut self) -> PcmsyncW < '_ , I2scfgrSpec > { PcmsyncW :: new (self , 7) }
#[doc = "Bits 8:9 - I2S configuration mode"]
#[inline (always)] pub fn i2scfg (& mut self) -> I2scfgW < '_ , I2scfgrSpec > { I2scfgW :: new (self , 8) }
#[doc = "Bit 10 - I2S Enable"]
#[inline (always)] pub fn i2se (& mut self) -> I2seW < '_ , I2scfgrSpec > { I2seW :: new (self , 10) }
#[doc = "Bit 11 - I2S mode selection"]
#[inline (always)] pub fn i2smod (& mut self) -> I2smodW < '_ , I2scfgrSpec > { I2smodW :: new (self , 11) } }
#[doc = "I2S configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`i2scfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i2scfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct I2scfgrSpec ; impl crate :: RegisterSpec for I2scfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`i2scfgr::R`](R) reader structure"] impl crate :: Readable for I2scfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`i2scfgr::W`](W) writer structure"] impl crate :: Writable for I2scfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets I2SCFGR to value 0"] impl crate :: Resettable for I2scfgrSpec { } }
#[doc = "I2SPR (rw) register accessor: I2S prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`i2spr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i2spr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@i2spr`] module"]
#[doc (alias = "I2SPR")] pub type I2spr = crate :: Reg < i2spr :: I2sprSpec > ;
#[doc = "I2S prescaler register"] pub mod i2spr {
#[doc = "Register `I2SPR` reader"] pub type R = crate :: R < I2sprSpec > ;
#[doc = "Register `I2SPR` writer"] pub type W = crate :: W < I2sprSpec > ;
#[doc = "Field `I2SDIV` reader - I2S Linear prescaler"] pub type I2sdivR = crate :: FieldReader ;
#[doc = "Field `I2SDIV` writer - I2S Linear prescaler"] pub type I2sdivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `ODD` reader - Odd factor for the prescaler"] pub type OddR = crate :: BitReader ;
#[doc = "Field `ODD` writer - Odd factor for the prescaler"] pub type OddW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCKOE` reader - Master clock output enable"] pub type MckoeR = crate :: BitReader ;
#[doc = "Field `MCKOE` writer - Master clock output enable"] pub type MckoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - I2S Linear prescaler"]
#[inline (always)] pub fn i2sdiv (& self) -> I2sdivR { I2sdivR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - Odd factor for the prescaler"]
#[inline (always)] pub fn odd (& self) -> OddR { OddR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Master clock output enable"]
#[inline (always)] pub fn mckoe (& self) -> MckoeR { MckoeR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - I2S Linear prescaler"]
#[inline (always)] pub fn i2sdiv (& mut self) -> I2sdivW < '_ , I2sprSpec > { I2sdivW :: new (self , 0) }
#[doc = "Bit 8 - Odd factor for the prescaler"]
#[inline (always)] pub fn odd (& mut self) -> OddW < '_ , I2sprSpec > { OddW :: new (self , 8) }
#[doc = "Bit 9 - Master clock output enable"]
#[inline (always)] pub fn mckoe (& mut self) -> MckoeW < '_ , I2sprSpec > { MckoeW :: new (self , 9) } }
#[doc = "I2S prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`i2spr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i2spr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct I2sprSpec ; impl crate :: RegisterSpec for I2sprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`i2spr::R`](R) reader structure"] impl crate :: Readable for I2sprSpec { }
#[doc = "`write(|w| ..)` method takes [`i2spr::W`](W) writer structure"] impl crate :: Writable for I2sprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets I2SPR to value 0x0a"] impl crate :: Resettable for I2sprSpec { const RESET_VALUE : u32 = 0x0a ; } } }
#[doc = "Serial peripheral interface"] pub type Spi2 = crate :: Periph < spi1 :: RegisterBlock , 0x4000_3800 > ; impl core :: fmt :: Debug for Spi2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi2") . finish () } }
#[doc = "Serial peripheral interface"] pub use self :: spi1 as spi2 ;
#[doc = "Serial peripheral interface"] pub type Spi3 = crate :: Periph < spi1 :: RegisterBlock , 0x4000_3c00 > ; impl core :: fmt :: Debug for Spi3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi3") . finish () } }
#[doc = "Serial peripheral interface"] pub use self :: spi1 as spi3 ;
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub type Usart1 = crate :: Periph < usart1 :: RegisterBlock , 0x4001_3800 > ; impl core :: fmt :: Debug for Usart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart1") . finish () } }
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub mod usart1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { sr : Sr , dr : Dr , brr : Brr , cr1 : Cr1 , cr2 : Cr2 , cr3 : Cr3 , gtpr : Gtpr , } impl RegisterBlock {
#[doc = "0x00 - Status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x04 - Data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x08 - Baud rate register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr }
#[doc = "0x0c - Control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x10 - Control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x14 - Control register 3"]
#[inline (always)] pub const fn cr3 (& self) -> & Cr3 { & self . cr3 }
#[doc = "0x18 - Guard time and prescaler register"]
#[inline (always)] pub const fn gtpr (& self) -> & Gtpr { & self . gtpr } }
#[doc = "SR (rw) register accessor: Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `PE` reader - Parity error"] pub type PeR = crate :: BitReader ;
#[doc = "Field `FE` reader - Framing error"] pub type FeR = crate :: BitReader ;
#[doc = "Field `NE` reader - Noise error flag"] pub type NeR = crate :: BitReader ;
#[doc = "Field `ORE` reader - Overrun error"] pub type OreR = crate :: BitReader ;
#[doc = "Field `IDLE` reader - IDLE line detected"] pub type IdleR = crate :: BitReader ;
#[doc = "Field `RXNE` reader - Read data register not empty"] pub type RxneR = crate :: BitReader ;
#[doc = "Field `RXNE` writer - Read data register not empty"] pub type RxneW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TC` reader - Transmission complete"] pub type TcR = crate :: BitReader ;
#[doc = "Field `TC` writer - Transmission complete"] pub type TcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXE` reader - Transmit data register empty"] pub type TxeR = crate :: BitReader ;
#[doc = "Field `LBD` reader - LIN break detection flag"] pub type LbdR = crate :: BitReader ;
#[doc = "Field `LBD` writer - LIN break detection flag"] pub type LbdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTS` reader - CTS flag"] pub type CtsR = crate :: BitReader ;
#[doc = "Field `CTS` writer - CTS flag"] pub type CtsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Parity error"]
#[inline (always)] pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Framing error"]
#[inline (always)] pub fn fe (& self) -> FeR { FeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Noise error flag"]
#[inline (always)] pub fn ne (& self) -> NeR { NeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Overrun error"]
#[inline (always)] pub fn ore (& self) -> OreR { OreR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IDLE line detected"]
#[inline (always)] pub fn idle (& self) -> IdleR { IdleR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Read data register not empty"]
#[inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmission complete"]
#[inline (always)] pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transmit data register empty"]
#[inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - LIN break detection flag"]
#[inline (always)] pub fn lbd (& self) -> LbdR { LbdR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - CTS flag"]
#[inline (always)] pub fn cts (& self) -> CtsR { CtsR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 5 - Read data register not empty"]
#[inline (always)] pub fn rxne (& mut self) -> RxneW < '_ , SrSpec > { RxneW :: new (self , 5) }
#[doc = "Bit 6 - Transmission complete"]
#[inline (always)] pub fn tc (& mut self) -> TcW < '_ , SrSpec > { TcW :: new (self , 6) }
#[doc = "Bit 8 - LIN break detection flag"]
#[inline (always)] pub fn lbd (& mut self) -> LbdW < '_ , SrSpec > { LbdW :: new (self , 8) }
#[doc = "Bit 9 - CTS flag"]
#[inline (always)] pub fn cts (& mut self) -> CtsW < '_ , SrSpec > { CtsW :: new (self , 9) } }
#[doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0xc0"] impl crate :: Resettable for SrSpec { const RESET_VALUE : u32 = 0xc0 ; } }
#[doc = "DR (rw) register accessor: Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "Data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - Data value"] pub type DrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DR` writer - Data value"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R {
#[doc = "Bits 0:8 - Data value"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new ((self . bits & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:8 - Data value"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "BRR (rw) register accessor: Baud rate register\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "Baud rate register"] pub mod brr {
#[doc = "Register `BRR` reader"] pub type R = crate :: R < BrrSpec > ;
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `DIV_Fraction` reader - fraction of USARTDIV"] pub type DivFractionR = crate :: FieldReader ;
#[doc = "Field `DIV_Fraction` writer - fraction of USARTDIV"] pub type DivFractionW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DIV_Mantissa` reader - mantissa of USARTDIV"] pub type DivMantissaR = crate :: FieldReader < u16 > ;
#[doc = "Field `DIV_Mantissa` writer - mantissa of USARTDIV"] pub type DivMantissaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:3 - fraction of USARTDIV"]
#[inline (always)] pub fn div_fraction (& self) -> DivFractionR { DivFractionR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:15 - mantissa of USARTDIV"]
#[inline (always)] pub fn div_mantissa (& self) -> DivMantissaR { DivMantissaR :: new (((self . bits >> 4) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:3 - fraction of USARTDIV"]
#[inline (always)] pub fn div_fraction (& mut self) -> DivFractionW < '_ , BrrSpec > { DivFractionW :: new (self , 0) }
#[doc = "Bits 4:15 - mantissa of USARTDIV"]
#[inline (always)] pub fn div_mantissa (& mut self) -> DivMantissaW < '_ , BrrSpec > { DivMantissaW :: new (self , 4) } }
#[doc = "Baud rate register\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`brr::R`](R) reader structure"] impl crate :: Readable for BrrSpec { }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } }
#[doc = "CR1 (rw) register accessor: Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "Control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `SBK` reader - Send break"] pub type SbkR = crate :: BitReader ;
#[doc = "Field `SBK` writer - Send break"] pub type SbkW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RWU` reader - Receiver wakeup"] pub type RwuR = crate :: BitReader ;
#[doc = "Field `RWU` writer - Receiver wakeup"] pub type RwuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RE` reader - Receiver enable"] pub type ReR = crate :: BitReader ;
#[doc = "Field `RE` writer - Receiver enable"] pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TE` reader - Transmitter enable"] pub type TeR = crate :: BitReader ;
#[doc = "Field `TE` writer - Transmitter enable"] pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDLEIE` reader - IDLE interrupt enable"] pub type IdleieR = crate :: BitReader ;
#[doc = "Field `IDLEIE` writer - IDLE interrupt enable"] pub type IdleieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXNEIE` reader - RXNE interrupt enable"] pub type RxneieR = crate :: BitReader ;
#[doc = "Field `RXNEIE` writer - RXNE interrupt enable"] pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transmission complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transmission complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEIE` reader - TXE interrupt enable"] pub type TxeieR = crate :: BitReader ;
#[doc = "Field `TXEIE` writer - TXE interrupt enable"] pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PEIE` reader - PE interrupt enable"] pub type PeieR = crate :: BitReader ;
#[doc = "Field `PEIE` writer - PE interrupt enable"] pub type PeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PS` reader - Parity selection"] pub type PsR = crate :: BitReader ;
#[doc = "Field `PS` writer - Parity selection"] pub type PsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PCE` reader - Parity control enable"] pub type PceR = crate :: BitReader ;
#[doc = "Field `PCE` writer - Parity control enable"] pub type PceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAKE` reader - Wakeup method"] pub type WakeR = crate :: BitReader ;
#[doc = "Field `WAKE` writer - Wakeup method"] pub type WakeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `M` reader - Word length"] pub type MR = crate :: BitReader ;
#[doc = "Field `M` writer - Word length"] pub type MW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UE` reader - USART enable"] pub type UeR = crate :: BitReader ;
#[doc = "Field `UE` writer - USART enable"] pub type UeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Send break"]
#[inline (always)] pub fn sbk (& self) -> SbkR { SbkR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receiver wakeup"]
#[inline (always)] pub fn rwu (& self) -> RwuR { RwuR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Receiver enable"]
#[inline (always)] pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmitter enable"]
#[inline (always)] pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IDLE interrupt enable"]
#[inline (always)] pub fn idleie (& self) -> IdleieR { IdleieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXNE interrupt enable"]
#[inline (always)] pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmission complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXE interrupt enable"]
#[inline (always)] pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - PE interrupt enable"]
#[inline (always)] pub fn peie (& self) -> PeieR { PeieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Parity selection"]
#[inline (always)] pub fn ps (& self) -> PsR { PsR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Parity control enable"]
#[inline (always)] pub fn pce (& self) -> PceR { PceR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Wakeup method"]
#[inline (always)] pub fn wake (& self) -> WakeR { WakeR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Word length"]
#[inline (always)] pub fn m (& self) -> MR { MR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - USART enable"]
#[inline (always)] pub fn ue (& self) -> UeR { UeR :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Send break"]
#[inline (always)] pub fn sbk (& mut self) -> SbkW < '_ , Cr1Spec > { SbkW :: new (self , 0) }
#[doc = "Bit 1 - Receiver wakeup"]
#[inline (always)] pub fn rwu (& mut self) -> RwuW < '_ , Cr1Spec > { RwuW :: new (self , 1) }
#[doc = "Bit 2 - Receiver enable"]
#[inline (always)] pub fn re (& mut self) -> ReW < '_ , Cr1Spec > { ReW :: new (self , 2) }
#[doc = "Bit 3 - Transmitter enable"]
#[inline (always)] pub fn te (& mut self) -> TeW < '_ , Cr1Spec > { TeW :: new (self , 3) }
#[doc = "Bit 4 - IDLE interrupt enable"]
#[inline (always)] pub fn idleie (& mut self) -> IdleieW < '_ , Cr1Spec > { IdleieW :: new (self , 4) }
#[doc = "Bit 5 - RXNE interrupt enable"]
#[inline (always)] pub fn rxneie (& mut self) -> RxneieW < '_ , Cr1Spec > { RxneieW :: new (self , 5) }
#[doc = "Bit 6 - Transmission complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Cr1Spec > { TcieW :: new (self , 6) }
#[doc = "Bit 7 - TXE interrupt enable"]
#[inline (always)] pub fn txeie (& mut self) -> TxeieW < '_ , Cr1Spec > { TxeieW :: new (self , 7) }
#[doc = "Bit 8 - PE interrupt enable"]
#[inline (always)] pub fn peie (& mut self) -> PeieW < '_ , Cr1Spec > { PeieW :: new (self , 8) }
#[doc = "Bit 9 - Parity selection"]
#[inline (always)] pub fn ps (& mut self) -> PsW < '_ , Cr1Spec > { PsW :: new (self , 9) }
#[doc = "Bit 10 - Parity control enable"]
#[inline (always)] pub fn pce (& mut self) -> PceW < '_ , Cr1Spec > { PceW :: new (self , 10) }
#[doc = "Bit 11 - Wakeup method"]
#[inline (always)] pub fn wake (& mut self) -> WakeW < '_ , Cr1Spec > { WakeW :: new (self , 11) }
#[doc = "Bit 12 - Word length"]
#[inline (always)] pub fn m (& mut self) -> MW < '_ , Cr1Spec > { MW :: new (self , 12) }
#[doc = "Bit 13 - USART enable"]
#[inline (always)] pub fn ue (& mut self) -> UeW < '_ , Cr1Spec > { UeW :: new (self , 13) } }
#[doc = "Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "Control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `ADD` reader - Address of the USART node"] pub type AddR = crate :: FieldReader ;
#[doc = "Field `ADD` writer - Address of the USART node"] pub type AddW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LBDL` reader - lin break detection length"] pub type LbdlR = crate :: BitReader ;
#[doc = "Field `LBDL` writer - lin break detection length"] pub type LbdlW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LBDIE` reader - LIN break detection interrupt enable"] pub type LbdieR = crate :: BitReader ;
#[doc = "Field `LBDIE` writer - LIN break detection interrupt enable"] pub type LbdieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LBCL` reader - Last bit clock pulse"] pub type LbclR = crate :: BitReader ;
#[doc = "Field `LBCL` writer - Last bit clock pulse"] pub type LbclW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPHA` reader - Clock phase"] pub type CphaR = crate :: BitReader ;
#[doc = "Field `CPHA` writer - Clock phase"] pub type CphaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPOL` reader - Clock polarity"] pub type CpolR = crate :: BitReader ;
#[doc = "Field `CPOL` writer - Clock polarity"] pub type CpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLKEN` reader - Clock enable"] pub type ClkenR = crate :: BitReader ;
#[doc = "Field `CLKEN` writer - Clock enable"] pub type ClkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOP` reader - STOP bits"] pub type StopR = crate :: FieldReader ;
#[doc = "Field `STOP` writer - STOP bits"] pub type StopW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LINEN` reader - LIN mode enable"] pub type LinenR = crate :: BitReader ;
#[doc = "Field `LINEN` writer - LIN mode enable"] pub type LinenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Address of the USART node"]
#[inline (always)] pub fn add (& self) -> AddR { AddR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 5 - lin break detection length"]
#[inline (always)] pub fn lbdl (& self) -> LbdlR { LbdlR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - LIN break detection interrupt enable"]
#[inline (always)] pub fn lbdie (& self) -> LbdieR { LbdieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Last bit clock pulse"]
#[inline (always)] pub fn lbcl (& self) -> LbclR { LbclR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Clock phase"]
#[inline (always)] pub fn cpha (& self) -> CphaR { CphaR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Clock polarity"]
#[inline (always)] pub fn cpol (& self) -> CpolR { CpolR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Clock enable"]
#[inline (always)] pub fn clken (& self) -> ClkenR { ClkenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - STOP bits"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - LIN mode enable"]
#[inline (always)] pub fn linen (& self) -> LinenR { LinenR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Address of the USART node"]
#[inline (always)] pub fn add (& mut self) -> AddW < '_ , Cr2Spec > { AddW :: new (self , 0) }
#[doc = "Bit 5 - lin break detection length"]
#[inline (always)] pub fn lbdl (& mut self) -> LbdlW < '_ , Cr2Spec > { LbdlW :: new (self , 5) }
#[doc = "Bit 6 - LIN break detection interrupt enable"]
#[inline (always)] pub fn lbdie (& mut self) -> LbdieW < '_ , Cr2Spec > { LbdieW :: new (self , 6) }
#[doc = "Bit 8 - Last bit clock pulse"]
#[inline (always)] pub fn lbcl (& mut self) -> LbclW < '_ , Cr2Spec > { LbclW :: new (self , 8) }
#[doc = "Bit 9 - Clock phase"]
#[inline (always)] pub fn cpha (& mut self) -> CphaW < '_ , Cr2Spec > { CphaW :: new (self , 9) }
#[doc = "Bit 10 - Clock polarity"]
#[inline (always)] pub fn cpol (& mut self) -> CpolW < '_ , Cr2Spec > { CpolW :: new (self , 10) }
#[doc = "Bit 11 - Clock enable"]
#[inline (always)] pub fn clken (& mut self) -> ClkenW < '_ , Cr2Spec > { ClkenW :: new (self , 11) }
#[doc = "Bits 12:13 - STOP bits"]
#[inline (always)] pub fn stop (& mut self) -> StopW < '_ , Cr2Spec > { StopW :: new (self , 12) }
#[doc = "Bit 14 - LIN mode enable"]
#[inline (always)] pub fn linen (& mut self) -> LinenW < '_ , Cr2Spec > { LinenW :: new (self , 14) } }
#[doc = "Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "CR3 (rw) register accessor: Control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr3`] module"]
#[doc (alias = "CR3")] pub type Cr3 = crate :: Reg < cr3 :: Cr3Spec > ;
#[doc = "Control register 3"] pub mod cr3 {
#[doc = "Register `CR3` reader"] pub type R = crate :: R < Cr3Spec > ;
#[doc = "Register `CR3` writer"] pub type W = crate :: W < Cr3Spec > ;
#[doc = "Field `EIE` reader - Error interrupt enable"] pub type EieR = crate :: BitReader ;
#[doc = "Field `EIE` writer - Error interrupt enable"] pub type EieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IREN` reader - IrDA mode enable"] pub type IrenR = crate :: BitReader ;
#[doc = "Field `IREN` writer - IrDA mode enable"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IRLP` reader - IrDA low-power"] pub type IrlpR = crate :: BitReader ;
#[doc = "Field `IRLP` writer - IrDA low-power"] pub type IrlpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HDSEL` reader - Half-duplex selection"] pub type HdselR = crate :: BitReader ;
#[doc = "Field `HDSEL` writer - Half-duplex selection"] pub type HdselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NACK` reader - Smartcard NACK enable"] pub type NackR = crate :: BitReader ;
#[doc = "Field `NACK` writer - Smartcard NACK enable"] pub type NackW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SCEN` reader - Smartcard mode enable"] pub type ScenR = crate :: BitReader ;
#[doc = "Field `SCEN` writer - Smartcard mode enable"] pub type ScenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAR` reader - DMA enable receiver"] pub type DmarR = crate :: BitReader ;
#[doc = "Field `DMAR` writer - DMA enable receiver"] pub type DmarW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAT` reader - DMA enable transmitter"] pub type DmatR = crate :: BitReader ;
#[doc = "Field `DMAT` writer - DMA enable transmitter"] pub type DmatW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTSE` reader - RTS enable"] pub type RtseR = crate :: BitReader ;
#[doc = "Field `RTSE` writer - RTS enable"] pub type RtseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTSE` reader - CTS enable"] pub type CtseR = crate :: BitReader ;
#[doc = "Field `CTSE` writer - CTS enable"] pub type CtseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTSIE` reader - CTS interrupt enable"] pub type CtsieR = crate :: BitReader ;
#[doc = "Field `CTSIE` writer - CTS interrupt enable"] pub type CtsieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Error interrupt enable"]
#[inline (always)] pub fn eie (& self) -> EieR { EieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - IrDA mode enable"]
#[inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IrDA low-power"]
#[inline (always)] pub fn irlp (& self) -> IrlpR { IrlpR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Half-duplex selection"]
#[inline (always)] pub fn hdsel (& self) -> HdselR { HdselR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Smartcard NACK enable"]
#[inline (always)] pub fn nack (& self) -> NackR { NackR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Smartcard mode enable"]
#[inline (always)] pub fn scen (& self) -> ScenR { ScenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - DMA enable receiver"]
#[inline (always)] pub fn dmar (& self) -> DmarR { DmarR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - DMA enable transmitter"]
#[inline (always)] pub fn dmat (& self) -> DmatR { DmatR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - RTS enable"]
#[inline (always)] pub fn rtse (& self) -> RtseR { RtseR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - CTS enable"]
#[inline (always)] pub fn ctse (& self) -> CtseR { CtseR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - CTS interrupt enable"]
#[inline (always)] pub fn ctsie (& self) -> CtsieR { CtsieR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Error interrupt enable"]
#[inline (always)] pub fn eie (& mut self) -> EieW < '_ , Cr3Spec > { EieW :: new (self , 0) }
#[doc = "Bit 1 - IrDA mode enable"]
#[inline (always)] pub fn iren (& mut self) -> IrenW < '_ , Cr3Spec > { IrenW :: new (self , 1) }
#[doc = "Bit 2 - IrDA low-power"]
#[inline (always)] pub fn irlp (& mut self) -> IrlpW < '_ , Cr3Spec > { IrlpW :: new (self , 2) }
#[doc = "Bit 3 - Half-duplex selection"]
#[inline (always)] pub fn hdsel (& mut self) -> HdselW < '_ , Cr3Spec > { HdselW :: new (self , 3) }
#[doc = "Bit 4 - Smartcard NACK enable"]
#[inline (always)] pub fn nack (& mut self) -> NackW < '_ , Cr3Spec > { NackW :: new (self , 4) }
#[doc = "Bit 5 - Smartcard mode enable"]
#[inline (always)] pub fn scen (& mut self) -> ScenW < '_ , Cr3Spec > { ScenW :: new (self , 5) }
#[doc = "Bit 6 - DMA enable receiver"]
#[inline (always)] pub fn dmar (& mut self) -> DmarW < '_ , Cr3Spec > { DmarW :: new (self , 6) }
#[doc = "Bit 7 - DMA enable transmitter"]
#[inline (always)] pub fn dmat (& mut self) -> DmatW < '_ , Cr3Spec > { DmatW :: new (self , 7) }
#[doc = "Bit 8 - RTS enable"]
#[inline (always)] pub fn rtse (& mut self) -> RtseW < '_ , Cr3Spec > { RtseW :: new (self , 8) }
#[doc = "Bit 9 - CTS enable"]
#[inline (always)] pub fn ctse (& mut self) -> CtseW < '_ , Cr3Spec > { CtseW :: new (self , 9) }
#[doc = "Bit 10 - CTS interrupt enable"]
#[inline (always)] pub fn ctsie (& mut self) -> CtsieW < '_ , Cr3Spec > { CtsieW :: new (self , 10) } }
#[doc = "Control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr3Spec ; impl crate :: RegisterSpec for Cr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr3::R`](R) reader structure"] impl crate :: Readable for Cr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cr3::W`](W) writer structure"] impl crate :: Writable for Cr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR3 to value 0"] impl crate :: Resettable for Cr3Spec { } }
#[doc = "GTPR (rw) register accessor: Guard time and prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`gtpr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gtpr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gtpr`] module"]
#[doc (alias = "GTPR")] pub type Gtpr = crate :: Reg < gtpr :: GtprSpec > ;
#[doc = "Guard time and prescaler register"] pub mod gtpr {
#[doc = "Register `GTPR` reader"] pub type R = crate :: R < GtprSpec > ;
#[doc = "Register `GTPR` writer"] pub type W = crate :: W < GtprSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `GT` reader - Guard time value"] pub type GtR = crate :: FieldReader ;
#[doc = "Field `GT` writer - Guard time value"] pub type GtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - Guard time value"]
#[inline (always)] pub fn gt (& self) -> GtR { GtR :: new (((self . bits >> 8) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , GtprSpec > { PscW :: new (self , 0) }
#[doc = "Bits 8:15 - Guard time value"]
#[inline (always)] pub fn gt (& mut self) -> GtW < '_ , GtprSpec > { GtW :: new (self , 8) } }
#[doc = "Guard time and prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`gtpr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gtpr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GtprSpec ; impl crate :: RegisterSpec for GtprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`gtpr::R`](R) reader structure"] impl crate :: Readable for GtprSpec { }
#[doc = "`write(|w| ..)` method takes [`gtpr::W`](W) writer structure"] impl crate :: Writable for GtprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets GTPR to value 0"] impl crate :: Resettable for GtprSpec { } } }
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub type Usart2 = crate :: Periph < usart1 :: RegisterBlock , 0x4000_4400 > ; impl core :: fmt :: Debug for Usart2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart2") . finish () } }
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub use self :: usart1 as usart2 ;
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub type Usart3 = crate :: Periph < usart1 :: RegisterBlock , 0x4000_4800 > ; impl core :: fmt :: Debug for Usart3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart3") . finish () } }
#[doc = "Universal synchronous asynchronous receiver transmitter"] pub use self :: usart1 as usart3 ;
#[doc = "Analog to digital converter"] pub type Adc1 = crate :: Periph < adc1 :: RegisterBlock , 0x4001_2400 > ; impl core :: fmt :: Debug for Adc1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc1") . finish () } }
#[doc = "Analog to digital converter"] pub mod adc1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { sr : Sr , cr1 : Cr1 , cr2 : Cr2 , smpr1 : Smpr1 , smpr2 : Smpr2 , jofr1 : Jofr1 , jofr2 : Jofr2 , jofr3 : Jofr3 , jofr4 : Jofr4 , htr : Htr , ltr : Ltr , sqr1 : Sqr1 , sqr2 : Sqr2 , sqr3 : Sqr3 , jsqr : Jsqr , jdr1 : Jdr1 , jdr2 : Jdr2 , jdr3 : Jdr3 , jdr4 : Jdr4 , dr : Dr , } impl RegisterBlock {
#[doc = "0x00 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x04 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x08 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x0c - sample time register 1"]
#[inline (always)] pub const fn smpr1 (& self) -> & Smpr1 { & self . smpr1 }
#[doc = "0x10 - sample time register 2"]
#[inline (always)] pub const fn smpr2 (& self) -> & Smpr2 { & self . smpr2 }
#[doc = "0x14 - injected channel data offset register x"]
#[inline (always)] pub const fn jofr1 (& self) -> & Jofr1 { & self . jofr1 }
#[doc = "0x18 - injected channel data offset register x"]
#[inline (always)] pub const fn jofr2 (& self) -> & Jofr2 { & self . jofr2 }
#[doc = "0x1c - injected channel data offset register x"]
#[inline (always)] pub const fn jofr3 (& self) -> & Jofr3 { & self . jofr3 }
#[doc = "0x20 - injected channel data offset register x"]
#[inline (always)] pub const fn jofr4 (& self) -> & Jofr4 { & self . jofr4 }
#[doc = "0x24 - watchdog higher threshold register"]
#[inline (always)] pub const fn htr (& self) -> & Htr { & self . htr }
#[doc = "0x28 - watchdog lower threshold register"]
#[inline (always)] pub const fn ltr (& self) -> & Ltr { & self . ltr }
#[doc = "0x2c - regular sequence register 1"]
#[inline (always)] pub const fn sqr1 (& self) -> & Sqr1 { & self . sqr1 }
#[doc = "0x30 - regular sequence register 2"]
#[inline (always)] pub const fn sqr2 (& self) -> & Sqr2 { & self . sqr2 }
#[doc = "0x34 - regular sequence register 3"]
#[inline (always)] pub const fn sqr3 (& self) -> & Sqr3 { & self . sqr3 }
#[doc = "0x38 - injected sequence register"]
#[inline (always)] pub const fn jsqr (& self) -> & Jsqr { & self . jsqr }
#[doc = "0x3c - injected data register x"]
#[inline (always)] pub const fn jdr1 (& self) -> & Jdr1 { & self . jdr1 }
#[doc = "0x40 - injected data register x"]
#[inline (always)] pub const fn jdr2 (& self) -> & Jdr2 { & self . jdr2 }
#[doc = "0x44 - injected data register x"]
#[inline (always)] pub const fn jdr3 (& self) -> & Jdr3 { & self . jdr3 }
#[doc = "0x48 - injected data register x"]
#[inline (always)] pub const fn jdr4 (& self) -> & Jdr4 { & self . jdr4 }
#[doc = "0x4c - regular data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `AWD` reader - Analog watchdog flag"] pub type AwdR = crate :: BitReader ;
#[doc = "Field `AWD` writer - Analog watchdog flag"] pub type AwdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOC` reader - Regular channel end of conversion"] pub type EocR = crate :: BitReader ;
#[doc = "Field `EOC` writer - Regular channel end of conversion"] pub type EocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEOC` reader - Injected channel end of conversion"] pub type JeocR = crate :: BitReader ;
#[doc = "Field `JEOC` writer - Injected channel end of conversion"] pub type JeocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JSTRT` reader - Injected channel start flag"] pub type JstrtR = crate :: BitReader ;
#[doc = "Field `JSTRT` writer - Injected channel start flag"] pub type JstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STRT` reader - Regular channel start flag"] pub type StrtR = crate :: BitReader ;
#[doc = "Field `STRT` writer - Regular channel start flag"] pub type StrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Analog watchdog flag"]
#[inline (always)] pub fn awd (& self) -> AwdR { AwdR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Regular channel end of conversion"]
#[inline (always)] pub fn eoc (& self) -> EocR { EocR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Injected channel end of conversion"]
#[inline (always)] pub fn jeoc (& self) -> JeocR { JeocR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Injected channel start flag"]
#[inline (always)] pub fn jstrt (& self) -> JstrtR { JstrtR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Regular channel start flag"]
#[inline (always)] pub fn strt (& self) -> StrtR { StrtR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Analog watchdog flag"]
#[inline (always)] pub fn awd (& mut self) -> AwdW < '_ , SrSpec > { AwdW :: new (self , 0) }
#[doc = "Bit 1 - Regular channel end of conversion"]
#[inline (always)] pub fn eoc (& mut self) -> EocW < '_ , SrSpec > { EocW :: new (self , 1) }
#[doc = "Bit 2 - Injected channel end of conversion"]
#[inline (always)] pub fn jeoc (& mut self) -> JeocW < '_ , SrSpec > { JeocW :: new (self , 2) }
#[doc = "Bit 3 - Injected channel start flag"]
#[inline (always)] pub fn jstrt (& mut self) -> JstrtW < '_ , SrSpec > { JstrtW :: new (self , 3) }
#[doc = "Bit 4 - Regular channel start flag"]
#[inline (always)] pub fn strt (& mut self) -> StrtW < '_ , SrSpec > { StrtW :: new (self , 4) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `AWDCH` reader - Analog watchdog channel select bits"] pub type AwdchR = crate :: FieldReader ;
#[doc = "Field `AWDCH` writer - Analog watchdog channel select bits"] pub type AwdchW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `EOCIE` reader - Interrupt enable for EOC"] pub type EocieR = crate :: BitReader ;
#[doc = "Field `EOCIE` writer - Interrupt enable for EOC"] pub type EocieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWDIE` reader - Analog watchdog interrupt enable"] pub type AwdieR = crate :: BitReader ;
#[doc = "Field `AWDIE` writer - Analog watchdog interrupt enable"] pub type AwdieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEOCIE` reader - Interrupt enable for injected channels"] pub type JeocieR = crate :: BitReader ;
#[doc = "Field `JEOCIE` writer - Interrupt enable for injected channels"] pub type JeocieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SCAN` reader - Scan mode"] pub type ScanR = crate :: BitReader ;
#[doc = "Field `SCAN` writer - Scan mode"] pub type ScanW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWDSGL` reader - Enable the watchdog on a single channel in scan mode"] pub type AwdsglR = crate :: BitReader ;
#[doc = "Field `AWDSGL` writer - Enable the watchdog on a single channel in scan mode"] pub type AwdsglW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JAUTO` reader - Automatic injected group conversion"] pub type JautoR = crate :: BitReader ;
#[doc = "Field `JAUTO` writer - Automatic injected group conversion"] pub type JautoW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISCEN` reader - Discontinuous mode on regular channels"] pub type DiscenR = crate :: BitReader ;
#[doc = "Field `DISCEN` writer - Discontinuous mode on regular channels"] pub type DiscenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JDISCEN` reader - Discontinuous mode on injected channels"] pub type JdiscenR = crate :: BitReader ;
#[doc = "Field `JDISCEN` writer - Discontinuous mode on injected channels"] pub type JdiscenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISCNUM` reader - Discontinuous mode channel count"] pub type DiscnumR = crate :: FieldReader ;
#[doc = "Field `DISCNUM` writer - Discontinuous mode channel count"] pub type DiscnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DUALMOD` reader - Dual mode selection"] pub type DualmodR = crate :: FieldReader ;
#[doc = "Field `DUALMOD` writer - Dual mode selection"] pub type DualmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `JAWDEN` reader - Analog watchdog enable on injected channels"] pub type JawdenR = crate :: BitReader ;
#[doc = "Field `JAWDEN` writer - Analog watchdog enable on injected channels"] pub type JawdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWDEN` reader - Analog watchdog enable on regular channels"] pub type AwdenR = crate :: BitReader ;
#[doc = "Field `AWDEN` writer - Analog watchdog enable on regular channels"] pub type AwdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:4 - Analog watchdog channel select bits"]
#[inline (always)] pub fn awdch (& self) -> AwdchR { AwdchR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bit 5 - Interrupt enable for EOC"]
#[inline (always)] pub fn eocie (& self) -> EocieR { EocieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Analog watchdog interrupt enable"]
#[inline (always)] pub fn awdie (& self) -> AwdieR { AwdieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Interrupt enable for injected channels"]
#[inline (always)] pub fn jeocie (& self) -> JeocieR { JeocieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Scan mode"]
#[inline (always)] pub fn scan (& self) -> ScanR { ScanR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"]
#[inline (always)] pub fn awdsgl (& self) -> AwdsglR { AwdsglR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Automatic injected group conversion"]
#[inline (always)] pub fn jauto (& self) -> JautoR { JautoR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Discontinuous mode on regular channels"]
#[inline (always)] pub fn discen (& self) -> DiscenR { DiscenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Discontinuous mode on injected channels"]
#[inline (always)] pub fn jdiscen (& self) -> JdiscenR { JdiscenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:15 - Discontinuous mode channel count"]
#[inline (always)] pub fn discnum (& self) -> DiscnumR { DiscnumR :: new (((self . bits >> 13) & 7) as u8) }
#[doc = "Bits 16:19 - Dual mode selection"]
#[inline (always)] pub fn dualmod (& self) -> DualmodR { DualmodR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bit 22 - Analog watchdog enable on injected channels"]
#[inline (always)] pub fn jawden (& self) -> JawdenR { JawdenR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Analog watchdog enable on regular channels"]
#[inline (always)] pub fn awden (& self) -> AwdenR { AwdenR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bits 0:4 - Analog watchdog channel select bits"]
#[inline (always)] pub fn awdch (& mut self) -> AwdchW < '_ , Cr1Spec > { AwdchW :: new (self , 0) }
#[doc = "Bit 5 - Interrupt enable for EOC"]
#[inline (always)] pub fn eocie (& mut self) -> EocieW < '_ , Cr1Spec > { EocieW :: new (self , 5) }
#[doc = "Bit 6 - Analog watchdog interrupt enable"]
#[inline (always)] pub fn awdie (& mut self) -> AwdieW < '_ , Cr1Spec > { AwdieW :: new (self , 6) }
#[doc = "Bit 7 - Interrupt enable for injected channels"]
#[inline (always)] pub fn jeocie (& mut self) -> JeocieW < '_ , Cr1Spec > { JeocieW :: new (self , 7) }
#[doc = "Bit 8 - Scan mode"]
#[inline (always)] pub fn scan (& mut self) -> ScanW < '_ , Cr1Spec > { ScanW :: new (self , 8) }
#[doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"]
#[inline (always)] pub fn awdsgl (& mut self) -> AwdsglW < '_ , Cr1Spec > { AwdsglW :: new (self , 9) }
#[doc = "Bit 10 - Automatic injected group conversion"]
#[inline (always)] pub fn jauto (& mut self) -> JautoW < '_ , Cr1Spec > { JautoW :: new (self , 10) }
#[doc = "Bit 11 - Discontinuous mode on regular channels"]
#[inline (always)] pub fn discen (& mut self) -> DiscenW < '_ , Cr1Spec > { DiscenW :: new (self , 11) }
#[doc = "Bit 12 - Discontinuous mode on injected channels"]
#[inline (always)] pub fn jdiscen (& mut self) -> JdiscenW < '_ , Cr1Spec > { JdiscenW :: new (self , 12) }
#[doc = "Bits 13:15 - Discontinuous mode channel count"]
#[inline (always)] pub fn discnum (& mut self) -> DiscnumW < '_ , Cr1Spec > { DiscnumW :: new (self , 13) }
#[doc = "Bits 16:19 - Dual mode selection"]
#[inline (always)] pub fn dualmod (& mut self) -> DualmodW < '_ , Cr1Spec > { DualmodW :: new (self , 16) }
#[doc = "Bit 22 - Analog watchdog enable on injected channels"]
#[inline (always)] pub fn jawden (& mut self) -> JawdenW < '_ , Cr1Spec > { JawdenW :: new (self , 22) }
#[doc = "Bit 23 - Analog watchdog enable on regular channels"]
#[inline (always)] pub fn awden (& mut self) -> AwdenW < '_ , Cr1Spec > { AwdenW :: new (self , 23) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `ADON` reader - A/D converter ON / OFF"] pub type AdonR = crate :: BitReader ;
#[doc = "Field `ADON` writer - A/D converter ON / OFF"] pub type AdonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CONT` reader - Continuous conversion"] pub type ContR = crate :: BitReader ;
#[doc = "Field `CONT` writer - Continuous conversion"] pub type ContW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CAL` reader - A/D calibration"] pub type CalR = crate :: BitReader ;
#[doc = "Field `CAL` writer - A/D calibration"] pub type CalW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RSTCAL` reader - Reset calibration"] pub type RstcalR = crate :: BitReader ;
#[doc = "Field `RSTCAL` writer - Reset calibration"] pub type RstcalW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA` reader - Direct memory access mode"] pub type DmaR = crate :: BitReader ;
#[doc = "Field `DMA` writer - Direct memory access mode"] pub type DmaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALIGN` reader - Data alignment"] pub type AlignR = crate :: BitReader ;
#[doc = "Field `ALIGN` writer - Data alignment"] pub type AlignW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEXTSEL` reader - External event select for injected group"] pub type JextselR = crate :: FieldReader ;
#[doc = "Field `JEXTSEL` writer - External event select for injected group"] pub type JextselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `JEXTTRIG` reader - External trigger conversion mode for injected channels"] pub type JexttrigR = crate :: BitReader ;
#[doc = "Field `JEXTTRIG` writer - External trigger conversion mode for injected channels"] pub type JexttrigW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTSEL` reader - External event select for regular group"] pub type ExtselR = crate :: FieldReader ;
#[doc = "Field `EXTSEL` writer - External event select for regular group"] pub type ExtselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTTRIG` reader - External trigger conversion mode for regular channels"] pub type ExttrigR = crate :: BitReader ;
#[doc = "Field `EXTTRIG` writer - External trigger conversion mode for regular channels"] pub type ExttrigW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JSWSTART` reader - Start conversion of injected channels"] pub type JswstartR = crate :: BitReader ;
#[doc = "Field `JSWSTART` writer - Start conversion of injected channels"] pub type JswstartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWSTART` reader - Start conversion of regular channels"] pub type SwstartR = crate :: BitReader ;
#[doc = "Field `SWSTART` writer - Start conversion of regular channels"] pub type SwstartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSVREFE` reader - Temperature sensor and VREFINT enable"] pub type TsvrefeR = crate :: BitReader ;
#[doc = "Field `TSVREFE` writer - Temperature sensor and VREFINT enable"] pub type TsvrefeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - A/D converter ON / OFF"]
#[inline (always)] pub fn adon (& self) -> AdonR { AdonR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Continuous conversion"]
#[inline (always)] pub fn cont (& self) -> ContR { ContR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - A/D calibration"]
#[inline (always)] pub fn cal (& self) -> CalR { CalR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Reset calibration"]
#[inline (always)] pub fn rstcal (& self) -> RstcalR { RstcalR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 8 - Direct memory access mode"]
#[inline (always)] pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 11 - Data alignment"]
#[inline (always)] pub fn align (& self) -> AlignR { AlignR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - External event select for injected group"]
#[inline (always)] pub fn jextsel (& self) -> JextselR { JextselR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - External trigger conversion mode for injected channels"]
#[inline (always)] pub fn jexttrig (& self) -> JexttrigR { JexttrigR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 17:19 - External event select for regular group"]
#[inline (always)] pub fn extsel (& self) -> ExtselR { ExtselR :: new (((self . bits >> 17) & 7) as u8) }
#[doc = "Bit 20 - External trigger conversion mode for regular channels"]
#[inline (always)] pub fn exttrig (& self) -> ExttrigR { ExttrigR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Start conversion of injected channels"]
#[inline (always)] pub fn jswstart (& self) -> JswstartR { JswstartR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Start conversion of regular channels"]
#[inline (always)] pub fn swstart (& self) -> SwstartR { SwstartR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Temperature sensor and VREFINT enable"]
#[inline (always)] pub fn tsvrefe (& self) -> TsvrefeR { TsvrefeR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - A/D converter ON / OFF"]
#[inline (always)] pub fn adon (& mut self) -> AdonW < '_ , Cr2Spec > { AdonW :: new (self , 0) }
#[doc = "Bit 1 - Continuous conversion"]
#[inline (always)] pub fn cont (& mut self) -> ContW < '_ , Cr2Spec > { ContW :: new (self , 1) }
#[doc = "Bit 2 - A/D calibration"]
#[inline (always)] pub fn cal (& mut self) -> CalW < '_ , Cr2Spec > { CalW :: new (self , 2) }
#[doc = "Bit 3 - Reset calibration"]
#[inline (always)] pub fn rstcal (& mut self) -> RstcalW < '_ , Cr2Spec > { RstcalW :: new (self , 3) }
#[doc = "Bit 8 - Direct memory access mode"]
#[inline (always)] pub fn dma (& mut self) -> DmaW < '_ , Cr2Spec > { DmaW :: new (self , 8) }
#[doc = "Bit 11 - Data alignment"]
#[inline (always)] pub fn align (& mut self) -> AlignW < '_ , Cr2Spec > { AlignW :: new (self , 11) }
#[doc = "Bits 12:14 - External event select for injected group"]
#[inline (always)] pub fn jextsel (& mut self) -> JextselW < '_ , Cr2Spec > { JextselW :: new (self , 12) }
#[doc = "Bit 15 - External trigger conversion mode for injected channels"]
#[inline (always)] pub fn jexttrig (& mut self) -> JexttrigW < '_ , Cr2Spec > { JexttrigW :: new (self , 15) }
#[doc = "Bits 17:19 - External event select for regular group"]
#[inline (always)] pub fn extsel (& mut self) -> ExtselW < '_ , Cr2Spec > { ExtselW :: new (self , 17) }
#[doc = "Bit 20 - External trigger conversion mode for regular channels"]
#[inline (always)] pub fn exttrig (& mut self) -> ExttrigW < '_ , Cr2Spec > { ExttrigW :: new (self , 20) }
#[doc = "Bit 21 - Start conversion of injected channels"]
#[inline (always)] pub fn jswstart (& mut self) -> JswstartW < '_ , Cr2Spec > { JswstartW :: new (self , 21) }
#[doc = "Bit 22 - Start conversion of regular channels"]
#[inline (always)] pub fn swstart (& mut self) -> SwstartW < '_ , Cr2Spec > { SwstartW :: new (self , 22) }
#[doc = "Bit 23 - Temperature sensor and VREFINT enable"]
#[inline (always)] pub fn tsvrefe (& mut self) -> TsvrefeW < '_ , Cr2Spec > { TsvrefeW :: new (self , 23) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMPR1 (rw) register accessor: sample time register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smpr1`] module"]
#[doc (alias = "SMPR1")] pub type Smpr1 = crate :: Reg < smpr1 :: Smpr1Spec > ;
#[doc = "sample time register 1"] pub mod smpr1 {
#[doc = "Register `SMPR1` reader"] pub type R = crate :: R < Smpr1Spec > ;
#[doc = "Register `SMPR1` writer"] pub type W = crate :: W < Smpr1Spec > ;
#[doc = "Field `SMP10` reader - Channel 10 sample time selection"] pub type Smp10R = crate :: FieldReader ;
#[doc = "Field `SMP10` writer - Channel 10 sample time selection"] pub type Smp10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP11` reader - Channel 11 sample time selection"] pub type Smp11R = crate :: FieldReader ;
#[doc = "Field `SMP11` writer - Channel 11 sample time selection"] pub type Smp11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP12` reader - Channel 12 sample time selection"] pub type Smp12R = crate :: FieldReader ;
#[doc = "Field `SMP12` writer - Channel 12 sample time selection"] pub type Smp12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP13` reader - Channel 13 sample time selection"] pub type Smp13R = crate :: FieldReader ;
#[doc = "Field `SMP13` writer - Channel 13 sample time selection"] pub type Smp13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP14` reader - Channel 14 sample time selection"] pub type Smp14R = crate :: FieldReader ;
#[doc = "Field `SMP14` writer - Channel 14 sample time selection"] pub type Smp14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP15` reader - Channel 15 sample time selection"] pub type Smp15R = crate :: FieldReader ;
#[doc = "Field `SMP15` writer - Channel 15 sample time selection"] pub type Smp15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP16` reader - Channel 16 sample time selection"] pub type Smp16R = crate :: FieldReader ;
#[doc = "Field `SMP16` writer - Channel 16 sample time selection"] pub type Smp16W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP17` reader - Channel 17 sample time selection"] pub type Smp17R = crate :: FieldReader ;
#[doc = "Field `SMP17` writer - Channel 17 sample time selection"] pub type Smp17W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Channel 10 sample time selection"]
#[inline (always)] pub fn smp10 (& self) -> Smp10R { Smp10R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 3:5 - Channel 11 sample time selection"]
#[inline (always)] pub fn smp11 (& self) -> Smp11R { Smp11R :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:8 - Channel 12 sample time selection"]
#[inline (always)] pub fn smp12 (& self) -> Smp12R { Smp12R :: new (((self . bits >> 6) & 7) as u8) }
#[doc = "Bits 9:11 - Channel 13 sample time selection"]
#[inline (always)] pub fn smp13 (& self) -> Smp13R { Smp13R :: new (((self . bits >> 9) & 7) as u8) }
#[doc = "Bits 12:14 - Channel 14 sample time selection"]
#[inline (always)] pub fn smp14 (& self) -> Smp14R { Smp14R :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 15:17 - Channel 15 sample time selection"]
#[inline (always)] pub fn smp15 (& self) -> Smp15R { Smp15R :: new (((self . bits >> 15) & 7) as u8) }
#[doc = "Bits 18:20 - Channel 16 sample time selection"]
#[inline (always)] pub fn smp16 (& self) -> Smp16R { Smp16R :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bits 21:23 - Channel 17 sample time selection"]
#[inline (always)] pub fn smp17 (& self) -> Smp17R { Smp17R :: new (((self . bits >> 21) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Channel 10 sample time selection"]
#[inline (always)] pub fn smp10 (& mut self) -> Smp10W < '_ , Smpr1Spec > { Smp10W :: new (self , 0) }
#[doc = "Bits 3:5 - Channel 11 sample time selection"]
#[inline (always)] pub fn smp11 (& mut self) -> Smp11W < '_ , Smpr1Spec > { Smp11W :: new (self , 3) }
#[doc = "Bits 6:8 - Channel 12 sample time selection"]
#[inline (always)] pub fn smp12 (& mut self) -> Smp12W < '_ , Smpr1Spec > { Smp12W :: new (self , 6) }
#[doc = "Bits 9:11 - Channel 13 sample time selection"]
#[inline (always)] pub fn smp13 (& mut self) -> Smp13W < '_ , Smpr1Spec > { Smp13W :: new (self , 9) }
#[doc = "Bits 12:14 - Channel 14 sample time selection"]
#[inline (always)] pub fn smp14 (& mut self) -> Smp14W < '_ , Smpr1Spec > { Smp14W :: new (self , 12) }
#[doc = "Bits 15:17 - Channel 15 sample time selection"]
#[inline (always)] pub fn smp15 (& mut self) -> Smp15W < '_ , Smpr1Spec > { Smp15W :: new (self , 15) }
#[doc = "Bits 18:20 - Channel 16 sample time selection"]
#[inline (always)] pub fn smp16 (& mut self) -> Smp16W < '_ , Smpr1Spec > { Smp16W :: new (self , 18) }
#[doc = "Bits 21:23 - Channel 17 sample time selection"]
#[inline (always)] pub fn smp17 (& mut self) -> Smp17W < '_ , Smpr1Spec > { Smp17W :: new (self , 21) } }
#[doc = "sample time register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Smpr1Spec ; impl crate :: RegisterSpec for Smpr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smpr1::R`](R) reader structure"] impl crate :: Readable for Smpr1Spec { }
#[doc = "`write(|w| ..)` method takes [`smpr1::W`](W) writer structure"] impl crate :: Writable for Smpr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMPR1 to value 0"] impl crate :: Resettable for Smpr1Spec { } }
#[doc = "SMPR2 (rw) register accessor: sample time register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smpr2`] module"]
#[doc (alias = "SMPR2")] pub type Smpr2 = crate :: Reg < smpr2 :: Smpr2Spec > ;
#[doc = "sample time register 2"] pub mod smpr2 {
#[doc = "Register `SMPR2` reader"] pub type R = crate :: R < Smpr2Spec > ;
#[doc = "Register `SMPR2` writer"] pub type W = crate :: W < Smpr2Spec > ;
#[doc = "Field `SMP0` reader - Channel 0 sample time selection"] pub type Smp0R = crate :: FieldReader ;
#[doc = "Field `SMP0` writer - Channel 0 sample time selection"] pub type Smp0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP1` reader - Channel 1 sample time selection"] pub type Smp1R = crate :: FieldReader ;
#[doc = "Field `SMP1` writer - Channel 1 sample time selection"] pub type Smp1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP2` reader - Channel 2 sample time selection"] pub type Smp2R = crate :: FieldReader ;
#[doc = "Field `SMP2` writer - Channel 2 sample time selection"] pub type Smp2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP3` reader - Channel 3 sample time selection"] pub type Smp3R = crate :: FieldReader ;
#[doc = "Field `SMP3` writer - Channel 3 sample time selection"] pub type Smp3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP4` reader - Channel 4 sample time selection"] pub type Smp4R = crate :: FieldReader ;
#[doc = "Field `SMP4` writer - Channel 4 sample time selection"] pub type Smp4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP5` reader - Channel 5 sample time selection"] pub type Smp5R = crate :: FieldReader ;
#[doc = "Field `SMP5` writer - Channel 5 sample time selection"] pub type Smp5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP6` reader - Channel 6 sample time selection"] pub type Smp6R = crate :: FieldReader ;
#[doc = "Field `SMP6` writer - Channel 6 sample time selection"] pub type Smp6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP7` reader - Channel 7 sample time selection"] pub type Smp7R = crate :: FieldReader ;
#[doc = "Field `SMP7` writer - Channel 7 sample time selection"] pub type Smp7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP8` reader - Channel 8 sample time selection"] pub type Smp8R = crate :: FieldReader ;
#[doc = "Field `SMP8` writer - Channel 8 sample time selection"] pub type Smp8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP9` reader - Channel 9 sample time selection"] pub type Smp9R = crate :: FieldReader ;
#[doc = "Field `SMP9` writer - Channel 9 sample time selection"] pub type Smp9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Channel 0 sample time selection"]
#[inline (always)] pub fn smp0 (& self) -> Smp0R { Smp0R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 3:5 - Channel 1 sample time selection"]
#[inline (always)] pub fn smp1 (& self) -> Smp1R { Smp1R :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:8 - Channel 2 sample time selection"]
#[inline (always)] pub fn smp2 (& self) -> Smp2R { Smp2R :: new (((self . bits >> 6) & 7) as u8) }
#[doc = "Bits 9:11 - Channel 3 sample time selection"]
#[inline (always)] pub fn smp3 (& self) -> Smp3R { Smp3R :: new (((self . bits >> 9) & 7) as u8) }
#[doc = "Bits 12:14 - Channel 4 sample time selection"]
#[inline (always)] pub fn smp4 (& self) -> Smp4R { Smp4R :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 15:17 - Channel 5 sample time selection"]
#[inline (always)] pub fn smp5 (& self) -> Smp5R { Smp5R :: new (((self . bits >> 15) & 7) as u8) }
#[doc = "Bits 18:20 - Channel 6 sample time selection"]
#[inline (always)] pub fn smp6 (& self) -> Smp6R { Smp6R :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bits 21:23 - Channel 7 sample time selection"]
#[inline (always)] pub fn smp7 (& self) -> Smp7R { Smp7R :: new (((self . bits >> 21) & 7) as u8) }
#[doc = "Bits 24:26 - Channel 8 sample time selection"]
#[inline (always)] pub fn smp8 (& self) -> Smp8R { Smp8R :: new (((self . bits >> 24) & 7) as u8) }
#[doc = "Bits 27:29 - Channel 9 sample time selection"]
#[inline (always)] pub fn smp9 (& self) -> Smp9R { Smp9R :: new (((self . bits >> 27) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Channel 0 sample time selection"]
#[inline (always)] pub fn smp0 (& mut self) -> Smp0W < '_ , Smpr2Spec > { Smp0W :: new (self , 0) }
#[doc = "Bits 3:5 - Channel 1 sample time selection"]
#[inline (always)] pub fn smp1 (& mut self) -> Smp1W < '_ , Smpr2Spec > { Smp1W :: new (self , 3) }
#[doc = "Bits 6:8 - Channel 2 sample time selection"]
#[inline (always)] pub fn smp2 (& mut self) -> Smp2W < '_ , Smpr2Spec > { Smp2W :: new (self , 6) }
#[doc = "Bits 9:11 - Channel 3 sample time selection"]
#[inline (always)] pub fn smp3 (& mut self) -> Smp3W < '_ , Smpr2Spec > { Smp3W :: new (self , 9) }
#[doc = "Bits 12:14 - Channel 4 sample time selection"]
#[inline (always)] pub fn smp4 (& mut self) -> Smp4W < '_ , Smpr2Spec > { Smp4W :: new (self , 12) }
#[doc = "Bits 15:17 - Channel 5 sample time selection"]
#[inline (always)] pub fn smp5 (& mut self) -> Smp5W < '_ , Smpr2Spec > { Smp5W :: new (self , 15) }
#[doc = "Bits 18:20 - Channel 6 sample time selection"]
#[inline (always)] pub fn smp6 (& mut self) -> Smp6W < '_ , Smpr2Spec > { Smp6W :: new (self , 18) }
#[doc = "Bits 21:23 - Channel 7 sample time selection"]
#[inline (always)] pub fn smp7 (& mut self) -> Smp7W < '_ , Smpr2Spec > { Smp7W :: new (self , 21) }
#[doc = "Bits 24:26 - Channel 8 sample time selection"]
#[inline (always)] pub fn smp8 (& mut self) -> Smp8W < '_ , Smpr2Spec > { Smp8W :: new (self , 24) }
#[doc = "Bits 27:29 - Channel 9 sample time selection"]
#[inline (always)] pub fn smp9 (& mut self) -> Smp9W < '_ , Smpr2Spec > { Smp9W :: new (self , 27) } }
#[doc = "sample time register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Smpr2Spec ; impl crate :: RegisterSpec for Smpr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smpr2::R`](R) reader structure"] impl crate :: Readable for Smpr2Spec { }
#[doc = "`write(|w| ..)` method takes [`smpr2::W`](W) writer structure"] impl crate :: Writable for Smpr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMPR2 to value 0"] impl crate :: Resettable for Smpr2Spec { } }
#[doc = "JOFR1 (rw) register accessor: injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jofr1`] module"]
#[doc (alias = "JOFR1")] pub type Jofr1 = crate :: Reg < jofr1 :: Jofr1Spec > ;
#[doc = "injected channel data offset register x"] pub mod jofr1 {
#[doc = "Register `JOFR1` reader"] pub type R = crate :: R < Jofr1Spec > ;
#[doc = "Register `JOFR1` writer"] pub type W = crate :: W < Jofr1Spec > ;
#[doc = "Field `JOFFSET1` reader - Data offset for injected channel x"] pub type Joffset1R = crate :: FieldReader < u16 > ;
#[doc = "Field `JOFFSET1` writer - Data offset for injected channel x"] pub type Joffset1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset1 (& self) -> Joffset1R { Joffset1R :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset1 (& mut self) -> Joffset1W < '_ , Jofr1Spec > { Joffset1W :: new (self , 0) } }
#[doc = "injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jofr1Spec ; impl crate :: RegisterSpec for Jofr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jofr1::R`](R) reader structure"] impl crate :: Readable for Jofr1Spec { }
#[doc = "`write(|w| ..)` method takes [`jofr1::W`](W) writer structure"] impl crate :: Writable for Jofr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JOFR1 to value 0"] impl crate :: Resettable for Jofr1Spec { } }
#[doc = "JOFR2 (rw) register accessor: injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jofr2`] module"]
#[doc (alias = "JOFR2")] pub type Jofr2 = crate :: Reg < jofr2 :: Jofr2Spec > ;
#[doc = "injected channel data offset register x"] pub mod jofr2 {
#[doc = "Register `JOFR2` reader"] pub type R = crate :: R < Jofr2Spec > ;
#[doc = "Register `JOFR2` writer"] pub type W = crate :: W < Jofr2Spec > ;
#[doc = "Field `JOFFSET2` reader - Data offset for injected channel x"] pub type Joffset2R = crate :: FieldReader < u16 > ;
#[doc = "Field `JOFFSET2` writer - Data offset for injected channel x"] pub type Joffset2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset2 (& self) -> Joffset2R { Joffset2R :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset2 (& mut self) -> Joffset2W < '_ , Jofr2Spec > { Joffset2W :: new (self , 0) } }
#[doc = "injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jofr2Spec ; impl crate :: RegisterSpec for Jofr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jofr2::R`](R) reader structure"] impl crate :: Readable for Jofr2Spec { }
#[doc = "`write(|w| ..)` method takes [`jofr2::W`](W) writer structure"] impl crate :: Writable for Jofr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JOFR2 to value 0"] impl crate :: Resettable for Jofr2Spec { } }
#[doc = "JOFR3 (rw) register accessor: injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jofr3`] module"]
#[doc (alias = "JOFR3")] pub type Jofr3 = crate :: Reg < jofr3 :: Jofr3Spec > ;
#[doc = "injected channel data offset register x"] pub mod jofr3 {
#[doc = "Register `JOFR3` reader"] pub type R = crate :: R < Jofr3Spec > ;
#[doc = "Register `JOFR3` writer"] pub type W = crate :: W < Jofr3Spec > ;
#[doc = "Field `JOFFSET3` reader - Data offset for injected channel x"] pub type Joffset3R = crate :: FieldReader < u16 > ;
#[doc = "Field `JOFFSET3` writer - Data offset for injected channel x"] pub type Joffset3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset3 (& self) -> Joffset3R { Joffset3R :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset3 (& mut self) -> Joffset3W < '_ , Jofr3Spec > { Joffset3W :: new (self , 0) } }
#[doc = "injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jofr3Spec ; impl crate :: RegisterSpec for Jofr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jofr3::R`](R) reader structure"] impl crate :: Readable for Jofr3Spec { }
#[doc = "`write(|w| ..)` method takes [`jofr3::W`](W) writer structure"] impl crate :: Writable for Jofr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JOFR3 to value 0"] impl crate :: Resettable for Jofr3Spec { } }
#[doc = "JOFR4 (rw) register accessor: injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jofr4`] module"]
#[doc (alias = "JOFR4")] pub type Jofr4 = crate :: Reg < jofr4 :: Jofr4Spec > ;
#[doc = "injected channel data offset register x"] pub mod jofr4 {
#[doc = "Register `JOFR4` reader"] pub type R = crate :: R < Jofr4Spec > ;
#[doc = "Register `JOFR4` writer"] pub type W = crate :: W < Jofr4Spec > ;
#[doc = "Field `JOFFSET4` reader - Data offset for injected channel x"] pub type Joffset4R = crate :: FieldReader < u16 > ;
#[doc = "Field `JOFFSET4` writer - Data offset for injected channel x"] pub type Joffset4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset4 (& self) -> Joffset4R { Joffset4R :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset4 (& mut self) -> Joffset4W < '_ , Jofr4Spec > { Joffset4W :: new (self , 0) } }
#[doc = "injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jofr4Spec ; impl crate :: RegisterSpec for Jofr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jofr4::R`](R) reader structure"] impl crate :: Readable for Jofr4Spec { }
#[doc = "`write(|w| ..)` method takes [`jofr4::W`](W) writer structure"] impl crate :: Writable for Jofr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JOFR4 to value 0"] impl crate :: Resettable for Jofr4Spec { } }
#[doc = "HTR (rw) register accessor: watchdog higher threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`htr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`htr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@htr`] module"]
#[doc (alias = "HTR")] pub type Htr = crate :: Reg < htr :: HtrSpec > ;
#[doc = "watchdog higher threshold register"] pub mod htr {
#[doc = "Register `HTR` reader"] pub type R = crate :: R < HtrSpec > ;
#[doc = "Register `HTR` writer"] pub type W = crate :: W < HtrSpec > ;
#[doc = "Field `HT` reader - Analog watchdog higher threshold"] pub type HtR = crate :: FieldReader < u16 > ;
#[doc = "Field `HT` writer - Analog watchdog higher threshold"] pub type HtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Analog watchdog higher threshold"]
#[inline (always)] pub fn ht (& self) -> HtR { HtR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Analog watchdog higher threshold"]
#[inline (always)] pub fn ht (& mut self) -> HtW < '_ , HtrSpec > { HtW :: new (self , 0) } }
#[doc = "watchdog higher threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`htr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`htr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HtrSpec ; impl crate :: RegisterSpec for HtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`htr::R`](R) reader structure"] impl crate :: Readable for HtrSpec { }
#[doc = "`write(|w| ..)` method takes [`htr::W`](W) writer structure"] impl crate :: Writable for HtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets HTR to value 0x0fff"] impl crate :: Resettable for HtrSpec { const RESET_VALUE : u32 = 0x0fff ; } }
#[doc = "LTR (rw) register accessor: watchdog lower threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`ltr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ltr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ltr`] module"]
#[doc (alias = "LTR")] pub type Ltr = crate :: Reg < ltr :: LtrSpec > ;
#[doc = "watchdog lower threshold register"] pub mod ltr {
#[doc = "Register `LTR` reader"] pub type R = crate :: R < LtrSpec > ;
#[doc = "Register `LTR` writer"] pub type W = crate :: W < LtrSpec > ;
#[doc = "Field `LT` reader - Analog watchdog lower threshold"] pub type LtR = crate :: FieldReader < u16 > ;
#[doc = "Field `LT` writer - Analog watchdog lower threshold"] pub type LtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Analog watchdog lower threshold"]
#[inline (always)] pub fn lt (& self) -> LtR { LtR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Analog watchdog lower threshold"]
#[inline (always)] pub fn lt (& mut self) -> LtW < '_ , LtrSpec > { LtW :: new (self , 0) } }
#[doc = "watchdog lower threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`ltr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ltr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LtrSpec ; impl crate :: RegisterSpec for LtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ltr::R`](R) reader structure"] impl crate :: Readable for LtrSpec { }
#[doc = "`write(|w| ..)` method takes [`ltr::W`](W) writer structure"] impl crate :: Writable for LtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LTR to value 0"] impl crate :: Resettable for LtrSpec { } }
#[doc = "SQR1 (rw) register accessor: regular sequence register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr1`] module"]
#[doc (alias = "SQR1")] pub type Sqr1 = crate :: Reg < sqr1 :: Sqr1Spec > ;
#[doc = "regular sequence register 1"] pub mod sqr1 {
#[doc = "Register `SQR1` reader"] pub type R = crate :: R < Sqr1Spec > ;
#[doc = "Register `SQR1` writer"] pub type W = crate :: W < Sqr1Spec > ;
#[doc = "Field `SQ13` reader - 13th conversion in regular sequence"] pub type Sq13R = crate :: FieldReader ;
#[doc = "Field `SQ13` writer - 13th conversion in regular sequence"] pub type Sq13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ14` reader - 14th conversion in regular sequence"] pub type Sq14R = crate :: FieldReader ;
#[doc = "Field `SQ14` writer - 14th conversion in regular sequence"] pub type Sq14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ15` reader - 15th conversion in regular sequence"] pub type Sq15R = crate :: FieldReader ;
#[doc = "Field `SQ15` writer - 15th conversion in regular sequence"] pub type Sq15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ16` reader - 16th conversion in regular sequence"] pub type Sq16R = crate :: FieldReader ;
#[doc = "Field `SQ16` writer - 16th conversion in regular sequence"] pub type Sq16W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `L` reader - Regular channel sequence length"] pub type LR = crate :: FieldReader ;
#[doc = "Field `L` writer - Regular channel sequence length"] pub type LW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:4 - 13th conversion in regular sequence"]
#[inline (always)] pub fn sq13 (& self) -> Sq13R { Sq13R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 5:9 - 14th conversion in regular sequence"]
#[inline (always)] pub fn sq14 (& self) -> Sq14R { Sq14R :: new (((self . bits >> 5) & 0x1f) as u8) }
#[doc = "Bits 10:14 - 15th conversion in regular sequence"]
#[inline (always)] pub fn sq15 (& self) -> Sq15R { Sq15R :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bits 15:19 - 16th conversion in regular sequence"]
#[inline (always)] pub fn sq16 (& self) -> Sq16R { Sq16R :: new (((self . bits >> 15) & 0x1f) as u8) }
#[doc = "Bits 20:23 - Regular channel sequence length"]
#[inline (always)] pub fn l (& self) -> LR { LR :: new (((self . bits >> 20) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:4 - 13th conversion in regular sequence"]
#[inline (always)] pub fn sq13 (& mut self) -> Sq13W < '_ , Sqr1Spec > { Sq13W :: new (self , 0) }
#[doc = "Bits 5:9 - 14th conversion in regular sequence"]
#[inline (always)] pub fn sq14 (& mut self) -> Sq14W < '_ , Sqr1Spec > { Sq14W :: new (self , 5) }
#[doc = "Bits 10:14 - 15th conversion in regular sequence"]
#[inline (always)] pub fn sq15 (& mut self) -> Sq15W < '_ , Sqr1Spec > { Sq15W :: new (self , 10) }
#[doc = "Bits 15:19 - 16th conversion in regular sequence"]
#[inline (always)] pub fn sq16 (& mut self) -> Sq16W < '_ , Sqr1Spec > { Sq16W :: new (self , 15) }
#[doc = "Bits 20:23 - Regular channel sequence length"]
#[inline (always)] pub fn l (& mut self) -> LW < '_ , Sqr1Spec > { LW :: new (self , 20) } }
#[doc = "regular sequence register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr1Spec ; impl crate :: RegisterSpec for Sqr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr1::R`](R) reader structure"] impl crate :: Readable for Sqr1Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr1::W`](W) writer structure"] impl crate :: Writable for Sqr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR1 to value 0"] impl crate :: Resettable for Sqr1Spec { } }
#[doc = "SQR2 (rw) register accessor: regular sequence register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr2`] module"]
#[doc (alias = "SQR2")] pub type Sqr2 = crate :: Reg < sqr2 :: Sqr2Spec > ;
#[doc = "regular sequence register 2"] pub mod sqr2 {
#[doc = "Register `SQR2` reader"] pub type R = crate :: R < Sqr2Spec > ;
#[doc = "Register `SQR2` writer"] pub type W = crate :: W < Sqr2Spec > ;
#[doc = "Field `SQ7` reader - 7th conversion in regular sequence"] pub type Sq7R = crate :: FieldReader ;
#[doc = "Field `SQ7` writer - 7th conversion in regular sequence"] pub type Sq7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ8` reader - 8th conversion in regular sequence"] pub type Sq8R = crate :: FieldReader ;
#[doc = "Field `SQ8` writer - 8th conversion in regular sequence"] pub type Sq8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ9` reader - 9th conversion in regular sequence"] pub type Sq9R = crate :: FieldReader ;
#[doc = "Field `SQ9` writer - 9th conversion in regular sequence"] pub type Sq9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ10` reader - 10th conversion in regular sequence"] pub type Sq10R = crate :: FieldReader ;
#[doc = "Field `SQ10` writer - 10th conversion in regular sequence"] pub type Sq10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ11` reader - 11th conversion in regular sequence"] pub type Sq11R = crate :: FieldReader ;
#[doc = "Field `SQ11` writer - 11th conversion in regular sequence"] pub type Sq11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ12` reader - 12th conversion in regular sequence"] pub type Sq12R = crate :: FieldReader ;
#[doc = "Field `SQ12` writer - 12th conversion in regular sequence"] pub type Sq12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - 7th conversion in regular sequence"]
#[inline (always)] pub fn sq7 (& self) -> Sq7R { Sq7R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 5:9 - 8th conversion in regular sequence"]
#[inline (always)] pub fn sq8 (& self) -> Sq8R { Sq8R :: new (((self . bits >> 5) & 0x1f) as u8) }
#[doc = "Bits 10:14 - 9th conversion in regular sequence"]
#[inline (always)] pub fn sq9 (& self) -> Sq9R { Sq9R :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bits 15:19 - 10th conversion in regular sequence"]
#[inline (always)] pub fn sq10 (& self) -> Sq10R { Sq10R :: new (((self . bits >> 15) & 0x1f) as u8) }
#[doc = "Bits 20:24 - 11th conversion in regular sequence"]
#[inline (always)] pub fn sq11 (& self) -> Sq11R { Sq11R :: new (((self . bits >> 20) & 0x1f) as u8) }
#[doc = "Bits 25:29 - 12th conversion in regular sequence"]
#[inline (always)] pub fn sq12 (& self) -> Sq12R { Sq12R :: new (((self . bits >> 25) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - 7th conversion in regular sequence"]
#[inline (always)] pub fn sq7 (& mut self) -> Sq7W < '_ , Sqr2Spec > { Sq7W :: new (self , 0) }
#[doc = "Bits 5:9 - 8th conversion in regular sequence"]
#[inline (always)] pub fn sq8 (& mut self) -> Sq8W < '_ , Sqr2Spec > { Sq8W :: new (self , 5) }
#[doc = "Bits 10:14 - 9th conversion in regular sequence"]
#[inline (always)] pub fn sq9 (& mut self) -> Sq9W < '_ , Sqr2Spec > { Sq9W :: new (self , 10) }
#[doc = "Bits 15:19 - 10th conversion in regular sequence"]
#[inline (always)] pub fn sq10 (& mut self) -> Sq10W < '_ , Sqr2Spec > { Sq10W :: new (self , 15) }
#[doc = "Bits 20:24 - 11th conversion in regular sequence"]
#[inline (always)] pub fn sq11 (& mut self) -> Sq11W < '_ , Sqr2Spec > { Sq11W :: new (self , 20) }
#[doc = "Bits 25:29 - 12th conversion in regular sequence"]
#[inline (always)] pub fn sq12 (& mut self) -> Sq12W < '_ , Sqr2Spec > { Sq12W :: new (self , 25) } }
#[doc = "regular sequence register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr2Spec ; impl crate :: RegisterSpec for Sqr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr2::R`](R) reader structure"] impl crate :: Readable for Sqr2Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr2::W`](W) writer structure"] impl crate :: Writable for Sqr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR2 to value 0"] impl crate :: Resettable for Sqr2Spec { } }
#[doc = "SQR3 (rw) register accessor: regular sequence register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr3`] module"]
#[doc (alias = "SQR3")] pub type Sqr3 = crate :: Reg < sqr3 :: Sqr3Spec > ;
#[doc = "regular sequence register 3"] pub mod sqr3 {
#[doc = "Register `SQR3` reader"] pub type R = crate :: R < Sqr3Spec > ;
#[doc = "Register `SQR3` writer"] pub type W = crate :: W < Sqr3Spec > ;
#[doc = "Field `SQ1` reader - 1st conversion in regular sequence"] pub type Sq1R = crate :: FieldReader ;
#[doc = "Field `SQ1` writer - 1st conversion in regular sequence"] pub type Sq1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ2` reader - 2nd conversion in regular sequence"] pub type Sq2R = crate :: FieldReader ;
#[doc = "Field `SQ2` writer - 2nd conversion in regular sequence"] pub type Sq2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ3` reader - 3rd conversion in regular sequence"] pub type Sq3R = crate :: FieldReader ;
#[doc = "Field `SQ3` writer - 3rd conversion in regular sequence"] pub type Sq3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ4` reader - 4th conversion in regular sequence"] pub type Sq4R = crate :: FieldReader ;
#[doc = "Field `SQ4` writer - 4th conversion in regular sequence"] pub type Sq4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ5` reader - 5th conversion in regular sequence"] pub type Sq5R = crate :: FieldReader ;
#[doc = "Field `SQ5` writer - 5th conversion in regular sequence"] pub type Sq5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ6` reader - 6th conversion in regular sequence"] pub type Sq6R = crate :: FieldReader ;
#[doc = "Field `SQ6` writer - 6th conversion in regular sequence"] pub type Sq6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - 1st conversion in regular sequence"]
#[inline (always)] pub fn sq1 (& self) -> Sq1R { Sq1R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 5:9 - 2nd conversion in regular sequence"]
#[inline (always)] pub fn sq2 (& self) -> Sq2R { Sq2R :: new (((self . bits >> 5) & 0x1f) as u8) }
#[doc = "Bits 10:14 - 3rd conversion in regular sequence"]
#[inline (always)] pub fn sq3 (& self) -> Sq3R { Sq3R :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bits 15:19 - 4th conversion in regular sequence"]
#[inline (always)] pub fn sq4 (& self) -> Sq4R { Sq4R :: new (((self . bits >> 15) & 0x1f) as u8) }
#[doc = "Bits 20:24 - 5th conversion in regular sequence"]
#[inline (always)] pub fn sq5 (& self) -> Sq5R { Sq5R :: new (((self . bits >> 20) & 0x1f) as u8) }
#[doc = "Bits 25:29 - 6th conversion in regular sequence"]
#[inline (always)] pub fn sq6 (& self) -> Sq6R { Sq6R :: new (((self . bits >> 25) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - 1st conversion in regular sequence"]
#[inline (always)] pub fn sq1 (& mut self) -> Sq1W < '_ , Sqr3Spec > { Sq1W :: new (self , 0) }
#[doc = "Bits 5:9 - 2nd conversion in regular sequence"]
#[inline (always)] pub fn sq2 (& mut self) -> Sq2W < '_ , Sqr3Spec > { Sq2W :: new (self , 5) }
#[doc = "Bits 10:14 - 3rd conversion in regular sequence"]
#[inline (always)] pub fn sq3 (& mut self) -> Sq3W < '_ , Sqr3Spec > { Sq3W :: new (self , 10) }
#[doc = "Bits 15:19 - 4th conversion in regular sequence"]
#[inline (always)] pub fn sq4 (& mut self) -> Sq4W < '_ , Sqr3Spec > { Sq4W :: new (self , 15) }
#[doc = "Bits 20:24 - 5th conversion in regular sequence"]
#[inline (always)] pub fn sq5 (& mut self) -> Sq5W < '_ , Sqr3Spec > { Sq5W :: new (self , 20) }
#[doc = "Bits 25:29 - 6th conversion in regular sequence"]
#[inline (always)] pub fn sq6 (& mut self) -> Sq6W < '_ , Sqr3Spec > { Sq6W :: new (self , 25) } }
#[doc = "regular sequence register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr3Spec ; impl crate :: RegisterSpec for Sqr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr3::R`](R) reader structure"] impl crate :: Readable for Sqr3Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr3::W`](W) writer structure"] impl crate :: Writable for Sqr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR3 to value 0"] impl crate :: Resettable for Sqr3Spec { } }
#[doc = "JSQR (rw) register accessor: injected sequence register\n\nYou can [`read`](crate::Reg::read) this register and get [`jsqr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jsqr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jsqr`] module"]
#[doc (alias = "JSQR")] pub type Jsqr = crate :: Reg < jsqr :: JsqrSpec > ;
#[doc = "injected sequence register"] pub mod jsqr {
#[doc = "Register `JSQR` reader"] pub type R = crate :: R < JsqrSpec > ;
#[doc = "Register `JSQR` writer"] pub type W = crate :: W < JsqrSpec > ;
#[doc = "Field `JSQ1` reader - 1st conversion in injected sequence"] pub type Jsq1R = crate :: FieldReader ;
#[doc = "Field `JSQ1` writer - 1st conversion in injected sequence"] pub type Jsq1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ2` reader - 2nd conversion in injected sequence"] pub type Jsq2R = crate :: FieldReader ;
#[doc = "Field `JSQ2` writer - 2nd conversion in injected sequence"] pub type Jsq2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ3` reader - 3rd conversion in injected sequence"] pub type Jsq3R = crate :: FieldReader ;
#[doc = "Field `JSQ3` writer - 3rd conversion in injected sequence"] pub type Jsq3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ4` reader - 4th conversion in injected sequence"] pub type Jsq4R = crate :: FieldReader ;
#[doc = "Field `JSQ4` writer - 4th conversion in injected sequence"] pub type Jsq4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JL` reader - Injected sequence length"] pub type JlR = crate :: FieldReader ;
#[doc = "Field `JL` writer - Injected sequence length"] pub type JlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:4 - 1st conversion in injected sequence"]
#[inline (always)] pub fn jsq1 (& self) -> Jsq1R { Jsq1R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 5:9 - 2nd conversion in injected sequence"]
#[inline (always)] pub fn jsq2 (& self) -> Jsq2R { Jsq2R :: new (((self . bits >> 5) & 0x1f) as u8) }
#[doc = "Bits 10:14 - 3rd conversion in injected sequence"]
#[inline (always)] pub fn jsq3 (& self) -> Jsq3R { Jsq3R :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bits 15:19 - 4th conversion in injected sequence"]
#[inline (always)] pub fn jsq4 (& self) -> Jsq4R { Jsq4R :: new (((self . bits >> 15) & 0x1f) as u8) }
#[doc = "Bits 20:21 - Injected sequence length"]
#[inline (always)] pub fn jl (& self) -> JlR { JlR :: new (((self . bits >> 20) & 3) as u8) } } impl W {
#[doc = "Bits 0:4 - 1st conversion in injected sequence"]
#[inline (always)] pub fn jsq1 (& mut self) -> Jsq1W < '_ , JsqrSpec > { Jsq1W :: new (self , 0) }
#[doc = "Bits 5:9 - 2nd conversion in injected sequence"]
#[inline (always)] pub fn jsq2 (& mut self) -> Jsq2W < '_ , JsqrSpec > { Jsq2W :: new (self , 5) }
#[doc = "Bits 10:14 - 3rd conversion in injected sequence"]
#[inline (always)] pub fn jsq3 (& mut self) -> Jsq3W < '_ , JsqrSpec > { Jsq3W :: new (self , 10) }
#[doc = "Bits 15:19 - 4th conversion in injected sequence"]
#[inline (always)] pub fn jsq4 (& mut self) -> Jsq4W < '_ , JsqrSpec > { Jsq4W :: new (self , 15) }
#[doc = "Bits 20:21 - Injected sequence length"]
#[inline (always)] pub fn jl (& mut self) -> JlW < '_ , JsqrSpec > { JlW :: new (self , 20) } }
#[doc = "injected sequence register\n\nYou can [`read`](crate::Reg::read) this register and get [`jsqr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jsqr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct JsqrSpec ; impl crate :: RegisterSpec for JsqrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jsqr::R`](R) reader structure"] impl crate :: Readable for JsqrSpec { }
#[doc = "`write(|w| ..)` method takes [`jsqr::W`](W) writer structure"] impl crate :: Writable for JsqrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JSQR to value 0"] impl crate :: Resettable for JsqrSpec { } }
#[doc = "JDR1 (r) register accessor: injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr1`] module"]
#[doc (alias = "JDR1")] pub type Jdr1 = crate :: Reg < jdr1 :: Jdr1Spec > ;
#[doc = "injected data register x"] pub mod jdr1 {
#[doc = "Register `JDR1` reader"] pub type R = crate :: R < Jdr1Spec > ;
#[doc = "Field `JDATA` reader - Injected data"] pub type JdataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Injected data"]
#[inline (always)] pub fn jdata (& self) -> JdataR { JdataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr1Spec ; impl crate :: RegisterSpec for Jdr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr1::R`](R) reader structure"] impl crate :: Readable for Jdr1Spec { }
#[doc = "`reset()` method sets JDR1 to value 0"] impl crate :: Resettable for Jdr1Spec { } }
#[doc = "JDR2 (r) register accessor: injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr2`] module"]
#[doc (alias = "JDR2")] pub type Jdr2 = crate :: Reg < jdr2 :: Jdr2Spec > ;
#[doc = "injected data register x"] pub mod jdr2 {
#[doc = "Register `JDR2` reader"] pub type R = crate :: R < Jdr2Spec > ;
#[doc = "Field `JDATA` reader - Injected data"] pub type JdataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Injected data"]
#[inline (always)] pub fn jdata (& self) -> JdataR { JdataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr2Spec ; impl crate :: RegisterSpec for Jdr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr2::R`](R) reader structure"] impl crate :: Readable for Jdr2Spec { }
#[doc = "`reset()` method sets JDR2 to value 0"] impl crate :: Resettable for Jdr2Spec { } }
#[doc = "JDR3 (r) register accessor: injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr3`] module"]
#[doc (alias = "JDR3")] pub type Jdr3 = crate :: Reg < jdr3 :: Jdr3Spec > ;
#[doc = "injected data register x"] pub mod jdr3 {
#[doc = "Register `JDR3` reader"] pub type R = crate :: R < Jdr3Spec > ;
#[doc = "Field `JDATA` reader - Injected data"] pub type JdataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Injected data"]
#[inline (always)] pub fn jdata (& self) -> JdataR { JdataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr3Spec ; impl crate :: RegisterSpec for Jdr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr3::R`](R) reader structure"] impl crate :: Readable for Jdr3Spec { }
#[doc = "`reset()` method sets JDR3 to value 0"] impl crate :: Resettable for Jdr3Spec { } }
#[doc = "JDR4 (r) register accessor: injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr4::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr4`] module"]
#[doc (alias = "JDR4")] pub type Jdr4 = crate :: Reg < jdr4 :: Jdr4Spec > ;
#[doc = "injected data register x"] pub mod jdr4 {
#[doc = "Register `JDR4` reader"] pub type R = crate :: R < Jdr4Spec > ;
#[doc = "Field `JDATA` reader - Injected data"] pub type JdataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Injected data"]
#[inline (always)] pub fn jdata (& self) -> JdataR { JdataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr4::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr4Spec ; impl crate :: RegisterSpec for Jdr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr4::R`](R) reader structure"] impl crate :: Readable for Jdr4Spec { }
#[doc = "`reset()` method sets JDR4 to value 0"] impl crate :: Resettable for Jdr4Spec { } }
#[doc = "DR (r) register accessor: regular data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "regular data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Field `DATA` reader - Regular data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADC2DATA` reader - ADC2 data"] pub type Adc2dataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Regular data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - ADC2 data"]
#[inline (always)] pub fn adc2data (& self) -> Adc2dataR { Adc2dataR :: new (((self . bits >> 16) & 0xffff) as u16) } }
#[doc = "regular data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } } }
#[doc = "Analog to digital converter"] pub type Adc2 = crate :: Periph < adc2 :: RegisterBlock , 0x4001_2800 > ; impl core :: fmt :: Debug for Adc2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc2") . finish () } }
#[doc = "Analog to digital converter"] pub mod adc2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { sr : Sr , cr1 : Cr1 , cr2 : Cr2 , smpr1 : Smpr1 , smpr2 : Smpr2 , jofr1 : Jofr1 , jofr2 : Jofr2 , jofr3 : Jofr3 , jofr4 : Jofr4 , htr : Htr , ltr : Ltr , sqr1 : Sqr1 , sqr2 : Sqr2 , sqr3 : Sqr3 , jsqr : Jsqr , jdr1 : Jdr1 , jdr2 : Jdr2 , jdr3 : Jdr3 , jdr4 : Jdr4 , dr : Dr , } impl RegisterBlock {
#[doc = "0x00 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x04 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x08 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x0c - sample time register 1"]
#[inline (always)] pub const fn smpr1 (& self) -> & Smpr1 { & self . smpr1 }
#[doc = "0x10 - sample time register 2"]
#[inline (always)] pub const fn smpr2 (& self) -> & Smpr2 { & self . smpr2 }
#[doc = "0x14 - injected channel data offset register x"]
#[inline (always)] pub const fn jofr1 (& self) -> & Jofr1 { & self . jofr1 }
#[doc = "0x18 - injected channel data offset register x"]
#[inline (always)] pub const fn jofr2 (& self) -> & Jofr2 { & self . jofr2 }
#[doc = "0x1c - injected channel data offset register x"]
#[inline (always)] pub const fn jofr3 (& self) -> & Jofr3 { & self . jofr3 }
#[doc = "0x20 - injected channel data offset register x"]
#[inline (always)] pub const fn jofr4 (& self) -> & Jofr4 { & self . jofr4 }
#[doc = "0x24 - watchdog higher threshold register"]
#[inline (always)] pub const fn htr (& self) -> & Htr { & self . htr }
#[doc = "0x28 - watchdog lower threshold register"]
#[inline (always)] pub const fn ltr (& self) -> & Ltr { & self . ltr }
#[doc = "0x2c - regular sequence register 1"]
#[inline (always)] pub const fn sqr1 (& self) -> & Sqr1 { & self . sqr1 }
#[doc = "0x30 - regular sequence register 2"]
#[inline (always)] pub const fn sqr2 (& self) -> & Sqr2 { & self . sqr2 }
#[doc = "0x34 - regular sequence register 3"]
#[inline (always)] pub const fn sqr3 (& self) -> & Sqr3 { & self . sqr3 }
#[doc = "0x38 - injected sequence register"]
#[inline (always)] pub const fn jsqr (& self) -> & Jsqr { & self . jsqr }
#[doc = "0x3c - injected data register x"]
#[inline (always)] pub const fn jdr1 (& self) -> & Jdr1 { & self . jdr1 }
#[doc = "0x40 - injected data register x"]
#[inline (always)] pub const fn jdr2 (& self) -> & Jdr2 { & self . jdr2 }
#[doc = "0x44 - injected data register x"]
#[inline (always)] pub const fn jdr3 (& self) -> & Jdr3 { & self . jdr3 }
#[doc = "0x48 - injected data register x"]
#[inline (always)] pub const fn jdr4 (& self) -> & Jdr4 { & self . jdr4 }
#[doc = "0x4c - regular data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `AWD` reader - Analog watchdog flag"] pub type AwdR = crate :: BitReader ;
#[doc = "Field `AWD` writer - Analog watchdog flag"] pub type AwdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOC` reader - Regular channel end of conversion"] pub type EocR = crate :: BitReader ;
#[doc = "Field `EOC` writer - Regular channel end of conversion"] pub type EocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEOC` reader - Injected channel end of conversion"] pub type JeocR = crate :: BitReader ;
#[doc = "Field `JEOC` writer - Injected channel end of conversion"] pub type JeocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JSTRT` reader - Injected channel start flag"] pub type JstrtR = crate :: BitReader ;
#[doc = "Field `JSTRT` writer - Injected channel start flag"] pub type JstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STRT` reader - Regular channel start flag"] pub type StrtR = crate :: BitReader ;
#[doc = "Field `STRT` writer - Regular channel start flag"] pub type StrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Analog watchdog flag"]
#[inline (always)] pub fn awd (& self) -> AwdR { AwdR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Regular channel end of conversion"]
#[inline (always)] pub fn eoc (& self) -> EocR { EocR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Injected channel end of conversion"]
#[inline (always)] pub fn jeoc (& self) -> JeocR { JeocR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Injected channel start flag"]
#[inline (always)] pub fn jstrt (& self) -> JstrtR { JstrtR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Regular channel start flag"]
#[inline (always)] pub fn strt (& self) -> StrtR { StrtR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Analog watchdog flag"]
#[inline (always)] pub fn awd (& mut self) -> AwdW < '_ , SrSpec > { AwdW :: new (self , 0) }
#[doc = "Bit 1 - Regular channel end of conversion"]
#[inline (always)] pub fn eoc (& mut self) -> EocW < '_ , SrSpec > { EocW :: new (self , 1) }
#[doc = "Bit 2 - Injected channel end of conversion"]
#[inline (always)] pub fn jeoc (& mut self) -> JeocW < '_ , SrSpec > { JeocW :: new (self , 2) }
#[doc = "Bit 3 - Injected channel start flag"]
#[inline (always)] pub fn jstrt (& mut self) -> JstrtW < '_ , SrSpec > { JstrtW :: new (self , 3) }
#[doc = "Bit 4 - Regular channel start flag"]
#[inline (always)] pub fn strt (& mut self) -> StrtW < '_ , SrSpec > { StrtW :: new (self , 4) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `AWDCH` reader - Analog watchdog channel select bits"] pub type AwdchR = crate :: FieldReader ;
#[doc = "Field `AWDCH` writer - Analog watchdog channel select bits"] pub type AwdchW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `EOCIE` reader - Interrupt enable for EOC"] pub type EocieR = crate :: BitReader ;
#[doc = "Field `EOCIE` writer - Interrupt enable for EOC"] pub type EocieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWDIE` reader - Analog watchdog interrupt enable"] pub type AwdieR = crate :: BitReader ;
#[doc = "Field `AWDIE` writer - Analog watchdog interrupt enable"] pub type AwdieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEOCIE` reader - Interrupt enable for injected channels"] pub type JeocieR = crate :: BitReader ;
#[doc = "Field `JEOCIE` writer - Interrupt enable for injected channels"] pub type JeocieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SCAN` reader - Scan mode"] pub type ScanR = crate :: BitReader ;
#[doc = "Field `SCAN` writer - Scan mode"] pub type ScanW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWDSGL` reader - Enable the watchdog on a single channel in scan mode"] pub type AwdsglR = crate :: BitReader ;
#[doc = "Field `AWDSGL` writer - Enable the watchdog on a single channel in scan mode"] pub type AwdsglW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JAUTO` reader - Automatic injected group conversion"] pub type JautoR = crate :: BitReader ;
#[doc = "Field `JAUTO` writer - Automatic injected group conversion"] pub type JautoW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISCEN` reader - Discontinuous mode on regular channels"] pub type DiscenR = crate :: BitReader ;
#[doc = "Field `DISCEN` writer - Discontinuous mode on regular channels"] pub type DiscenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JDISCEN` reader - Discontinuous mode on injected channels"] pub type JdiscenR = crate :: BitReader ;
#[doc = "Field `JDISCEN` writer - Discontinuous mode on injected channels"] pub type JdiscenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISCNUM` reader - Discontinuous mode channel count"] pub type DiscnumR = crate :: FieldReader ;
#[doc = "Field `DISCNUM` writer - Discontinuous mode channel count"] pub type DiscnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `JAWDEN` reader - Analog watchdog enable on injected channels"] pub type JawdenR = crate :: BitReader ;
#[doc = "Field `JAWDEN` writer - Analog watchdog enable on injected channels"] pub type JawdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWDEN` reader - Analog watchdog enable on regular channels"] pub type AwdenR = crate :: BitReader ;
#[doc = "Field `AWDEN` writer - Analog watchdog enable on regular channels"] pub type AwdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:4 - Analog watchdog channel select bits"]
#[inline (always)] pub fn awdch (& self) -> AwdchR { AwdchR :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bit 5 - Interrupt enable for EOC"]
#[inline (always)] pub fn eocie (& self) -> EocieR { EocieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Analog watchdog interrupt enable"]
#[inline (always)] pub fn awdie (& self) -> AwdieR { AwdieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Interrupt enable for injected channels"]
#[inline (always)] pub fn jeocie (& self) -> JeocieR { JeocieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Scan mode"]
#[inline (always)] pub fn scan (& self) -> ScanR { ScanR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"]
#[inline (always)] pub fn awdsgl (& self) -> AwdsglR { AwdsglR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Automatic injected group conversion"]
#[inline (always)] pub fn jauto (& self) -> JautoR { JautoR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Discontinuous mode on regular channels"]
#[inline (always)] pub fn discen (& self) -> DiscenR { DiscenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Discontinuous mode on injected channels"]
#[inline (always)] pub fn jdiscen (& self) -> JdiscenR { JdiscenR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:15 - Discontinuous mode channel count"]
#[inline (always)] pub fn discnum (& self) -> DiscnumR { DiscnumR :: new (((self . bits >> 13) & 7) as u8) }
#[doc = "Bit 22 - Analog watchdog enable on injected channels"]
#[inline (always)] pub fn jawden (& self) -> JawdenR { JawdenR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Analog watchdog enable on regular channels"]
#[inline (always)] pub fn awden (& self) -> AwdenR { AwdenR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bits 0:4 - Analog watchdog channel select bits"]
#[inline (always)] pub fn awdch (& mut self) -> AwdchW < '_ , Cr1Spec > { AwdchW :: new (self , 0) }
#[doc = "Bit 5 - Interrupt enable for EOC"]
#[inline (always)] pub fn eocie (& mut self) -> EocieW < '_ , Cr1Spec > { EocieW :: new (self , 5) }
#[doc = "Bit 6 - Analog watchdog interrupt enable"]
#[inline (always)] pub fn awdie (& mut self) -> AwdieW < '_ , Cr1Spec > { AwdieW :: new (self , 6) }
#[doc = "Bit 7 - Interrupt enable for injected channels"]
#[inline (always)] pub fn jeocie (& mut self) -> JeocieW < '_ , Cr1Spec > { JeocieW :: new (self , 7) }
#[doc = "Bit 8 - Scan mode"]
#[inline (always)] pub fn scan (& mut self) -> ScanW < '_ , Cr1Spec > { ScanW :: new (self , 8) }
#[doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"]
#[inline (always)] pub fn awdsgl (& mut self) -> AwdsglW < '_ , Cr1Spec > { AwdsglW :: new (self , 9) }
#[doc = "Bit 10 - Automatic injected group conversion"]
#[inline (always)] pub fn jauto (& mut self) -> JautoW < '_ , Cr1Spec > { JautoW :: new (self , 10) }
#[doc = "Bit 11 - Discontinuous mode on regular channels"]
#[inline (always)] pub fn discen (& mut self) -> DiscenW < '_ , Cr1Spec > { DiscenW :: new (self , 11) }
#[doc = "Bit 12 - Discontinuous mode on injected channels"]
#[inline (always)] pub fn jdiscen (& mut self) -> JdiscenW < '_ , Cr1Spec > { JdiscenW :: new (self , 12) }
#[doc = "Bits 13:15 - Discontinuous mode channel count"]
#[inline (always)] pub fn discnum (& mut self) -> DiscnumW < '_ , Cr1Spec > { DiscnumW :: new (self , 13) }
#[doc = "Bit 22 - Analog watchdog enable on injected channels"]
#[inline (always)] pub fn jawden (& mut self) -> JawdenW < '_ , Cr1Spec > { JawdenW :: new (self , 22) }
#[doc = "Bit 23 - Analog watchdog enable on regular channels"]
#[inline (always)] pub fn awden (& mut self) -> AwdenW < '_ , Cr1Spec > { AwdenW :: new (self , 23) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `ADON` reader - A/D converter ON / OFF"] pub type AdonR = crate :: BitReader ;
#[doc = "Field `ADON` writer - A/D converter ON / OFF"] pub type AdonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CONT` reader - Continuous conversion"] pub type ContR = crate :: BitReader ;
#[doc = "Field `CONT` writer - Continuous conversion"] pub type ContW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CAL` reader - A/D calibration"] pub type CalR = crate :: BitReader ;
#[doc = "Field `CAL` writer - A/D calibration"] pub type CalW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RSTCAL` reader - Reset calibration"] pub type RstcalR = crate :: BitReader ;
#[doc = "Field `RSTCAL` writer - Reset calibration"] pub type RstcalW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA` reader - Direct memory access mode"] pub type DmaR = crate :: BitReader ;
#[doc = "Field `DMA` writer - Direct memory access mode"] pub type DmaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALIGN` reader - Data alignment"] pub type AlignR = crate :: BitReader ;
#[doc = "Field `ALIGN` writer - Data alignment"] pub type AlignW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JEXTSEL` reader - External event select for injected group"] pub type JextselR = crate :: FieldReader ;
#[doc = "Field `JEXTSEL` writer - External event select for injected group"] pub type JextselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `JEXTTRIG` reader - External trigger conversion mode for injected channels"] pub type JexttrigR = crate :: BitReader ;
#[doc = "Field `JEXTTRIG` writer - External trigger conversion mode for injected channels"] pub type JexttrigW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXTSEL` reader - External event select for regular group"] pub type ExtselR = crate :: FieldReader ;
#[doc = "Field `EXTSEL` writer - External event select for regular group"] pub type ExtselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `EXTTRIG` reader - External trigger conversion mode for regular channels"] pub type ExttrigR = crate :: BitReader ;
#[doc = "Field `EXTTRIG` writer - External trigger conversion mode for regular channels"] pub type ExttrigW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `JSWSTART` reader - Start conversion of injected channels"] pub type JswstartR = crate :: BitReader ;
#[doc = "Field `JSWSTART` writer - Start conversion of injected channels"] pub type JswstartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWSTART` reader - Start conversion of regular channels"] pub type SwstartR = crate :: BitReader ;
#[doc = "Field `SWSTART` writer - Start conversion of regular channels"] pub type SwstartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSVREFE` reader - Temperature sensor and VREFINT enable"] pub type TsvrefeR = crate :: BitReader ;
#[doc = "Field `TSVREFE` writer - Temperature sensor and VREFINT enable"] pub type TsvrefeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - A/D converter ON / OFF"]
#[inline (always)] pub fn adon (& self) -> AdonR { AdonR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Continuous conversion"]
#[inline (always)] pub fn cont (& self) -> ContR { ContR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - A/D calibration"]
#[inline (always)] pub fn cal (& self) -> CalR { CalR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Reset calibration"]
#[inline (always)] pub fn rstcal (& self) -> RstcalR { RstcalR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 8 - Direct memory access mode"]
#[inline (always)] pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 11 - Data alignment"]
#[inline (always)] pub fn align (& self) -> AlignR { AlignR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - External event select for injected group"]
#[inline (always)] pub fn jextsel (& self) -> JextselR { JextselR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - External trigger conversion mode for injected channels"]
#[inline (always)] pub fn jexttrig (& self) -> JexttrigR { JexttrigR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 17:19 - External event select for regular group"]
#[inline (always)] pub fn extsel (& self) -> ExtselR { ExtselR :: new (((self . bits >> 17) & 7) as u8) }
#[doc = "Bit 20 - External trigger conversion mode for regular channels"]
#[inline (always)] pub fn exttrig (& self) -> ExttrigR { ExttrigR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Start conversion of injected channels"]
#[inline (always)] pub fn jswstart (& self) -> JswstartR { JswstartR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Start conversion of regular channels"]
#[inline (always)] pub fn swstart (& self) -> SwstartR { SwstartR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Temperature sensor and VREFINT enable"]
#[inline (always)] pub fn tsvrefe (& self) -> TsvrefeR { TsvrefeR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - A/D converter ON / OFF"]
#[inline (always)] pub fn adon (& mut self) -> AdonW < '_ , Cr2Spec > { AdonW :: new (self , 0) }
#[doc = "Bit 1 - Continuous conversion"]
#[inline (always)] pub fn cont (& mut self) -> ContW < '_ , Cr2Spec > { ContW :: new (self , 1) }
#[doc = "Bit 2 - A/D calibration"]
#[inline (always)] pub fn cal (& mut self) -> CalW < '_ , Cr2Spec > { CalW :: new (self , 2) }
#[doc = "Bit 3 - Reset calibration"]
#[inline (always)] pub fn rstcal (& mut self) -> RstcalW < '_ , Cr2Spec > { RstcalW :: new (self , 3) }
#[doc = "Bit 8 - Direct memory access mode"]
#[inline (always)] pub fn dma (& mut self) -> DmaW < '_ , Cr2Spec > { DmaW :: new (self , 8) }
#[doc = "Bit 11 - Data alignment"]
#[inline (always)] pub fn align (& mut self) -> AlignW < '_ , Cr2Spec > { AlignW :: new (self , 11) }
#[doc = "Bits 12:14 - External event select for injected group"]
#[inline (always)] pub fn jextsel (& mut self) -> JextselW < '_ , Cr2Spec > { JextselW :: new (self , 12) }
#[doc = "Bit 15 - External trigger conversion mode for injected channels"]
#[inline (always)] pub fn jexttrig (& mut self) -> JexttrigW < '_ , Cr2Spec > { JexttrigW :: new (self , 15) }
#[doc = "Bits 17:19 - External event select for regular group"]
#[inline (always)] pub fn extsel (& mut self) -> ExtselW < '_ , Cr2Spec > { ExtselW :: new (self , 17) }
#[doc = "Bit 20 - External trigger conversion mode for regular channels"]
#[inline (always)] pub fn exttrig (& mut self) -> ExttrigW < '_ , Cr2Spec > { ExttrigW :: new (self , 20) }
#[doc = "Bit 21 - Start conversion of injected channels"]
#[inline (always)] pub fn jswstart (& mut self) -> JswstartW < '_ , Cr2Spec > { JswstartW :: new (self , 21) }
#[doc = "Bit 22 - Start conversion of regular channels"]
#[inline (always)] pub fn swstart (& mut self) -> SwstartW < '_ , Cr2Spec > { SwstartW :: new (self , 22) }
#[doc = "Bit 23 - Temperature sensor and VREFINT enable"]
#[inline (always)] pub fn tsvrefe (& mut self) -> TsvrefeW < '_ , Cr2Spec > { TsvrefeW :: new (self , 23) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMPR1 (rw) register accessor: sample time register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smpr1`] module"]
#[doc (alias = "SMPR1")] pub type Smpr1 = crate :: Reg < smpr1 :: Smpr1Spec > ;
#[doc = "sample time register 1"] pub mod smpr1 {
#[doc = "Register `SMPR1` reader"] pub type R = crate :: R < Smpr1Spec > ;
#[doc = "Register `SMPR1` writer"] pub type W = crate :: W < Smpr1Spec > ;
#[doc = "Field `SMP10` reader - Channel 10 sample time selection"] pub type Smp10R = crate :: FieldReader ;
#[doc = "Field `SMP10` writer - Channel 10 sample time selection"] pub type Smp10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP11` reader - Channel 11 sample time selection"] pub type Smp11R = crate :: FieldReader ;
#[doc = "Field `SMP11` writer - Channel 11 sample time selection"] pub type Smp11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP12` reader - Channel 12 sample time selection"] pub type Smp12R = crate :: FieldReader ;
#[doc = "Field `SMP12` writer - Channel 12 sample time selection"] pub type Smp12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP13` reader - Channel 13 sample time selection"] pub type Smp13R = crate :: FieldReader ;
#[doc = "Field `SMP13` writer - Channel 13 sample time selection"] pub type Smp13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP14` reader - Channel 14 sample time selection"] pub type Smp14R = crate :: FieldReader ;
#[doc = "Field `SMP14` writer - Channel 14 sample time selection"] pub type Smp14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP15` reader - Channel 15 sample time selection"] pub type Smp15R = crate :: FieldReader ;
#[doc = "Field `SMP15` writer - Channel 15 sample time selection"] pub type Smp15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP16` reader - Channel 16 sample time selection"] pub type Smp16R = crate :: FieldReader ;
#[doc = "Field `SMP16` writer - Channel 16 sample time selection"] pub type Smp16W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP17` reader - Channel 17 sample time selection"] pub type Smp17R = crate :: FieldReader ;
#[doc = "Field `SMP17` writer - Channel 17 sample time selection"] pub type Smp17W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Channel 10 sample time selection"]
#[inline (always)] pub fn smp10 (& self) -> Smp10R { Smp10R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 3:5 - Channel 11 sample time selection"]
#[inline (always)] pub fn smp11 (& self) -> Smp11R { Smp11R :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:8 - Channel 12 sample time selection"]
#[inline (always)] pub fn smp12 (& self) -> Smp12R { Smp12R :: new (((self . bits >> 6) & 7) as u8) }
#[doc = "Bits 9:11 - Channel 13 sample time selection"]
#[inline (always)] pub fn smp13 (& self) -> Smp13R { Smp13R :: new (((self . bits >> 9) & 7) as u8) }
#[doc = "Bits 12:14 - Channel 14 sample time selection"]
#[inline (always)] pub fn smp14 (& self) -> Smp14R { Smp14R :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 15:17 - Channel 15 sample time selection"]
#[inline (always)] pub fn smp15 (& self) -> Smp15R { Smp15R :: new (((self . bits >> 15) & 7) as u8) }
#[doc = "Bits 18:20 - Channel 16 sample time selection"]
#[inline (always)] pub fn smp16 (& self) -> Smp16R { Smp16R :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bits 21:23 - Channel 17 sample time selection"]
#[inline (always)] pub fn smp17 (& self) -> Smp17R { Smp17R :: new (((self . bits >> 21) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Channel 10 sample time selection"]
#[inline (always)] pub fn smp10 (& mut self) -> Smp10W < '_ , Smpr1Spec > { Smp10W :: new (self , 0) }
#[doc = "Bits 3:5 - Channel 11 sample time selection"]
#[inline (always)] pub fn smp11 (& mut self) -> Smp11W < '_ , Smpr1Spec > { Smp11W :: new (self , 3) }
#[doc = "Bits 6:8 - Channel 12 sample time selection"]
#[inline (always)] pub fn smp12 (& mut self) -> Smp12W < '_ , Smpr1Spec > { Smp12W :: new (self , 6) }
#[doc = "Bits 9:11 - Channel 13 sample time selection"]
#[inline (always)] pub fn smp13 (& mut self) -> Smp13W < '_ , Smpr1Spec > { Smp13W :: new (self , 9) }
#[doc = "Bits 12:14 - Channel 14 sample time selection"]
#[inline (always)] pub fn smp14 (& mut self) -> Smp14W < '_ , Smpr1Spec > { Smp14W :: new (self , 12) }
#[doc = "Bits 15:17 - Channel 15 sample time selection"]
#[inline (always)] pub fn smp15 (& mut self) -> Smp15W < '_ , Smpr1Spec > { Smp15W :: new (self , 15) }
#[doc = "Bits 18:20 - Channel 16 sample time selection"]
#[inline (always)] pub fn smp16 (& mut self) -> Smp16W < '_ , Smpr1Spec > { Smp16W :: new (self , 18) }
#[doc = "Bits 21:23 - Channel 17 sample time selection"]
#[inline (always)] pub fn smp17 (& mut self) -> Smp17W < '_ , Smpr1Spec > { Smp17W :: new (self , 21) } }
#[doc = "sample time register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Smpr1Spec ; impl crate :: RegisterSpec for Smpr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smpr1::R`](R) reader structure"] impl crate :: Readable for Smpr1Spec { }
#[doc = "`write(|w| ..)` method takes [`smpr1::W`](W) writer structure"] impl crate :: Writable for Smpr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMPR1 to value 0"] impl crate :: Resettable for Smpr1Spec { } }
#[doc = "SMPR2 (rw) register accessor: sample time register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smpr2`] module"]
#[doc (alias = "SMPR2")] pub type Smpr2 = crate :: Reg < smpr2 :: Smpr2Spec > ;
#[doc = "sample time register 2"] pub mod smpr2 {
#[doc = "Register `SMPR2` reader"] pub type R = crate :: R < Smpr2Spec > ;
#[doc = "Register `SMPR2` writer"] pub type W = crate :: W < Smpr2Spec > ;
#[doc = "Field `SMP0` reader - Channel 0 sample time selection"] pub type Smp0R = crate :: FieldReader ;
#[doc = "Field `SMP0` writer - Channel 0 sample time selection"] pub type Smp0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP1` reader - Channel 1 sample time selection"] pub type Smp1R = crate :: FieldReader ;
#[doc = "Field `SMP1` writer - Channel 1 sample time selection"] pub type Smp1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP2` reader - Channel 2 sample time selection"] pub type Smp2R = crate :: FieldReader ;
#[doc = "Field `SMP2` writer - Channel 2 sample time selection"] pub type Smp2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP3` reader - Channel 3 sample time selection"] pub type Smp3R = crate :: FieldReader ;
#[doc = "Field `SMP3` writer - Channel 3 sample time selection"] pub type Smp3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP4` reader - Channel 4 sample time selection"] pub type Smp4R = crate :: FieldReader ;
#[doc = "Field `SMP4` writer - Channel 4 sample time selection"] pub type Smp4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP5` reader - Channel 5 sample time selection"] pub type Smp5R = crate :: FieldReader ;
#[doc = "Field `SMP5` writer - Channel 5 sample time selection"] pub type Smp5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP6` reader - Channel 6 sample time selection"] pub type Smp6R = crate :: FieldReader ;
#[doc = "Field `SMP6` writer - Channel 6 sample time selection"] pub type Smp6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP7` reader - Channel 7 sample time selection"] pub type Smp7R = crate :: FieldReader ;
#[doc = "Field `SMP7` writer - Channel 7 sample time selection"] pub type Smp7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP8` reader - Channel 8 sample time selection"] pub type Smp8R = crate :: FieldReader ;
#[doc = "Field `SMP8` writer - Channel 8 sample time selection"] pub type Smp8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SMP9` reader - Channel 9 sample time selection"] pub type Smp9R = crate :: FieldReader ;
#[doc = "Field `SMP9` writer - Channel 9 sample time selection"] pub type Smp9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Channel 0 sample time selection"]
#[inline (always)] pub fn smp0 (& self) -> Smp0R { Smp0R :: new ((self . bits & 7) as u8) }
#[doc = "Bits 3:5 - Channel 1 sample time selection"]
#[inline (always)] pub fn smp1 (& self) -> Smp1R { Smp1R :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:8 - Channel 2 sample time selection"]
#[inline (always)] pub fn smp2 (& self) -> Smp2R { Smp2R :: new (((self . bits >> 6) & 7) as u8) }
#[doc = "Bits 9:11 - Channel 3 sample time selection"]
#[inline (always)] pub fn smp3 (& self) -> Smp3R { Smp3R :: new (((self . bits >> 9) & 7) as u8) }
#[doc = "Bits 12:14 - Channel 4 sample time selection"]
#[inline (always)] pub fn smp4 (& self) -> Smp4R { Smp4R :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bits 15:17 - Channel 5 sample time selection"]
#[inline (always)] pub fn smp5 (& self) -> Smp5R { Smp5R :: new (((self . bits >> 15) & 7) as u8) }
#[doc = "Bits 18:20 - Channel 6 sample time selection"]
#[inline (always)] pub fn smp6 (& self) -> Smp6R { Smp6R :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bits 21:23 - Channel 7 sample time selection"]
#[inline (always)] pub fn smp7 (& self) -> Smp7R { Smp7R :: new (((self . bits >> 21) & 7) as u8) }
#[doc = "Bits 24:26 - Channel 8 sample time selection"]
#[inline (always)] pub fn smp8 (& self) -> Smp8R { Smp8R :: new (((self . bits >> 24) & 7) as u8) }
#[doc = "Bits 27:29 - Channel 9 sample time selection"]
#[inline (always)] pub fn smp9 (& self) -> Smp9R { Smp9R :: new (((self . bits >> 27) & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Channel 0 sample time selection"]
#[inline (always)] pub fn smp0 (& mut self) -> Smp0W < '_ , Smpr2Spec > { Smp0W :: new (self , 0) }
#[doc = "Bits 3:5 - Channel 1 sample time selection"]
#[inline (always)] pub fn smp1 (& mut self) -> Smp1W < '_ , Smpr2Spec > { Smp1W :: new (self , 3) }
#[doc = "Bits 6:8 - Channel 2 sample time selection"]
#[inline (always)] pub fn smp2 (& mut self) -> Smp2W < '_ , Smpr2Spec > { Smp2W :: new (self , 6) }
#[doc = "Bits 9:11 - Channel 3 sample time selection"]
#[inline (always)] pub fn smp3 (& mut self) -> Smp3W < '_ , Smpr2Spec > { Smp3W :: new (self , 9) }
#[doc = "Bits 12:14 - Channel 4 sample time selection"]
#[inline (always)] pub fn smp4 (& mut self) -> Smp4W < '_ , Smpr2Spec > { Smp4W :: new (self , 12) }
#[doc = "Bits 15:17 - Channel 5 sample time selection"]
#[inline (always)] pub fn smp5 (& mut self) -> Smp5W < '_ , Smpr2Spec > { Smp5W :: new (self , 15) }
#[doc = "Bits 18:20 - Channel 6 sample time selection"]
#[inline (always)] pub fn smp6 (& mut self) -> Smp6W < '_ , Smpr2Spec > { Smp6W :: new (self , 18) }
#[doc = "Bits 21:23 - Channel 7 sample time selection"]
#[inline (always)] pub fn smp7 (& mut self) -> Smp7W < '_ , Smpr2Spec > { Smp7W :: new (self , 21) }
#[doc = "Bits 24:26 - Channel 8 sample time selection"]
#[inline (always)] pub fn smp8 (& mut self) -> Smp8W < '_ , Smpr2Spec > { Smp8W :: new (self , 24) }
#[doc = "Bits 27:29 - Channel 9 sample time selection"]
#[inline (always)] pub fn smp9 (& mut self) -> Smp9W < '_ , Smpr2Spec > { Smp9W :: new (self , 27) } }
#[doc = "sample time register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Smpr2Spec ; impl crate :: RegisterSpec for Smpr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smpr2::R`](R) reader structure"] impl crate :: Readable for Smpr2Spec { }
#[doc = "`write(|w| ..)` method takes [`smpr2::W`](W) writer structure"] impl crate :: Writable for Smpr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMPR2 to value 0"] impl crate :: Resettable for Smpr2Spec { } }
#[doc = "JOFR1 (rw) register accessor: injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jofr1`] module"]
#[doc (alias = "JOFR1")] pub type Jofr1 = crate :: Reg < jofr1 :: Jofr1Spec > ;
#[doc = "injected channel data offset register x"] pub mod jofr1 {
#[doc = "Register `JOFR1` reader"] pub type R = crate :: R < Jofr1Spec > ;
#[doc = "Register `JOFR1` writer"] pub type W = crate :: W < Jofr1Spec > ;
#[doc = "Field `JOFFSET1` reader - Data offset for injected channel x"] pub type Joffset1R = crate :: FieldReader < u16 > ;
#[doc = "Field `JOFFSET1` writer - Data offset for injected channel x"] pub type Joffset1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset1 (& self) -> Joffset1R { Joffset1R :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset1 (& mut self) -> Joffset1W < '_ , Jofr1Spec > { Joffset1W :: new (self , 0) } }
#[doc = "injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jofr1Spec ; impl crate :: RegisterSpec for Jofr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jofr1::R`](R) reader structure"] impl crate :: Readable for Jofr1Spec { }
#[doc = "`write(|w| ..)` method takes [`jofr1::W`](W) writer structure"] impl crate :: Writable for Jofr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JOFR1 to value 0"] impl crate :: Resettable for Jofr1Spec { } }
#[doc = "JOFR2 (rw) register accessor: injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jofr2`] module"]
#[doc (alias = "JOFR2")] pub type Jofr2 = crate :: Reg < jofr2 :: Jofr2Spec > ;
#[doc = "injected channel data offset register x"] pub mod jofr2 {
#[doc = "Register `JOFR2` reader"] pub type R = crate :: R < Jofr2Spec > ;
#[doc = "Register `JOFR2` writer"] pub type W = crate :: W < Jofr2Spec > ;
#[doc = "Field `JOFFSET2` reader - Data offset for injected channel x"] pub type Joffset2R = crate :: FieldReader < u16 > ;
#[doc = "Field `JOFFSET2` writer - Data offset for injected channel x"] pub type Joffset2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset2 (& self) -> Joffset2R { Joffset2R :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset2 (& mut self) -> Joffset2W < '_ , Jofr2Spec > { Joffset2W :: new (self , 0) } }
#[doc = "injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jofr2Spec ; impl crate :: RegisterSpec for Jofr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jofr2::R`](R) reader structure"] impl crate :: Readable for Jofr2Spec { }
#[doc = "`write(|w| ..)` method takes [`jofr2::W`](W) writer structure"] impl crate :: Writable for Jofr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JOFR2 to value 0"] impl crate :: Resettable for Jofr2Spec { } }
#[doc = "JOFR3 (rw) register accessor: injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jofr3`] module"]
#[doc (alias = "JOFR3")] pub type Jofr3 = crate :: Reg < jofr3 :: Jofr3Spec > ;
#[doc = "injected channel data offset register x"] pub mod jofr3 {
#[doc = "Register `JOFR3` reader"] pub type R = crate :: R < Jofr3Spec > ;
#[doc = "Register `JOFR3` writer"] pub type W = crate :: W < Jofr3Spec > ;
#[doc = "Field `JOFFSET3` reader - Data offset for injected channel x"] pub type Joffset3R = crate :: FieldReader < u16 > ;
#[doc = "Field `JOFFSET3` writer - Data offset for injected channel x"] pub type Joffset3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset3 (& self) -> Joffset3R { Joffset3R :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset3 (& mut self) -> Joffset3W < '_ , Jofr3Spec > { Joffset3W :: new (self , 0) } }
#[doc = "injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jofr3Spec ; impl crate :: RegisterSpec for Jofr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jofr3::R`](R) reader structure"] impl crate :: Readable for Jofr3Spec { }
#[doc = "`write(|w| ..)` method takes [`jofr3::W`](W) writer structure"] impl crate :: Writable for Jofr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JOFR3 to value 0"] impl crate :: Resettable for Jofr3Spec { } }
#[doc = "JOFR4 (rw) register accessor: injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jofr4`] module"]
#[doc (alias = "JOFR4")] pub type Jofr4 = crate :: Reg < jofr4 :: Jofr4Spec > ;
#[doc = "injected channel data offset register x"] pub mod jofr4 {
#[doc = "Register `JOFR4` reader"] pub type R = crate :: R < Jofr4Spec > ;
#[doc = "Register `JOFR4` writer"] pub type W = crate :: W < Jofr4Spec > ;
#[doc = "Field `JOFFSET4` reader - Data offset for injected channel x"] pub type Joffset4R = crate :: FieldReader < u16 > ;
#[doc = "Field `JOFFSET4` writer - Data offset for injected channel x"] pub type Joffset4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset4 (& self) -> Joffset4R { Joffset4R :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Data offset for injected channel x"]
#[inline (always)] pub fn joffset4 (& mut self) -> Joffset4W < '_ , Jofr4Spec > { Joffset4W :: new (self , 0) } }
#[doc = "injected channel data offset register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jofr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jofr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jofr4Spec ; impl crate :: RegisterSpec for Jofr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jofr4::R`](R) reader structure"] impl crate :: Readable for Jofr4Spec { }
#[doc = "`write(|w| ..)` method takes [`jofr4::W`](W) writer structure"] impl crate :: Writable for Jofr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JOFR4 to value 0"] impl crate :: Resettable for Jofr4Spec { } }
#[doc = "HTR (rw) register accessor: watchdog higher threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`htr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`htr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@htr`] module"]
#[doc (alias = "HTR")] pub type Htr = crate :: Reg < htr :: HtrSpec > ;
#[doc = "watchdog higher threshold register"] pub mod htr {
#[doc = "Register `HTR` reader"] pub type R = crate :: R < HtrSpec > ;
#[doc = "Register `HTR` writer"] pub type W = crate :: W < HtrSpec > ;
#[doc = "Field `HT` reader - Analog watchdog higher threshold"] pub type HtR = crate :: FieldReader < u16 > ;
#[doc = "Field `HT` writer - Analog watchdog higher threshold"] pub type HtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Analog watchdog higher threshold"]
#[inline (always)] pub fn ht (& self) -> HtR { HtR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Analog watchdog higher threshold"]
#[inline (always)] pub fn ht (& mut self) -> HtW < '_ , HtrSpec > { HtW :: new (self , 0) } }
#[doc = "watchdog higher threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`htr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`htr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HtrSpec ; impl crate :: RegisterSpec for HtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`htr::R`](R) reader structure"] impl crate :: Readable for HtrSpec { }
#[doc = "`write(|w| ..)` method takes [`htr::W`](W) writer structure"] impl crate :: Writable for HtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets HTR to value 0x0fff"] impl crate :: Resettable for HtrSpec { const RESET_VALUE : u32 = 0x0fff ; } }
#[doc = "LTR (rw) register accessor: watchdog lower threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`ltr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ltr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ltr`] module"]
#[doc (alias = "LTR")] pub type Ltr = crate :: Reg < ltr :: LtrSpec > ;
#[doc = "watchdog lower threshold register"] pub mod ltr {
#[doc = "Register `LTR` reader"] pub type R = crate :: R < LtrSpec > ;
#[doc = "Register `LTR` writer"] pub type W = crate :: W < LtrSpec > ;
#[doc = "Field `LT` reader - Analog watchdog lower threshold"] pub type LtR = crate :: FieldReader < u16 > ;
#[doc = "Field `LT` writer - Analog watchdog lower threshold"] pub type LtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Analog watchdog lower threshold"]
#[inline (always)] pub fn lt (& self) -> LtR { LtR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Analog watchdog lower threshold"]
#[inline (always)] pub fn lt (& mut self) -> LtW < '_ , LtrSpec > { LtW :: new (self , 0) } }
#[doc = "watchdog lower threshold register\n\nYou can [`read`](crate::Reg::read) this register and get [`ltr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ltr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LtrSpec ; impl crate :: RegisterSpec for LtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ltr::R`](R) reader structure"] impl crate :: Readable for LtrSpec { }
#[doc = "`write(|w| ..)` method takes [`ltr::W`](W) writer structure"] impl crate :: Writable for LtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LTR to value 0"] impl crate :: Resettable for LtrSpec { } }
#[doc = "SQR1 (rw) register accessor: regular sequence register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr1`] module"]
#[doc (alias = "SQR1")] pub type Sqr1 = crate :: Reg < sqr1 :: Sqr1Spec > ;
#[doc = "regular sequence register 1"] pub mod sqr1 {
#[doc = "Register `SQR1` reader"] pub type R = crate :: R < Sqr1Spec > ;
#[doc = "Register `SQR1` writer"] pub type W = crate :: W < Sqr1Spec > ;
#[doc = "Field `SQ13` reader - 13th conversion in regular sequence"] pub type Sq13R = crate :: FieldReader ;
#[doc = "Field `SQ13` writer - 13th conversion in regular sequence"] pub type Sq13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ14` reader - 14th conversion in regular sequence"] pub type Sq14R = crate :: FieldReader ;
#[doc = "Field `SQ14` writer - 14th conversion in regular sequence"] pub type Sq14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ15` reader - 15th conversion in regular sequence"] pub type Sq15R = crate :: FieldReader ;
#[doc = "Field `SQ15` writer - 15th conversion in regular sequence"] pub type Sq15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ16` reader - 16th conversion in regular sequence"] pub type Sq16R = crate :: FieldReader ;
#[doc = "Field `SQ16` writer - 16th conversion in regular sequence"] pub type Sq16W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `L` reader - Regular channel sequence length"] pub type LR = crate :: FieldReader ;
#[doc = "Field `L` writer - Regular channel sequence length"] pub type LW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:4 - 13th conversion in regular sequence"]
#[inline (always)] pub fn sq13 (& self) -> Sq13R { Sq13R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 5:9 - 14th conversion in regular sequence"]
#[inline (always)] pub fn sq14 (& self) -> Sq14R { Sq14R :: new (((self . bits >> 5) & 0x1f) as u8) }
#[doc = "Bits 10:14 - 15th conversion in regular sequence"]
#[inline (always)] pub fn sq15 (& self) -> Sq15R { Sq15R :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bits 15:19 - 16th conversion in regular sequence"]
#[inline (always)] pub fn sq16 (& self) -> Sq16R { Sq16R :: new (((self . bits >> 15) & 0x1f) as u8) }
#[doc = "Bits 20:23 - Regular channel sequence length"]
#[inline (always)] pub fn l (& self) -> LR { LR :: new (((self . bits >> 20) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:4 - 13th conversion in regular sequence"]
#[inline (always)] pub fn sq13 (& mut self) -> Sq13W < '_ , Sqr1Spec > { Sq13W :: new (self , 0) }
#[doc = "Bits 5:9 - 14th conversion in regular sequence"]
#[inline (always)] pub fn sq14 (& mut self) -> Sq14W < '_ , Sqr1Spec > { Sq14W :: new (self , 5) }
#[doc = "Bits 10:14 - 15th conversion in regular sequence"]
#[inline (always)] pub fn sq15 (& mut self) -> Sq15W < '_ , Sqr1Spec > { Sq15W :: new (self , 10) }
#[doc = "Bits 15:19 - 16th conversion in regular sequence"]
#[inline (always)] pub fn sq16 (& mut self) -> Sq16W < '_ , Sqr1Spec > { Sq16W :: new (self , 15) }
#[doc = "Bits 20:23 - Regular channel sequence length"]
#[inline (always)] pub fn l (& mut self) -> LW < '_ , Sqr1Spec > { LW :: new (self , 20) } }
#[doc = "regular sequence register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr1Spec ; impl crate :: RegisterSpec for Sqr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr1::R`](R) reader structure"] impl crate :: Readable for Sqr1Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr1::W`](W) writer structure"] impl crate :: Writable for Sqr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR1 to value 0"] impl crate :: Resettable for Sqr1Spec { } }
#[doc = "SQR2 (rw) register accessor: regular sequence register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr2`] module"]
#[doc (alias = "SQR2")] pub type Sqr2 = crate :: Reg < sqr2 :: Sqr2Spec > ;
#[doc = "regular sequence register 2"] pub mod sqr2 {
#[doc = "Register `SQR2` reader"] pub type R = crate :: R < Sqr2Spec > ;
#[doc = "Register `SQR2` writer"] pub type W = crate :: W < Sqr2Spec > ;
#[doc = "Field `SQ7` reader - 7th conversion in regular sequence"] pub type Sq7R = crate :: FieldReader ;
#[doc = "Field `SQ7` writer - 7th conversion in regular sequence"] pub type Sq7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ8` reader - 8th conversion in regular sequence"] pub type Sq8R = crate :: FieldReader ;
#[doc = "Field `SQ8` writer - 8th conversion in regular sequence"] pub type Sq8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ9` reader - 9th conversion in regular sequence"] pub type Sq9R = crate :: FieldReader ;
#[doc = "Field `SQ9` writer - 9th conversion in regular sequence"] pub type Sq9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ10` reader - 10th conversion in regular sequence"] pub type Sq10R = crate :: FieldReader ;
#[doc = "Field `SQ10` writer - 10th conversion in regular sequence"] pub type Sq10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ11` reader - 11th conversion in regular sequence"] pub type Sq11R = crate :: FieldReader ;
#[doc = "Field `SQ11` writer - 11th conversion in regular sequence"] pub type Sq11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ12` reader - 12th conversion in regular sequence"] pub type Sq12R = crate :: FieldReader ;
#[doc = "Field `SQ12` writer - 12th conversion in regular sequence"] pub type Sq12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - 7th conversion in regular sequence"]
#[inline (always)] pub fn sq7 (& self) -> Sq7R { Sq7R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 5:9 - 8th conversion in regular sequence"]
#[inline (always)] pub fn sq8 (& self) -> Sq8R { Sq8R :: new (((self . bits >> 5) & 0x1f) as u8) }
#[doc = "Bits 10:14 - 9th conversion in regular sequence"]
#[inline (always)] pub fn sq9 (& self) -> Sq9R { Sq9R :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bits 15:19 - 10th conversion in regular sequence"]
#[inline (always)] pub fn sq10 (& self) -> Sq10R { Sq10R :: new (((self . bits >> 15) & 0x1f) as u8) }
#[doc = "Bits 20:24 - 11th conversion in regular sequence"]
#[inline (always)] pub fn sq11 (& self) -> Sq11R { Sq11R :: new (((self . bits >> 20) & 0x1f) as u8) }
#[doc = "Bits 25:29 - 12th conversion in regular sequence"]
#[inline (always)] pub fn sq12 (& self) -> Sq12R { Sq12R :: new (((self . bits >> 25) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - 7th conversion in regular sequence"]
#[inline (always)] pub fn sq7 (& mut self) -> Sq7W < '_ , Sqr2Spec > { Sq7W :: new (self , 0) }
#[doc = "Bits 5:9 - 8th conversion in regular sequence"]
#[inline (always)] pub fn sq8 (& mut self) -> Sq8W < '_ , Sqr2Spec > { Sq8W :: new (self , 5) }
#[doc = "Bits 10:14 - 9th conversion in regular sequence"]
#[inline (always)] pub fn sq9 (& mut self) -> Sq9W < '_ , Sqr2Spec > { Sq9W :: new (self , 10) }
#[doc = "Bits 15:19 - 10th conversion in regular sequence"]
#[inline (always)] pub fn sq10 (& mut self) -> Sq10W < '_ , Sqr2Spec > { Sq10W :: new (self , 15) }
#[doc = "Bits 20:24 - 11th conversion in regular sequence"]
#[inline (always)] pub fn sq11 (& mut self) -> Sq11W < '_ , Sqr2Spec > { Sq11W :: new (self , 20) }
#[doc = "Bits 25:29 - 12th conversion in regular sequence"]
#[inline (always)] pub fn sq12 (& mut self) -> Sq12W < '_ , Sqr2Spec > { Sq12W :: new (self , 25) } }
#[doc = "regular sequence register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr2Spec ; impl crate :: RegisterSpec for Sqr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr2::R`](R) reader structure"] impl crate :: Readable for Sqr2Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr2::W`](W) writer structure"] impl crate :: Writable for Sqr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR2 to value 0"] impl crate :: Resettable for Sqr2Spec { } }
#[doc = "SQR3 (rw) register accessor: regular sequence register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sqr3`] module"]
#[doc (alias = "SQR3")] pub type Sqr3 = crate :: Reg < sqr3 :: Sqr3Spec > ;
#[doc = "regular sequence register 3"] pub mod sqr3 {
#[doc = "Register `SQR3` reader"] pub type R = crate :: R < Sqr3Spec > ;
#[doc = "Register `SQR3` writer"] pub type W = crate :: W < Sqr3Spec > ;
#[doc = "Field `SQ1` reader - 1st conversion in regular sequence"] pub type Sq1R = crate :: FieldReader ;
#[doc = "Field `SQ1` writer - 1st conversion in regular sequence"] pub type Sq1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ2` reader - 2nd conversion in regular sequence"] pub type Sq2R = crate :: FieldReader ;
#[doc = "Field `SQ2` writer - 2nd conversion in regular sequence"] pub type Sq2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ3` reader - 3rd conversion in regular sequence"] pub type Sq3R = crate :: FieldReader ;
#[doc = "Field `SQ3` writer - 3rd conversion in regular sequence"] pub type Sq3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ4` reader - 4th conversion in regular sequence"] pub type Sq4R = crate :: FieldReader ;
#[doc = "Field `SQ4` writer - 4th conversion in regular sequence"] pub type Sq4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ5` reader - 5th conversion in regular sequence"] pub type Sq5R = crate :: FieldReader ;
#[doc = "Field `SQ5` writer - 5th conversion in regular sequence"] pub type Sq5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `SQ6` reader - 6th conversion in regular sequence"] pub type Sq6R = crate :: FieldReader ;
#[doc = "Field `SQ6` writer - 6th conversion in regular sequence"] pub type Sq6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - 1st conversion in regular sequence"]
#[inline (always)] pub fn sq1 (& self) -> Sq1R { Sq1R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 5:9 - 2nd conversion in regular sequence"]
#[inline (always)] pub fn sq2 (& self) -> Sq2R { Sq2R :: new (((self . bits >> 5) & 0x1f) as u8) }
#[doc = "Bits 10:14 - 3rd conversion in regular sequence"]
#[inline (always)] pub fn sq3 (& self) -> Sq3R { Sq3R :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bits 15:19 - 4th conversion in regular sequence"]
#[inline (always)] pub fn sq4 (& self) -> Sq4R { Sq4R :: new (((self . bits >> 15) & 0x1f) as u8) }
#[doc = "Bits 20:24 - 5th conversion in regular sequence"]
#[inline (always)] pub fn sq5 (& self) -> Sq5R { Sq5R :: new (((self . bits >> 20) & 0x1f) as u8) }
#[doc = "Bits 25:29 - 6th conversion in regular sequence"]
#[inline (always)] pub fn sq6 (& self) -> Sq6R { Sq6R :: new (((self . bits >> 25) & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - 1st conversion in regular sequence"]
#[inline (always)] pub fn sq1 (& mut self) -> Sq1W < '_ , Sqr3Spec > { Sq1W :: new (self , 0) }
#[doc = "Bits 5:9 - 2nd conversion in regular sequence"]
#[inline (always)] pub fn sq2 (& mut self) -> Sq2W < '_ , Sqr3Spec > { Sq2W :: new (self , 5) }
#[doc = "Bits 10:14 - 3rd conversion in regular sequence"]
#[inline (always)] pub fn sq3 (& mut self) -> Sq3W < '_ , Sqr3Spec > { Sq3W :: new (self , 10) }
#[doc = "Bits 15:19 - 4th conversion in regular sequence"]
#[inline (always)] pub fn sq4 (& mut self) -> Sq4W < '_ , Sqr3Spec > { Sq4W :: new (self , 15) }
#[doc = "Bits 20:24 - 5th conversion in regular sequence"]
#[inline (always)] pub fn sq5 (& mut self) -> Sq5W < '_ , Sqr3Spec > { Sq5W :: new (self , 20) }
#[doc = "Bits 25:29 - 6th conversion in regular sequence"]
#[inline (always)] pub fn sq6 (& mut self) -> Sq6W < '_ , Sqr3Spec > { Sq6W :: new (self , 25) } }
#[doc = "regular sequence register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`sqr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sqr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sqr3Spec ; impl crate :: RegisterSpec for Sqr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sqr3::R`](R) reader structure"] impl crate :: Readable for Sqr3Spec { }
#[doc = "`write(|w| ..)` method takes [`sqr3::W`](W) writer structure"] impl crate :: Writable for Sqr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SQR3 to value 0"] impl crate :: Resettable for Sqr3Spec { } }
#[doc = "JSQR (rw) register accessor: injected sequence register\n\nYou can [`read`](crate::Reg::read) this register and get [`jsqr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jsqr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jsqr`] module"]
#[doc (alias = "JSQR")] pub type Jsqr = crate :: Reg < jsqr :: JsqrSpec > ;
#[doc = "injected sequence register"] pub mod jsqr {
#[doc = "Register `JSQR` reader"] pub type R = crate :: R < JsqrSpec > ;
#[doc = "Register `JSQR` writer"] pub type W = crate :: W < JsqrSpec > ;
#[doc = "Field `JSQ1` reader - 1st conversion in injected sequence"] pub type Jsq1R = crate :: FieldReader ;
#[doc = "Field `JSQ1` writer - 1st conversion in injected sequence"] pub type Jsq1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ2` reader - 2nd conversion in injected sequence"] pub type Jsq2R = crate :: FieldReader ;
#[doc = "Field `JSQ2` writer - 2nd conversion in injected sequence"] pub type Jsq2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ3` reader - 3rd conversion in injected sequence"] pub type Jsq3R = crate :: FieldReader ;
#[doc = "Field `JSQ3` writer - 3rd conversion in injected sequence"] pub type Jsq3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JSQ4` reader - 4th conversion in injected sequence"] pub type Jsq4R = crate :: FieldReader ;
#[doc = "Field `JSQ4` writer - 4th conversion in injected sequence"] pub type Jsq4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `JL` reader - Injected sequence length"] pub type JlR = crate :: FieldReader ;
#[doc = "Field `JL` writer - Injected sequence length"] pub type JlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:4 - 1st conversion in injected sequence"]
#[inline (always)] pub fn jsq1 (& self) -> Jsq1R { Jsq1R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 5:9 - 2nd conversion in injected sequence"]
#[inline (always)] pub fn jsq2 (& self) -> Jsq2R { Jsq2R :: new (((self . bits >> 5) & 0x1f) as u8) }
#[doc = "Bits 10:14 - 3rd conversion in injected sequence"]
#[inline (always)] pub fn jsq3 (& self) -> Jsq3R { Jsq3R :: new (((self . bits >> 10) & 0x1f) as u8) }
#[doc = "Bits 15:19 - 4th conversion in injected sequence"]
#[inline (always)] pub fn jsq4 (& self) -> Jsq4R { Jsq4R :: new (((self . bits >> 15) & 0x1f) as u8) }
#[doc = "Bits 20:21 - Injected sequence length"]
#[inline (always)] pub fn jl (& self) -> JlR { JlR :: new (((self . bits >> 20) & 3) as u8) } } impl W {
#[doc = "Bits 0:4 - 1st conversion in injected sequence"]
#[inline (always)] pub fn jsq1 (& mut self) -> Jsq1W < '_ , JsqrSpec > { Jsq1W :: new (self , 0) }
#[doc = "Bits 5:9 - 2nd conversion in injected sequence"]
#[inline (always)] pub fn jsq2 (& mut self) -> Jsq2W < '_ , JsqrSpec > { Jsq2W :: new (self , 5) }
#[doc = "Bits 10:14 - 3rd conversion in injected sequence"]
#[inline (always)] pub fn jsq3 (& mut self) -> Jsq3W < '_ , JsqrSpec > { Jsq3W :: new (self , 10) }
#[doc = "Bits 15:19 - 4th conversion in injected sequence"]
#[inline (always)] pub fn jsq4 (& mut self) -> Jsq4W < '_ , JsqrSpec > { Jsq4W :: new (self , 15) }
#[doc = "Bits 20:21 - Injected sequence length"]
#[inline (always)] pub fn jl (& mut self) -> JlW < '_ , JsqrSpec > { JlW :: new (self , 20) } }
#[doc = "injected sequence register\n\nYou can [`read`](crate::Reg::read) this register and get [`jsqr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`jsqr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct JsqrSpec ; impl crate :: RegisterSpec for JsqrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jsqr::R`](R) reader structure"] impl crate :: Readable for JsqrSpec { }
#[doc = "`write(|w| ..)` method takes [`jsqr::W`](W) writer structure"] impl crate :: Writable for JsqrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets JSQR to value 0"] impl crate :: Resettable for JsqrSpec { } }
#[doc = "JDR1 (r) register accessor: injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr1`] module"]
#[doc (alias = "JDR1")] pub type Jdr1 = crate :: Reg < jdr1 :: Jdr1Spec > ;
#[doc = "injected data register x"] pub mod jdr1 {
#[doc = "Register `JDR1` reader"] pub type R = crate :: R < Jdr1Spec > ;
#[doc = "Field `JDATA` reader - Injected data"] pub type JdataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Injected data"]
#[inline (always)] pub fn jdata (& self) -> JdataR { JdataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr1Spec ; impl crate :: RegisterSpec for Jdr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr1::R`](R) reader structure"] impl crate :: Readable for Jdr1Spec { }
#[doc = "`reset()` method sets JDR1 to value 0"] impl crate :: Resettable for Jdr1Spec { } }
#[doc = "JDR2 (r) register accessor: injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr2`] module"]
#[doc (alias = "JDR2")] pub type Jdr2 = crate :: Reg < jdr2 :: Jdr2Spec > ;
#[doc = "injected data register x"] pub mod jdr2 {
#[doc = "Register `JDR2` reader"] pub type R = crate :: R < Jdr2Spec > ;
#[doc = "Field `JDATA` reader - Injected data"] pub type JdataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Injected data"]
#[inline (always)] pub fn jdata (& self) -> JdataR { JdataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr2Spec ; impl crate :: RegisterSpec for Jdr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr2::R`](R) reader structure"] impl crate :: Readable for Jdr2Spec { }
#[doc = "`reset()` method sets JDR2 to value 0"] impl crate :: Resettable for Jdr2Spec { } }
#[doc = "JDR3 (r) register accessor: injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr3`] module"]
#[doc (alias = "JDR3")] pub type Jdr3 = crate :: Reg < jdr3 :: Jdr3Spec > ;
#[doc = "injected data register x"] pub mod jdr3 {
#[doc = "Register `JDR3` reader"] pub type R = crate :: R < Jdr3Spec > ;
#[doc = "Field `JDATA` reader - Injected data"] pub type JdataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Injected data"]
#[inline (always)] pub fn jdata (& self) -> JdataR { JdataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr3Spec ; impl crate :: RegisterSpec for Jdr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr3::R`](R) reader structure"] impl crate :: Readable for Jdr3Spec { }
#[doc = "`reset()` method sets JDR3 to value 0"] impl crate :: Resettable for Jdr3Spec { } }
#[doc = "JDR4 (r) register accessor: injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr4::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@jdr4`] module"]
#[doc (alias = "JDR4")] pub type Jdr4 = crate :: Reg < jdr4 :: Jdr4Spec > ;
#[doc = "injected data register x"] pub mod jdr4 {
#[doc = "Register `JDR4` reader"] pub type R = crate :: R < Jdr4Spec > ;
#[doc = "Field `JDATA` reader - Injected data"] pub type JdataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Injected data"]
#[inline (always)] pub fn jdata (& self) -> JdataR { JdataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "injected data register x\n\nYou can [`read`](crate::Reg::read) this register and get [`jdr4::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Jdr4Spec ; impl crate :: RegisterSpec for Jdr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`jdr4::R`](R) reader structure"] impl crate :: Readable for Jdr4Spec { }
#[doc = "`reset()` method sets JDR4 to value 0"] impl crate :: Resettable for Jdr4Spec { } }
#[doc = "DR (r) register accessor: regular data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "regular data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Field `DATA` reader - Regular data"] pub type DataR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Regular data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "regular data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } } }
#[doc = "Analog to digital converter"] pub type Adc3 = crate :: Periph < adc2 :: RegisterBlock , 0x4001_3c00 > ; impl core :: fmt :: Debug for Adc3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc3") . finish () } }
#[doc = "Analog to digital converter"] pub use self :: adc2 as adc3 ;
#[doc = "Controller area network"] pub type Can1 = crate :: Periph < can1 :: RegisterBlock , 0x4000_6400 > ; impl core :: fmt :: Debug for Can1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Can1") . finish () } }
#[doc = "Controller area network"] pub mod can1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { can_mcr : CanMcr , can_msr : CanMsr , can_tsr : CanTsr , can_rf0r : CanRf0r , can_rf1r : CanRf1r , can_ier : CanIer , can_esr : CanEsr , can_btr : CanBtr , _reserved8 : [u8 ; 0x0160] , can_ti0r : CanTi0r , can_tdt0r : CanTdt0r , can_tdl0r : CanTdl0r , can_tdh0r : CanTdh0r , can_ti1r : CanTi1r , can_tdt1r : CanTdt1r , can_tdl1r : CanTdl1r , can_tdh1r : CanTdh1r , can_ti2r : CanTi2r , can_tdt2r : CanTdt2r , can_tdl2r : CanTdl2r , can_tdh2r : CanTdh2r , can_ri0r : CanRi0r , can_rdt0r : CanRdt0r , can_rdl0r : CanRdl0r , can_rdh0r : CanRdh0r , can_ri1r : CanRi1r , can_rdt1r : CanRdt1r , can_rdl1r : CanRdl1r , can_rdh1r : CanRdh1r , _reserved28 : [u8 ; 0x30] , can_fmr : CanFmr , can_fm1r : CanFm1r , _reserved30 : [u8 ; 0x04] , can_fs1r : CanFs1r , _reserved31 : [u8 ; 0x04] , can_ffa1r : CanFfa1r , _reserved32 : [u8 ; 0x04] , can_fa1r : CanFa1r , _reserved33 : [u8 ; 0x20] , f0r1 : F0r1 , f0r2 : F0r2 , f1r1 : F1r1 , f1r2 : F1r2 , f2r1 : F2r1 , f2r2 : F2r2 , f3r1 : F3r1 , f3r2 : F3r2 , f4r1 : F4r1 , f4r2 : F4r2 , f5r1 : F5r1 , f5r2 : F5r2 , f6r1 : F6r1 , f6r2 : F6r2 , f7r1 : F7r1 , f7r2 : F7r2 , f8r1 : F8r1 , f8r2 : F8r2 , f9r1 : F9r1 , f9r2 : F9r2 , f10r1 : F10r1 , f10r2 : F10r2 , f11r1 : F11r1 , f11r2 : F11r2 , f12r1 : F12r1 , f12r2 : F12r2 , f13r1 : F13r1 , f13r2 : F13r2 , } impl RegisterBlock {
#[doc = "0x00 - CAN_MCR"]
#[inline (always)] pub const fn can_mcr (& self) -> & CanMcr { & self . can_mcr }
#[doc = "0x04 - CAN_MSR"]
#[inline (always)] pub const fn can_msr (& self) -> & CanMsr { & self . can_msr }
#[doc = "0x08 - CAN_TSR"]
#[inline (always)] pub const fn can_tsr (& self) -> & CanTsr { & self . can_tsr }
#[doc = "0x0c - CAN_RF0R"]
#[inline (always)] pub const fn can_rf0r (& self) -> & CanRf0r { & self . can_rf0r }
#[doc = "0x10 - CAN_RF1R"]
#[inline (always)] pub const fn can_rf1r (& self) -> & CanRf1r { & self . can_rf1r }
#[doc = "0x14 - CAN_IER"]
#[inline (always)] pub const fn can_ier (& self) -> & CanIer { & self . can_ier }
#[doc = "0x18 - CAN_ESR"]
#[inline (always)] pub const fn can_esr (& self) -> & CanEsr { & self . can_esr }
#[doc = "0x1c - CAN_BTR"]
#[inline (always)] pub const fn can_btr (& self) -> & CanBtr { & self . can_btr }
#[doc = "0x180 - CAN_TI0R"]
#[inline (always)] pub const fn can_ti0r (& self) -> & CanTi0r { & self . can_ti0r }
#[doc = "0x184 - CAN_TDT0R"]
#[inline (always)] pub const fn can_tdt0r (& self) -> & CanTdt0r { & self . can_tdt0r }
#[doc = "0x188 - CAN_TDL0R"]
#[inline (always)] pub const fn can_tdl0r (& self) -> & CanTdl0r { & self . can_tdl0r }
#[doc = "0x18c - CAN_TDH0R"]
#[inline (always)] pub const fn can_tdh0r (& self) -> & CanTdh0r { & self . can_tdh0r }
#[doc = "0x190 - CAN_TI1R"]
#[inline (always)] pub const fn can_ti1r (& self) -> & CanTi1r { & self . can_ti1r }
#[doc = "0x194 - CAN_TDT1R"]
#[inline (always)] pub const fn can_tdt1r (& self) -> & CanTdt1r { & self . can_tdt1r }
#[doc = "0x198 - CAN_TDL1R"]
#[inline (always)] pub const fn can_tdl1r (& self) -> & CanTdl1r { & self . can_tdl1r }
#[doc = "0x19c - CAN_TDH1R"]
#[inline (always)] pub const fn can_tdh1r (& self) -> & CanTdh1r { & self . can_tdh1r }
#[doc = "0x1a0 - CAN_TI2R"]
#[inline (always)] pub const fn can_ti2r (& self) -> & CanTi2r { & self . can_ti2r }
#[doc = "0x1a4 - CAN_TDT2R"]
#[inline (always)] pub const fn can_tdt2r (& self) -> & CanTdt2r { & self . can_tdt2r }
#[doc = "0x1a8 - CAN_TDL2R"]
#[inline (always)] pub const fn can_tdl2r (& self) -> & CanTdl2r { & self . can_tdl2r }
#[doc = "0x1ac - CAN_TDH2R"]
#[inline (always)] pub const fn can_tdh2r (& self) -> & CanTdh2r { & self . can_tdh2r }
#[doc = "0x1b0 - CAN_RI0R"]
#[inline (always)] pub const fn can_ri0r (& self) -> & CanRi0r { & self . can_ri0r }
#[doc = "0x1b4 - CAN_RDT0R"]
#[inline (always)] pub const fn can_rdt0r (& self) -> & CanRdt0r { & self . can_rdt0r }
#[doc = "0x1b8 - CAN_RDL0R"]
#[inline (always)] pub const fn can_rdl0r (& self) -> & CanRdl0r { & self . can_rdl0r }
#[doc = "0x1bc - CAN_RDH0R"]
#[inline (always)] pub const fn can_rdh0r (& self) -> & CanRdh0r { & self . can_rdh0r }
#[doc = "0x1c0 - CAN_RI1R"]
#[inline (always)] pub const fn can_ri1r (& self) -> & CanRi1r { & self . can_ri1r }
#[doc = "0x1c4 - CAN_RDT1R"]
#[inline (always)] pub const fn can_rdt1r (& self) -> & CanRdt1r { & self . can_rdt1r }
#[doc = "0x1c8 - CAN_RDL1R"]
#[inline (always)] pub const fn can_rdl1r (& self) -> & CanRdl1r { & self . can_rdl1r }
#[doc = "0x1cc - CAN_RDH1R"]
#[inline (always)] pub const fn can_rdh1r (& self) -> & CanRdh1r { & self . can_rdh1r }
#[doc = "0x200 - CAN_FMR"]
#[inline (always)] pub const fn can_fmr (& self) -> & CanFmr { & self . can_fmr }
#[doc = "0x204 - CAN_FM1R"]
#[inline (always)] pub const fn can_fm1r (& self) -> & CanFm1r { & self . can_fm1r }
#[doc = "0x20c - CAN_FS1R"]
#[inline (always)] pub const fn can_fs1r (& self) -> & CanFs1r { & self . can_fs1r }
#[doc = "0x214 - CAN_FFA1R"]
#[inline (always)] pub const fn can_ffa1r (& self) -> & CanFfa1r { & self . can_ffa1r }
#[doc = "0x21c - CAN_FA1R"]
#[inline (always)] pub const fn can_fa1r (& self) -> & CanFa1r { & self . can_fa1r }
#[doc = "0x240 - Filter bank 0 register 1"]
#[inline (always)] pub const fn f0r1 (& self) -> & F0r1 { & self . f0r1 }
#[doc = "0x244 - Filter bank 0 register 2"]
#[inline (always)] pub const fn f0r2 (& self) -> & F0r2 { & self . f0r2 }
#[doc = "0x248 - Filter bank 1 register 1"]
#[inline (always)] pub const fn f1r1 (& self) -> & F1r1 { & self . f1r1 }
#[doc = "0x24c - Filter bank 1 register 2"]
#[inline (always)] pub const fn f1r2 (& self) -> & F1r2 { & self . f1r2 }
#[doc = "0x250 - Filter bank 2 register 1"]
#[inline (always)] pub const fn f2r1 (& self) -> & F2r1 { & self . f2r1 }
#[doc = "0x254 - Filter bank 2 register 2"]
#[inline (always)] pub const fn f2r2 (& self) -> & F2r2 { & self . f2r2 }
#[doc = "0x258 - Filter bank 3 register 1"]
#[inline (always)] pub const fn f3r1 (& self) -> & F3r1 { & self . f3r1 }
#[doc = "0x25c - Filter bank 3 register 2"]
#[inline (always)] pub const fn f3r2 (& self) -> & F3r2 { & self . f3r2 }
#[doc = "0x260 - Filter bank 4 register 1"]
#[inline (always)] pub const fn f4r1 (& self) -> & F4r1 { & self . f4r1 }
#[doc = "0x264 - Filter bank 4 register 2"]
#[inline (always)] pub const fn f4r2 (& self) -> & F4r2 { & self . f4r2 }
#[doc = "0x268 - Filter bank 5 register 1"]
#[inline (always)] pub const fn f5r1 (& self) -> & F5r1 { & self . f5r1 }
#[doc = "0x26c - Filter bank 5 register 2"]
#[inline (always)] pub const fn f5r2 (& self) -> & F5r2 { & self . f5r2 }
#[doc = "0x270 - Filter bank 6 register 1"]
#[inline (always)] pub const fn f6r1 (& self) -> & F6r1 { & self . f6r1 }
#[doc = "0x274 - Filter bank 6 register 2"]
#[inline (always)] pub const fn f6r2 (& self) -> & F6r2 { & self . f6r2 }
#[doc = "0x278 - Filter bank 7 register 1"]
#[inline (always)] pub const fn f7r1 (& self) -> & F7r1 { & self . f7r1 }
#[doc = "0x27c - Filter bank 7 register 2"]
#[inline (always)] pub const fn f7r2 (& self) -> & F7r2 { & self . f7r2 }
#[doc = "0x280 - Filter bank 8 register 1"]
#[inline (always)] pub const fn f8r1 (& self) -> & F8r1 { & self . f8r1 }
#[doc = "0x284 - Filter bank 8 register 2"]
#[inline (always)] pub const fn f8r2 (& self) -> & F8r2 { & self . f8r2 }
#[doc = "0x288 - Filter bank 9 register 1"]
#[inline (always)] pub const fn f9r1 (& self) -> & F9r1 { & self . f9r1 }
#[doc = "0x28c - Filter bank 9 register 2"]
#[inline (always)] pub const fn f9r2 (& self) -> & F9r2 { & self . f9r2 }
#[doc = "0x290 - Filter bank 10 register 1"]
#[inline (always)] pub const fn f10r1 (& self) -> & F10r1 { & self . f10r1 }
#[doc = "0x294 - Filter bank 10 register 2"]
#[inline (always)] pub const fn f10r2 (& self) -> & F10r2 { & self . f10r2 }
#[doc = "0x298 - Filter bank 11 register 1"]
#[inline (always)] pub const fn f11r1 (& self) -> & F11r1 { & self . f11r1 }
#[doc = "0x29c - Filter bank 11 register 2"]
#[inline (always)] pub const fn f11r2 (& self) -> & F11r2 { & self . f11r2 }
#[doc = "0x2a0 - Filter bank 4 register 1"]
#[inline (always)] pub const fn f12r1 (& self) -> & F12r1 { & self . f12r1 }
#[doc = "0x2a4 - Filter bank 12 register 2"]
#[inline (always)] pub const fn f12r2 (& self) -> & F12r2 { & self . f12r2 }
#[doc = "0x2a8 - Filter bank 13 register 1"]
#[inline (always)] pub const fn f13r1 (& self) -> & F13r1 { & self . f13r1 }
#[doc = "0x2ac - Filter bank 13 register 2"]
#[inline (always)] pub const fn f13r2 (& self) -> & F13r2 { & self . f13r2 } }
#[doc = "CAN_MCR (rw) register accessor: CAN_MCR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_mcr`] module"]
#[doc (alias = "CAN_MCR")] pub type CanMcr = crate :: Reg < can_mcr :: CanMcrSpec > ;
#[doc = "CAN_MCR"] pub mod can_mcr {
#[doc = "Register `CAN_MCR` reader"] pub type R = crate :: R < CanMcrSpec > ;
#[doc = "Register `CAN_MCR` writer"] pub type W = crate :: W < CanMcrSpec > ;
#[doc = "Field `INRQ` reader - INRQ"] pub type InrqR = crate :: BitReader ;
#[doc = "Field `INRQ` writer - INRQ"] pub type InrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLEEP` reader - SLEEP"] pub type SleepR = crate :: BitReader ;
#[doc = "Field `SLEEP` writer - SLEEP"] pub type SleepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFP` reader - TXFP"] pub type TxfpR = crate :: BitReader ;
#[doc = "Field `TXFP` writer - TXFP"] pub type TxfpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RFLM` reader - RFLM"] pub type RflmR = crate :: BitReader ;
#[doc = "Field `RFLM` writer - RFLM"] pub type RflmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NART` reader - NART"] pub type NartR = crate :: BitReader ;
#[doc = "Field `NART` writer - NART"] pub type NartW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AWUM` reader - AWUM"] pub type AwumR = crate :: BitReader ;
#[doc = "Field `AWUM` writer - AWUM"] pub type AwumW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABOM` reader - ABOM"] pub type AbomR = crate :: BitReader ;
#[doc = "Field `ABOM` writer - ABOM"] pub type AbomW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TTCM` reader - TTCM"] pub type TtcmR = crate :: BitReader ;
#[doc = "Field `TTCM` writer - TTCM"] pub type TtcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RESET` reader - RESET"] pub type ResetR = crate :: BitReader ;
#[doc = "Field `RESET` writer - RESET"] pub type ResetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBF` reader - DBF"] pub type DbfR = crate :: BitReader ;
#[doc = "Field `DBF` writer - DBF"] pub type DbfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - INRQ"]
#[inline (always)] pub fn inrq (& self) -> InrqR { InrqR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - SLEEP"]
#[inline (always)] pub fn sleep (& self) -> SleepR { SleepR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - TXFP"]
#[inline (always)] pub fn txfp (& self) -> TxfpR { TxfpR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RFLM"]
#[inline (always)] pub fn rflm (& self) -> RflmR { RflmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NART"]
#[inline (always)] pub fn nart (& self) -> NartR { NartR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - AWUM"]
#[inline (always)] pub fn awum (& self) -> AwumR { AwumR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - ABOM"]
#[inline (always)] pub fn abom (& self) -> AbomR { AbomR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TTCM"]
#[inline (always)] pub fn ttcm (& self) -> TtcmR { TtcmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 15 - RESET"]
#[inline (always)] pub fn reset (& self) -> ResetR { ResetR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - DBF"]
#[inline (always)] pub fn dbf (& self) -> DbfR { DbfR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - INRQ"]
#[inline (always)] pub fn inrq (& mut self) -> InrqW < '_ , CanMcrSpec > { InrqW :: new (self , 0) }
#[doc = "Bit 1 - SLEEP"]
#[inline (always)] pub fn sleep (& mut self) -> SleepW < '_ , CanMcrSpec > { SleepW :: new (self , 1) }
#[doc = "Bit 2 - TXFP"]
#[inline (always)] pub fn txfp (& mut self) -> TxfpW < '_ , CanMcrSpec > { TxfpW :: new (self , 2) }
#[doc = "Bit 3 - RFLM"]
#[inline (always)] pub fn rflm (& mut self) -> RflmW < '_ , CanMcrSpec > { RflmW :: new (self , 3) }
#[doc = "Bit 4 - NART"]
#[inline (always)] pub fn nart (& mut self) -> NartW < '_ , CanMcrSpec > { NartW :: new (self , 4) }
#[doc = "Bit 5 - AWUM"]
#[inline (always)] pub fn awum (& mut self) -> AwumW < '_ , CanMcrSpec > { AwumW :: new (self , 5) }
#[doc = "Bit 6 - ABOM"]
#[inline (always)] pub fn abom (& mut self) -> AbomW < '_ , CanMcrSpec > { AbomW :: new (self , 6) }
#[doc = "Bit 7 - TTCM"]
#[inline (always)] pub fn ttcm (& mut self) -> TtcmW < '_ , CanMcrSpec > { TtcmW :: new (self , 7) }
#[doc = "Bit 15 - RESET"]
#[inline (always)] pub fn reset (& mut self) -> ResetW < '_ , CanMcrSpec > { ResetW :: new (self , 15) }
#[doc = "Bit 16 - DBF"]
#[inline (always)] pub fn dbf (& mut self) -> DbfW < '_ , CanMcrSpec > { DbfW :: new (self , 16) } }
#[doc = "CAN_MCR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanMcrSpec ; impl crate :: RegisterSpec for CanMcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_mcr::R`](R) reader structure"] impl crate :: Readable for CanMcrSpec { }
#[doc = "`write(|w| ..)` method takes [`can_mcr::W`](W) writer structure"] impl crate :: Writable for CanMcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_MCR to value 0"] impl crate :: Resettable for CanMcrSpec { } }
#[doc = "CAN_MSR (rw) register accessor: CAN_MSR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_msr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_msr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_msr`] module"]
#[doc (alias = "CAN_MSR")] pub type CanMsr = crate :: Reg < can_msr :: CanMsrSpec > ;
#[doc = "CAN_MSR"] pub mod can_msr {
#[doc = "Register `CAN_MSR` reader"] pub type R = crate :: R < CanMsrSpec > ;
#[doc = "Register `CAN_MSR` writer"] pub type W = crate :: W < CanMsrSpec > ;
#[doc = "Field `INAK` reader - INAK"] pub type InakR = crate :: BitReader ;
#[doc = "Field `SLAK` reader - SLAK"] pub type SlakR = crate :: BitReader ;
#[doc = "Field `ERRI` reader - ERRI"] pub type ErriR = crate :: BitReader ;
#[doc = "Field `ERRI` writer - ERRI"] pub type ErriW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WKUI` reader - WKUI"] pub type WkuiR = crate :: BitReader ;
#[doc = "Field `WKUI` writer - WKUI"] pub type WkuiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLAKI` reader - SLAKI"] pub type SlakiR = crate :: BitReader ;
#[doc = "Field `SLAKI` writer - SLAKI"] pub type SlakiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXM` reader - TXM"] pub type TxmR = crate :: BitReader ;
#[doc = "Field `RXM` reader - RXM"] pub type RxmR = crate :: BitReader ;
#[doc = "Field `SAMP` reader - SAMP"] pub type SampR = crate :: BitReader ;
#[doc = "Field `RX` reader - RX"] pub type RxR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - INAK"]
#[inline (always)] pub fn inak (& self) -> InakR { InakR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - SLAK"]
#[inline (always)] pub fn slak (& self) -> SlakR { SlakR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - ERRI"]
#[inline (always)] pub fn erri (& self) -> ErriR { ErriR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - WKUI"]
#[inline (always)] pub fn wkui (& self) -> WkuiR { WkuiR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - SLAKI"]
#[inline (always)] pub fn slaki (& self) -> SlakiR { SlakiR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 8 - TXM"]
#[inline (always)] pub fn txm (& self) -> TxmR { TxmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - RXM"]
#[inline (always)] pub fn rxm (& self) -> RxmR { RxmR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - SAMP"]
#[inline (always)] pub fn samp (& self) -> SampR { SampR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - RX"]
#[inline (always)] pub fn rx (& self) -> RxR { RxR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 2 - ERRI"]
#[inline (always)] pub fn erri (& mut self) -> ErriW < '_ , CanMsrSpec > { ErriW :: new (self , 2) }
#[doc = "Bit 3 - WKUI"]
#[inline (always)] pub fn wkui (& mut self) -> WkuiW < '_ , CanMsrSpec > { WkuiW :: new (self , 3) }
#[doc = "Bit 4 - SLAKI"]
#[inline (always)] pub fn slaki (& mut self) -> SlakiW < '_ , CanMsrSpec > { SlakiW :: new (self , 4) } }
#[doc = "CAN_MSR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_msr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_msr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanMsrSpec ; impl crate :: RegisterSpec for CanMsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_msr::R`](R) reader structure"] impl crate :: Readable for CanMsrSpec { }
#[doc = "`write(|w| ..)` method takes [`can_msr::W`](W) writer structure"] impl crate :: Writable for CanMsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_MSR to value 0"] impl crate :: Resettable for CanMsrSpec { } }
#[doc = "CAN_TSR (rw) register accessor: CAN_TSR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tsr`] module"]
#[doc (alias = "CAN_TSR")] pub type CanTsr = crate :: Reg < can_tsr :: CanTsrSpec > ;
#[doc = "CAN_TSR"] pub mod can_tsr {
#[doc = "Register `CAN_TSR` reader"] pub type R = crate :: R < CanTsrSpec > ;
#[doc = "Register `CAN_TSR` writer"] pub type W = crate :: W < CanTsrSpec > ;
#[doc = "Field `RQCP0` reader - RQCP0"] pub type Rqcp0R = crate :: BitReader ;
#[doc = "Field `RQCP0` writer - RQCP0"] pub type Rqcp0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXOK0` reader - TXOK0"] pub type Txok0R = crate :: BitReader ;
#[doc = "Field `TXOK0` writer - TXOK0"] pub type Txok0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALST0` reader - ALST0"] pub type Alst0R = crate :: BitReader ;
#[doc = "Field `ALST0` writer - ALST0"] pub type Alst0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TERR0` reader - TERR0"] pub type Terr0R = crate :: BitReader ;
#[doc = "Field `TERR0` writer - TERR0"] pub type Terr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABRQ0` reader - ABRQ0"] pub type Abrq0R = crate :: BitReader ;
#[doc = "Field `ABRQ0` writer - ABRQ0"] pub type Abrq0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RQCP1` reader - RQCP1"] pub type Rqcp1R = crate :: BitReader ;
#[doc = "Field `RQCP1` writer - RQCP1"] pub type Rqcp1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXOK1` reader - TXOK1"] pub type Txok1R = crate :: BitReader ;
#[doc = "Field `TXOK1` writer - TXOK1"] pub type Txok1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALST1` reader - ALST1"] pub type Alst1R = crate :: BitReader ;
#[doc = "Field `ALST1` writer - ALST1"] pub type Alst1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TERR1` reader - TERR1"] pub type Terr1R = crate :: BitReader ;
#[doc = "Field `TERR1` writer - TERR1"] pub type Terr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABRQ1` reader - ABRQ1"] pub type Abrq1R = crate :: BitReader ;
#[doc = "Field `ABRQ1` writer - ABRQ1"] pub type Abrq1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RQCP2` reader - RQCP2"] pub type Rqcp2R = crate :: BitReader ;
#[doc = "Field `RQCP2` writer - RQCP2"] pub type Rqcp2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXOK2` reader - TXOK2"] pub type Txok2R = crate :: BitReader ;
#[doc = "Field `TXOK2` writer - TXOK2"] pub type Txok2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALST2` reader - ALST2"] pub type Alst2R = crate :: BitReader ;
#[doc = "Field `ALST2` writer - ALST2"] pub type Alst2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TERR2` reader - TERR2"] pub type Terr2R = crate :: BitReader ;
#[doc = "Field `TERR2` writer - TERR2"] pub type Terr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABRQ2` reader - ABRQ2"] pub type Abrq2R = crate :: BitReader ;
#[doc = "Field `ABRQ2` writer - ABRQ2"] pub type Abrq2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CODE` reader - CODE"] pub type CodeR = crate :: FieldReader ;
#[doc = "Field `TME0` reader - Lowest priority flag for mailbox 0"] pub type Tme0R = crate :: BitReader ;
#[doc = "Field `TME1` reader - Lowest priority flag for mailbox 1"] pub type Tme1R = crate :: BitReader ;
#[doc = "Field `TME2` reader - Lowest priority flag for mailbox 2"] pub type Tme2R = crate :: BitReader ;
#[doc = "Field `LOW0` reader - Lowest priority flag for mailbox 0"] pub type Low0R = crate :: BitReader ;
#[doc = "Field `LOW1` reader - Lowest priority flag for mailbox 1"] pub type Low1R = crate :: BitReader ;
#[doc = "Field `LOW2` reader - Lowest priority flag for mailbox 2"] pub type Low2R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RQCP0"]
#[inline (always)] pub fn rqcp0 (& self) -> Rqcp0R { Rqcp0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - TXOK0"]
#[inline (always)] pub fn txok0 (& self) -> Txok0R { Txok0R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - ALST0"]
#[inline (always)] pub fn alst0 (& self) -> Alst0R { Alst0R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - TERR0"]
#[inline (always)] pub fn terr0 (& self) -> Terr0R { Terr0R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - ABRQ0"]
#[inline (always)] pub fn abrq0 (& self) -> Abrq0R { Abrq0R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - RQCP1"]
#[inline (always)] pub fn rqcp1 (& self) -> Rqcp1R { Rqcp1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - TXOK1"]
#[inline (always)] pub fn txok1 (& self) -> Txok1R { Txok1R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - ALST1"]
#[inline (always)] pub fn alst1 (& self) -> Alst1R { Alst1R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - TERR1"]
#[inline (always)] pub fn terr1 (& self) -> Terr1R { Terr1R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 15 - ABRQ1"]
#[inline (always)] pub fn abrq1 (& self) -> Abrq1R { Abrq1R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - RQCP2"]
#[inline (always)] pub fn rqcp2 (& self) -> Rqcp2R { Rqcp2R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - TXOK2"]
#[inline (always)] pub fn txok2 (& self) -> Txok2R { Txok2R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - ALST2"]
#[inline (always)] pub fn alst2 (& self) -> Alst2R { Alst2R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - TERR2"]
#[inline (always)] pub fn terr2 (& self) -> Terr2R { Terr2R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 23 - ABRQ2"]
#[inline (always)] pub fn abrq2 (& self) -> Abrq2R { Abrq2R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bits 24:25 - CODE"]
#[inline (always)] pub fn code (& self) -> CodeR { CodeR :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bit 26 - Lowest priority flag for mailbox 0"]
#[inline (always)] pub fn tme0 (& self) -> Tme0R { Tme0R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Lowest priority flag for mailbox 1"]
#[inline (always)] pub fn tme1 (& self) -> Tme1R { Tme1R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Lowest priority flag for mailbox 2"]
#[inline (always)] pub fn tme2 (& self) -> Tme2R { Tme2R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Lowest priority flag for mailbox 0"]
#[inline (always)] pub fn low0 (& self) -> Low0R { Low0R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Lowest priority flag for mailbox 1"]
#[inline (always)] pub fn low1 (& self) -> Low1R { Low1R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Lowest priority flag for mailbox 2"]
#[inline (always)] pub fn low2 (& self) -> Low2R { Low2R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RQCP0"]
#[inline (always)] pub fn rqcp0 (& mut self) -> Rqcp0W < '_ , CanTsrSpec > { Rqcp0W :: new (self , 0) }
#[doc = "Bit 1 - TXOK0"]
#[inline (always)] pub fn txok0 (& mut self) -> Txok0W < '_ , CanTsrSpec > { Txok0W :: new (self , 1) }
#[doc = "Bit 2 - ALST0"]
#[inline (always)] pub fn alst0 (& mut self) -> Alst0W < '_ , CanTsrSpec > { Alst0W :: new (self , 2) }
#[doc = "Bit 3 - TERR0"]
#[inline (always)] pub fn terr0 (& mut self) -> Terr0W < '_ , CanTsrSpec > { Terr0W :: new (self , 3) }
#[doc = "Bit 7 - ABRQ0"]
#[inline (always)] pub fn abrq0 (& mut self) -> Abrq0W < '_ , CanTsrSpec > { Abrq0W :: new (self , 7) }
#[doc = "Bit 8 - RQCP1"]
#[inline (always)] pub fn rqcp1 (& mut self) -> Rqcp1W < '_ , CanTsrSpec > { Rqcp1W :: new (self , 8) }
#[doc = "Bit 9 - TXOK1"]
#[inline (always)] pub fn txok1 (& mut self) -> Txok1W < '_ , CanTsrSpec > { Txok1W :: new (self , 9) }
#[doc = "Bit 10 - ALST1"]
#[inline (always)] pub fn alst1 (& mut self) -> Alst1W < '_ , CanTsrSpec > { Alst1W :: new (self , 10) }
#[doc = "Bit 11 - TERR1"]
#[inline (always)] pub fn terr1 (& mut self) -> Terr1W < '_ , CanTsrSpec > { Terr1W :: new (self , 11) }
#[doc = "Bit 15 - ABRQ1"]
#[inline (always)] pub fn abrq1 (& mut self) -> Abrq1W < '_ , CanTsrSpec > { Abrq1W :: new (self , 15) }
#[doc = "Bit 16 - RQCP2"]
#[inline (always)] pub fn rqcp2 (& mut self) -> Rqcp2W < '_ , CanTsrSpec > { Rqcp2W :: new (self , 16) }
#[doc = "Bit 17 - TXOK2"]
#[inline (always)] pub fn txok2 (& mut self) -> Txok2W < '_ , CanTsrSpec > { Txok2W :: new (self , 17) }
#[doc = "Bit 18 - ALST2"]
#[inline (always)] pub fn alst2 (& mut self) -> Alst2W < '_ , CanTsrSpec > { Alst2W :: new (self , 18) }
#[doc = "Bit 19 - TERR2"]
#[inline (always)] pub fn terr2 (& mut self) -> Terr2W < '_ , CanTsrSpec > { Terr2W :: new (self , 19) }
#[doc = "Bit 23 - ABRQ2"]
#[inline (always)] pub fn abrq2 (& mut self) -> Abrq2W < '_ , CanTsrSpec > { Abrq2W :: new (self , 23) } }
#[doc = "CAN_TSR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTsrSpec ; impl crate :: RegisterSpec for CanTsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tsr::R`](R) reader structure"] impl crate :: Readable for CanTsrSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tsr::W`](W) writer structure"] impl crate :: Writable for CanTsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TSR to value 0"] impl crate :: Resettable for CanTsrSpec { } }
#[doc = "CAN_RF0R (rw) register accessor: CAN_RF0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rf0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_rf0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_rf0r`] module"]
#[doc (alias = "CAN_RF0R")] pub type CanRf0r = crate :: Reg < can_rf0r :: CanRf0rSpec > ;
#[doc = "CAN_RF0R"] pub mod can_rf0r {
#[doc = "Register `CAN_RF0R` reader"] pub type R = crate :: R < CanRf0rSpec > ;
#[doc = "Register `CAN_RF0R` writer"] pub type W = crate :: W < CanRf0rSpec > ;
#[doc = "Field `FMP0` reader - FMP0"] pub type Fmp0R = crate :: FieldReader ;
#[doc = "Field `FULL0` reader - FULL0"] pub type Full0R = crate :: BitReader ;
#[doc = "Field `FULL0` writer - FULL0"] pub type Full0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FOVR0` reader - FOVR0"] pub type Fovr0R = crate :: BitReader ;
#[doc = "Field `FOVR0` writer - FOVR0"] pub type Fovr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RFOM0` reader - RFOM0"] pub type Rfom0R = crate :: BitReader ;
#[doc = "Field `RFOM0` writer - RFOM0"] pub type Rfom0W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - FMP0"]
#[inline (always)] pub fn fmp0 (& self) -> Fmp0R { Fmp0R :: new ((self . bits & 3) as u8) }
#[doc = "Bit 3 - FULL0"]
#[inline (always)] pub fn full0 (& self) -> Full0R { Full0R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - FOVR0"]
#[inline (always)] pub fn fovr0 (& self) -> Fovr0R { Fovr0R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RFOM0"]
#[inline (always)] pub fn rfom0 (& self) -> Rfom0R { Rfom0R :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 3 - FULL0"]
#[inline (always)] pub fn full0 (& mut self) -> Full0W < '_ , CanRf0rSpec > { Full0W :: new (self , 3) }
#[doc = "Bit 4 - FOVR0"]
#[inline (always)] pub fn fovr0 (& mut self) -> Fovr0W < '_ , CanRf0rSpec > { Fovr0W :: new (self , 4) }
#[doc = "Bit 5 - RFOM0"]
#[inline (always)] pub fn rfom0 (& mut self) -> Rfom0W < '_ , CanRf0rSpec > { Rfom0W :: new (self , 5) } }
#[doc = "CAN_RF0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rf0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_rf0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRf0rSpec ; impl crate :: RegisterSpec for CanRf0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_rf0r::R`](R) reader structure"] impl crate :: Readable for CanRf0rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_rf0r::W`](W) writer structure"] impl crate :: Writable for CanRf0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_RF0R to value 0"] impl crate :: Resettable for CanRf0rSpec { } }
#[doc = "CAN_RF1R (rw) register accessor: CAN_RF1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rf1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_rf1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_rf1r`] module"]
#[doc (alias = "CAN_RF1R")] pub type CanRf1r = crate :: Reg < can_rf1r :: CanRf1rSpec > ;
#[doc = "CAN_RF1R"] pub mod can_rf1r {
#[doc = "Register `CAN_RF1R` reader"] pub type R = crate :: R < CanRf1rSpec > ;
#[doc = "Register `CAN_RF1R` writer"] pub type W = crate :: W < CanRf1rSpec > ;
#[doc = "Field `FMP1` reader - FMP1"] pub type Fmp1R = crate :: FieldReader ;
#[doc = "Field `FULL1` reader - FULL1"] pub type Full1R = crate :: BitReader ;
#[doc = "Field `FULL1` writer - FULL1"] pub type Full1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FOVR1` reader - FOVR1"] pub type Fovr1R = crate :: BitReader ;
#[doc = "Field `FOVR1` writer - FOVR1"] pub type Fovr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RFOM1` reader - RFOM1"] pub type Rfom1R = crate :: BitReader ;
#[doc = "Field `RFOM1` writer - RFOM1"] pub type Rfom1W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - FMP1"]
#[inline (always)] pub fn fmp1 (& self) -> Fmp1R { Fmp1R :: new ((self . bits & 3) as u8) }
#[doc = "Bit 3 - FULL1"]
#[inline (always)] pub fn full1 (& self) -> Full1R { Full1R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - FOVR1"]
#[inline (always)] pub fn fovr1 (& self) -> Fovr1R { Fovr1R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RFOM1"]
#[inline (always)] pub fn rfom1 (& self) -> Rfom1R { Rfom1R :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 3 - FULL1"]
#[inline (always)] pub fn full1 (& mut self) -> Full1W < '_ , CanRf1rSpec > { Full1W :: new (self , 3) }
#[doc = "Bit 4 - FOVR1"]
#[inline (always)] pub fn fovr1 (& mut self) -> Fovr1W < '_ , CanRf1rSpec > { Fovr1W :: new (self , 4) }
#[doc = "Bit 5 - RFOM1"]
#[inline (always)] pub fn rfom1 (& mut self) -> Rfom1W < '_ , CanRf1rSpec > { Rfom1W :: new (self , 5) } }
#[doc = "CAN_RF1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rf1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_rf1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRf1rSpec ; impl crate :: RegisterSpec for CanRf1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_rf1r::R`](R) reader structure"] impl crate :: Readable for CanRf1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_rf1r::W`](W) writer structure"] impl crate :: Writable for CanRf1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_RF1R to value 0"] impl crate :: Resettable for CanRf1rSpec { } }
#[doc = "CAN_IER (rw) register accessor: CAN_IER\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_ier`] module"]
#[doc (alias = "CAN_IER")] pub type CanIer = crate :: Reg < can_ier :: CanIerSpec > ;
#[doc = "CAN_IER"] pub mod can_ier {
#[doc = "Register `CAN_IER` reader"] pub type R = crate :: R < CanIerSpec > ;
#[doc = "Register `CAN_IER` writer"] pub type W = crate :: W < CanIerSpec > ;
#[doc = "Field `TMEIE` reader - TMEIE"] pub type TmeieR = crate :: BitReader ;
#[doc = "Field `TMEIE` writer - TMEIE"] pub type TmeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FMPIE0` reader - FMPIE0"] pub type Fmpie0R = crate :: BitReader ;
#[doc = "Field `FMPIE0` writer - FMPIE0"] pub type Fmpie0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFIE0` reader - FFIE0"] pub type Ffie0R = crate :: BitReader ;
#[doc = "Field `FFIE0` writer - FFIE0"] pub type Ffie0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FOVIE0` reader - FOVIE0"] pub type Fovie0R = crate :: BitReader ;
#[doc = "Field `FOVIE0` writer - FOVIE0"] pub type Fovie0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FMPIE1` reader - FMPIE1"] pub type Fmpie1R = crate :: BitReader ;
#[doc = "Field `FMPIE1` writer - FMPIE1"] pub type Fmpie1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFIE1` reader - FFIE1"] pub type Ffie1R = crate :: BitReader ;
#[doc = "Field `FFIE1` writer - FFIE1"] pub type Ffie1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FOVIE1` reader - FOVIE1"] pub type Fovie1R = crate :: BitReader ;
#[doc = "Field `FOVIE1` writer - FOVIE1"] pub type Fovie1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWGIE` reader - EWGIE"] pub type EwgieR = crate :: BitReader ;
#[doc = "Field `EWGIE` writer - EWGIE"] pub type EwgieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPVIE` reader - EPVIE"] pub type EpvieR = crate :: BitReader ;
#[doc = "Field `EPVIE` writer - EPVIE"] pub type EpvieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BOFIE` reader - BOFIE"] pub type BofieR = crate :: BitReader ;
#[doc = "Field `BOFIE` writer - BOFIE"] pub type BofieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LECIE` reader - LECIE"] pub type LecieR = crate :: BitReader ;
#[doc = "Field `LECIE` writer - LECIE"] pub type LecieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - ERRIE"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - ERRIE"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WKUIE` reader - WKUIE"] pub type WkuieR = crate :: BitReader ;
#[doc = "Field `WKUIE` writer - WKUIE"] pub type WkuieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLKIE` reader - SLKIE"] pub type SlkieR = crate :: BitReader ;
#[doc = "Field `SLKIE` writer - SLKIE"] pub type SlkieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - TMEIE"]
#[inline (always)] pub fn tmeie (& self) -> TmeieR { TmeieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - FMPIE0"]
#[inline (always)] pub fn fmpie0 (& self) -> Fmpie0R { Fmpie0R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - FFIE0"]
#[inline (always)] pub fn ffie0 (& self) -> Ffie0R { Ffie0R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - FOVIE0"]
#[inline (always)] pub fn fovie0 (& self) -> Fovie0R { Fovie0R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - FMPIE1"]
#[inline (always)] pub fn fmpie1 (& self) -> Fmpie1R { Fmpie1R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - FFIE1"]
#[inline (always)] pub fn ffie1 (& self) -> Ffie1R { Ffie1R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - FOVIE1"]
#[inline (always)] pub fn fovie1 (& self) -> Fovie1R { Fovie1R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - EWGIE"]
#[inline (always)] pub fn ewgie (& self) -> EwgieR { EwgieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - EPVIE"]
#[inline (always)] pub fn epvie (& self) -> EpvieR { EpvieR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - BOFIE"]
#[inline (always)] pub fn bofie (& self) -> BofieR { BofieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - LECIE"]
#[inline (always)] pub fn lecie (& self) -> LecieR { LecieR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 15 - ERRIE"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - WKUIE"]
#[inline (always)] pub fn wkuie (& self) -> WkuieR { WkuieR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - SLKIE"]
#[inline (always)] pub fn slkie (& self) -> SlkieR { SlkieR :: new (((self . bits >> 17) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TMEIE"]
#[inline (always)] pub fn tmeie (& mut self) -> TmeieW < '_ , CanIerSpec > { TmeieW :: new (self , 0) }
#[doc = "Bit 1 - FMPIE0"]
#[inline (always)] pub fn fmpie0 (& mut self) -> Fmpie0W < '_ , CanIerSpec > { Fmpie0W :: new (self , 1) }
#[doc = "Bit 2 - FFIE0"]
#[inline (always)] pub fn ffie0 (& mut self) -> Ffie0W < '_ , CanIerSpec > { Ffie0W :: new (self , 2) }
#[doc = "Bit 3 - FOVIE0"]
#[inline (always)] pub fn fovie0 (& mut self) -> Fovie0W < '_ , CanIerSpec > { Fovie0W :: new (self , 3) }
#[doc = "Bit 4 - FMPIE1"]
#[inline (always)] pub fn fmpie1 (& mut self) -> Fmpie1W < '_ , CanIerSpec > { Fmpie1W :: new (self , 4) }
#[doc = "Bit 5 - FFIE1"]
#[inline (always)] pub fn ffie1 (& mut self) -> Ffie1W < '_ , CanIerSpec > { Ffie1W :: new (self , 5) }
#[doc = "Bit 6 - FOVIE1"]
#[inline (always)] pub fn fovie1 (& mut self) -> Fovie1W < '_ , CanIerSpec > { Fovie1W :: new (self , 6) }
#[doc = "Bit 8 - EWGIE"]
#[inline (always)] pub fn ewgie (& mut self) -> EwgieW < '_ , CanIerSpec > { EwgieW :: new (self , 8) }
#[doc = "Bit 9 - EPVIE"]
#[inline (always)] pub fn epvie (& mut self) -> EpvieW < '_ , CanIerSpec > { EpvieW :: new (self , 9) }
#[doc = "Bit 10 - BOFIE"]
#[inline (always)] pub fn bofie (& mut self) -> BofieW < '_ , CanIerSpec > { BofieW :: new (self , 10) }
#[doc = "Bit 11 - LECIE"]
#[inline (always)] pub fn lecie (& mut self) -> LecieW < '_ , CanIerSpec > { LecieW :: new (self , 11) }
#[doc = "Bit 15 - ERRIE"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , CanIerSpec > { ErrieW :: new (self , 15) }
#[doc = "Bit 16 - WKUIE"]
#[inline (always)] pub fn wkuie (& mut self) -> WkuieW < '_ , CanIerSpec > { WkuieW :: new (self , 16) }
#[doc = "Bit 17 - SLKIE"]
#[inline (always)] pub fn slkie (& mut self) -> SlkieW < '_ , CanIerSpec > { SlkieW :: new (self , 17) } }
#[doc = "CAN_IER\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanIerSpec ; impl crate :: RegisterSpec for CanIerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_ier::R`](R) reader structure"] impl crate :: Readable for CanIerSpec { }
#[doc = "`write(|w| ..)` method takes [`can_ier::W`](W) writer structure"] impl crate :: Writable for CanIerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_IER to value 0"] impl crate :: Resettable for CanIerSpec { } }
#[doc = "CAN_ESR (rw) register accessor: CAN_ESR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_esr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_esr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_esr`] module"]
#[doc (alias = "CAN_ESR")] pub type CanEsr = crate :: Reg < can_esr :: CanEsrSpec > ;
#[doc = "CAN_ESR"] pub mod can_esr {
#[doc = "Register `CAN_ESR` reader"] pub type R = crate :: R < CanEsrSpec > ;
#[doc = "Register `CAN_ESR` writer"] pub type W = crate :: W < CanEsrSpec > ;
#[doc = "Field `EWGF` reader - EWGF"] pub type EwgfR = crate :: BitReader ;
#[doc = "Field `EPVF` reader - EPVF"] pub type EpvfR = crate :: BitReader ;
#[doc = "Field `BOFF` reader - BOFF"] pub type BoffR = crate :: BitReader ;
#[doc = "Field `LEC` reader - LEC"] pub type LecR = crate :: FieldReader ;
#[doc = "Field `LEC` writer - LEC"] pub type LecW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TEC` reader - TEC"] pub type TecR = crate :: FieldReader ;
#[doc = "Field `REC` reader - REC"] pub type RecR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - EWGF"]
#[inline (always)] pub fn ewgf (& self) -> EwgfR { EwgfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPVF"]
#[inline (always)] pub fn epvf (& self) -> EpvfR { EpvfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - BOFF"]
#[inline (always)] pub fn boff (& self) -> BoffR { BoffR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 4:6 - LEC"]
#[inline (always)] pub fn lec (& self) -> LecR { LecR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 16:23 - TEC"]
#[inline (always)] pub fn tec (& self) -> TecR { TecR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - REC"]
#[inline (always)] pub fn rec (& self) -> RecR { RecR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 4:6 - LEC"]
#[inline (always)] pub fn lec (& mut self) -> LecW < '_ , CanEsrSpec > { LecW :: new (self , 4) } }
#[doc = "CAN_ESR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_esr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_esr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanEsrSpec ; impl crate :: RegisterSpec for CanEsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_esr::R`](R) reader structure"] impl crate :: Readable for CanEsrSpec { }
#[doc = "`write(|w| ..)` method takes [`can_esr::W`](W) writer structure"] impl crate :: Writable for CanEsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_ESR to value 0"] impl crate :: Resettable for CanEsrSpec { } }
#[doc = "CAN_BTR (rw) register accessor: CAN_BTR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_btr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_btr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_btr`] module"]
#[doc (alias = "CAN_BTR")] pub type CanBtr = crate :: Reg < can_btr :: CanBtrSpec > ;
#[doc = "CAN_BTR"] pub mod can_btr {
#[doc = "Register `CAN_BTR` reader"] pub type R = crate :: R < CanBtrSpec > ;
#[doc = "Register `CAN_BTR` writer"] pub type W = crate :: W < CanBtrSpec > ;
#[doc = "Field `BRP` reader - BRP"] pub type BrpR = crate :: FieldReader < u16 > ;
#[doc = "Field `BRP` writer - BRP"] pub type BrpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `TS1` reader - TS1"] pub type Ts1R = crate :: FieldReader ;
#[doc = "Field `TS1` writer - TS1"] pub type Ts1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TS2` reader - TS2"] pub type Ts2R = crate :: FieldReader ;
#[doc = "Field `TS2` writer - TS2"] pub type Ts2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SJW` reader - SJW"] pub type SjwR = crate :: FieldReader ;
#[doc = "Field `SJW` writer - SJW"] pub type SjwW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LBKM` reader - LBKM"] pub type LbkmR = crate :: BitReader ;
#[doc = "Field `LBKM` writer - LBKM"] pub type LbkmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SILM` reader - SILM"] pub type SilmR = crate :: BitReader ;
#[doc = "Field `SILM` writer - SILM"] pub type SilmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - BRP"]
#[inline (always)] pub fn brp (& self) -> BrpR { BrpR :: new ((self . bits & 0x03ff) as u16) }
#[doc = "Bits 16:19 - TS1"]
#[inline (always)] pub fn ts1 (& self) -> Ts1R { Ts1R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:22 - TS2"]
#[inline (always)] pub fn ts2 (& self) -> Ts2R { Ts2R :: new (((self . bits >> 20) & 7) as u8) }
#[doc = "Bits 24:25 - SJW"]
#[inline (always)] pub fn sjw (& self) -> SjwR { SjwR :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bit 30 - LBKM"]
#[inline (always)] pub fn lbkm (& self) -> LbkmR { LbkmR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - SILM"]
#[inline (always)] pub fn silm (& self) -> SilmR { SilmR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:9 - BRP"]
#[inline (always)] pub fn brp (& mut self) -> BrpW < '_ , CanBtrSpec > { BrpW :: new (self , 0) }
#[doc = "Bits 16:19 - TS1"]
#[inline (always)] pub fn ts1 (& mut self) -> Ts1W < '_ , CanBtrSpec > { Ts1W :: new (self , 16) }
#[doc = "Bits 20:22 - TS2"]
#[inline (always)] pub fn ts2 (& mut self) -> Ts2W < '_ , CanBtrSpec > { Ts2W :: new (self , 20) }
#[doc = "Bits 24:25 - SJW"]
#[inline (always)] pub fn sjw (& mut self) -> SjwW < '_ , CanBtrSpec > { SjwW :: new (self , 24) }
#[doc = "Bit 30 - LBKM"]
#[inline (always)] pub fn lbkm (& mut self) -> LbkmW < '_ , CanBtrSpec > { LbkmW :: new (self , 30) }
#[doc = "Bit 31 - SILM"]
#[inline (always)] pub fn silm (& mut self) -> SilmW < '_ , CanBtrSpec > { SilmW :: new (self , 31) } }
#[doc = "CAN_BTR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_btr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_btr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanBtrSpec ; impl crate :: RegisterSpec for CanBtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_btr::R`](R) reader structure"] impl crate :: Readable for CanBtrSpec { }
#[doc = "`write(|w| ..)` method takes [`can_btr::W`](W) writer structure"] impl crate :: Writable for CanBtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_BTR to value 0"] impl crate :: Resettable for CanBtrSpec { } }
#[doc = "CAN_TI0R (rw) register accessor: CAN_TI0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ti0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ti0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_ti0r`] module"]
#[doc (alias = "CAN_TI0R")] pub type CanTi0r = crate :: Reg < can_ti0r :: CanTi0rSpec > ;
#[doc = "CAN_TI0R"] pub mod can_ti0r {
#[doc = "Register `CAN_TI0R` reader"] pub type R = crate :: R < CanTi0rSpec > ;
#[doc = "Register `CAN_TI0R` writer"] pub type W = crate :: W < CanTi0rSpec > ;
#[doc = "Field `TXRQ` reader - TXRQ"] pub type TxrqR = crate :: BitReader ;
#[doc = "Field `TXRQ` writer - TXRQ"] pub type TxrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTR` reader - RTR"] pub type RtrR = crate :: BitReader ;
#[doc = "Field `RTR` writer - RTR"] pub type RtrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDE` reader - IDE"] pub type IdeR = crate :: BitReader ;
#[doc = "Field `IDE` writer - IDE"] pub type IdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXID` reader - EXID"] pub type ExidR = crate :: FieldReader < u32 > ;
#[doc = "Field `EXID` writer - EXID"] pub type ExidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 18 , u32 > ;
#[doc = "Field `STID` reader - STID"] pub type StidR = crate :: FieldReader < u16 > ;
#[doc = "Field `STID` writer - STID"] pub type StidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl R {
#[doc = "Bit 0 - TXRQ"]
#[inline (always)] pub fn txrq (& self) -> TxrqR { TxrqR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RTR"]
#[inline (always)] pub fn rtr (& self) -> RtrR { RtrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IDE"]
#[inline (always)] pub fn ide (& self) -> IdeR { IdeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:20 - EXID"]
#[inline (always)] pub fn exid (& self) -> ExidR { ExidR :: new ((self . bits >> 3) & 0x0003_ffff) }
#[doc = "Bits 21:31 - STID"]
#[inline (always)] pub fn stid (& self) -> StidR { StidR :: new (((self . bits >> 21) & 0x07ff) as u16) } } impl W {
#[doc = "Bit 0 - TXRQ"]
#[inline (always)] pub fn txrq (& mut self) -> TxrqW < '_ , CanTi0rSpec > { TxrqW :: new (self , 0) }
#[doc = "Bit 1 - RTR"]
#[inline (always)] pub fn rtr (& mut self) -> RtrW < '_ , CanTi0rSpec > { RtrW :: new (self , 1) }
#[doc = "Bit 2 - IDE"]
#[inline (always)] pub fn ide (& mut self) -> IdeW < '_ , CanTi0rSpec > { IdeW :: new (self , 2) }
#[doc = "Bits 3:20 - EXID"]
#[inline (always)] pub fn exid (& mut self) -> ExidW < '_ , CanTi0rSpec > { ExidW :: new (self , 3) }
#[doc = "Bits 21:31 - STID"]
#[inline (always)] pub fn stid (& mut self) -> StidW < '_ , CanTi0rSpec > { StidW :: new (self , 21) } }
#[doc = "CAN_TI0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ti0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ti0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTi0rSpec ; impl crate :: RegisterSpec for CanTi0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_ti0r::R`](R) reader structure"] impl crate :: Readable for CanTi0rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_ti0r::W`](W) writer structure"] impl crate :: Writable for CanTi0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TI0R to value 0"] impl crate :: Resettable for CanTi0rSpec { } }
#[doc = "CAN_TDT0R (rw) register accessor: CAN_TDT0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdt0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdt0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdt0r`] module"]
#[doc (alias = "CAN_TDT0R")] pub type CanTdt0r = crate :: Reg < can_tdt0r :: CanTdt0rSpec > ;
#[doc = "CAN_TDT0R"] pub mod can_tdt0r {
#[doc = "Register `CAN_TDT0R` reader"] pub type R = crate :: R < CanTdt0rSpec > ;
#[doc = "Register `CAN_TDT0R` writer"] pub type W = crate :: W < CanTdt0rSpec > ;
#[doc = "Field `DLC` reader - DLC"] pub type DlcR = crate :: FieldReader ;
#[doc = "Field `DLC` writer - DLC"] pub type DlcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TGT` reader - TGT"] pub type TgtR = crate :: BitReader ;
#[doc = "Field `TGT` writer - TGT"] pub type TgtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIME` reader - TIME"] pub type TimeR = crate :: FieldReader < u16 > ;
#[doc = "Field `TIME` writer - TIME"] pub type TimeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:3 - DLC"]
#[inline (always)] pub fn dlc (& self) -> DlcR { DlcR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 8 - TGT"]
#[inline (always)] pub fn tgt (& self) -> TgtR { TgtR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 16:31 - TIME"]
#[inline (always)] pub fn time (& self) -> TimeR { TimeR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:3 - DLC"]
#[inline (always)] pub fn dlc (& mut self) -> DlcW < '_ , CanTdt0rSpec > { DlcW :: new (self , 0) }
#[doc = "Bit 8 - TGT"]
#[inline (always)] pub fn tgt (& mut self) -> TgtW < '_ , CanTdt0rSpec > { TgtW :: new (self , 8) }
#[doc = "Bits 16:31 - TIME"]
#[inline (always)] pub fn time (& mut self) -> TimeW < '_ , CanTdt0rSpec > { TimeW :: new (self , 16) } }
#[doc = "CAN_TDT0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdt0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdt0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdt0rSpec ; impl crate :: RegisterSpec for CanTdt0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdt0r::R`](R) reader structure"] impl crate :: Readable for CanTdt0rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdt0r::W`](W) writer structure"] impl crate :: Writable for CanTdt0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDT0R to value 0"] impl crate :: Resettable for CanTdt0rSpec { } }
#[doc = "CAN_TDL0R (rw) register accessor: CAN_TDL0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdl0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdl0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdl0r`] module"]
#[doc (alias = "CAN_TDL0R")] pub type CanTdl0r = crate :: Reg < can_tdl0r :: CanTdl0rSpec > ;
#[doc = "CAN_TDL0R"] pub mod can_tdl0r {
#[doc = "Register `CAN_TDL0R` reader"] pub type R = crate :: R < CanTdl0rSpec > ;
#[doc = "Register `CAN_TDL0R` writer"] pub type W = crate :: W < CanTdl0rSpec > ;
#[doc = "Field `DATA0` reader - DATA0"] pub type Data0R = crate :: FieldReader ;
#[doc = "Field `DATA0` writer - DATA0"] pub type Data0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA1` reader - DATA1"] pub type Data1R = crate :: FieldReader ;
#[doc = "Field `DATA1` writer - DATA1"] pub type Data1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA2` reader - DATA2"] pub type Data2R = crate :: FieldReader ;
#[doc = "Field `DATA2` writer - DATA2"] pub type Data2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA3` reader - DATA3"] pub type Data3R = crate :: FieldReader ;
#[doc = "Field `DATA3` writer - DATA3"] pub type Data3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DATA0"]
#[inline (always)] pub fn data0 (& self) -> Data0R { Data0R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA1"]
#[inline (always)] pub fn data1 (& self) -> Data1R { Data1R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA2"]
#[inline (always)] pub fn data2 (& self) -> Data2R { Data2R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA3"]
#[inline (always)] pub fn data3 (& self) -> Data3R { Data3R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DATA0"]
#[inline (always)] pub fn data0 (& mut self) -> Data0W < '_ , CanTdl0rSpec > { Data0W :: new (self , 0) }
#[doc = "Bits 8:15 - DATA1"]
#[inline (always)] pub fn data1 (& mut self) -> Data1W < '_ , CanTdl0rSpec > { Data1W :: new (self , 8) }
#[doc = "Bits 16:23 - DATA2"]
#[inline (always)] pub fn data2 (& mut self) -> Data2W < '_ , CanTdl0rSpec > { Data2W :: new (self , 16) }
#[doc = "Bits 24:31 - DATA3"]
#[inline (always)] pub fn data3 (& mut self) -> Data3W < '_ , CanTdl0rSpec > { Data3W :: new (self , 24) } }
#[doc = "CAN_TDL0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdl0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdl0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdl0rSpec ; impl crate :: RegisterSpec for CanTdl0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdl0r::R`](R) reader structure"] impl crate :: Readable for CanTdl0rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdl0r::W`](W) writer structure"] impl crate :: Writable for CanTdl0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDL0R to value 0"] impl crate :: Resettable for CanTdl0rSpec { } }
#[doc = "CAN_TDH0R (rw) register accessor: CAN_TDH0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdh0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdh0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdh0r`] module"]
#[doc (alias = "CAN_TDH0R")] pub type CanTdh0r = crate :: Reg < can_tdh0r :: CanTdh0rSpec > ;
#[doc = "CAN_TDH0R"] pub mod can_tdh0r {
#[doc = "Register `CAN_TDH0R` reader"] pub type R = crate :: R < CanTdh0rSpec > ;
#[doc = "Register `CAN_TDH0R` writer"] pub type W = crate :: W < CanTdh0rSpec > ;
#[doc = "Field `DATA4` reader - DATA4"] pub type Data4R = crate :: FieldReader ;
#[doc = "Field `DATA4` writer - DATA4"] pub type Data4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA5` reader - DATA5"] pub type Data5R = crate :: FieldReader ;
#[doc = "Field `DATA5` writer - DATA5"] pub type Data5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA6` reader - DATA6"] pub type Data6R = crate :: FieldReader ;
#[doc = "Field `DATA6` writer - DATA6"] pub type Data6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA7` reader - DATA7"] pub type Data7R = crate :: FieldReader ;
#[doc = "Field `DATA7` writer - DATA7"] pub type Data7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DATA4"]
#[inline (always)] pub fn data4 (& self) -> Data4R { Data4R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA5"]
#[inline (always)] pub fn data5 (& self) -> Data5R { Data5R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA6"]
#[inline (always)] pub fn data6 (& self) -> Data6R { Data6R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA7"]
#[inline (always)] pub fn data7 (& self) -> Data7R { Data7R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DATA4"]
#[inline (always)] pub fn data4 (& mut self) -> Data4W < '_ , CanTdh0rSpec > { Data4W :: new (self , 0) }
#[doc = "Bits 8:15 - DATA5"]
#[inline (always)] pub fn data5 (& mut self) -> Data5W < '_ , CanTdh0rSpec > { Data5W :: new (self , 8) }
#[doc = "Bits 16:23 - DATA6"]
#[inline (always)] pub fn data6 (& mut self) -> Data6W < '_ , CanTdh0rSpec > { Data6W :: new (self , 16) }
#[doc = "Bits 24:31 - DATA7"]
#[inline (always)] pub fn data7 (& mut self) -> Data7W < '_ , CanTdh0rSpec > { Data7W :: new (self , 24) } }
#[doc = "CAN_TDH0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdh0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdh0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdh0rSpec ; impl crate :: RegisterSpec for CanTdh0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdh0r::R`](R) reader structure"] impl crate :: Readable for CanTdh0rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdh0r::W`](W) writer structure"] impl crate :: Writable for CanTdh0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDH0R to value 0"] impl crate :: Resettable for CanTdh0rSpec { } }
#[doc = "CAN_TI1R (rw) register accessor: CAN_TI1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ti1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ti1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_ti1r`] module"]
#[doc (alias = "CAN_TI1R")] pub type CanTi1r = crate :: Reg < can_ti1r :: CanTi1rSpec > ;
#[doc = "CAN_TI1R"] pub mod can_ti1r {
#[doc = "Register `CAN_TI1R` reader"] pub type R = crate :: R < CanTi1rSpec > ;
#[doc = "Register `CAN_TI1R` writer"] pub type W = crate :: W < CanTi1rSpec > ;
#[doc = "Field `TXRQ` reader - TXRQ"] pub type TxrqR = crate :: BitReader ;
#[doc = "Field `TXRQ` writer - TXRQ"] pub type TxrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTR` reader - RTR"] pub type RtrR = crate :: BitReader ;
#[doc = "Field `RTR` writer - RTR"] pub type RtrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDE` reader - IDE"] pub type IdeR = crate :: BitReader ;
#[doc = "Field `IDE` writer - IDE"] pub type IdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXID` reader - EXID"] pub type ExidR = crate :: FieldReader < u32 > ;
#[doc = "Field `EXID` writer - EXID"] pub type ExidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 18 , u32 > ;
#[doc = "Field `STID` reader - STID"] pub type StidR = crate :: FieldReader < u16 > ;
#[doc = "Field `STID` writer - STID"] pub type StidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl R {
#[doc = "Bit 0 - TXRQ"]
#[inline (always)] pub fn txrq (& self) -> TxrqR { TxrqR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RTR"]
#[inline (always)] pub fn rtr (& self) -> RtrR { RtrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IDE"]
#[inline (always)] pub fn ide (& self) -> IdeR { IdeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:20 - EXID"]
#[inline (always)] pub fn exid (& self) -> ExidR { ExidR :: new ((self . bits >> 3) & 0x0003_ffff) }
#[doc = "Bits 21:31 - STID"]
#[inline (always)] pub fn stid (& self) -> StidR { StidR :: new (((self . bits >> 21) & 0x07ff) as u16) } } impl W {
#[doc = "Bit 0 - TXRQ"]
#[inline (always)] pub fn txrq (& mut self) -> TxrqW < '_ , CanTi1rSpec > { TxrqW :: new (self , 0) }
#[doc = "Bit 1 - RTR"]
#[inline (always)] pub fn rtr (& mut self) -> RtrW < '_ , CanTi1rSpec > { RtrW :: new (self , 1) }
#[doc = "Bit 2 - IDE"]
#[inline (always)] pub fn ide (& mut self) -> IdeW < '_ , CanTi1rSpec > { IdeW :: new (self , 2) }
#[doc = "Bits 3:20 - EXID"]
#[inline (always)] pub fn exid (& mut self) -> ExidW < '_ , CanTi1rSpec > { ExidW :: new (self , 3) }
#[doc = "Bits 21:31 - STID"]
#[inline (always)] pub fn stid (& mut self) -> StidW < '_ , CanTi1rSpec > { StidW :: new (self , 21) } }
#[doc = "CAN_TI1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ti1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ti1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTi1rSpec ; impl crate :: RegisterSpec for CanTi1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_ti1r::R`](R) reader structure"] impl crate :: Readable for CanTi1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_ti1r::W`](W) writer structure"] impl crate :: Writable for CanTi1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TI1R to value 0"] impl crate :: Resettable for CanTi1rSpec { } }
#[doc = "CAN_TDT1R (rw) register accessor: CAN_TDT1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdt1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdt1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdt1r`] module"]
#[doc (alias = "CAN_TDT1R")] pub type CanTdt1r = crate :: Reg < can_tdt1r :: CanTdt1rSpec > ;
#[doc = "CAN_TDT1R"] pub mod can_tdt1r {
#[doc = "Register `CAN_TDT1R` reader"] pub type R = crate :: R < CanTdt1rSpec > ;
#[doc = "Register `CAN_TDT1R` writer"] pub type W = crate :: W < CanTdt1rSpec > ;
#[doc = "Field `DLC` reader - DLC"] pub type DlcR = crate :: FieldReader ;
#[doc = "Field `DLC` writer - DLC"] pub type DlcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TGT` reader - TGT"] pub type TgtR = crate :: BitReader ;
#[doc = "Field `TGT` writer - TGT"] pub type TgtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIME` reader - TIME"] pub type TimeR = crate :: FieldReader < u16 > ;
#[doc = "Field `TIME` writer - TIME"] pub type TimeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:3 - DLC"]
#[inline (always)] pub fn dlc (& self) -> DlcR { DlcR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 8 - TGT"]
#[inline (always)] pub fn tgt (& self) -> TgtR { TgtR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 16:31 - TIME"]
#[inline (always)] pub fn time (& self) -> TimeR { TimeR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:3 - DLC"]
#[inline (always)] pub fn dlc (& mut self) -> DlcW < '_ , CanTdt1rSpec > { DlcW :: new (self , 0) }
#[doc = "Bit 8 - TGT"]
#[inline (always)] pub fn tgt (& mut self) -> TgtW < '_ , CanTdt1rSpec > { TgtW :: new (self , 8) }
#[doc = "Bits 16:31 - TIME"]
#[inline (always)] pub fn time (& mut self) -> TimeW < '_ , CanTdt1rSpec > { TimeW :: new (self , 16) } }
#[doc = "CAN_TDT1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdt1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdt1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdt1rSpec ; impl crate :: RegisterSpec for CanTdt1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdt1r::R`](R) reader structure"] impl crate :: Readable for CanTdt1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdt1r::W`](W) writer structure"] impl crate :: Writable for CanTdt1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDT1R to value 0"] impl crate :: Resettable for CanTdt1rSpec { } }
#[doc = "CAN_TDL1R (rw) register accessor: CAN_TDL1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdl1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdl1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdl1r`] module"]
#[doc (alias = "CAN_TDL1R")] pub type CanTdl1r = crate :: Reg < can_tdl1r :: CanTdl1rSpec > ;
#[doc = "CAN_TDL1R"] pub mod can_tdl1r {
#[doc = "Register `CAN_TDL1R` reader"] pub type R = crate :: R < CanTdl1rSpec > ;
#[doc = "Register `CAN_TDL1R` writer"] pub type W = crate :: W < CanTdl1rSpec > ;
#[doc = "Field `DATA0` reader - DATA0"] pub type Data0R = crate :: FieldReader ;
#[doc = "Field `DATA0` writer - DATA0"] pub type Data0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA1` reader - DATA1"] pub type Data1R = crate :: FieldReader ;
#[doc = "Field `DATA1` writer - DATA1"] pub type Data1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA2` reader - DATA2"] pub type Data2R = crate :: FieldReader ;
#[doc = "Field `DATA2` writer - DATA2"] pub type Data2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA3` reader - DATA3"] pub type Data3R = crate :: FieldReader ;
#[doc = "Field `DATA3` writer - DATA3"] pub type Data3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DATA0"]
#[inline (always)] pub fn data0 (& self) -> Data0R { Data0R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA1"]
#[inline (always)] pub fn data1 (& self) -> Data1R { Data1R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA2"]
#[inline (always)] pub fn data2 (& self) -> Data2R { Data2R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA3"]
#[inline (always)] pub fn data3 (& self) -> Data3R { Data3R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DATA0"]
#[inline (always)] pub fn data0 (& mut self) -> Data0W < '_ , CanTdl1rSpec > { Data0W :: new (self , 0) }
#[doc = "Bits 8:15 - DATA1"]
#[inline (always)] pub fn data1 (& mut self) -> Data1W < '_ , CanTdl1rSpec > { Data1W :: new (self , 8) }
#[doc = "Bits 16:23 - DATA2"]
#[inline (always)] pub fn data2 (& mut self) -> Data2W < '_ , CanTdl1rSpec > { Data2W :: new (self , 16) }
#[doc = "Bits 24:31 - DATA3"]
#[inline (always)] pub fn data3 (& mut self) -> Data3W < '_ , CanTdl1rSpec > { Data3W :: new (self , 24) } }
#[doc = "CAN_TDL1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdl1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdl1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdl1rSpec ; impl crate :: RegisterSpec for CanTdl1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdl1r::R`](R) reader structure"] impl crate :: Readable for CanTdl1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdl1r::W`](W) writer structure"] impl crate :: Writable for CanTdl1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDL1R to value 0"] impl crate :: Resettable for CanTdl1rSpec { } }
#[doc = "CAN_TDH1R (rw) register accessor: CAN_TDH1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdh1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdh1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdh1r`] module"]
#[doc (alias = "CAN_TDH1R")] pub type CanTdh1r = crate :: Reg < can_tdh1r :: CanTdh1rSpec > ;
#[doc = "CAN_TDH1R"] pub mod can_tdh1r {
#[doc = "Register `CAN_TDH1R` reader"] pub type R = crate :: R < CanTdh1rSpec > ;
#[doc = "Register `CAN_TDH1R` writer"] pub type W = crate :: W < CanTdh1rSpec > ;
#[doc = "Field `DATA4` reader - DATA4"] pub type Data4R = crate :: FieldReader ;
#[doc = "Field `DATA4` writer - DATA4"] pub type Data4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA5` reader - DATA5"] pub type Data5R = crate :: FieldReader ;
#[doc = "Field `DATA5` writer - DATA5"] pub type Data5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA6` reader - DATA6"] pub type Data6R = crate :: FieldReader ;
#[doc = "Field `DATA6` writer - DATA6"] pub type Data6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA7` reader - DATA7"] pub type Data7R = crate :: FieldReader ;
#[doc = "Field `DATA7` writer - DATA7"] pub type Data7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DATA4"]
#[inline (always)] pub fn data4 (& self) -> Data4R { Data4R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA5"]
#[inline (always)] pub fn data5 (& self) -> Data5R { Data5R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA6"]
#[inline (always)] pub fn data6 (& self) -> Data6R { Data6R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA7"]
#[inline (always)] pub fn data7 (& self) -> Data7R { Data7R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DATA4"]
#[inline (always)] pub fn data4 (& mut self) -> Data4W < '_ , CanTdh1rSpec > { Data4W :: new (self , 0) }
#[doc = "Bits 8:15 - DATA5"]
#[inline (always)] pub fn data5 (& mut self) -> Data5W < '_ , CanTdh1rSpec > { Data5W :: new (self , 8) }
#[doc = "Bits 16:23 - DATA6"]
#[inline (always)] pub fn data6 (& mut self) -> Data6W < '_ , CanTdh1rSpec > { Data6W :: new (self , 16) }
#[doc = "Bits 24:31 - DATA7"]
#[inline (always)] pub fn data7 (& mut self) -> Data7W < '_ , CanTdh1rSpec > { Data7W :: new (self , 24) } }
#[doc = "CAN_TDH1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdh1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdh1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdh1rSpec ; impl crate :: RegisterSpec for CanTdh1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdh1r::R`](R) reader structure"] impl crate :: Readable for CanTdh1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdh1r::W`](W) writer structure"] impl crate :: Writable for CanTdh1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDH1R to value 0"] impl crate :: Resettable for CanTdh1rSpec { } }
#[doc = "CAN_TI2R (rw) register accessor: CAN_TI2R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ti2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ti2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_ti2r`] module"]
#[doc (alias = "CAN_TI2R")] pub type CanTi2r = crate :: Reg < can_ti2r :: CanTi2rSpec > ;
#[doc = "CAN_TI2R"] pub mod can_ti2r {
#[doc = "Register `CAN_TI2R` reader"] pub type R = crate :: R < CanTi2rSpec > ;
#[doc = "Register `CAN_TI2R` writer"] pub type W = crate :: W < CanTi2rSpec > ;
#[doc = "Field `TXRQ` reader - TXRQ"] pub type TxrqR = crate :: BitReader ;
#[doc = "Field `TXRQ` writer - TXRQ"] pub type TxrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTR` reader - RTR"] pub type RtrR = crate :: BitReader ;
#[doc = "Field `RTR` writer - RTR"] pub type RtrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDE` reader - IDE"] pub type IdeR = crate :: BitReader ;
#[doc = "Field `IDE` writer - IDE"] pub type IdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EXID` reader - EXID"] pub type ExidR = crate :: FieldReader < u32 > ;
#[doc = "Field `EXID` writer - EXID"] pub type ExidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 18 , u32 > ;
#[doc = "Field `STID` reader - STID"] pub type StidR = crate :: FieldReader < u16 > ;
#[doc = "Field `STID` writer - STID"] pub type StidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl R {
#[doc = "Bit 0 - TXRQ"]
#[inline (always)] pub fn txrq (& self) -> TxrqR { TxrqR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RTR"]
#[inline (always)] pub fn rtr (& self) -> RtrR { RtrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IDE"]
#[inline (always)] pub fn ide (& self) -> IdeR { IdeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:20 - EXID"]
#[inline (always)] pub fn exid (& self) -> ExidR { ExidR :: new ((self . bits >> 3) & 0x0003_ffff) }
#[doc = "Bits 21:31 - STID"]
#[inline (always)] pub fn stid (& self) -> StidR { StidR :: new (((self . bits >> 21) & 0x07ff) as u16) } } impl W {
#[doc = "Bit 0 - TXRQ"]
#[inline (always)] pub fn txrq (& mut self) -> TxrqW < '_ , CanTi2rSpec > { TxrqW :: new (self , 0) }
#[doc = "Bit 1 - RTR"]
#[inline (always)] pub fn rtr (& mut self) -> RtrW < '_ , CanTi2rSpec > { RtrW :: new (self , 1) }
#[doc = "Bit 2 - IDE"]
#[inline (always)] pub fn ide (& mut self) -> IdeW < '_ , CanTi2rSpec > { IdeW :: new (self , 2) }
#[doc = "Bits 3:20 - EXID"]
#[inline (always)] pub fn exid (& mut self) -> ExidW < '_ , CanTi2rSpec > { ExidW :: new (self , 3) }
#[doc = "Bits 21:31 - STID"]
#[inline (always)] pub fn stid (& mut self) -> StidW < '_ , CanTi2rSpec > { StidW :: new (self , 21) } }
#[doc = "CAN_TI2R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ti2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ti2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTi2rSpec ; impl crate :: RegisterSpec for CanTi2rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_ti2r::R`](R) reader structure"] impl crate :: Readable for CanTi2rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_ti2r::W`](W) writer structure"] impl crate :: Writable for CanTi2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TI2R to value 0"] impl crate :: Resettable for CanTi2rSpec { } }
#[doc = "CAN_TDT2R (rw) register accessor: CAN_TDT2R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdt2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdt2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdt2r`] module"]
#[doc (alias = "CAN_TDT2R")] pub type CanTdt2r = crate :: Reg < can_tdt2r :: CanTdt2rSpec > ;
#[doc = "CAN_TDT2R"] pub mod can_tdt2r {
#[doc = "Register `CAN_TDT2R` reader"] pub type R = crate :: R < CanTdt2rSpec > ;
#[doc = "Register `CAN_TDT2R` writer"] pub type W = crate :: W < CanTdt2rSpec > ;
#[doc = "Field `DLC` reader - DLC"] pub type DlcR = crate :: FieldReader ;
#[doc = "Field `DLC` writer - DLC"] pub type DlcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `TGT` reader - TGT"] pub type TgtR = crate :: BitReader ;
#[doc = "Field `TGT` writer - TGT"] pub type TgtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIME` reader - TIME"] pub type TimeR = crate :: FieldReader < u16 > ;
#[doc = "Field `TIME` writer - TIME"] pub type TimeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:3 - DLC"]
#[inline (always)] pub fn dlc (& self) -> DlcR { DlcR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 8 - TGT"]
#[inline (always)] pub fn tgt (& self) -> TgtR { TgtR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 16:31 - TIME"]
#[inline (always)] pub fn time (& self) -> TimeR { TimeR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:3 - DLC"]
#[inline (always)] pub fn dlc (& mut self) -> DlcW < '_ , CanTdt2rSpec > { DlcW :: new (self , 0) }
#[doc = "Bit 8 - TGT"]
#[inline (always)] pub fn tgt (& mut self) -> TgtW < '_ , CanTdt2rSpec > { TgtW :: new (self , 8) }
#[doc = "Bits 16:31 - TIME"]
#[inline (always)] pub fn time (& mut self) -> TimeW < '_ , CanTdt2rSpec > { TimeW :: new (self , 16) } }
#[doc = "CAN_TDT2R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdt2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdt2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdt2rSpec ; impl crate :: RegisterSpec for CanTdt2rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdt2r::R`](R) reader structure"] impl crate :: Readable for CanTdt2rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdt2r::W`](W) writer structure"] impl crate :: Writable for CanTdt2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDT2R to value 0"] impl crate :: Resettable for CanTdt2rSpec { } }
#[doc = "CAN_TDL2R (rw) register accessor: CAN_TDL2R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdl2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdl2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdl2r`] module"]
#[doc (alias = "CAN_TDL2R")] pub type CanTdl2r = crate :: Reg < can_tdl2r :: CanTdl2rSpec > ;
#[doc = "CAN_TDL2R"] pub mod can_tdl2r {
#[doc = "Register `CAN_TDL2R` reader"] pub type R = crate :: R < CanTdl2rSpec > ;
#[doc = "Register `CAN_TDL2R` writer"] pub type W = crate :: W < CanTdl2rSpec > ;
#[doc = "Field `DATA0` reader - DATA0"] pub type Data0R = crate :: FieldReader ;
#[doc = "Field `DATA0` writer - DATA0"] pub type Data0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA1` reader - DATA1"] pub type Data1R = crate :: FieldReader ;
#[doc = "Field `DATA1` writer - DATA1"] pub type Data1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA2` reader - DATA2"] pub type Data2R = crate :: FieldReader ;
#[doc = "Field `DATA2` writer - DATA2"] pub type Data2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA3` reader - DATA3"] pub type Data3R = crate :: FieldReader ;
#[doc = "Field `DATA3` writer - DATA3"] pub type Data3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DATA0"]
#[inline (always)] pub fn data0 (& self) -> Data0R { Data0R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA1"]
#[inline (always)] pub fn data1 (& self) -> Data1R { Data1R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA2"]
#[inline (always)] pub fn data2 (& self) -> Data2R { Data2R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA3"]
#[inline (always)] pub fn data3 (& self) -> Data3R { Data3R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DATA0"]
#[inline (always)] pub fn data0 (& mut self) -> Data0W < '_ , CanTdl2rSpec > { Data0W :: new (self , 0) }
#[doc = "Bits 8:15 - DATA1"]
#[inline (always)] pub fn data1 (& mut self) -> Data1W < '_ , CanTdl2rSpec > { Data1W :: new (self , 8) }
#[doc = "Bits 16:23 - DATA2"]
#[inline (always)] pub fn data2 (& mut self) -> Data2W < '_ , CanTdl2rSpec > { Data2W :: new (self , 16) }
#[doc = "Bits 24:31 - DATA3"]
#[inline (always)] pub fn data3 (& mut self) -> Data3W < '_ , CanTdl2rSpec > { Data3W :: new (self , 24) } }
#[doc = "CAN_TDL2R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdl2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdl2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdl2rSpec ; impl crate :: RegisterSpec for CanTdl2rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdl2r::R`](R) reader structure"] impl crate :: Readable for CanTdl2rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdl2r::W`](W) writer structure"] impl crate :: Writable for CanTdl2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDL2R to value 0"] impl crate :: Resettable for CanTdl2rSpec { } }
#[doc = "CAN_TDH2R (rw) register accessor: CAN_TDH2R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdh2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdh2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_tdh2r`] module"]
#[doc (alias = "CAN_TDH2R")] pub type CanTdh2r = crate :: Reg < can_tdh2r :: CanTdh2rSpec > ;
#[doc = "CAN_TDH2R"] pub mod can_tdh2r {
#[doc = "Register `CAN_TDH2R` reader"] pub type R = crate :: R < CanTdh2rSpec > ;
#[doc = "Register `CAN_TDH2R` writer"] pub type W = crate :: W < CanTdh2rSpec > ;
#[doc = "Field `DATA4` reader - DATA4"] pub type Data4R = crate :: FieldReader ;
#[doc = "Field `DATA4` writer - DATA4"] pub type Data4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA5` reader - DATA5"] pub type Data5R = crate :: FieldReader ;
#[doc = "Field `DATA5` writer - DATA5"] pub type Data5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA6` reader - DATA6"] pub type Data6R = crate :: FieldReader ;
#[doc = "Field `DATA6` writer - DATA6"] pub type Data6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DATA7` reader - DATA7"] pub type Data7R = crate :: FieldReader ;
#[doc = "Field `DATA7` writer - DATA7"] pub type Data7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DATA4"]
#[inline (always)] pub fn data4 (& self) -> Data4R { Data4R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA5"]
#[inline (always)] pub fn data5 (& self) -> Data5R { Data5R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA6"]
#[inline (always)] pub fn data6 (& self) -> Data6R { Data6R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA7"]
#[inline (always)] pub fn data7 (& self) -> Data7R { Data7R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DATA4"]
#[inline (always)] pub fn data4 (& mut self) -> Data4W < '_ , CanTdh2rSpec > { Data4W :: new (self , 0) }
#[doc = "Bits 8:15 - DATA5"]
#[inline (always)] pub fn data5 (& mut self) -> Data5W < '_ , CanTdh2rSpec > { Data5W :: new (self , 8) }
#[doc = "Bits 16:23 - DATA6"]
#[inline (always)] pub fn data6 (& mut self) -> Data6W < '_ , CanTdh2rSpec > { Data6W :: new (self , 16) }
#[doc = "Bits 24:31 - DATA7"]
#[inline (always)] pub fn data7 (& mut self) -> Data7W < '_ , CanTdh2rSpec > { Data7W :: new (self , 24) } }
#[doc = "CAN_TDH2R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_tdh2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_tdh2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanTdh2rSpec ; impl crate :: RegisterSpec for CanTdh2rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_tdh2r::R`](R) reader structure"] impl crate :: Readable for CanTdh2rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_tdh2r::W`](W) writer structure"] impl crate :: Writable for CanTdh2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_TDH2R to value 0"] impl crate :: Resettable for CanTdh2rSpec { } }
#[doc = "CAN_RI0R (r) register accessor: CAN_RI0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ri0r::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_ri0r`] module"]
#[doc (alias = "CAN_RI0R")] pub type CanRi0r = crate :: Reg < can_ri0r :: CanRi0rSpec > ;
#[doc = "CAN_RI0R"] pub mod can_ri0r {
#[doc = "Register `CAN_RI0R` reader"] pub type R = crate :: R < CanRi0rSpec > ;
#[doc = "Field `RTR` reader - RTR"] pub type RtrR = crate :: BitReader ;
#[doc = "Field `IDE` reader - IDE"] pub type IdeR = crate :: BitReader ;
#[doc = "Field `EXID` reader - EXID"] pub type ExidR = crate :: FieldReader < u32 > ;
#[doc = "Field `STID` reader - STID"] pub type StidR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bit 1 - RTR"]
#[inline (always)] pub fn rtr (& self) -> RtrR { RtrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IDE"]
#[inline (always)] pub fn ide (& self) -> IdeR { IdeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:20 - EXID"]
#[inline (always)] pub fn exid (& self) -> ExidR { ExidR :: new ((self . bits >> 3) & 0x0003_ffff) }
#[doc = "Bits 21:31 - STID"]
#[inline (always)] pub fn stid (& self) -> StidR { StidR :: new (((self . bits >> 21) & 0x07ff) as u16) } }
#[doc = "CAN_RI0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ri0r::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRi0rSpec ; impl crate :: RegisterSpec for CanRi0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_ri0r::R`](R) reader structure"] impl crate :: Readable for CanRi0rSpec { }
#[doc = "`reset()` method sets CAN_RI0R to value 0"] impl crate :: Resettable for CanRi0rSpec { } }
#[doc = "CAN_RDT0R (r) register accessor: CAN_RDT0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdt0r::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_rdt0r`] module"]
#[doc (alias = "CAN_RDT0R")] pub type CanRdt0r = crate :: Reg < can_rdt0r :: CanRdt0rSpec > ;
#[doc = "CAN_RDT0R"] pub mod can_rdt0r {
#[doc = "Register `CAN_RDT0R` reader"] pub type R = crate :: R < CanRdt0rSpec > ;
#[doc = "Field `DLC` reader - DLC"] pub type DlcR = crate :: FieldReader ;
#[doc = "Field `FMI` reader - FMI"] pub type FmiR = crate :: FieldReader ;
#[doc = "Field `TIME` reader - TIME"] pub type TimeR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:3 - DLC"]
#[inline (always)] pub fn dlc (& self) -> DlcR { DlcR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 8:15 - FMI"]
#[inline (always)] pub fn fmi (& self) -> FmiR { FmiR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:31 - TIME"]
#[inline (always)] pub fn time (& self) -> TimeR { TimeR :: new (((self . bits >> 16) & 0xffff) as u16) } }
#[doc = "CAN_RDT0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdt0r::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRdt0rSpec ; impl crate :: RegisterSpec for CanRdt0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_rdt0r::R`](R) reader structure"] impl crate :: Readable for CanRdt0rSpec { }
#[doc = "`reset()` method sets CAN_RDT0R to value 0"] impl crate :: Resettable for CanRdt0rSpec { } }
#[doc = "CAN_RDL0R (r) register accessor: CAN_RDL0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdl0r::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_rdl0r`] module"]
#[doc (alias = "CAN_RDL0R")] pub type CanRdl0r = crate :: Reg < can_rdl0r :: CanRdl0rSpec > ;
#[doc = "CAN_RDL0R"] pub mod can_rdl0r {
#[doc = "Register `CAN_RDL0R` reader"] pub type R = crate :: R < CanRdl0rSpec > ;
#[doc = "Field `DATA0` reader - DATA0"] pub type Data0R = crate :: FieldReader ;
#[doc = "Field `DATA1` reader - DATA1"] pub type Data1R = crate :: FieldReader ;
#[doc = "Field `DATA2` reader - DATA2"] pub type Data2R = crate :: FieldReader ;
#[doc = "Field `DATA3` reader - DATA3"] pub type Data3R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - DATA0"]
#[inline (always)] pub fn data0 (& self) -> Data0R { Data0R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA1"]
#[inline (always)] pub fn data1 (& self) -> Data1R { Data1R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA2"]
#[inline (always)] pub fn data2 (& self) -> Data2R { Data2R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA3"]
#[inline (always)] pub fn data3 (& self) -> Data3R { Data3R :: new (((self . bits >> 24) & 0xff) as u8) } }
#[doc = "CAN_RDL0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdl0r::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRdl0rSpec ; impl crate :: RegisterSpec for CanRdl0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_rdl0r::R`](R) reader structure"] impl crate :: Readable for CanRdl0rSpec { }
#[doc = "`reset()` method sets CAN_RDL0R to value 0"] impl crate :: Resettable for CanRdl0rSpec { } }
#[doc = "CAN_RDH0R (r) register accessor: CAN_RDH0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdh0r::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_rdh0r`] module"]
#[doc (alias = "CAN_RDH0R")] pub type CanRdh0r = crate :: Reg < can_rdh0r :: CanRdh0rSpec > ;
#[doc = "CAN_RDH0R"] pub mod can_rdh0r {
#[doc = "Register `CAN_RDH0R` reader"] pub type R = crate :: R < CanRdh0rSpec > ;
#[doc = "Field `DATA4` reader - DATA4"] pub type Data4R = crate :: FieldReader ;
#[doc = "Field `DATA5` reader - DATA5"] pub type Data5R = crate :: FieldReader ;
#[doc = "Field `DATA6` reader - DATA6"] pub type Data6R = crate :: FieldReader ;
#[doc = "Field `DATA7` reader - DATA7"] pub type Data7R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - DATA4"]
#[inline (always)] pub fn data4 (& self) -> Data4R { Data4R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA5"]
#[inline (always)] pub fn data5 (& self) -> Data5R { Data5R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA6"]
#[inline (always)] pub fn data6 (& self) -> Data6R { Data6R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA7"]
#[inline (always)] pub fn data7 (& self) -> Data7R { Data7R :: new (((self . bits >> 24) & 0xff) as u8) } }
#[doc = "CAN_RDH0R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdh0r::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRdh0rSpec ; impl crate :: RegisterSpec for CanRdh0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_rdh0r::R`](R) reader structure"] impl crate :: Readable for CanRdh0rSpec { }
#[doc = "`reset()` method sets CAN_RDH0R to value 0"] impl crate :: Resettable for CanRdh0rSpec { } }
#[doc = "CAN_RI1R (r) register accessor: CAN_RI1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ri1r::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_ri1r`] module"]
#[doc (alias = "CAN_RI1R")] pub type CanRi1r = crate :: Reg < can_ri1r :: CanRi1rSpec > ;
#[doc = "CAN_RI1R"] pub mod can_ri1r {
#[doc = "Register `CAN_RI1R` reader"] pub type R = crate :: R < CanRi1rSpec > ;
#[doc = "Field `RTR` reader - RTR"] pub type RtrR = crate :: BitReader ;
#[doc = "Field `IDE` reader - IDE"] pub type IdeR = crate :: BitReader ;
#[doc = "Field `EXID` reader - EXID"] pub type ExidR = crate :: FieldReader < u32 > ;
#[doc = "Field `STID` reader - STID"] pub type StidR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bit 1 - RTR"]
#[inline (always)] pub fn rtr (& self) -> RtrR { RtrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IDE"]
#[inline (always)] pub fn ide (& self) -> IdeR { IdeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:20 - EXID"]
#[inline (always)] pub fn exid (& self) -> ExidR { ExidR :: new ((self . bits >> 3) & 0x0003_ffff) }
#[doc = "Bits 21:31 - STID"]
#[inline (always)] pub fn stid (& self) -> StidR { StidR :: new (((self . bits >> 21) & 0x07ff) as u16) } }
#[doc = "CAN_RI1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ri1r::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRi1rSpec ; impl crate :: RegisterSpec for CanRi1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_ri1r::R`](R) reader structure"] impl crate :: Readable for CanRi1rSpec { }
#[doc = "`reset()` method sets CAN_RI1R to value 0"] impl crate :: Resettable for CanRi1rSpec { } }
#[doc = "CAN_RDT1R (r) register accessor: CAN_RDT1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdt1r::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_rdt1r`] module"]
#[doc (alias = "CAN_RDT1R")] pub type CanRdt1r = crate :: Reg < can_rdt1r :: CanRdt1rSpec > ;
#[doc = "CAN_RDT1R"] pub mod can_rdt1r {
#[doc = "Register `CAN_RDT1R` reader"] pub type R = crate :: R < CanRdt1rSpec > ;
#[doc = "Field `DLC` reader - DLC"] pub type DlcR = crate :: FieldReader ;
#[doc = "Field `FMI` reader - FMI"] pub type FmiR = crate :: FieldReader ;
#[doc = "Field `TIME` reader - TIME"] pub type TimeR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:3 - DLC"]
#[inline (always)] pub fn dlc (& self) -> DlcR { DlcR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 8:15 - FMI"]
#[inline (always)] pub fn fmi (& self) -> FmiR { FmiR :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:31 - TIME"]
#[inline (always)] pub fn time (& self) -> TimeR { TimeR :: new (((self . bits >> 16) & 0xffff) as u16) } }
#[doc = "CAN_RDT1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdt1r::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRdt1rSpec ; impl crate :: RegisterSpec for CanRdt1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_rdt1r::R`](R) reader structure"] impl crate :: Readable for CanRdt1rSpec { }
#[doc = "`reset()` method sets CAN_RDT1R to value 0"] impl crate :: Resettable for CanRdt1rSpec { } }
#[doc = "CAN_RDL1R (r) register accessor: CAN_RDL1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdl1r::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_rdl1r`] module"]
#[doc (alias = "CAN_RDL1R")] pub type CanRdl1r = crate :: Reg < can_rdl1r :: CanRdl1rSpec > ;
#[doc = "CAN_RDL1R"] pub mod can_rdl1r {
#[doc = "Register `CAN_RDL1R` reader"] pub type R = crate :: R < CanRdl1rSpec > ;
#[doc = "Field `DATA0` reader - DATA0"] pub type Data0R = crate :: FieldReader ;
#[doc = "Field `DATA1` reader - DATA1"] pub type Data1R = crate :: FieldReader ;
#[doc = "Field `DATA2` reader - DATA2"] pub type Data2R = crate :: FieldReader ;
#[doc = "Field `DATA3` reader - DATA3"] pub type Data3R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - DATA0"]
#[inline (always)] pub fn data0 (& self) -> Data0R { Data0R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA1"]
#[inline (always)] pub fn data1 (& self) -> Data1R { Data1R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA2"]
#[inline (always)] pub fn data2 (& self) -> Data2R { Data2R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA3"]
#[inline (always)] pub fn data3 (& self) -> Data3R { Data3R :: new (((self . bits >> 24) & 0xff) as u8) } }
#[doc = "CAN_RDL1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdl1r::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRdl1rSpec ; impl crate :: RegisterSpec for CanRdl1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_rdl1r::R`](R) reader structure"] impl crate :: Readable for CanRdl1rSpec { }
#[doc = "`reset()` method sets CAN_RDL1R to value 0"] impl crate :: Resettable for CanRdl1rSpec { } }
#[doc = "CAN_RDH1R (r) register accessor: CAN_RDH1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdh1r::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_rdh1r`] module"]
#[doc (alias = "CAN_RDH1R")] pub type CanRdh1r = crate :: Reg < can_rdh1r :: CanRdh1rSpec > ;
#[doc = "CAN_RDH1R"] pub mod can_rdh1r {
#[doc = "Register `CAN_RDH1R` reader"] pub type R = crate :: R < CanRdh1rSpec > ;
#[doc = "Field `DATA4` reader - DATA4"] pub type Data4R = crate :: FieldReader ;
#[doc = "Field `DATA5` reader - DATA5"] pub type Data5R = crate :: FieldReader ;
#[doc = "Field `DATA6` reader - DATA6"] pub type Data6R = crate :: FieldReader ;
#[doc = "Field `DATA7` reader - DATA7"] pub type Data7R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - DATA4"]
#[inline (always)] pub fn data4 (& self) -> Data4R { Data4R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DATA5"]
#[inline (always)] pub fn data5 (& self) -> Data5R { Data5R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - DATA6"]
#[inline (always)] pub fn data6 (& self) -> Data6R { Data6R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - DATA7"]
#[inline (always)] pub fn data7 (& self) -> Data7R { Data7R :: new (((self . bits >> 24) & 0xff) as u8) } }
#[doc = "CAN_RDH1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_rdh1r::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanRdh1rSpec ; impl crate :: RegisterSpec for CanRdh1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_rdh1r::R`](R) reader structure"] impl crate :: Readable for CanRdh1rSpec { }
#[doc = "`reset()` method sets CAN_RDH1R to value 0"] impl crate :: Resettable for CanRdh1rSpec { } }
#[doc = "CAN_FMR (rw) register accessor: CAN_FMR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_fmr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_fmr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_fmr`] module"]
#[doc (alias = "CAN_FMR")] pub type CanFmr = crate :: Reg < can_fmr :: CanFmrSpec > ;
#[doc = "CAN_FMR"] pub mod can_fmr {
#[doc = "Register `CAN_FMR` reader"] pub type R = crate :: R < CanFmrSpec > ;
#[doc = "Register `CAN_FMR` writer"] pub type W = crate :: W < CanFmrSpec > ;
#[doc = "Field `FINIT` reader - FINIT"] pub type FinitR = crate :: BitReader ;
#[doc = "Field `FINIT` writer - FINIT"] pub type FinitW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - FINIT"]
#[inline (always)] pub fn finit (& self) -> FinitR { FinitR :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - FINIT"]
#[inline (always)] pub fn finit (& mut self) -> FinitW < '_ , CanFmrSpec > { FinitW :: new (self , 0) } }
#[doc = "CAN_FMR\n\nYou can [`read`](crate::Reg::read) this register and get [`can_fmr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_fmr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanFmrSpec ; impl crate :: RegisterSpec for CanFmrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_fmr::R`](R) reader structure"] impl crate :: Readable for CanFmrSpec { }
#[doc = "`write(|w| ..)` method takes [`can_fmr::W`](W) writer structure"] impl crate :: Writable for CanFmrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_FMR to value 0"] impl crate :: Resettable for CanFmrSpec { } }
#[doc = "CAN_FM1R (rw) register accessor: CAN_FM1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_fm1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_fm1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_fm1r`] module"]
#[doc (alias = "CAN_FM1R")] pub type CanFm1r = crate :: Reg < can_fm1r :: CanFm1rSpec > ;
#[doc = "CAN_FM1R"] pub mod can_fm1r {
#[doc = "Register `CAN_FM1R` reader"] pub type R = crate :: R < CanFm1rSpec > ;
#[doc = "Register `CAN_FM1R` writer"] pub type W = crate :: W < CanFm1rSpec > ;
#[doc = "Field `FBM0` reader - Filter mode"] pub type Fbm0R = crate :: BitReader ;
#[doc = "Field `FBM0` writer - Filter mode"] pub type Fbm0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM1` reader - Filter mode"] pub type Fbm1R = crate :: BitReader ;
#[doc = "Field `FBM1` writer - Filter mode"] pub type Fbm1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM2` reader - Filter mode"] pub type Fbm2R = crate :: BitReader ;
#[doc = "Field `FBM2` writer - Filter mode"] pub type Fbm2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM3` reader - Filter mode"] pub type Fbm3R = crate :: BitReader ;
#[doc = "Field `FBM3` writer - Filter mode"] pub type Fbm3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM4` reader - Filter mode"] pub type Fbm4R = crate :: BitReader ;
#[doc = "Field `FBM4` writer - Filter mode"] pub type Fbm4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM5` reader - Filter mode"] pub type Fbm5R = crate :: BitReader ;
#[doc = "Field `FBM5` writer - Filter mode"] pub type Fbm5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM6` reader - Filter mode"] pub type Fbm6R = crate :: BitReader ;
#[doc = "Field `FBM6` writer - Filter mode"] pub type Fbm6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM7` reader - Filter mode"] pub type Fbm7R = crate :: BitReader ;
#[doc = "Field `FBM7` writer - Filter mode"] pub type Fbm7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM8` reader - Filter mode"] pub type Fbm8R = crate :: BitReader ;
#[doc = "Field `FBM8` writer - Filter mode"] pub type Fbm8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM9` reader - Filter mode"] pub type Fbm9R = crate :: BitReader ;
#[doc = "Field `FBM9` writer - Filter mode"] pub type Fbm9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM10` reader - Filter mode"] pub type Fbm10R = crate :: BitReader ;
#[doc = "Field `FBM10` writer - Filter mode"] pub type Fbm10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM11` reader - Filter mode"] pub type Fbm11R = crate :: BitReader ;
#[doc = "Field `FBM11` writer - Filter mode"] pub type Fbm11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM12` reader - Filter mode"] pub type Fbm12R = crate :: BitReader ;
#[doc = "Field `FBM12` writer - Filter mode"] pub type Fbm12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBM13` reader - Filter mode"] pub type Fbm13R = crate :: BitReader ;
#[doc = "Field `FBM13` writer - Filter mode"] pub type Fbm13W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter mode"]
#[inline (always)] pub fn fbm0 (& self) -> Fbm0R { Fbm0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter mode"]
#[inline (always)] pub fn fbm1 (& self) -> Fbm1R { Fbm1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter mode"]
#[inline (always)] pub fn fbm2 (& self) -> Fbm2R { Fbm2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter mode"]
#[inline (always)] pub fn fbm3 (& self) -> Fbm3R { Fbm3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter mode"]
#[inline (always)] pub fn fbm4 (& self) -> Fbm4R { Fbm4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter mode"]
#[inline (always)] pub fn fbm5 (& self) -> Fbm5R { Fbm5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter mode"]
#[inline (always)] pub fn fbm6 (& self) -> Fbm6R { Fbm6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter mode"]
#[inline (always)] pub fn fbm7 (& self) -> Fbm7R { Fbm7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter mode"]
#[inline (always)] pub fn fbm8 (& self) -> Fbm8R { Fbm8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter mode"]
#[inline (always)] pub fn fbm9 (& self) -> Fbm9R { Fbm9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter mode"]
#[inline (always)] pub fn fbm10 (& self) -> Fbm10R { Fbm10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter mode"]
#[inline (always)] pub fn fbm11 (& self) -> Fbm11R { Fbm11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter mode"]
#[inline (always)] pub fn fbm12 (& self) -> Fbm12R { Fbm12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter mode"]
#[inline (always)] pub fn fbm13 (& self) -> Fbm13R { Fbm13R :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter mode"]
#[inline (always)] pub fn fbm0 (& mut self) -> Fbm0W < '_ , CanFm1rSpec > { Fbm0W :: new (self , 0) }
#[doc = "Bit 1 - Filter mode"]
#[inline (always)] pub fn fbm1 (& mut self) -> Fbm1W < '_ , CanFm1rSpec > { Fbm1W :: new (self , 1) }
#[doc = "Bit 2 - Filter mode"]
#[inline (always)] pub fn fbm2 (& mut self) -> Fbm2W < '_ , CanFm1rSpec > { Fbm2W :: new (self , 2) }
#[doc = "Bit 3 - Filter mode"]
#[inline (always)] pub fn fbm3 (& mut self) -> Fbm3W < '_ , CanFm1rSpec > { Fbm3W :: new (self , 3) }
#[doc = "Bit 4 - Filter mode"]
#[inline (always)] pub fn fbm4 (& mut self) -> Fbm4W < '_ , CanFm1rSpec > { Fbm4W :: new (self , 4) }
#[doc = "Bit 5 - Filter mode"]
#[inline (always)] pub fn fbm5 (& mut self) -> Fbm5W < '_ , CanFm1rSpec > { Fbm5W :: new (self , 5) }
#[doc = "Bit 6 - Filter mode"]
#[inline (always)] pub fn fbm6 (& mut self) -> Fbm6W < '_ , CanFm1rSpec > { Fbm6W :: new (self , 6) }
#[doc = "Bit 7 - Filter mode"]
#[inline (always)] pub fn fbm7 (& mut self) -> Fbm7W < '_ , CanFm1rSpec > { Fbm7W :: new (self , 7) }
#[doc = "Bit 8 - Filter mode"]
#[inline (always)] pub fn fbm8 (& mut self) -> Fbm8W < '_ , CanFm1rSpec > { Fbm8W :: new (self , 8) }
#[doc = "Bit 9 - Filter mode"]
#[inline (always)] pub fn fbm9 (& mut self) -> Fbm9W < '_ , CanFm1rSpec > { Fbm9W :: new (self , 9) }
#[doc = "Bit 10 - Filter mode"]
#[inline (always)] pub fn fbm10 (& mut self) -> Fbm10W < '_ , CanFm1rSpec > { Fbm10W :: new (self , 10) }
#[doc = "Bit 11 - Filter mode"]
#[inline (always)] pub fn fbm11 (& mut self) -> Fbm11W < '_ , CanFm1rSpec > { Fbm11W :: new (self , 11) }
#[doc = "Bit 12 - Filter mode"]
#[inline (always)] pub fn fbm12 (& mut self) -> Fbm12W < '_ , CanFm1rSpec > { Fbm12W :: new (self , 12) }
#[doc = "Bit 13 - Filter mode"]
#[inline (always)] pub fn fbm13 (& mut self) -> Fbm13W < '_ , CanFm1rSpec > { Fbm13W :: new (self , 13) } }
#[doc = "CAN_FM1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_fm1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_fm1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanFm1rSpec ; impl crate :: RegisterSpec for CanFm1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_fm1r::R`](R) reader structure"] impl crate :: Readable for CanFm1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_fm1r::W`](W) writer structure"] impl crate :: Writable for CanFm1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_FM1R to value 0"] impl crate :: Resettable for CanFm1rSpec { } }
#[doc = "CAN_FS1R (rw) register accessor: CAN_FS1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_fs1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_fs1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_fs1r`] module"]
#[doc (alias = "CAN_FS1R")] pub type CanFs1r = crate :: Reg < can_fs1r :: CanFs1rSpec > ;
#[doc = "CAN_FS1R"] pub mod can_fs1r {
#[doc = "Register `CAN_FS1R` reader"] pub type R = crate :: R < CanFs1rSpec > ;
#[doc = "Register `CAN_FS1R` writer"] pub type W = crate :: W < CanFs1rSpec > ;
#[doc = "Field `FSC0` reader - Filter scale configuration"] pub type Fsc0R = crate :: BitReader ;
#[doc = "Field `FSC0` writer - Filter scale configuration"] pub type Fsc0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC1` reader - Filter scale configuration"] pub type Fsc1R = crate :: BitReader ;
#[doc = "Field `FSC1` writer - Filter scale configuration"] pub type Fsc1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC2` reader - Filter scale configuration"] pub type Fsc2R = crate :: BitReader ;
#[doc = "Field `FSC2` writer - Filter scale configuration"] pub type Fsc2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC3` reader - Filter scale configuration"] pub type Fsc3R = crate :: BitReader ;
#[doc = "Field `FSC3` writer - Filter scale configuration"] pub type Fsc3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC4` reader - Filter scale configuration"] pub type Fsc4R = crate :: BitReader ;
#[doc = "Field `FSC4` writer - Filter scale configuration"] pub type Fsc4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC5` reader - Filter scale configuration"] pub type Fsc5R = crate :: BitReader ;
#[doc = "Field `FSC5` writer - Filter scale configuration"] pub type Fsc5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC6` reader - Filter scale configuration"] pub type Fsc6R = crate :: BitReader ;
#[doc = "Field `FSC6` writer - Filter scale configuration"] pub type Fsc6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC7` reader - Filter scale configuration"] pub type Fsc7R = crate :: BitReader ;
#[doc = "Field `FSC7` writer - Filter scale configuration"] pub type Fsc7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC8` reader - Filter scale configuration"] pub type Fsc8R = crate :: BitReader ;
#[doc = "Field `FSC8` writer - Filter scale configuration"] pub type Fsc8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC9` reader - Filter scale configuration"] pub type Fsc9R = crate :: BitReader ;
#[doc = "Field `FSC9` writer - Filter scale configuration"] pub type Fsc9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC10` reader - Filter scale configuration"] pub type Fsc10R = crate :: BitReader ;
#[doc = "Field `FSC10` writer - Filter scale configuration"] pub type Fsc10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC11` reader - Filter scale configuration"] pub type Fsc11R = crate :: BitReader ;
#[doc = "Field `FSC11` writer - Filter scale configuration"] pub type Fsc11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC12` reader - Filter scale configuration"] pub type Fsc12R = crate :: BitReader ;
#[doc = "Field `FSC12` writer - Filter scale configuration"] pub type Fsc12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSC13` reader - Filter scale configuration"] pub type Fsc13R = crate :: BitReader ;
#[doc = "Field `FSC13` writer - Filter scale configuration"] pub type Fsc13W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter scale configuration"]
#[inline (always)] pub fn fsc0 (& self) -> Fsc0R { Fsc0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter scale configuration"]
#[inline (always)] pub fn fsc1 (& self) -> Fsc1R { Fsc1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter scale configuration"]
#[inline (always)] pub fn fsc2 (& self) -> Fsc2R { Fsc2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter scale configuration"]
#[inline (always)] pub fn fsc3 (& self) -> Fsc3R { Fsc3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter scale configuration"]
#[inline (always)] pub fn fsc4 (& self) -> Fsc4R { Fsc4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter scale configuration"]
#[inline (always)] pub fn fsc5 (& self) -> Fsc5R { Fsc5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter scale configuration"]
#[inline (always)] pub fn fsc6 (& self) -> Fsc6R { Fsc6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter scale configuration"]
#[inline (always)] pub fn fsc7 (& self) -> Fsc7R { Fsc7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter scale configuration"]
#[inline (always)] pub fn fsc8 (& self) -> Fsc8R { Fsc8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter scale configuration"]
#[inline (always)] pub fn fsc9 (& self) -> Fsc9R { Fsc9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter scale configuration"]
#[inline (always)] pub fn fsc10 (& self) -> Fsc10R { Fsc10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter scale configuration"]
#[inline (always)] pub fn fsc11 (& self) -> Fsc11R { Fsc11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter scale configuration"]
#[inline (always)] pub fn fsc12 (& self) -> Fsc12R { Fsc12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter scale configuration"]
#[inline (always)] pub fn fsc13 (& self) -> Fsc13R { Fsc13R :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter scale configuration"]
#[inline (always)] pub fn fsc0 (& mut self) -> Fsc0W < '_ , CanFs1rSpec > { Fsc0W :: new (self , 0) }
#[doc = "Bit 1 - Filter scale configuration"]
#[inline (always)] pub fn fsc1 (& mut self) -> Fsc1W < '_ , CanFs1rSpec > { Fsc1W :: new (self , 1) }
#[doc = "Bit 2 - Filter scale configuration"]
#[inline (always)] pub fn fsc2 (& mut self) -> Fsc2W < '_ , CanFs1rSpec > { Fsc2W :: new (self , 2) }
#[doc = "Bit 3 - Filter scale configuration"]
#[inline (always)] pub fn fsc3 (& mut self) -> Fsc3W < '_ , CanFs1rSpec > { Fsc3W :: new (self , 3) }
#[doc = "Bit 4 - Filter scale configuration"]
#[inline (always)] pub fn fsc4 (& mut self) -> Fsc4W < '_ , CanFs1rSpec > { Fsc4W :: new (self , 4) }
#[doc = "Bit 5 - Filter scale configuration"]
#[inline (always)] pub fn fsc5 (& mut self) -> Fsc5W < '_ , CanFs1rSpec > { Fsc5W :: new (self , 5) }
#[doc = "Bit 6 - Filter scale configuration"]
#[inline (always)] pub fn fsc6 (& mut self) -> Fsc6W < '_ , CanFs1rSpec > { Fsc6W :: new (self , 6) }
#[doc = "Bit 7 - Filter scale configuration"]
#[inline (always)] pub fn fsc7 (& mut self) -> Fsc7W < '_ , CanFs1rSpec > { Fsc7W :: new (self , 7) }
#[doc = "Bit 8 - Filter scale configuration"]
#[inline (always)] pub fn fsc8 (& mut self) -> Fsc8W < '_ , CanFs1rSpec > { Fsc8W :: new (self , 8) }
#[doc = "Bit 9 - Filter scale configuration"]
#[inline (always)] pub fn fsc9 (& mut self) -> Fsc9W < '_ , CanFs1rSpec > { Fsc9W :: new (self , 9) }
#[doc = "Bit 10 - Filter scale configuration"]
#[inline (always)] pub fn fsc10 (& mut self) -> Fsc10W < '_ , CanFs1rSpec > { Fsc10W :: new (self , 10) }
#[doc = "Bit 11 - Filter scale configuration"]
#[inline (always)] pub fn fsc11 (& mut self) -> Fsc11W < '_ , CanFs1rSpec > { Fsc11W :: new (self , 11) }
#[doc = "Bit 12 - Filter scale configuration"]
#[inline (always)] pub fn fsc12 (& mut self) -> Fsc12W < '_ , CanFs1rSpec > { Fsc12W :: new (self , 12) }
#[doc = "Bit 13 - Filter scale configuration"]
#[inline (always)] pub fn fsc13 (& mut self) -> Fsc13W < '_ , CanFs1rSpec > { Fsc13W :: new (self , 13) } }
#[doc = "CAN_FS1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_fs1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_fs1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanFs1rSpec ; impl crate :: RegisterSpec for CanFs1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_fs1r::R`](R) reader structure"] impl crate :: Readable for CanFs1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_fs1r::W`](W) writer structure"] impl crate :: Writable for CanFs1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_FS1R to value 0"] impl crate :: Resettable for CanFs1rSpec { } }
#[doc = "CAN_FFA1R (rw) register accessor: CAN_FFA1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ffa1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ffa1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_ffa1r`] module"]
#[doc (alias = "CAN_FFA1R")] pub type CanFfa1r = crate :: Reg < can_ffa1r :: CanFfa1rSpec > ;
#[doc = "CAN_FFA1R"] pub mod can_ffa1r {
#[doc = "Register `CAN_FFA1R` reader"] pub type R = crate :: R < CanFfa1rSpec > ;
#[doc = "Register `CAN_FFA1R` writer"] pub type W = crate :: W < CanFfa1rSpec > ;
#[doc = "Field `FFA0` reader - Filter FIFO assignment for filter 0"] pub type Ffa0R = crate :: BitReader ;
#[doc = "Field `FFA0` writer - Filter FIFO assignment for filter 0"] pub type Ffa0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA1` reader - Filter FIFO assignment for filter 1"] pub type Ffa1R = crate :: BitReader ;
#[doc = "Field `FFA1` writer - Filter FIFO assignment for filter 1"] pub type Ffa1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA2` reader - Filter FIFO assignment for filter 2"] pub type Ffa2R = crate :: BitReader ;
#[doc = "Field `FFA2` writer - Filter FIFO assignment for filter 2"] pub type Ffa2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA3` reader - Filter FIFO assignment for filter 3"] pub type Ffa3R = crate :: BitReader ;
#[doc = "Field `FFA3` writer - Filter FIFO assignment for filter 3"] pub type Ffa3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA4` reader - Filter FIFO assignment for filter 4"] pub type Ffa4R = crate :: BitReader ;
#[doc = "Field `FFA4` writer - Filter FIFO assignment for filter 4"] pub type Ffa4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA5` reader - Filter FIFO assignment for filter 5"] pub type Ffa5R = crate :: BitReader ;
#[doc = "Field `FFA5` writer - Filter FIFO assignment for filter 5"] pub type Ffa5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA6` reader - Filter FIFO assignment for filter 6"] pub type Ffa6R = crate :: BitReader ;
#[doc = "Field `FFA6` writer - Filter FIFO assignment for filter 6"] pub type Ffa6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA7` reader - Filter FIFO assignment for filter 7"] pub type Ffa7R = crate :: BitReader ;
#[doc = "Field `FFA7` writer - Filter FIFO assignment for filter 7"] pub type Ffa7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA8` reader - Filter FIFO assignment for filter 8"] pub type Ffa8R = crate :: BitReader ;
#[doc = "Field `FFA8` writer - Filter FIFO assignment for filter 8"] pub type Ffa8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA9` reader - Filter FIFO assignment for filter 9"] pub type Ffa9R = crate :: BitReader ;
#[doc = "Field `FFA9` writer - Filter FIFO assignment for filter 9"] pub type Ffa9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA10` reader - Filter FIFO assignment for filter 10"] pub type Ffa10R = crate :: BitReader ;
#[doc = "Field `FFA10` writer - Filter FIFO assignment for filter 10"] pub type Ffa10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA11` reader - Filter FIFO assignment for filter 11"] pub type Ffa11R = crate :: BitReader ;
#[doc = "Field `FFA11` writer - Filter FIFO assignment for filter 11"] pub type Ffa11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA12` reader - Filter FIFO assignment for filter 12"] pub type Ffa12R = crate :: BitReader ;
#[doc = "Field `FFA12` writer - Filter FIFO assignment for filter 12"] pub type Ffa12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FFA13` reader - Filter FIFO assignment for filter 13"] pub type Ffa13R = crate :: BitReader ;
#[doc = "Field `FFA13` writer - Filter FIFO assignment for filter 13"] pub type Ffa13W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter FIFO assignment for filter 0"]
#[inline (always)] pub fn ffa0 (& self) -> Ffa0R { Ffa0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter FIFO assignment for filter 1"]
#[inline (always)] pub fn ffa1 (& self) -> Ffa1R { Ffa1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter FIFO assignment for filter 2"]
#[inline (always)] pub fn ffa2 (& self) -> Ffa2R { Ffa2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter FIFO assignment for filter 3"]
#[inline (always)] pub fn ffa3 (& self) -> Ffa3R { Ffa3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter FIFO assignment for filter 4"]
#[inline (always)] pub fn ffa4 (& self) -> Ffa4R { Ffa4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter FIFO assignment for filter 5"]
#[inline (always)] pub fn ffa5 (& self) -> Ffa5R { Ffa5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter FIFO assignment for filter 6"]
#[inline (always)] pub fn ffa6 (& self) -> Ffa6R { Ffa6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter FIFO assignment for filter 7"]
#[inline (always)] pub fn ffa7 (& self) -> Ffa7R { Ffa7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter FIFO assignment for filter 8"]
#[inline (always)] pub fn ffa8 (& self) -> Ffa8R { Ffa8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter FIFO assignment for filter 9"]
#[inline (always)] pub fn ffa9 (& self) -> Ffa9R { Ffa9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter FIFO assignment for filter 10"]
#[inline (always)] pub fn ffa10 (& self) -> Ffa10R { Ffa10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter FIFO assignment for filter 11"]
#[inline (always)] pub fn ffa11 (& self) -> Ffa11R { Ffa11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter FIFO assignment for filter 12"]
#[inline (always)] pub fn ffa12 (& self) -> Ffa12R { Ffa12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter FIFO assignment for filter 13"]
#[inline (always)] pub fn ffa13 (& self) -> Ffa13R { Ffa13R :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter FIFO assignment for filter 0"]
#[inline (always)] pub fn ffa0 (& mut self) -> Ffa0W < '_ , CanFfa1rSpec > { Ffa0W :: new (self , 0) }
#[doc = "Bit 1 - Filter FIFO assignment for filter 1"]
#[inline (always)] pub fn ffa1 (& mut self) -> Ffa1W < '_ , CanFfa1rSpec > { Ffa1W :: new (self , 1) }
#[doc = "Bit 2 - Filter FIFO assignment for filter 2"]
#[inline (always)] pub fn ffa2 (& mut self) -> Ffa2W < '_ , CanFfa1rSpec > { Ffa2W :: new (self , 2) }
#[doc = "Bit 3 - Filter FIFO assignment for filter 3"]
#[inline (always)] pub fn ffa3 (& mut self) -> Ffa3W < '_ , CanFfa1rSpec > { Ffa3W :: new (self , 3) }
#[doc = "Bit 4 - Filter FIFO assignment for filter 4"]
#[inline (always)] pub fn ffa4 (& mut self) -> Ffa4W < '_ , CanFfa1rSpec > { Ffa4W :: new (self , 4) }
#[doc = "Bit 5 - Filter FIFO assignment for filter 5"]
#[inline (always)] pub fn ffa5 (& mut self) -> Ffa5W < '_ , CanFfa1rSpec > { Ffa5W :: new (self , 5) }
#[doc = "Bit 6 - Filter FIFO assignment for filter 6"]
#[inline (always)] pub fn ffa6 (& mut self) -> Ffa6W < '_ , CanFfa1rSpec > { Ffa6W :: new (self , 6) }
#[doc = "Bit 7 - Filter FIFO assignment for filter 7"]
#[inline (always)] pub fn ffa7 (& mut self) -> Ffa7W < '_ , CanFfa1rSpec > { Ffa7W :: new (self , 7) }
#[doc = "Bit 8 - Filter FIFO assignment for filter 8"]
#[inline (always)] pub fn ffa8 (& mut self) -> Ffa8W < '_ , CanFfa1rSpec > { Ffa8W :: new (self , 8) }
#[doc = "Bit 9 - Filter FIFO assignment for filter 9"]
#[inline (always)] pub fn ffa9 (& mut self) -> Ffa9W < '_ , CanFfa1rSpec > { Ffa9W :: new (self , 9) }
#[doc = "Bit 10 - Filter FIFO assignment for filter 10"]
#[inline (always)] pub fn ffa10 (& mut self) -> Ffa10W < '_ , CanFfa1rSpec > { Ffa10W :: new (self , 10) }
#[doc = "Bit 11 - Filter FIFO assignment for filter 11"]
#[inline (always)] pub fn ffa11 (& mut self) -> Ffa11W < '_ , CanFfa1rSpec > { Ffa11W :: new (self , 11) }
#[doc = "Bit 12 - Filter FIFO assignment for filter 12"]
#[inline (always)] pub fn ffa12 (& mut self) -> Ffa12W < '_ , CanFfa1rSpec > { Ffa12W :: new (self , 12) }
#[doc = "Bit 13 - Filter FIFO assignment for filter 13"]
#[inline (always)] pub fn ffa13 (& mut self) -> Ffa13W < '_ , CanFfa1rSpec > { Ffa13W :: new (self , 13) } }
#[doc = "CAN_FFA1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_ffa1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_ffa1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanFfa1rSpec ; impl crate :: RegisterSpec for CanFfa1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_ffa1r::R`](R) reader structure"] impl crate :: Readable for CanFfa1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_ffa1r::W`](W) writer structure"] impl crate :: Writable for CanFfa1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_FFA1R to value 0"] impl crate :: Resettable for CanFfa1rSpec { } }
#[doc = "CAN_FA1R (rw) register accessor: CAN_FA1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_fa1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_fa1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@can_fa1r`] module"]
#[doc (alias = "CAN_FA1R")] pub type CanFa1r = crate :: Reg < can_fa1r :: CanFa1rSpec > ;
#[doc = "CAN_FA1R"] pub mod can_fa1r {
#[doc = "Register `CAN_FA1R` reader"] pub type R = crate :: R < CanFa1rSpec > ;
#[doc = "Register `CAN_FA1R` writer"] pub type W = crate :: W < CanFa1rSpec > ;
#[doc = "Field `FACT0` reader - Filter active"] pub type Fact0R = crate :: BitReader ;
#[doc = "Field `FACT0` writer - Filter active"] pub type Fact0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT1` reader - Filter active"] pub type Fact1R = crate :: BitReader ;
#[doc = "Field `FACT1` writer - Filter active"] pub type Fact1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT2` reader - Filter active"] pub type Fact2R = crate :: BitReader ;
#[doc = "Field `FACT2` writer - Filter active"] pub type Fact2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT3` reader - Filter active"] pub type Fact3R = crate :: BitReader ;
#[doc = "Field `FACT3` writer - Filter active"] pub type Fact3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT4` reader - Filter active"] pub type Fact4R = crate :: BitReader ;
#[doc = "Field `FACT4` writer - Filter active"] pub type Fact4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT5` reader - Filter active"] pub type Fact5R = crate :: BitReader ;
#[doc = "Field `FACT5` writer - Filter active"] pub type Fact5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT6` reader - Filter active"] pub type Fact6R = crate :: BitReader ;
#[doc = "Field `FACT6` writer - Filter active"] pub type Fact6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT7` reader - Filter active"] pub type Fact7R = crate :: BitReader ;
#[doc = "Field `FACT7` writer - Filter active"] pub type Fact7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT8` reader - Filter active"] pub type Fact8R = crate :: BitReader ;
#[doc = "Field `FACT8` writer - Filter active"] pub type Fact8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT9` reader - Filter active"] pub type Fact9R = crate :: BitReader ;
#[doc = "Field `FACT9` writer - Filter active"] pub type Fact9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT10` reader - Filter active"] pub type Fact10R = crate :: BitReader ;
#[doc = "Field `FACT10` writer - Filter active"] pub type Fact10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT11` reader - Filter active"] pub type Fact11R = crate :: BitReader ;
#[doc = "Field `FACT11` writer - Filter active"] pub type Fact11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT12` reader - Filter active"] pub type Fact12R = crate :: BitReader ;
#[doc = "Field `FACT12` writer - Filter active"] pub type Fact12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FACT13` reader - Filter active"] pub type Fact13R = crate :: BitReader ;
#[doc = "Field `FACT13` writer - Filter active"] pub type Fact13W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter active"]
#[inline (always)] pub fn fact0 (& self) -> Fact0R { Fact0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter active"]
#[inline (always)] pub fn fact1 (& self) -> Fact1R { Fact1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter active"]
#[inline (always)] pub fn fact2 (& self) -> Fact2R { Fact2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter active"]
#[inline (always)] pub fn fact3 (& self) -> Fact3R { Fact3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter active"]
#[inline (always)] pub fn fact4 (& self) -> Fact4R { Fact4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter active"]
#[inline (always)] pub fn fact5 (& self) -> Fact5R { Fact5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter active"]
#[inline (always)] pub fn fact6 (& self) -> Fact6R { Fact6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter active"]
#[inline (always)] pub fn fact7 (& self) -> Fact7R { Fact7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter active"]
#[inline (always)] pub fn fact8 (& self) -> Fact8R { Fact8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter active"]
#[inline (always)] pub fn fact9 (& self) -> Fact9R { Fact9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter active"]
#[inline (always)] pub fn fact10 (& self) -> Fact10R { Fact10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter active"]
#[inline (always)] pub fn fact11 (& self) -> Fact11R { Fact11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter active"]
#[inline (always)] pub fn fact12 (& self) -> Fact12R { Fact12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter active"]
#[inline (always)] pub fn fact13 (& self) -> Fact13R { Fact13R :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter active"]
#[inline (always)] pub fn fact0 (& mut self) -> Fact0W < '_ , CanFa1rSpec > { Fact0W :: new (self , 0) }
#[doc = "Bit 1 - Filter active"]
#[inline (always)] pub fn fact1 (& mut self) -> Fact1W < '_ , CanFa1rSpec > { Fact1W :: new (self , 1) }
#[doc = "Bit 2 - Filter active"]
#[inline (always)] pub fn fact2 (& mut self) -> Fact2W < '_ , CanFa1rSpec > { Fact2W :: new (self , 2) }
#[doc = "Bit 3 - Filter active"]
#[inline (always)] pub fn fact3 (& mut self) -> Fact3W < '_ , CanFa1rSpec > { Fact3W :: new (self , 3) }
#[doc = "Bit 4 - Filter active"]
#[inline (always)] pub fn fact4 (& mut self) -> Fact4W < '_ , CanFa1rSpec > { Fact4W :: new (self , 4) }
#[doc = "Bit 5 - Filter active"]
#[inline (always)] pub fn fact5 (& mut self) -> Fact5W < '_ , CanFa1rSpec > { Fact5W :: new (self , 5) }
#[doc = "Bit 6 - Filter active"]
#[inline (always)] pub fn fact6 (& mut self) -> Fact6W < '_ , CanFa1rSpec > { Fact6W :: new (self , 6) }
#[doc = "Bit 7 - Filter active"]
#[inline (always)] pub fn fact7 (& mut self) -> Fact7W < '_ , CanFa1rSpec > { Fact7W :: new (self , 7) }
#[doc = "Bit 8 - Filter active"]
#[inline (always)] pub fn fact8 (& mut self) -> Fact8W < '_ , CanFa1rSpec > { Fact8W :: new (self , 8) }
#[doc = "Bit 9 - Filter active"]
#[inline (always)] pub fn fact9 (& mut self) -> Fact9W < '_ , CanFa1rSpec > { Fact9W :: new (self , 9) }
#[doc = "Bit 10 - Filter active"]
#[inline (always)] pub fn fact10 (& mut self) -> Fact10W < '_ , CanFa1rSpec > { Fact10W :: new (self , 10) }
#[doc = "Bit 11 - Filter active"]
#[inline (always)] pub fn fact11 (& mut self) -> Fact11W < '_ , CanFa1rSpec > { Fact11W :: new (self , 11) }
#[doc = "Bit 12 - Filter active"]
#[inline (always)] pub fn fact12 (& mut self) -> Fact12W < '_ , CanFa1rSpec > { Fact12W :: new (self , 12) }
#[doc = "Bit 13 - Filter active"]
#[inline (always)] pub fn fact13 (& mut self) -> Fact13W < '_ , CanFa1rSpec > { Fact13W :: new (self , 13) } }
#[doc = "CAN_FA1R\n\nYou can [`read`](crate::Reg::read) this register and get [`can_fa1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`can_fa1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CanFa1rSpec ; impl crate :: RegisterSpec for CanFa1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`can_fa1r::R`](R) reader structure"] impl crate :: Readable for CanFa1rSpec { }
#[doc = "`write(|w| ..)` method takes [`can_fa1r::W`](W) writer structure"] impl crate :: Writable for CanFa1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CAN_FA1R to value 0"] impl crate :: Resettable for CanFa1rSpec { } }
#[doc = "F0R1 (rw) register accessor: Filter bank 0 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f0r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f0r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f0r1`] module"]
#[doc (alias = "F0R1")] pub type F0r1 = crate :: Reg < f0r1 :: F0r1Spec > ;
#[doc = "Filter bank 0 register 1"] pub mod f0r1 {
#[doc = "Register `F0R1` reader"] pub type R = crate :: R < F0r1Spec > ;
#[doc = "Register `F0R1` writer"] pub type W = crate :: W < F0r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F0r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F0r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F0r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F0r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F0r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F0r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F0r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F0r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F0r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F0r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F0r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F0r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F0r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F0r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F0r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F0r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F0r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F0r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F0r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F0r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F0r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F0r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F0r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F0r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F0r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F0r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F0r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F0r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F0r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F0r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F0r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F0r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 0 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f0r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f0r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F0r1Spec ; impl crate :: RegisterSpec for F0r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f0r1::R`](R) reader structure"] impl crate :: Readable for F0r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f0r1::W`](W) writer structure"] impl crate :: Writable for F0r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F0R1 to value 0"] impl crate :: Resettable for F0r1Spec { } }
#[doc = "F0R2 (rw) register accessor: Filter bank 0 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f0r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f0r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f0r2`] module"]
#[doc (alias = "F0R2")] pub type F0r2 = crate :: Reg < f0r2 :: F0r2Spec > ;
#[doc = "Filter bank 0 register 2"] pub mod f0r2 {
#[doc = "Register `F0R2` reader"] pub type R = crate :: R < F0r2Spec > ;
#[doc = "Register `F0R2` writer"] pub type W = crate :: W < F0r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F0r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F0r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F0r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F0r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F0r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F0r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F0r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F0r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F0r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F0r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F0r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F0r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F0r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F0r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F0r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F0r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F0r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F0r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F0r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F0r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F0r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F0r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F0r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F0r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F0r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F0r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F0r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F0r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F0r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F0r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F0r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F0r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 0 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f0r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f0r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F0r2Spec ; impl crate :: RegisterSpec for F0r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f0r2::R`](R) reader structure"] impl crate :: Readable for F0r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f0r2::W`](W) writer structure"] impl crate :: Writable for F0r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F0R2 to value 0"] impl crate :: Resettable for F0r2Spec { } }
#[doc = "F1R1 (rw) register accessor: Filter bank 1 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f1r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f1r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f1r1`] module"]
#[doc (alias = "F1R1")] pub type F1r1 = crate :: Reg < f1r1 :: F1r1Spec > ;
#[doc = "Filter bank 1 register 1"] pub mod f1r1 {
#[doc = "Register `F1R1` reader"] pub type R = crate :: R < F1r1Spec > ;
#[doc = "Register `F1R1` writer"] pub type W = crate :: W < F1r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F1r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F1r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F1r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F1r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F1r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F1r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F1r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F1r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F1r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F1r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F1r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F1r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F1r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F1r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F1r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F1r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F1r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F1r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F1r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F1r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F1r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F1r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F1r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F1r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F1r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F1r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F1r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F1r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F1r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F1r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F1r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F1r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 1 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f1r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f1r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F1r1Spec ; impl crate :: RegisterSpec for F1r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f1r1::R`](R) reader structure"] impl crate :: Readable for F1r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f1r1::W`](W) writer structure"] impl crate :: Writable for F1r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F1R1 to value 0"] impl crate :: Resettable for F1r1Spec { } }
#[doc = "F1R2 (rw) register accessor: Filter bank 1 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f1r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f1r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f1r2`] module"]
#[doc (alias = "F1R2")] pub type F1r2 = crate :: Reg < f1r2 :: F1r2Spec > ;
#[doc = "Filter bank 1 register 2"] pub mod f1r2 {
#[doc = "Register `F1R2` reader"] pub type R = crate :: R < F1r2Spec > ;
#[doc = "Register `F1R2` writer"] pub type W = crate :: W < F1r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F1r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F1r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F1r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F1r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F1r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F1r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F1r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F1r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F1r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F1r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F1r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F1r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F1r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F1r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F1r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F1r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F1r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F1r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F1r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F1r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F1r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F1r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F1r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F1r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F1r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F1r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F1r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F1r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F1r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F1r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F1r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F1r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 1 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f1r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f1r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F1r2Spec ; impl crate :: RegisterSpec for F1r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f1r2::R`](R) reader structure"] impl crate :: Readable for F1r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f1r2::W`](W) writer structure"] impl crate :: Writable for F1r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F1R2 to value 0"] impl crate :: Resettable for F1r2Spec { } }
#[doc = "F2R1 (rw) register accessor: Filter bank 2 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f2r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f2r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f2r1`] module"]
#[doc (alias = "F2R1")] pub type F2r1 = crate :: Reg < f2r1 :: F2r1Spec > ;
#[doc = "Filter bank 2 register 1"] pub mod f2r1 {
#[doc = "Register `F2R1` reader"] pub type R = crate :: R < F2r1Spec > ;
#[doc = "Register `F2R1` writer"] pub type W = crate :: W < F2r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F2r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F2r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F2r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F2r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F2r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F2r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F2r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F2r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F2r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F2r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F2r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F2r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F2r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F2r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F2r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F2r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F2r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F2r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F2r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F2r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F2r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F2r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F2r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F2r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F2r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F2r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F2r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F2r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F2r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F2r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F2r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F2r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 2 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f2r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f2r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F2r1Spec ; impl crate :: RegisterSpec for F2r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f2r1::R`](R) reader structure"] impl crate :: Readable for F2r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f2r1::W`](W) writer structure"] impl crate :: Writable for F2r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F2R1 to value 0"] impl crate :: Resettable for F2r1Spec { } }
#[doc = "F2R2 (rw) register accessor: Filter bank 2 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f2r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f2r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f2r2`] module"]
#[doc (alias = "F2R2")] pub type F2r2 = crate :: Reg < f2r2 :: F2r2Spec > ;
#[doc = "Filter bank 2 register 2"] pub mod f2r2 {
#[doc = "Register `F2R2` reader"] pub type R = crate :: R < F2r2Spec > ;
#[doc = "Register `F2R2` writer"] pub type W = crate :: W < F2r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F2r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F2r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F2r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F2r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F2r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F2r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F2r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F2r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F2r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F2r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F2r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F2r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F2r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F2r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F2r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F2r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F2r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F2r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F2r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F2r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F2r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F2r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F2r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F2r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F2r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F2r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F2r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F2r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F2r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F2r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F2r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F2r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 2 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f2r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f2r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F2r2Spec ; impl crate :: RegisterSpec for F2r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f2r2::R`](R) reader structure"] impl crate :: Readable for F2r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f2r2::W`](W) writer structure"] impl crate :: Writable for F2r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F2R2 to value 0"] impl crate :: Resettable for F2r2Spec { } }
#[doc = "F3R1 (rw) register accessor: Filter bank 3 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f3r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f3r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f3r1`] module"]
#[doc (alias = "F3R1")] pub type F3r1 = crate :: Reg < f3r1 :: F3r1Spec > ;
#[doc = "Filter bank 3 register 1"] pub mod f3r1 {
#[doc = "Register `F3R1` reader"] pub type R = crate :: R < F3r1Spec > ;
#[doc = "Register `F3R1` writer"] pub type W = crate :: W < F3r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F3r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F3r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F3r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F3r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F3r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F3r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F3r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F3r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F3r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F3r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F3r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F3r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F3r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F3r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F3r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F3r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F3r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F3r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F3r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F3r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F3r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F3r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F3r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F3r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F3r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F3r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F3r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F3r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F3r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F3r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F3r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F3r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 3 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f3r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f3r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F3r1Spec ; impl crate :: RegisterSpec for F3r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f3r1::R`](R) reader structure"] impl crate :: Readable for F3r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f3r1::W`](W) writer structure"] impl crate :: Writable for F3r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F3R1 to value 0"] impl crate :: Resettable for F3r1Spec { } }
#[doc = "F3R2 (rw) register accessor: Filter bank 3 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f3r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f3r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f3r2`] module"]
#[doc (alias = "F3R2")] pub type F3r2 = crate :: Reg < f3r2 :: F3r2Spec > ;
#[doc = "Filter bank 3 register 2"] pub mod f3r2 {
#[doc = "Register `F3R2` reader"] pub type R = crate :: R < F3r2Spec > ;
#[doc = "Register `F3R2` writer"] pub type W = crate :: W < F3r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F3r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F3r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F3r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F3r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F3r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F3r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F3r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F3r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F3r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F3r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F3r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F3r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F3r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F3r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F3r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F3r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F3r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F3r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F3r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F3r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F3r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F3r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F3r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F3r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F3r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F3r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F3r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F3r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F3r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F3r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F3r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F3r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 3 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f3r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f3r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F3r2Spec ; impl crate :: RegisterSpec for F3r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f3r2::R`](R) reader structure"] impl crate :: Readable for F3r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f3r2::W`](W) writer structure"] impl crate :: Writable for F3r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F3R2 to value 0"] impl crate :: Resettable for F3r2Spec { } }
#[doc = "F4R1 (rw) register accessor: Filter bank 4 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f4r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f4r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f4r1`] module"]
#[doc (alias = "F4R1")] pub type F4r1 = crate :: Reg < f4r1 :: F4r1Spec > ;
#[doc = "Filter bank 4 register 1"] pub mod f4r1 {
#[doc = "Register `F4R1` reader"] pub type R = crate :: R < F4r1Spec > ;
#[doc = "Register `F4R1` writer"] pub type W = crate :: W < F4r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F4r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F4r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F4r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F4r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F4r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F4r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F4r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F4r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F4r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F4r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F4r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F4r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F4r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F4r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F4r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F4r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F4r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F4r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F4r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F4r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F4r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F4r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F4r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F4r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F4r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F4r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F4r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F4r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F4r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F4r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F4r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F4r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 4 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f4r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f4r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F4r1Spec ; impl crate :: RegisterSpec for F4r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f4r1::R`](R) reader structure"] impl crate :: Readable for F4r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f4r1::W`](W) writer structure"] impl crate :: Writable for F4r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F4R1 to value 0"] impl crate :: Resettable for F4r1Spec { } }
#[doc = "F4R2 (rw) register accessor: Filter bank 4 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f4r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f4r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f4r2`] module"]
#[doc (alias = "F4R2")] pub type F4r2 = crate :: Reg < f4r2 :: F4r2Spec > ;
#[doc = "Filter bank 4 register 2"] pub mod f4r2 {
#[doc = "Register `F4R2` reader"] pub type R = crate :: R < F4r2Spec > ;
#[doc = "Register `F4R2` writer"] pub type W = crate :: W < F4r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F4r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F4r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F4r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F4r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F4r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F4r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F4r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F4r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F4r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F4r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F4r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F4r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F4r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F4r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F4r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F4r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F4r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F4r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F4r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F4r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F4r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F4r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F4r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F4r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F4r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F4r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F4r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F4r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F4r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F4r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F4r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F4r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 4 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f4r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f4r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F4r2Spec ; impl crate :: RegisterSpec for F4r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f4r2::R`](R) reader structure"] impl crate :: Readable for F4r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f4r2::W`](W) writer structure"] impl crate :: Writable for F4r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F4R2 to value 0"] impl crate :: Resettable for F4r2Spec { } }
#[doc = "F5R1 (rw) register accessor: Filter bank 5 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f5r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f5r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f5r1`] module"]
#[doc (alias = "F5R1")] pub type F5r1 = crate :: Reg < f5r1 :: F5r1Spec > ;
#[doc = "Filter bank 5 register 1"] pub mod f5r1 {
#[doc = "Register `F5R1` reader"] pub type R = crate :: R < F5r1Spec > ;
#[doc = "Register `F5R1` writer"] pub type W = crate :: W < F5r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F5r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F5r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F5r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F5r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F5r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F5r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F5r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F5r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F5r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F5r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F5r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F5r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F5r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F5r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F5r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F5r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F5r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F5r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F5r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F5r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F5r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F5r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F5r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F5r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F5r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F5r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F5r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F5r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F5r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F5r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F5r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F5r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 5 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f5r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f5r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F5r1Spec ; impl crate :: RegisterSpec for F5r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f5r1::R`](R) reader structure"] impl crate :: Readable for F5r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f5r1::W`](W) writer structure"] impl crate :: Writable for F5r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F5R1 to value 0"] impl crate :: Resettable for F5r1Spec { } }
#[doc = "F5R2 (rw) register accessor: Filter bank 5 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f5r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f5r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f5r2`] module"]
#[doc (alias = "F5R2")] pub type F5r2 = crate :: Reg < f5r2 :: F5r2Spec > ;
#[doc = "Filter bank 5 register 2"] pub mod f5r2 {
#[doc = "Register `F5R2` reader"] pub type R = crate :: R < F5r2Spec > ;
#[doc = "Register `F5R2` writer"] pub type W = crate :: W < F5r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F5r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F5r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F5r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F5r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F5r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F5r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F5r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F5r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F5r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F5r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F5r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F5r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F5r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F5r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F5r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F5r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F5r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F5r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F5r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F5r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F5r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F5r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F5r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F5r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F5r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F5r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F5r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F5r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F5r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F5r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F5r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F5r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 5 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f5r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f5r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F5r2Spec ; impl crate :: RegisterSpec for F5r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f5r2::R`](R) reader structure"] impl crate :: Readable for F5r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f5r2::W`](W) writer structure"] impl crate :: Writable for F5r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F5R2 to value 0"] impl crate :: Resettable for F5r2Spec { } }
#[doc = "F6R1 (rw) register accessor: Filter bank 6 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f6r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f6r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f6r1`] module"]
#[doc (alias = "F6R1")] pub type F6r1 = crate :: Reg < f6r1 :: F6r1Spec > ;
#[doc = "Filter bank 6 register 1"] pub mod f6r1 {
#[doc = "Register `F6R1` reader"] pub type R = crate :: R < F6r1Spec > ;
#[doc = "Register `F6R1` writer"] pub type W = crate :: W < F6r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F6r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F6r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F6r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F6r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F6r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F6r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F6r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F6r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F6r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F6r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F6r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F6r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F6r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F6r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F6r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F6r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F6r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F6r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F6r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F6r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F6r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F6r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F6r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F6r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F6r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F6r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F6r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F6r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F6r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F6r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F6r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F6r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 6 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f6r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f6r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F6r1Spec ; impl crate :: RegisterSpec for F6r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f6r1::R`](R) reader structure"] impl crate :: Readable for F6r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f6r1::W`](W) writer structure"] impl crate :: Writable for F6r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F6R1 to value 0"] impl crate :: Resettable for F6r1Spec { } }
#[doc = "F6R2 (rw) register accessor: Filter bank 6 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f6r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f6r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f6r2`] module"]
#[doc (alias = "F6R2")] pub type F6r2 = crate :: Reg < f6r2 :: F6r2Spec > ;
#[doc = "Filter bank 6 register 2"] pub mod f6r2 {
#[doc = "Register `F6R2` reader"] pub type R = crate :: R < F6r2Spec > ;
#[doc = "Register `F6R2` writer"] pub type W = crate :: W < F6r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F6r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F6r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F6r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F6r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F6r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F6r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F6r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F6r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F6r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F6r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F6r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F6r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F6r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F6r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F6r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F6r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F6r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F6r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F6r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F6r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F6r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F6r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F6r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F6r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F6r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F6r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F6r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F6r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F6r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F6r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F6r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F6r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 6 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f6r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f6r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F6r2Spec ; impl crate :: RegisterSpec for F6r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f6r2::R`](R) reader structure"] impl crate :: Readable for F6r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f6r2::W`](W) writer structure"] impl crate :: Writable for F6r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F6R2 to value 0"] impl crate :: Resettable for F6r2Spec { } }
#[doc = "F7R1 (rw) register accessor: Filter bank 7 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f7r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f7r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f7r1`] module"]
#[doc (alias = "F7R1")] pub type F7r1 = crate :: Reg < f7r1 :: F7r1Spec > ;
#[doc = "Filter bank 7 register 1"] pub mod f7r1 {
#[doc = "Register `F7R1` reader"] pub type R = crate :: R < F7r1Spec > ;
#[doc = "Register `F7R1` writer"] pub type W = crate :: W < F7r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F7r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F7r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F7r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F7r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F7r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F7r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F7r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F7r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F7r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F7r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F7r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F7r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F7r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F7r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F7r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F7r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F7r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F7r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F7r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F7r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F7r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F7r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F7r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F7r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F7r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F7r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F7r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F7r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F7r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F7r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F7r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F7r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 7 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f7r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f7r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F7r1Spec ; impl crate :: RegisterSpec for F7r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f7r1::R`](R) reader structure"] impl crate :: Readable for F7r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f7r1::W`](W) writer structure"] impl crate :: Writable for F7r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F7R1 to value 0"] impl crate :: Resettable for F7r1Spec { } }
#[doc = "F7R2 (rw) register accessor: Filter bank 7 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f7r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f7r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f7r2`] module"]
#[doc (alias = "F7R2")] pub type F7r2 = crate :: Reg < f7r2 :: F7r2Spec > ;
#[doc = "Filter bank 7 register 2"] pub mod f7r2 {
#[doc = "Register `F7R2` reader"] pub type R = crate :: R < F7r2Spec > ;
#[doc = "Register `F7R2` writer"] pub type W = crate :: W < F7r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F7r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F7r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F7r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F7r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F7r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F7r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F7r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F7r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F7r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F7r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F7r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F7r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F7r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F7r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F7r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F7r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F7r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F7r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F7r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F7r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F7r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F7r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F7r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F7r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F7r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F7r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F7r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F7r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F7r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F7r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F7r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F7r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 7 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f7r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f7r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F7r2Spec ; impl crate :: RegisterSpec for F7r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f7r2::R`](R) reader structure"] impl crate :: Readable for F7r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f7r2::W`](W) writer structure"] impl crate :: Writable for F7r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F7R2 to value 0"] impl crate :: Resettable for F7r2Spec { } }
#[doc = "F8R1 (rw) register accessor: Filter bank 8 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f8r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f8r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f8r1`] module"]
#[doc (alias = "F8R1")] pub type F8r1 = crate :: Reg < f8r1 :: F8r1Spec > ;
#[doc = "Filter bank 8 register 1"] pub mod f8r1 {
#[doc = "Register `F8R1` reader"] pub type R = crate :: R < F8r1Spec > ;
#[doc = "Register `F8R1` writer"] pub type W = crate :: W < F8r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F8r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F8r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F8r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F8r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F8r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F8r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F8r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F8r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F8r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F8r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F8r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F8r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F8r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F8r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F8r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F8r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F8r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F8r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F8r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F8r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F8r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F8r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F8r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F8r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F8r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F8r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F8r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F8r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F8r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F8r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F8r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F8r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 8 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f8r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f8r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F8r1Spec ; impl crate :: RegisterSpec for F8r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f8r1::R`](R) reader structure"] impl crate :: Readable for F8r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f8r1::W`](W) writer structure"] impl crate :: Writable for F8r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F8R1 to value 0"] impl crate :: Resettable for F8r1Spec { } }
#[doc = "F8R2 (rw) register accessor: Filter bank 8 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f8r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f8r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f8r2`] module"]
#[doc (alias = "F8R2")] pub type F8r2 = crate :: Reg < f8r2 :: F8r2Spec > ;
#[doc = "Filter bank 8 register 2"] pub mod f8r2 {
#[doc = "Register `F8R2` reader"] pub type R = crate :: R < F8r2Spec > ;
#[doc = "Register `F8R2` writer"] pub type W = crate :: W < F8r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F8r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F8r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F8r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F8r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F8r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F8r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F8r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F8r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F8r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F8r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F8r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F8r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F8r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F8r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F8r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F8r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F8r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F8r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F8r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F8r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F8r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F8r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F8r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F8r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F8r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F8r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F8r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F8r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F8r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F8r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F8r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F8r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 8 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f8r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f8r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F8r2Spec ; impl crate :: RegisterSpec for F8r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f8r2::R`](R) reader structure"] impl crate :: Readable for F8r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f8r2::W`](W) writer structure"] impl crate :: Writable for F8r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F8R2 to value 0"] impl crate :: Resettable for F8r2Spec { } }
#[doc = "F9R1 (rw) register accessor: Filter bank 9 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f9r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f9r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f9r1`] module"]
#[doc (alias = "F9R1")] pub type F9r1 = crate :: Reg < f9r1 :: F9r1Spec > ;
#[doc = "Filter bank 9 register 1"] pub mod f9r1 {
#[doc = "Register `F9R1` reader"] pub type R = crate :: R < F9r1Spec > ;
#[doc = "Register `F9R1` writer"] pub type W = crate :: W < F9r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F9r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F9r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F9r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F9r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F9r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F9r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F9r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F9r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F9r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F9r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F9r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F9r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F9r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F9r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F9r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F9r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F9r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F9r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F9r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F9r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F9r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F9r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F9r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F9r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F9r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F9r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F9r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F9r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F9r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F9r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F9r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F9r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 9 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f9r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f9r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F9r1Spec ; impl crate :: RegisterSpec for F9r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f9r1::R`](R) reader structure"] impl crate :: Readable for F9r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f9r1::W`](W) writer structure"] impl crate :: Writable for F9r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F9R1 to value 0"] impl crate :: Resettable for F9r1Spec { } }
#[doc = "F9R2 (rw) register accessor: Filter bank 9 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f9r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f9r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f9r2`] module"]
#[doc (alias = "F9R2")] pub type F9r2 = crate :: Reg < f9r2 :: F9r2Spec > ;
#[doc = "Filter bank 9 register 2"] pub mod f9r2 {
#[doc = "Register `F9R2` reader"] pub type R = crate :: R < F9r2Spec > ;
#[doc = "Register `F9R2` writer"] pub type W = crate :: W < F9r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F9r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F9r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F9r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F9r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F9r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F9r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F9r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F9r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F9r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F9r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F9r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F9r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F9r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F9r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F9r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F9r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F9r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F9r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F9r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F9r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F9r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F9r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F9r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F9r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F9r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F9r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F9r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F9r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F9r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F9r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F9r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F9r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 9 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f9r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f9r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F9r2Spec ; impl crate :: RegisterSpec for F9r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f9r2::R`](R) reader structure"] impl crate :: Readable for F9r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f9r2::W`](W) writer structure"] impl crate :: Writable for F9r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F9R2 to value 0"] impl crate :: Resettable for F9r2Spec { } }
#[doc = "F10R1 (rw) register accessor: Filter bank 10 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f10r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f10r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f10r1`] module"]
#[doc (alias = "F10R1")] pub type F10r1 = crate :: Reg < f10r1 :: F10r1Spec > ;
#[doc = "Filter bank 10 register 1"] pub mod f10r1 {
#[doc = "Register `F10R1` reader"] pub type R = crate :: R < F10r1Spec > ;
#[doc = "Register `F10R1` writer"] pub type W = crate :: W < F10r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F10r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F10r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F10r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F10r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F10r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F10r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F10r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F10r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F10r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F10r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F10r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F10r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F10r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F10r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F10r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F10r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F10r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F10r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F10r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F10r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F10r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F10r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F10r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F10r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F10r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F10r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F10r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F10r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F10r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F10r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F10r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F10r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 10 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f10r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f10r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F10r1Spec ; impl crate :: RegisterSpec for F10r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f10r1::R`](R) reader structure"] impl crate :: Readable for F10r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f10r1::W`](W) writer structure"] impl crate :: Writable for F10r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F10R1 to value 0"] impl crate :: Resettable for F10r1Spec { } }
#[doc = "F10R2 (rw) register accessor: Filter bank 10 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f10r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f10r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f10r2`] module"]
#[doc (alias = "F10R2")] pub type F10r2 = crate :: Reg < f10r2 :: F10r2Spec > ;
#[doc = "Filter bank 10 register 2"] pub mod f10r2 {
#[doc = "Register `F10R2` reader"] pub type R = crate :: R < F10r2Spec > ;
#[doc = "Register `F10R2` writer"] pub type W = crate :: W < F10r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F10r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F10r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F10r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F10r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F10r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F10r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F10r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F10r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F10r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F10r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F10r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F10r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F10r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F10r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F10r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F10r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F10r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F10r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F10r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F10r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F10r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F10r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F10r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F10r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F10r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F10r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F10r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F10r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F10r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F10r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F10r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F10r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 10 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f10r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f10r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F10r2Spec ; impl crate :: RegisterSpec for F10r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f10r2::R`](R) reader structure"] impl crate :: Readable for F10r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f10r2::W`](W) writer structure"] impl crate :: Writable for F10r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F10R2 to value 0"] impl crate :: Resettable for F10r2Spec { } }
#[doc = "F11R1 (rw) register accessor: Filter bank 11 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f11r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f11r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f11r1`] module"]
#[doc (alias = "F11R1")] pub type F11r1 = crate :: Reg < f11r1 :: F11r1Spec > ;
#[doc = "Filter bank 11 register 1"] pub mod f11r1 {
#[doc = "Register `F11R1` reader"] pub type R = crate :: R < F11r1Spec > ;
#[doc = "Register `F11R1` writer"] pub type W = crate :: W < F11r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F11r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F11r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F11r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F11r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F11r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F11r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F11r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F11r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F11r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F11r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F11r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F11r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F11r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F11r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F11r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F11r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F11r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F11r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F11r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F11r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F11r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F11r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F11r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F11r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F11r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F11r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F11r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F11r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F11r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F11r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F11r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F11r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 11 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f11r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f11r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F11r1Spec ; impl crate :: RegisterSpec for F11r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f11r1::R`](R) reader structure"] impl crate :: Readable for F11r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f11r1::W`](W) writer structure"] impl crate :: Writable for F11r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F11R1 to value 0"] impl crate :: Resettable for F11r1Spec { } }
#[doc = "F11R2 (rw) register accessor: Filter bank 11 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f11r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f11r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f11r2`] module"]
#[doc (alias = "F11R2")] pub type F11r2 = crate :: Reg < f11r2 :: F11r2Spec > ;
#[doc = "Filter bank 11 register 2"] pub mod f11r2 {
#[doc = "Register `F11R2` reader"] pub type R = crate :: R < F11r2Spec > ;
#[doc = "Register `F11R2` writer"] pub type W = crate :: W < F11r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F11r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F11r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F11r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F11r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F11r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F11r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F11r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F11r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F11r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F11r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F11r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F11r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F11r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F11r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F11r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F11r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F11r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F11r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F11r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F11r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F11r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F11r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F11r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F11r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F11r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F11r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F11r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F11r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F11r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F11r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F11r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F11r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 11 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f11r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f11r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F11r2Spec ; impl crate :: RegisterSpec for F11r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f11r2::R`](R) reader structure"] impl crate :: Readable for F11r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f11r2::W`](W) writer structure"] impl crate :: Writable for F11r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F11R2 to value 0"] impl crate :: Resettable for F11r2Spec { } }
#[doc = "F12R1 (rw) register accessor: Filter bank 4 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f12r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f12r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f12r1`] module"]
#[doc (alias = "F12R1")] pub type F12r1 = crate :: Reg < f12r1 :: F12r1Spec > ;
#[doc = "Filter bank 4 register 1"] pub mod f12r1 {
#[doc = "Register `F12R1` reader"] pub type R = crate :: R < F12r1Spec > ;
#[doc = "Register `F12R1` writer"] pub type W = crate :: W < F12r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F12r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F12r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F12r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F12r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F12r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F12r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F12r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F12r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F12r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F12r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F12r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F12r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F12r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F12r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F12r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F12r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F12r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F12r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F12r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F12r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F12r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F12r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F12r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F12r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F12r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F12r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F12r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F12r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F12r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F12r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F12r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F12r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 4 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f12r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f12r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F12r1Spec ; impl crate :: RegisterSpec for F12r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f12r1::R`](R) reader structure"] impl crate :: Readable for F12r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f12r1::W`](W) writer structure"] impl crate :: Writable for F12r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F12R1 to value 0"] impl crate :: Resettable for F12r1Spec { } }
#[doc = "F12R2 (rw) register accessor: Filter bank 12 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f12r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f12r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f12r2`] module"]
#[doc (alias = "F12R2")] pub type F12r2 = crate :: Reg < f12r2 :: F12r2Spec > ;
#[doc = "Filter bank 12 register 2"] pub mod f12r2 {
#[doc = "Register `F12R2` reader"] pub type R = crate :: R < F12r2Spec > ;
#[doc = "Register `F12R2` writer"] pub type W = crate :: W < F12r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F12r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F12r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F12r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F12r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F12r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F12r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F12r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F12r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F12r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F12r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F12r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F12r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F12r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F12r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F12r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F12r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F12r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F12r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F12r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F12r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F12r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F12r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F12r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F12r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F12r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F12r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F12r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F12r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F12r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F12r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F12r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F12r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 12 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f12r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f12r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F12r2Spec ; impl crate :: RegisterSpec for F12r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f12r2::R`](R) reader structure"] impl crate :: Readable for F12r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f12r2::W`](W) writer structure"] impl crate :: Writable for F12r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F12R2 to value 0"] impl crate :: Resettable for F12r2Spec { } }
#[doc = "F13R1 (rw) register accessor: Filter bank 13 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f13r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f13r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f13r1`] module"]
#[doc (alias = "F13R1")] pub type F13r1 = crate :: Reg < f13r1 :: F13r1Spec > ;
#[doc = "Filter bank 13 register 1"] pub mod f13r1 {
#[doc = "Register `F13R1` reader"] pub type R = crate :: R < F13r1Spec > ;
#[doc = "Register `F13R1` writer"] pub type W = crate :: W < F13r1Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F13r1Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F13r1Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F13r1Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F13r1Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F13r1Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F13r1Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F13r1Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F13r1Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F13r1Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F13r1Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F13r1Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F13r1Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F13r1Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F13r1Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F13r1Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F13r1Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F13r1Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F13r1Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F13r1Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F13r1Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F13r1Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F13r1Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F13r1Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F13r1Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F13r1Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F13r1Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F13r1Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F13r1Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F13r1Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F13r1Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F13r1Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F13r1Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 13 register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`f13r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f13r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F13r1Spec ; impl crate :: RegisterSpec for F13r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f13r1::R`](R) reader structure"] impl crate :: Readable for F13r1Spec { }
#[doc = "`write(|w| ..)` method takes [`f13r1::W`](W) writer structure"] impl crate :: Writable for F13r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F13R1 to value 0"] impl crate :: Resettable for F13r1Spec { } }
#[doc = "F13R2 (rw) register accessor: Filter bank 13 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f13r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f13r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@f13r2`] module"]
#[doc (alias = "F13R2")] pub type F13r2 = crate :: Reg < f13r2 :: F13r2Spec > ;
#[doc = "Filter bank 13 register 2"] pub mod f13r2 {
#[doc = "Register `F13R2` reader"] pub type R = crate :: R < F13r2Spec > ;
#[doc = "Register `F13R2` writer"] pub type W = crate :: W < F13r2Spec > ;
#[doc = "Field `FB0` reader - Filter bits"] pub type Fb0R = crate :: BitReader ;
#[doc = "Field `FB0` writer - Filter bits"] pub type Fb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB1` reader - Filter bits"] pub type Fb1R = crate :: BitReader ;
#[doc = "Field `FB1` writer - Filter bits"] pub type Fb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB2` reader - Filter bits"] pub type Fb2R = crate :: BitReader ;
#[doc = "Field `FB2` writer - Filter bits"] pub type Fb2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB3` reader - Filter bits"] pub type Fb3R = crate :: BitReader ;
#[doc = "Field `FB3` writer - Filter bits"] pub type Fb3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB4` reader - Filter bits"] pub type Fb4R = crate :: BitReader ;
#[doc = "Field `FB4` writer - Filter bits"] pub type Fb4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB5` reader - Filter bits"] pub type Fb5R = crate :: BitReader ;
#[doc = "Field `FB5` writer - Filter bits"] pub type Fb5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB6` reader - Filter bits"] pub type Fb6R = crate :: BitReader ;
#[doc = "Field `FB6` writer - Filter bits"] pub type Fb6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB7` reader - Filter bits"] pub type Fb7R = crate :: BitReader ;
#[doc = "Field `FB7` writer - Filter bits"] pub type Fb7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB8` reader - Filter bits"] pub type Fb8R = crate :: BitReader ;
#[doc = "Field `FB8` writer - Filter bits"] pub type Fb8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB9` reader - Filter bits"] pub type Fb9R = crate :: BitReader ;
#[doc = "Field `FB9` writer - Filter bits"] pub type Fb9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB10` reader - Filter bits"] pub type Fb10R = crate :: BitReader ;
#[doc = "Field `FB10` writer - Filter bits"] pub type Fb10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB11` reader - Filter bits"] pub type Fb11R = crate :: BitReader ;
#[doc = "Field `FB11` writer - Filter bits"] pub type Fb11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB12` reader - Filter bits"] pub type Fb12R = crate :: BitReader ;
#[doc = "Field `FB12` writer - Filter bits"] pub type Fb12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB13` reader - Filter bits"] pub type Fb13R = crate :: BitReader ;
#[doc = "Field `FB13` writer - Filter bits"] pub type Fb13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB14` reader - Filter bits"] pub type Fb14R = crate :: BitReader ;
#[doc = "Field `FB14` writer - Filter bits"] pub type Fb14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB15` reader - Filter bits"] pub type Fb15R = crate :: BitReader ;
#[doc = "Field `FB15` writer - Filter bits"] pub type Fb15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB16` reader - Filter bits"] pub type Fb16R = crate :: BitReader ;
#[doc = "Field `FB16` writer - Filter bits"] pub type Fb16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB17` reader - Filter bits"] pub type Fb17R = crate :: BitReader ;
#[doc = "Field `FB17` writer - Filter bits"] pub type Fb17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB18` reader - Filter bits"] pub type Fb18R = crate :: BitReader ;
#[doc = "Field `FB18` writer - Filter bits"] pub type Fb18W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB19` reader - Filter bits"] pub type Fb19R = crate :: BitReader ;
#[doc = "Field `FB19` writer - Filter bits"] pub type Fb19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB20` reader - Filter bits"] pub type Fb20R = crate :: BitReader ;
#[doc = "Field `FB20` writer - Filter bits"] pub type Fb20W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB21` reader - Filter bits"] pub type Fb21R = crate :: BitReader ;
#[doc = "Field `FB21` writer - Filter bits"] pub type Fb21W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB22` reader - Filter bits"] pub type Fb22R = crate :: BitReader ;
#[doc = "Field `FB22` writer - Filter bits"] pub type Fb22W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB23` reader - Filter bits"] pub type Fb23R = crate :: BitReader ;
#[doc = "Field `FB23` writer - Filter bits"] pub type Fb23W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB24` reader - Filter bits"] pub type Fb24R = crate :: BitReader ;
#[doc = "Field `FB24` writer - Filter bits"] pub type Fb24W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB25` reader - Filter bits"] pub type Fb25R = crate :: BitReader ;
#[doc = "Field `FB25` writer - Filter bits"] pub type Fb25W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB26` reader - Filter bits"] pub type Fb26R = crate :: BitReader ;
#[doc = "Field `FB26` writer - Filter bits"] pub type Fb26W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB27` reader - Filter bits"] pub type Fb27R = crate :: BitReader ;
#[doc = "Field `FB27` writer - Filter bits"] pub type Fb27W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB28` reader - Filter bits"] pub type Fb28R = crate :: BitReader ;
#[doc = "Field `FB28` writer - Filter bits"] pub type Fb28W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB29` reader - Filter bits"] pub type Fb29R = crate :: BitReader ;
#[doc = "Field `FB29` writer - Filter bits"] pub type Fb29W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB30` reader - Filter bits"] pub type Fb30R = crate :: BitReader ;
#[doc = "Field `FB30` writer - Filter bits"] pub type Fb30W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FB31` reader - Filter bits"] pub type Fb31R = crate :: BitReader ;
#[doc = "Field `FB31` writer - Filter bits"] pub type Fb31W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& self) -> Fb0R { Fb0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& self) -> Fb1R { Fb1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& self) -> Fb2R { Fb2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& self) -> Fb3R { Fb3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& self) -> Fb4R { Fb4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& self) -> Fb5R { Fb5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& self) -> Fb6R { Fb6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& self) -> Fb7R { Fb7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& self) -> Fb8R { Fb8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& self) -> Fb9R { Fb9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& self) -> Fb10R { Fb10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& self) -> Fb11R { Fb11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& self) -> Fb12R { Fb12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& self) -> Fb13R { Fb13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& self) -> Fb14R { Fb14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& self) -> Fb15R { Fb15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& self) -> Fb16R { Fb16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& self) -> Fb17R { Fb17R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& self) -> Fb18R { Fb18R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& self) -> Fb19R { Fb19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& self) -> Fb20R { Fb20R :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& self) -> Fb21R { Fb21R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& self) -> Fb22R { Fb22R :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& self) -> Fb23R { Fb23R :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& self) -> Fb24R { Fb24R :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& self) -> Fb25R { Fb25R :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& self) -> Fb26R { Fb26R :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& self) -> Fb27R { Fb27R :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& self) -> Fb28R { Fb28R :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& self) -> Fb29R { Fb29R :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& self) -> Fb30R { Fb30R :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& self) -> Fb31R { Fb31R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Filter bits"]
#[inline (always)] pub fn fb0 (& mut self) -> Fb0W < '_ , F13r2Spec > { Fb0W :: new (self , 0) }
#[doc = "Bit 1 - Filter bits"]
#[inline (always)] pub fn fb1 (& mut self) -> Fb1W < '_ , F13r2Spec > { Fb1W :: new (self , 1) }
#[doc = "Bit 2 - Filter bits"]
#[inline (always)] pub fn fb2 (& mut self) -> Fb2W < '_ , F13r2Spec > { Fb2W :: new (self , 2) }
#[doc = "Bit 3 - Filter bits"]
#[inline (always)] pub fn fb3 (& mut self) -> Fb3W < '_ , F13r2Spec > { Fb3W :: new (self , 3) }
#[doc = "Bit 4 - Filter bits"]
#[inline (always)] pub fn fb4 (& mut self) -> Fb4W < '_ , F13r2Spec > { Fb4W :: new (self , 4) }
#[doc = "Bit 5 - Filter bits"]
#[inline (always)] pub fn fb5 (& mut self) -> Fb5W < '_ , F13r2Spec > { Fb5W :: new (self , 5) }
#[doc = "Bit 6 - Filter bits"]
#[inline (always)] pub fn fb6 (& mut self) -> Fb6W < '_ , F13r2Spec > { Fb6W :: new (self , 6) }
#[doc = "Bit 7 - Filter bits"]
#[inline (always)] pub fn fb7 (& mut self) -> Fb7W < '_ , F13r2Spec > { Fb7W :: new (self , 7) }
#[doc = "Bit 8 - Filter bits"]
#[inline (always)] pub fn fb8 (& mut self) -> Fb8W < '_ , F13r2Spec > { Fb8W :: new (self , 8) }
#[doc = "Bit 9 - Filter bits"]
#[inline (always)] pub fn fb9 (& mut self) -> Fb9W < '_ , F13r2Spec > { Fb9W :: new (self , 9) }
#[doc = "Bit 10 - Filter bits"]
#[inline (always)] pub fn fb10 (& mut self) -> Fb10W < '_ , F13r2Spec > { Fb10W :: new (self , 10) }
#[doc = "Bit 11 - Filter bits"]
#[inline (always)] pub fn fb11 (& mut self) -> Fb11W < '_ , F13r2Spec > { Fb11W :: new (self , 11) }
#[doc = "Bit 12 - Filter bits"]
#[inline (always)] pub fn fb12 (& mut self) -> Fb12W < '_ , F13r2Spec > { Fb12W :: new (self , 12) }
#[doc = "Bit 13 - Filter bits"]
#[inline (always)] pub fn fb13 (& mut self) -> Fb13W < '_ , F13r2Spec > { Fb13W :: new (self , 13) }
#[doc = "Bit 14 - Filter bits"]
#[inline (always)] pub fn fb14 (& mut self) -> Fb14W < '_ , F13r2Spec > { Fb14W :: new (self , 14) }
#[doc = "Bit 15 - Filter bits"]
#[inline (always)] pub fn fb15 (& mut self) -> Fb15W < '_ , F13r2Spec > { Fb15W :: new (self , 15) }
#[doc = "Bit 16 - Filter bits"]
#[inline (always)] pub fn fb16 (& mut self) -> Fb16W < '_ , F13r2Spec > { Fb16W :: new (self , 16) }
#[doc = "Bit 17 - Filter bits"]
#[inline (always)] pub fn fb17 (& mut self) -> Fb17W < '_ , F13r2Spec > { Fb17W :: new (self , 17) }
#[doc = "Bit 18 - Filter bits"]
#[inline (always)] pub fn fb18 (& mut self) -> Fb18W < '_ , F13r2Spec > { Fb18W :: new (self , 18) }
#[doc = "Bit 19 - Filter bits"]
#[inline (always)] pub fn fb19 (& mut self) -> Fb19W < '_ , F13r2Spec > { Fb19W :: new (self , 19) }
#[doc = "Bit 20 - Filter bits"]
#[inline (always)] pub fn fb20 (& mut self) -> Fb20W < '_ , F13r2Spec > { Fb20W :: new (self , 20) }
#[doc = "Bit 21 - Filter bits"]
#[inline (always)] pub fn fb21 (& mut self) -> Fb21W < '_ , F13r2Spec > { Fb21W :: new (self , 21) }
#[doc = "Bit 22 - Filter bits"]
#[inline (always)] pub fn fb22 (& mut self) -> Fb22W < '_ , F13r2Spec > { Fb22W :: new (self , 22) }
#[doc = "Bit 23 - Filter bits"]
#[inline (always)] pub fn fb23 (& mut self) -> Fb23W < '_ , F13r2Spec > { Fb23W :: new (self , 23) }
#[doc = "Bit 24 - Filter bits"]
#[inline (always)] pub fn fb24 (& mut self) -> Fb24W < '_ , F13r2Spec > { Fb24W :: new (self , 24) }
#[doc = "Bit 25 - Filter bits"]
#[inline (always)] pub fn fb25 (& mut self) -> Fb25W < '_ , F13r2Spec > { Fb25W :: new (self , 25) }
#[doc = "Bit 26 - Filter bits"]
#[inline (always)] pub fn fb26 (& mut self) -> Fb26W < '_ , F13r2Spec > { Fb26W :: new (self , 26) }
#[doc = "Bit 27 - Filter bits"]
#[inline (always)] pub fn fb27 (& mut self) -> Fb27W < '_ , F13r2Spec > { Fb27W :: new (self , 27) }
#[doc = "Bit 28 - Filter bits"]
#[inline (always)] pub fn fb28 (& mut self) -> Fb28W < '_ , F13r2Spec > { Fb28W :: new (self , 28) }
#[doc = "Bit 29 - Filter bits"]
#[inline (always)] pub fn fb29 (& mut self) -> Fb29W < '_ , F13r2Spec > { Fb29W :: new (self , 29) }
#[doc = "Bit 30 - Filter bits"]
#[inline (always)] pub fn fb30 (& mut self) -> Fb30W < '_ , F13r2Spec > { Fb30W :: new (self , 30) }
#[doc = "Bit 31 - Filter bits"]
#[inline (always)] pub fn fb31 (& mut self) -> Fb31W < '_ , F13r2Spec > { Fb31W :: new (self , 31) } }
#[doc = "Filter bank 13 register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`f13r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`f13r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct F13r2Spec ; impl crate :: RegisterSpec for F13r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`f13r2::R`](R) reader structure"] impl crate :: Readable for F13r2Spec { }
#[doc = "`write(|w| ..)` method takes [`f13r2::W`](W) writer structure"] impl crate :: Writable for F13r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets F13R2 to value 0"] impl crate :: Resettable for F13r2Spec { } } }
#[doc = "Controller area network"] pub type Can2 = crate :: Periph < can1 :: RegisterBlock , 0x4000_6800 > ; impl core :: fmt :: Debug for Can2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Can2") . finish () } }
#[doc = "Controller area network"] pub use self :: can1 as can2 ;
#[doc = "Digital to analog converter"] pub type Dac = crate :: Periph < dac :: RegisterBlock , 0x4000_7400 > ; impl core :: fmt :: Debug for Dac { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dac") . finish () } }
#[doc = "Digital to analog converter"] pub mod dac {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , swtrigr : Swtrigr , dhr12r1 : Dhr12r1 , dhr12l1 : Dhr12l1 , dhr8r1 : Dhr8r1 , dhr12r2 : Dhr12r2 , dhr12l2 : Dhr12l2 , dhr8r2 : Dhr8r2 , dhr12rd : Dhr12rd , dhr12ld : Dhr12ld , dhr8rd : Dhr8rd , dor1 : Dor1 , dor2 : Dor2 , } impl RegisterBlock {
#[doc = "0x00 - Control register (DAC_CR)"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - DAC software trigger register (DAC_SWTRIGR)"]
#[inline (always)] pub const fn swtrigr (& self) -> & Swtrigr { & self . swtrigr }
#[doc = "0x08 - DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)"]
#[inline (always)] pub const fn dhr12r1 (& self) -> & Dhr12r1 { & self . dhr12r1 }
#[doc = "0x0c - DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)"]
#[inline (always)] pub const fn dhr12l1 (& self) -> & Dhr12l1 { & self . dhr12l1 }
#[doc = "0x10 - DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)"]
#[inline (always)] pub const fn dhr8r1 (& self) -> & Dhr8r1 { & self . dhr8r1 }
#[doc = "0x14 - DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)"]
#[inline (always)] pub const fn dhr12r2 (& self) -> & Dhr12r2 { & self . dhr12r2 }
#[doc = "0x18 - DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)"]
#[inline (always)] pub const fn dhr12l2 (& self) -> & Dhr12l2 { & self . dhr12l2 }
#[doc = "0x1c - DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)"]
#[inline (always)] pub const fn dhr8r2 (& self) -> & Dhr8r2 { & self . dhr8r2 }
#[doc = "0x20 - Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved"]
#[inline (always)] pub const fn dhr12rd (& self) -> & Dhr12rd { & self . dhr12rd }
#[doc = "0x24 - DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved"]
#[inline (always)] pub const fn dhr12ld (& self) -> & Dhr12ld { & self . dhr12ld }
#[doc = "0x28 - DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved"]
#[inline (always)] pub const fn dhr8rd (& self) -> & Dhr8rd { & self . dhr8rd }
#[doc = "0x2c - DAC channel1 data output register (DAC_DOR1)"]
#[inline (always)] pub const fn dor1 (& self) -> & Dor1 { & self . dor1 }
#[doc = "0x30 - DAC channel2 data output register (DAC_DOR2)"]
#[inline (always)] pub const fn dor2 (& self) -> & Dor2 { & self . dor2 } }
#[doc = "CR (rw) register accessor: Control register (DAC_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register (DAC_CR)"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `EN1` reader - DAC channel1 enable"] pub type En1R = crate :: BitReader ;
#[doc = "Field `EN1` writer - DAC channel1 enable"] pub type En1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BOFF1` reader - DAC channel1 output buffer disable"] pub type Boff1R = crate :: BitReader ;
#[doc = "Field `BOFF1` writer - DAC channel1 output buffer disable"] pub type Boff1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEN1` reader - DAC channel1 trigger enable"] pub type Ten1R = crate :: BitReader ;
#[doc = "Field `TEN1` writer - DAC channel1 trigger enable"] pub type Ten1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSEL1` reader - DAC channel1 trigger selection"] pub type Tsel1R = crate :: FieldReader ;
#[doc = "Field `TSEL1` writer - DAC channel1 trigger selection"] pub type Tsel1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `WAVE1` reader - DAC channel1 noise/triangle wave generation enable"] pub type Wave1R = crate :: FieldReader ;
#[doc = "Field `WAVE1` writer - DAC channel1 noise/triangle wave generation enable"] pub type Wave1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MAMP1` reader - DAC channel1 mask/amplitude selector"] pub type Mamp1R = crate :: FieldReader ;
#[doc = "Field `MAMP1` writer - DAC channel1 mask/amplitude selector"] pub type Mamp1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DMAEN1` reader - DAC channel1 DMA enable"] pub type Dmaen1R = crate :: BitReader ;
#[doc = "Field `DMAEN1` writer - DAC channel1 DMA enable"] pub type Dmaen1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EN2` reader - DAC channel2 enable"] pub type En2R = crate :: BitReader ;
#[doc = "Field `EN2` writer - DAC channel2 enable"] pub type En2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BOFF2` reader - DAC channel2 output buffer disable"] pub type Boff2R = crate :: BitReader ;
#[doc = "Field `BOFF2` writer - DAC channel2 output buffer disable"] pub type Boff2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEN2` reader - DAC channel2 trigger enable"] pub type Ten2R = crate :: BitReader ;
#[doc = "Field `TEN2` writer - DAC channel2 trigger enable"] pub type Ten2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSEL2` reader - DAC channel2 trigger selection"] pub type Tsel2R = crate :: FieldReader ;
#[doc = "Field `TSEL2` writer - DAC channel2 trigger selection"] pub type Tsel2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `WAVE2` reader - DAC channel2 noise/triangle wave generation enable"] pub type Wave2R = crate :: FieldReader ;
#[doc = "Field `WAVE2` writer - DAC channel2 noise/triangle wave generation enable"] pub type Wave2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MAMP2` reader - DAC channel2 mask/amplitude selector"] pub type Mamp2R = crate :: FieldReader ;
#[doc = "Field `MAMP2` writer - DAC channel2 mask/amplitude selector"] pub type Mamp2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DMAEN2` reader - DAC channel2 DMA enable"] pub type Dmaen2R = crate :: BitReader ;
#[doc = "Field `DMAEN2` writer - DAC channel2 DMA enable"] pub type Dmaen2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DAC channel1 enable"]
#[inline (always)] pub fn en1 (& self) -> En1R { En1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DAC channel1 output buffer disable"]
#[inline (always)] pub fn boff1 (& self) -> Boff1R { Boff1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - DAC channel1 trigger enable"]
#[inline (always)] pub fn ten1 (& self) -> Ten1R { Ten1R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:5 - DAC channel1 trigger selection"]
#[inline (always)] pub fn tsel1 (& self) -> Tsel1R { Tsel1R :: new (((self . bits >> 3) & 7) as u8) }
#[doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable"]
#[inline (always)] pub fn wave1 (& self) -> Wave1R { Wave1R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:11 - DAC channel1 mask/amplitude selector"]
#[inline (always)] pub fn mamp1 (& self) -> Mamp1R { Mamp1R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bit 12 - DAC channel1 DMA enable"]
#[inline (always)] pub fn dmaen1 (& self) -> Dmaen1R { Dmaen1R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - DAC channel2 enable"]
#[inline (always)] pub fn en2 (& self) -> En2R { En2R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - DAC channel2 output buffer disable"]
#[inline (always)] pub fn boff2 (& self) -> Boff2R { Boff2R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - DAC channel2 trigger enable"]
#[inline (always)] pub fn ten2 (& self) -> Ten2R { Ten2R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bits 19:21 - DAC channel2 trigger selection"]
#[inline (always)] pub fn tsel2 (& self) -> Tsel2R { Tsel2R :: new (((self . bits >> 19) & 7) as u8) }
#[doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable"]
#[inline (always)] pub fn wave2 (& self) -> Wave2R { Wave2R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:27 - DAC channel2 mask/amplitude selector"]
#[inline (always)] pub fn mamp2 (& self) -> Mamp2R { Mamp2R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bit 28 - DAC channel2 DMA enable"]
#[inline (always)] pub fn dmaen2 (& self) -> Dmaen2R { Dmaen2R :: new (((self . bits >> 28) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DAC channel1 enable"]
#[inline (always)] pub fn en1 (& mut self) -> En1W < '_ , CrSpec > { En1W :: new (self , 0) }
#[doc = "Bit 1 - DAC channel1 output buffer disable"]
#[inline (always)] pub fn boff1 (& mut self) -> Boff1W < '_ , CrSpec > { Boff1W :: new (self , 1) }
#[doc = "Bit 2 - DAC channel1 trigger enable"]
#[inline (always)] pub fn ten1 (& mut self) -> Ten1W < '_ , CrSpec > { Ten1W :: new (self , 2) }
#[doc = "Bits 3:5 - DAC channel1 trigger selection"]
#[inline (always)] pub fn tsel1 (& mut self) -> Tsel1W < '_ , CrSpec > { Tsel1W :: new (self , 3) }
#[doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable"]
#[inline (always)] pub fn wave1 (& mut self) -> Wave1W < '_ , CrSpec > { Wave1W :: new (self , 6) }
#[doc = "Bits 8:11 - DAC channel1 mask/amplitude selector"]
#[inline (always)] pub fn mamp1 (& mut self) -> Mamp1W < '_ , CrSpec > { Mamp1W :: new (self , 8) }
#[doc = "Bit 12 - DAC channel1 DMA enable"]
#[inline (always)] pub fn dmaen1 (& mut self) -> Dmaen1W < '_ , CrSpec > { Dmaen1W :: new (self , 12) }
#[doc = "Bit 16 - DAC channel2 enable"]
#[inline (always)] pub fn en2 (& mut self) -> En2W < '_ , CrSpec > { En2W :: new (self , 16) }
#[doc = "Bit 17 - DAC channel2 output buffer disable"]
#[inline (always)] pub fn boff2 (& mut self) -> Boff2W < '_ , CrSpec > { Boff2W :: new (self , 17) }
#[doc = "Bit 18 - DAC channel2 trigger enable"]
#[inline (always)] pub fn ten2 (& mut self) -> Ten2W < '_ , CrSpec > { Ten2W :: new (self , 18) }
#[doc = "Bits 19:21 - DAC channel2 trigger selection"]
#[inline (always)] pub fn tsel2 (& mut self) -> Tsel2W < '_ , CrSpec > { Tsel2W :: new (self , 19) }
#[doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable"]
#[inline (always)] pub fn wave2 (& mut self) -> Wave2W < '_ , CrSpec > { Wave2W :: new (self , 22) }
#[doc = "Bits 24:27 - DAC channel2 mask/amplitude selector"]
#[inline (always)] pub fn mamp2 (& mut self) -> Mamp2W < '_ , CrSpec > { Mamp2W :: new (self , 24) }
#[doc = "Bit 28 - DAC channel2 DMA enable"]
#[inline (always)] pub fn dmaen2 (& mut self) -> Dmaen2W < '_ , CrSpec > { Dmaen2W :: new (self , 28) } }
#[doc = "Control register (DAC_CR)\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "SWTRIGR (w) register accessor: DAC software trigger register (DAC_SWTRIGR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swtrigr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@swtrigr`] module"]
#[doc (alias = "SWTRIGR")] pub type Swtrigr = crate :: Reg < swtrigr :: SwtrigrSpec > ;
#[doc = "DAC software trigger register (DAC_SWTRIGR)"] pub mod swtrigr {
#[doc = "Register `SWTRIGR` writer"] pub type W = crate :: W < SwtrigrSpec > ;
#[doc = "Field `SWTRIG1` writer - DAC channel1 software trigger"] pub type Swtrig1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWTRIG2` writer - DAC channel2 software trigger"] pub type Swtrig2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - DAC channel1 software trigger"]
#[inline (always)] pub fn swtrig1 (& mut self) -> Swtrig1W < '_ , SwtrigrSpec > { Swtrig1W :: new (self , 0) }
#[doc = "Bit 1 - DAC channel2 software trigger"]
#[inline (always)] pub fn swtrig2 (& mut self) -> Swtrig2W < '_ , SwtrigrSpec > { Swtrig2W :: new (self , 1) } }
#[doc = "DAC software trigger register (DAC_SWTRIGR)\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swtrigr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SwtrigrSpec ; impl crate :: RegisterSpec for SwtrigrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`swtrigr::W`](W) writer structure"] impl crate :: Writable for SwtrigrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SWTRIGR to value 0"] impl crate :: Resettable for SwtrigrSpec { } }
#[doc = "DHR12R1 (rw) register accessor: DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr12r1`] module"]
#[doc (alias = "DHR12R1")] pub type Dhr12r1 = crate :: Reg < dhr12r1 :: Dhr12r1Spec > ;
#[doc = "DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)"] pub mod dhr12r1 {
#[doc = "Register `DHR12R1` reader"] pub type R = crate :: R < Dhr12r1Spec > ;
#[doc = "Register `DHR12R1` writer"] pub type W = crate :: W < Dhr12r1Spec > ;
#[doc = "Field `DACC1DHR` reader - DAC channel1 12-bit right-aligned data"] pub type Dacc1dhrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DACC1DHR` writer - DAC channel1 12-bit right-aligned data"] pub type Dacc1dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
#[inline (always)] pub fn dacc1dhr (& self) -> Dacc1dhrR { Dacc1dhrR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
#[inline (always)] pub fn dacc1dhr (& mut self) -> Dacc1dhrW < '_ , Dhr12r1Spec > { Dacc1dhrW :: new (self , 0) } }
#[doc = "DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr12r1Spec ; impl crate :: RegisterSpec for Dhr12r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr12r1::R`](R) reader structure"] impl crate :: Readable for Dhr12r1Spec { }
#[doc = "`write(|w| ..)` method takes [`dhr12r1::W`](W) writer structure"] impl crate :: Writable for Dhr12r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR12R1 to value 0"] impl crate :: Resettable for Dhr12r1Spec { } }
#[doc = "DHR12L1 (rw) register accessor: DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12l1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12l1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr12l1`] module"]
#[doc (alias = "DHR12L1")] pub type Dhr12l1 = crate :: Reg < dhr12l1 :: Dhr12l1Spec > ;
#[doc = "DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)"] pub mod dhr12l1 {
#[doc = "Register `DHR12L1` reader"] pub type R = crate :: R < Dhr12l1Spec > ;
#[doc = "Register `DHR12L1` writer"] pub type W = crate :: W < Dhr12l1Spec > ;
#[doc = "Field `DACC1DHR` reader - DAC channel1 12-bit left-aligned data"] pub type Dacc1dhrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DACC1DHR` writer - DAC channel1 12-bit left-aligned data"] pub type Dacc1dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
#[inline (always)] pub fn dacc1dhr (& self) -> Dacc1dhrR { Dacc1dhrR :: new (((self . bits >> 4) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
#[inline (always)] pub fn dacc1dhr (& mut self) -> Dacc1dhrW < '_ , Dhr12l1Spec > { Dacc1dhrW :: new (self , 4) } }
#[doc = "DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12l1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12l1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr12l1Spec ; impl crate :: RegisterSpec for Dhr12l1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr12l1::R`](R) reader structure"] impl crate :: Readable for Dhr12l1Spec { }
#[doc = "`write(|w| ..)` method takes [`dhr12l1::W`](W) writer structure"] impl crate :: Writable for Dhr12l1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR12L1 to value 0"] impl crate :: Resettable for Dhr12l1Spec { } }
#[doc = "DHR8R1 (rw) register accessor: DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr8r1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr8r1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr8r1`] module"]
#[doc (alias = "DHR8R1")] pub type Dhr8r1 = crate :: Reg < dhr8r1 :: Dhr8r1Spec > ;
#[doc = "DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)"] pub mod dhr8r1 {
#[doc = "Register `DHR8R1` reader"] pub type R = crate :: R < Dhr8r1Spec > ;
#[doc = "Register `DHR8R1` writer"] pub type W = crate :: W < Dhr8r1Spec > ;
#[doc = "Field `DACC1DHR` reader - DAC channel1 8-bit right-aligned data"] pub type Dacc1dhrR = crate :: FieldReader ;
#[doc = "Field `DACC1DHR` writer - DAC channel1 8-bit right-aligned data"] pub type Dacc1dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
#[inline (always)] pub fn dacc1dhr (& self) -> Dacc1dhrR { Dacc1dhrR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
#[inline (always)] pub fn dacc1dhr (& mut self) -> Dacc1dhrW < '_ , Dhr8r1Spec > { Dacc1dhrW :: new (self , 0) } }
#[doc = "DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr8r1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr8r1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr8r1Spec ; impl crate :: RegisterSpec for Dhr8r1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr8r1::R`](R) reader structure"] impl crate :: Readable for Dhr8r1Spec { }
#[doc = "`write(|w| ..)` method takes [`dhr8r1::W`](W) writer structure"] impl crate :: Writable for Dhr8r1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR8R1 to value 0"] impl crate :: Resettable for Dhr8r1Spec { } }
#[doc = "DHR12R2 (rw) register accessor: DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr12r2`] module"]
#[doc (alias = "DHR12R2")] pub type Dhr12r2 = crate :: Reg < dhr12r2 :: Dhr12r2Spec > ;
#[doc = "DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)"] pub mod dhr12r2 {
#[doc = "Register `DHR12R2` reader"] pub type R = crate :: R < Dhr12r2Spec > ;
#[doc = "Register `DHR12R2` writer"] pub type W = crate :: W < Dhr12r2Spec > ;
#[doc = "Field `DACC2DHR` reader - DAC channel2 12-bit right-aligned data"] pub type Dacc2dhrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DACC2DHR` writer - DAC channel2 12-bit right-aligned data"] pub type Dacc2dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - DAC channel2 12-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& self) -> Dacc2dhrR { Dacc2dhrR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - DAC channel2 12-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& mut self) -> Dacc2dhrW < '_ , Dhr12r2Spec > { Dacc2dhrW :: new (self , 0) } }
#[doc = "DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr12r2Spec ; impl crate :: RegisterSpec for Dhr12r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr12r2::R`](R) reader structure"] impl crate :: Readable for Dhr12r2Spec { }
#[doc = "`write(|w| ..)` method takes [`dhr12r2::W`](W) writer structure"] impl crate :: Writable for Dhr12r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR12R2 to value 0"] impl crate :: Resettable for Dhr12r2Spec { } }
#[doc = "DHR12L2 (rw) register accessor: DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12l2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12l2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr12l2`] module"]
#[doc (alias = "DHR12L2")] pub type Dhr12l2 = crate :: Reg < dhr12l2 :: Dhr12l2Spec > ;
#[doc = "DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)"] pub mod dhr12l2 {
#[doc = "Register `DHR12L2` reader"] pub type R = crate :: R < Dhr12l2Spec > ;
#[doc = "Register `DHR12L2` writer"] pub type W = crate :: W < Dhr12l2Spec > ;
#[doc = "Field `DACC2DHR` reader - DAC channel2 12-bit left-aligned data"] pub type Dacc2dhrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DACC2DHR` writer - DAC channel2 12-bit left-aligned data"] pub type Dacc2dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 4:15 - DAC channel2 12-bit left-aligned data"]
#[inline (always)] pub fn dacc2dhr (& self) -> Dacc2dhrR { Dacc2dhrR :: new (((self . bits >> 4) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 4:15 - DAC channel2 12-bit left-aligned data"]
#[inline (always)] pub fn dacc2dhr (& mut self) -> Dacc2dhrW < '_ , Dhr12l2Spec > { Dacc2dhrW :: new (self , 4) } }
#[doc = "DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12l2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12l2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr12l2Spec ; impl crate :: RegisterSpec for Dhr12l2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr12l2::R`](R) reader structure"] impl crate :: Readable for Dhr12l2Spec { }
#[doc = "`write(|w| ..)` method takes [`dhr12l2::W`](W) writer structure"] impl crate :: Writable for Dhr12l2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR12L2 to value 0"] impl crate :: Resettable for Dhr12l2Spec { } }
#[doc = "DHR8R2 (rw) register accessor: DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr8r2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr8r2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr8r2`] module"]
#[doc (alias = "DHR8R2")] pub type Dhr8r2 = crate :: Reg < dhr8r2 :: Dhr8r2Spec > ;
#[doc = "DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)"] pub mod dhr8r2 {
#[doc = "Register `DHR8R2` reader"] pub type R = crate :: R < Dhr8r2Spec > ;
#[doc = "Register `DHR8R2` writer"] pub type W = crate :: W < Dhr8r2Spec > ;
#[doc = "Field `DACC2DHR` reader - DAC channel2 8-bit right-aligned data"] pub type Dacc2dhrR = crate :: FieldReader ;
#[doc = "Field `DACC2DHR` writer - DAC channel2 8-bit right-aligned data"] pub type Dacc2dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DAC channel2 8-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& self) -> Dacc2dhrR { Dacc2dhrR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DAC channel2 8-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& mut self) -> Dacc2dhrW < '_ , Dhr8r2Spec > { Dacc2dhrW :: new (self , 0) } }
#[doc = "DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr8r2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr8r2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr8r2Spec ; impl crate :: RegisterSpec for Dhr8r2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr8r2::R`](R) reader structure"] impl crate :: Readable for Dhr8r2Spec { }
#[doc = "`write(|w| ..)` method takes [`dhr8r2::W`](W) writer structure"] impl crate :: Writable for Dhr8r2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR8R2 to value 0"] impl crate :: Resettable for Dhr8r2Spec { } }
#[doc = "DHR12RD (rw) register accessor: Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12rd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12rd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr12rd`] module"]
#[doc (alias = "DHR12RD")] pub type Dhr12rd = crate :: Reg < dhr12rd :: Dhr12rdSpec > ;
#[doc = "Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved"] pub mod dhr12rd {
#[doc = "Register `DHR12RD` reader"] pub type R = crate :: R < Dhr12rdSpec > ;
#[doc = "Register `DHR12RD` writer"] pub type W = crate :: W < Dhr12rdSpec > ;
#[doc = "Field `DACC1DHR` reader - DAC channel1 12-bit right-aligned data"] pub type Dacc1dhrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DACC1DHR` writer - DAC channel1 12-bit right-aligned data"] pub type Dacc1dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `DACC2DHR` reader - DAC channel2 12-bit right-aligned data"] pub type Dacc2dhrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DACC2DHR` writer - DAC channel2 12-bit right-aligned data"] pub type Dacc2dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
#[inline (always)] pub fn dacc1dhr (& self) -> Dacc1dhrR { Dacc1dhrR :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 16:27 - DAC channel2 12-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& self) -> Dacc2dhrR { Dacc2dhrR :: new (((self . bits >> 16) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
#[inline (always)] pub fn dacc1dhr (& mut self) -> Dacc1dhrW < '_ , Dhr12rdSpec > { Dacc1dhrW :: new (self , 0) }
#[doc = "Bits 16:27 - DAC channel2 12-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& mut self) -> Dacc2dhrW < '_ , Dhr12rdSpec > { Dacc2dhrW :: new (self , 16) } }
#[doc = "Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12rd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12rd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr12rdSpec ; impl crate :: RegisterSpec for Dhr12rdSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr12rd::R`](R) reader structure"] impl crate :: Readable for Dhr12rdSpec { }
#[doc = "`write(|w| ..)` method takes [`dhr12rd::W`](W) writer structure"] impl crate :: Writable for Dhr12rdSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR12RD to value 0"] impl crate :: Resettable for Dhr12rdSpec { } }
#[doc = "DHR12LD (rw) register accessor: DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12ld::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12ld::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr12ld`] module"]
#[doc (alias = "DHR12LD")] pub type Dhr12ld = crate :: Reg < dhr12ld :: Dhr12ldSpec > ;
#[doc = "DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved"] pub mod dhr12ld {
#[doc = "Register `DHR12LD` reader"] pub type R = crate :: R < Dhr12ldSpec > ;
#[doc = "Register `DHR12LD` writer"] pub type W = crate :: W < Dhr12ldSpec > ;
#[doc = "Field `DACC1DHR` reader - DAC channel1 12-bit left-aligned data"] pub type Dacc1dhrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DACC1DHR` writer - DAC channel1 12-bit left-aligned data"] pub type Dacc1dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `DACC2DHR` reader - DAC channel2 12-bit right-aligned data"] pub type Dacc2dhrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DACC2DHR` writer - DAC channel2 12-bit right-aligned data"] pub type Dacc2dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
#[inline (always)] pub fn dacc1dhr (& self) -> Dacc1dhrR { Dacc1dhrR :: new (((self . bits >> 4) & 0x0fff) as u16) }
#[doc = "Bits 20:31 - DAC channel2 12-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& self) -> Dacc2dhrR { Dacc2dhrR :: new (((self . bits >> 20) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
#[inline (always)] pub fn dacc1dhr (& mut self) -> Dacc1dhrW < '_ , Dhr12ldSpec > { Dacc1dhrW :: new (self , 4) }
#[doc = "Bits 20:31 - DAC channel2 12-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& mut self) -> Dacc2dhrW < '_ , Dhr12ldSpec > { Dacc2dhrW :: new (self , 20) } }
#[doc = "DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr12ld::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr12ld::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr12ldSpec ; impl crate :: RegisterSpec for Dhr12ldSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr12ld::R`](R) reader structure"] impl crate :: Readable for Dhr12ldSpec { }
#[doc = "`write(|w| ..)` method takes [`dhr12ld::W`](W) writer structure"] impl crate :: Writable for Dhr12ldSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR12LD to value 0"] impl crate :: Resettable for Dhr12ldSpec { } }
#[doc = "DHR8RD (rw) register accessor: DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr8rd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr8rd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dhr8rd`] module"]
#[doc (alias = "DHR8RD")] pub type Dhr8rd = crate :: Reg < dhr8rd :: Dhr8rdSpec > ;
#[doc = "DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved"] pub mod dhr8rd {
#[doc = "Register `DHR8RD` reader"] pub type R = crate :: R < Dhr8rdSpec > ;
#[doc = "Register `DHR8RD` writer"] pub type W = crate :: W < Dhr8rdSpec > ;
#[doc = "Field `DACC1DHR` reader - DAC channel1 8-bit right-aligned data"] pub type Dacc1dhrR = crate :: FieldReader ;
#[doc = "Field `DACC1DHR` writer - DAC channel1 8-bit right-aligned data"] pub type Dacc1dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DACC2DHR` reader - DAC channel2 8-bit right-aligned data"] pub type Dacc2dhrR = crate :: FieldReader ;
#[doc = "Field `DACC2DHR` writer - DAC channel2 8-bit right-aligned data"] pub type Dacc2dhrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
#[inline (always)] pub fn dacc1dhr (& self) -> Dacc1dhrR { Dacc1dhrR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - DAC channel2 8-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& self) -> Dacc2dhrR { Dacc2dhrR :: new (((self . bits >> 8) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
#[inline (always)] pub fn dacc1dhr (& mut self) -> Dacc1dhrW < '_ , Dhr8rdSpec > { Dacc1dhrW :: new (self , 0) }
#[doc = "Bits 8:15 - DAC channel2 8-bit right-aligned data"]
#[inline (always)] pub fn dacc2dhr (& mut self) -> Dacc2dhrW < '_ , Dhr8rdSpec > { Dacc2dhrW :: new (self , 8) } }
#[doc = "DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved\n\nYou can [`read`](crate::Reg::read) this register and get [`dhr8rd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dhr8rd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dhr8rdSpec ; impl crate :: RegisterSpec for Dhr8rdSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dhr8rd::R`](R) reader structure"] impl crate :: Readable for Dhr8rdSpec { }
#[doc = "`write(|w| ..)` method takes [`dhr8rd::W`](W) writer structure"] impl crate :: Writable for Dhr8rdSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DHR8RD to value 0"] impl crate :: Resettable for Dhr8rdSpec { } }
#[doc = "DOR1 (r) register accessor: DAC channel1 data output register (DAC_DOR1)\n\nYou can [`read`](crate::Reg::read) this register and get [`dor1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dor1`] module"]
#[doc (alias = "DOR1")] pub type Dor1 = crate :: Reg < dor1 :: Dor1Spec > ;
#[doc = "DAC channel1 data output register (DAC_DOR1)"] pub mod dor1 {
#[doc = "Register `DOR1` reader"] pub type R = crate :: R < Dor1Spec > ;
#[doc = "Field `DACC1DOR` reader - DAC channel1 data output"] pub type Dacc1dorR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:11 - DAC channel1 data output"]
#[inline (always)] pub fn dacc1dor (& self) -> Dacc1dorR { Dacc1dorR :: new ((self . bits & 0x0fff) as u16) } }
#[doc = "DAC channel1 data output register (DAC_DOR1)\n\nYou can [`read`](crate::Reg::read) this register and get [`dor1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dor1Spec ; impl crate :: RegisterSpec for Dor1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dor1::R`](R) reader structure"] impl crate :: Readable for Dor1Spec { }
#[doc = "`reset()` method sets DOR1 to value 0"] impl crate :: Resettable for Dor1Spec { } }
#[doc = "DOR2 (r) register accessor: DAC channel2 data output register (DAC_DOR2)\n\nYou can [`read`](crate::Reg::read) this register and get [`dor2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dor2`] module"]
#[doc (alias = "DOR2")] pub type Dor2 = crate :: Reg < dor2 :: Dor2Spec > ;
#[doc = "DAC channel2 data output register (DAC_DOR2)"] pub mod dor2 {
#[doc = "Register `DOR2` reader"] pub type R = crate :: R < Dor2Spec > ;
#[doc = "Field `DACC2DOR` reader - DAC channel2 data output"] pub type Dacc2dorR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:11 - DAC channel2 data output"]
#[inline (always)] pub fn dacc2dor (& self) -> Dacc2dorR { Dacc2dorR :: new ((self . bits & 0x0fff) as u16) } }
#[doc = "DAC channel2 data output register (DAC_DOR2)\n\nYou can [`read`](crate::Reg::read) this register and get [`dor2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dor2Spec ; impl crate :: RegisterSpec for Dor2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dor2::R`](R) reader structure"] impl crate :: Readable for Dor2Spec { }
#[doc = "`reset()` method sets DOR2 to value 0"] impl crate :: Resettable for Dor2Spec { } } }
#[doc = "Debug support"] pub type Dbg = crate :: Periph < dbg :: RegisterBlock , 0xe004_2000 > ; impl core :: fmt :: Debug for Dbg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dbg") . finish () } }
#[doc = "Debug support"] pub mod dbg {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { idcode : Idcode , cr : Cr , } impl RegisterBlock {
#[doc = "0x00 - DBGMCU_IDCODE"]
#[inline (always)] pub const fn idcode (& self) -> & Idcode { & self . idcode }
#[doc = "0x04 - DBGMCU_CR"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr } }
#[doc = "IDCODE (r) register accessor: DBGMCU_IDCODE\n\nYou can [`read`](crate::Reg::read) this register and get [`idcode::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idcode`] module"]
#[doc (alias = "IDCODE")] pub type Idcode = crate :: Reg < idcode :: IdcodeSpec > ;
#[doc = "DBGMCU_IDCODE"] pub mod idcode {
#[doc = "Register `IDCODE` reader"] pub type R = crate :: R < IdcodeSpec > ;
#[doc = "Field `DEV_ID` reader - DEV_ID"] pub type DevIdR = crate :: FieldReader < u16 > ;
#[doc = "Field `REV_ID` reader - REV_ID"] pub type RevIdR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:11 - DEV_ID"]
#[inline (always)] pub fn dev_id (& self) -> DevIdR { DevIdR :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 16:31 - REV_ID"]
#[inline (always)] pub fn rev_id (& self) -> RevIdR { RevIdR :: new (((self . bits >> 16) & 0xffff) as u16) } }
#[doc = "DBGMCU_IDCODE\n\nYou can [`read`](crate::Reg::read) this register and get [`idcode::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdcodeSpec ; impl crate :: RegisterSpec for IdcodeSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idcode::R`](R) reader structure"] impl crate :: Readable for IdcodeSpec { }
#[doc = "`reset()` method sets IDCODE to value 0"] impl crate :: Resettable for IdcodeSpec { } }
#[doc = "CR (rw) register accessor: DBGMCU_CR\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "DBGMCU_CR"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `DBG_SLEEP` reader - DBG_SLEEP"] pub type DbgSleepR = crate :: BitReader ;
#[doc = "Field `DBG_SLEEP` writer - DBG_SLEEP"] pub type DbgSleepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_STOP` reader - DBG_STOP"] pub type DbgStopR = crate :: BitReader ;
#[doc = "Field `DBG_STOP` writer - DBG_STOP"] pub type DbgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_STANDBY` reader - DBG_STANDBY"] pub type DbgStandbyR = crate :: BitReader ;
#[doc = "Field `DBG_STANDBY` writer - DBG_STANDBY"] pub type DbgStandbyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRACE_IOEN` reader - TRACE_IOEN"] pub type TraceIoenR = crate :: BitReader ;
#[doc = "Field `TRACE_IOEN` writer - TRACE_IOEN"] pub type TraceIoenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRACE_MODE` reader - TRACE_MODE"] pub type TraceModeR = crate :: FieldReader ;
#[doc = "Field `TRACE_MODE` writer - TRACE_MODE"] pub type TraceModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DBG_IWDG_STOP` reader - DBG_IWDG_STOP"] pub type DbgIwdgStopR = crate :: BitReader ;
#[doc = "Field `DBG_IWDG_STOP` writer - DBG_IWDG_STOP"] pub type DbgIwdgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_WWDG_STOP` reader - DBG_WWDG_STOP"] pub type DbgWwdgStopR = crate :: BitReader ;
#[doc = "Field `DBG_WWDG_STOP` writer - DBG_WWDG_STOP"] pub type DbgWwdgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM1_STOP` reader - DBG_TIM1_STOP"] pub type DbgTim1StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM1_STOP` writer - DBG_TIM1_STOP"] pub type DbgTim1StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM2_STOP` reader - DBG_TIM2_STOP"] pub type DbgTim2StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM2_STOP` writer - DBG_TIM2_STOP"] pub type DbgTim2StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM3_STOP` reader - DBG_TIM3_STOP"] pub type DbgTim3StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM3_STOP` writer - DBG_TIM3_STOP"] pub type DbgTim3StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM4_STOP` reader - DBG_TIM4_STOP"] pub type DbgTim4StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM4_STOP` writer - DBG_TIM4_STOP"] pub type DbgTim4StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_CAN1_STOP` reader - DBG_CAN1_STOP"] pub type DbgCan1StopR = crate :: BitReader ;
#[doc = "Field `DBG_CAN1_STOP` writer - DBG_CAN1_STOP"] pub type DbgCan1StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_I2C1_SMBUS_TIMEOUT` reader - DBG_I2C1_SMBUS_TIMEOUT"] pub type DbgI2c1SmbusTimeoutR = crate :: BitReader ;
#[doc = "Field `DBG_I2C1_SMBUS_TIMEOUT` writer - DBG_I2C1_SMBUS_TIMEOUT"] pub type DbgI2c1SmbusTimeoutW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_I2C2_SMBUS_TIMEOUT` reader - DBG_I2C2_SMBUS_TIMEOUT"] pub type DbgI2c2SmbusTimeoutR = crate :: BitReader ;
#[doc = "Field `DBG_I2C2_SMBUS_TIMEOUT` writer - DBG_I2C2_SMBUS_TIMEOUT"] pub type DbgI2c2SmbusTimeoutW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM8_STOP` reader - DBG_TIM8_STOP"] pub type DbgTim8StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM8_STOP` writer - DBG_TIM8_STOP"] pub type DbgTim8StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM5_STOP` reader - DBG_TIM5_STOP"] pub type DbgTim5StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM5_STOP` writer - DBG_TIM5_STOP"] pub type DbgTim5StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM6_STOP` reader - DBG_TIM6_STOP"] pub type DbgTim6StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM6_STOP` writer - DBG_TIM6_STOP"] pub type DbgTim6StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIM7_STOP` reader - DBG_TIM7_STOP"] pub type DbgTim7StopR = crate :: BitReader ;
#[doc = "Field `DBG_TIM7_STOP` writer - DBG_TIM7_STOP"] pub type DbgTim7StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_CAN2_STOP` reader - DBG_CAN2_STOP"] pub type DbgCan2StopR = crate :: BitReader ;
#[doc = "Field `DBG_CAN2_STOP` writer - DBG_CAN2_STOP"] pub type DbgCan2StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DBG_SLEEP"]
#[inline (always)] pub fn dbg_sleep (& self) -> DbgSleepR { DbgSleepR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DBG_STOP"]
#[inline (always)] pub fn dbg_stop (& self) -> DbgStopR { DbgStopR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - DBG_STANDBY"]
#[inline (always)] pub fn dbg_standby (& self) -> DbgStandbyR { DbgStandbyR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 5 - TRACE_IOEN"]
#[inline (always)] pub fn trace_ioen (& self) -> TraceIoenR { TraceIoenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bits 6:7 - TRACE_MODE"]
#[inline (always)] pub fn trace_mode (& self) -> TraceModeR { TraceModeR :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bit 8 - DBG_IWDG_STOP"]
#[inline (always)] pub fn dbg_iwdg_stop (& self) -> DbgIwdgStopR { DbgIwdgStopR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - DBG_WWDG_STOP"]
#[inline (always)] pub fn dbg_wwdg_stop (& self) -> DbgWwdgStopR { DbgWwdgStopR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - DBG_TIM1_STOP"]
#[inline (always)] pub fn dbg_tim1_stop (& self) -> DbgTim1StopR { DbgTim1StopR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - DBG_TIM2_STOP"]
#[inline (always)] pub fn dbg_tim2_stop (& self) -> DbgTim2StopR { DbgTim2StopR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - DBG_TIM3_STOP"]
#[inline (always)] pub fn dbg_tim3_stop (& self) -> DbgTim3StopR { DbgTim3StopR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - DBG_TIM4_STOP"]
#[inline (always)] pub fn dbg_tim4_stop (& self) -> DbgTim4StopR { DbgTim4StopR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - DBG_CAN1_STOP"]
#[inline (always)] pub fn dbg_can1_stop (& self) -> DbgCan1StopR { DbgCan1StopR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - DBG_I2C1_SMBUS_TIMEOUT"]
#[inline (always)] pub fn dbg_i2c1_smbus_timeout (& self) -> DbgI2c1SmbusTimeoutR { DbgI2c1SmbusTimeoutR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - DBG_I2C2_SMBUS_TIMEOUT"]
#[inline (always)] pub fn dbg_i2c2_smbus_timeout (& self) -> DbgI2c2SmbusTimeoutR { DbgI2c2SmbusTimeoutR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - DBG_TIM8_STOP"]
#[inline (always)] pub fn dbg_tim8_stop (& self) -> DbgTim8StopR { DbgTim8StopR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - DBG_TIM5_STOP"]
#[inline (always)] pub fn dbg_tim5_stop (& self) -> DbgTim5StopR { DbgTim5StopR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - DBG_TIM6_STOP"]
#[inline (always)] pub fn dbg_tim6_stop (& self) -> DbgTim6StopR { DbgTim6StopR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - DBG_TIM7_STOP"]
#[inline (always)] pub fn dbg_tim7_stop (& self) -> DbgTim7StopR { DbgTim7StopR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - DBG_CAN2_STOP"]
#[inline (always)] pub fn dbg_can2_stop (& self) -> DbgCan2StopR { DbgCan2StopR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DBG_SLEEP"]
#[inline (always)] pub fn dbg_sleep (& mut self) -> DbgSleepW < '_ , CrSpec > { DbgSleepW :: new (self , 0) }
#[doc = "Bit 1 - DBG_STOP"]
#[inline (always)] pub fn dbg_stop (& mut self) -> DbgStopW < '_ , CrSpec > { DbgStopW :: new (self , 1) }
#[doc = "Bit 2 - DBG_STANDBY"]
#[inline (always)] pub fn dbg_standby (& mut self) -> DbgStandbyW < '_ , CrSpec > { DbgStandbyW :: new (self , 2) }
#[doc = "Bit 5 - TRACE_IOEN"]
#[inline (always)] pub fn trace_ioen (& mut self) -> TraceIoenW < '_ , CrSpec > { TraceIoenW :: new (self , 5) }
#[doc = "Bits 6:7 - TRACE_MODE"]
#[inline (always)] pub fn trace_mode (& mut self) -> TraceModeW < '_ , CrSpec > { TraceModeW :: new (self , 6) }
#[doc = "Bit 8 - DBG_IWDG_STOP"]
#[inline (always)] pub fn dbg_iwdg_stop (& mut self) -> DbgIwdgStopW < '_ , CrSpec > { DbgIwdgStopW :: new (self , 8) }
#[doc = "Bit 9 - DBG_WWDG_STOP"]
#[inline (always)] pub fn dbg_wwdg_stop (& mut self) -> DbgWwdgStopW < '_ , CrSpec > { DbgWwdgStopW :: new (self , 9) }
#[doc = "Bit 10 - DBG_TIM1_STOP"]
#[inline (always)] pub fn dbg_tim1_stop (& mut self) -> DbgTim1StopW < '_ , CrSpec > { DbgTim1StopW :: new (self , 10) }
#[doc = "Bit 11 - DBG_TIM2_STOP"]
#[inline (always)] pub fn dbg_tim2_stop (& mut self) -> DbgTim2StopW < '_ , CrSpec > { DbgTim2StopW :: new (self , 11) }
#[doc = "Bit 12 - DBG_TIM3_STOP"]
#[inline (always)] pub fn dbg_tim3_stop (& mut self) -> DbgTim3StopW < '_ , CrSpec > { DbgTim3StopW :: new (self , 12) }
#[doc = "Bit 13 - DBG_TIM4_STOP"]
#[inline (always)] pub fn dbg_tim4_stop (& mut self) -> DbgTim4StopW < '_ , CrSpec > { DbgTim4StopW :: new (self , 13) }
#[doc = "Bit 14 - DBG_CAN1_STOP"]
#[inline (always)] pub fn dbg_can1_stop (& mut self) -> DbgCan1StopW < '_ , CrSpec > { DbgCan1StopW :: new (self , 14) }
#[doc = "Bit 15 - DBG_I2C1_SMBUS_TIMEOUT"]
#[inline (always)] pub fn dbg_i2c1_smbus_timeout (& mut self) -> DbgI2c1SmbusTimeoutW < '_ , CrSpec > { DbgI2c1SmbusTimeoutW :: new (self , 15) }
#[doc = "Bit 16 - DBG_I2C2_SMBUS_TIMEOUT"]
#[inline (always)] pub fn dbg_i2c2_smbus_timeout (& mut self) -> DbgI2c2SmbusTimeoutW < '_ , CrSpec > { DbgI2c2SmbusTimeoutW :: new (self , 16) }
#[doc = "Bit 17 - DBG_TIM8_STOP"]
#[inline (always)] pub fn dbg_tim8_stop (& mut self) -> DbgTim8StopW < '_ , CrSpec > { DbgTim8StopW :: new (self , 17) }
#[doc = "Bit 18 - DBG_TIM5_STOP"]
#[inline (always)] pub fn dbg_tim5_stop (& mut self) -> DbgTim5StopW < '_ , CrSpec > { DbgTim5StopW :: new (self , 18) }
#[doc = "Bit 19 - DBG_TIM6_STOP"]
#[inline (always)] pub fn dbg_tim6_stop (& mut self) -> DbgTim6StopW < '_ , CrSpec > { DbgTim6StopW :: new (self , 19) }
#[doc = "Bit 20 - DBG_TIM7_STOP"]
#[inline (always)] pub fn dbg_tim7_stop (& mut self) -> DbgTim7StopW < '_ , CrSpec > { DbgTim7StopW :: new (self , 20) }
#[doc = "Bit 21 - DBG_CAN2_STOP"]
#[inline (always)] pub fn dbg_can2_stop (& mut self) -> DbgCan2StopW < '_ , CrSpec > { DbgCan2StopW :: new (self , 21) } }
#[doc = "DBGMCU_CR\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } } }
#[doc = "Universal asynchronous receiver transmitter"] pub type Uart4 = crate :: Periph < uart4 :: RegisterBlock , 0x4000_4c00 > ; impl core :: fmt :: Debug for Uart4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart4") . finish () } }
#[doc = "Universal asynchronous receiver transmitter"] pub mod uart4 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { sr : Sr , dr : Dr , brr : Brr , cr1 : Cr1 , cr2 : Cr2 , cr3 : Cr3 , } impl RegisterBlock {
#[doc = "0x00 - UART4_SR"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x04 - UART4_DR"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x08 - UART4_BRR"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr }
#[doc = "0x0c - UART4_CR1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x10 - UART4_CR2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x14 - UART4_CR3"]
#[inline (always)] pub const fn cr3 (& self) -> & Cr3 { & self . cr3 } }
#[doc = "SR (rw) register accessor: UART4_SR\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "UART4_SR"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `PE` reader - Parity error"] pub type PeR = crate :: BitReader ;
#[doc = "Field `FE` reader - Framing error"] pub type FeR = crate :: BitReader ;
#[doc = "Field `NE` reader - Noise error flag"] pub type NeR = crate :: BitReader ;
#[doc = "Field `ORE` reader - Overrun error"] pub type OreR = crate :: BitReader ;
#[doc = "Field `IDLE` reader - IDLE line detected"] pub type IdleR = crate :: BitReader ;
#[doc = "Field `RXNE` reader - Read data register not empty"] pub type RxneR = crate :: BitReader ;
#[doc = "Field `RXNE` writer - Read data register not empty"] pub type RxneW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TC` reader - Transmission complete"] pub type TcR = crate :: BitReader ;
#[doc = "Field `TC` writer - Transmission complete"] pub type TcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXE` reader - Transmit data register empty"] pub type TxeR = crate :: BitReader ;
#[doc = "Field `LBD` reader - LIN break detection flag"] pub type LbdR = crate :: BitReader ;
#[doc = "Field `LBD` writer - LIN break detection flag"] pub type LbdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Parity error"]
#[inline (always)] pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Framing error"]
#[inline (always)] pub fn fe (& self) -> FeR { FeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Noise error flag"]
#[inline (always)] pub fn ne (& self) -> NeR { NeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Overrun error"]
#[inline (always)] pub fn ore (& self) -> OreR { OreR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IDLE line detected"]
#[inline (always)] pub fn idle (& self) -> IdleR { IdleR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Read data register not empty"]
#[inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmission complete"]
#[inline (always)] pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transmit data register empty"]
#[inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - LIN break detection flag"]
#[inline (always)] pub fn lbd (& self) -> LbdR { LbdR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 5 - Read data register not empty"]
#[inline (always)] pub fn rxne (& mut self) -> RxneW < '_ , SrSpec > { RxneW :: new (self , 5) }
#[doc = "Bit 6 - Transmission complete"]
#[inline (always)] pub fn tc (& mut self) -> TcW < '_ , SrSpec > { TcW :: new (self , 6) }
#[doc = "Bit 8 - LIN break detection flag"]
#[inline (always)] pub fn lbd (& mut self) -> LbdW < '_ , SrSpec > { LbdW :: new (self , 8) } }
#[doc = "UART4_SR\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "DR (rw) register accessor: UART4_DR\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "UART4_DR"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - DR"] pub type DrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DR` writer - DR"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R {
#[doc = "Bits 0:8 - DR"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new ((self . bits & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:8 - DR"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "UART4_DR\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "BRR (rw) register accessor: UART4_BRR\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "UART4_BRR"] pub mod brr {
#[doc = "Register `BRR` reader"] pub type R = crate :: R < BrrSpec > ;
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `DIV_Fraction` reader - DIV_Fraction"] pub type DivFractionR = crate :: FieldReader ;
#[doc = "Field `DIV_Fraction` writer - DIV_Fraction"] pub type DivFractionW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DIV_Mantissa` reader - DIV_Mantissa"] pub type DivMantissaR = crate :: FieldReader < u16 > ;
#[doc = "Field `DIV_Mantissa` writer - DIV_Mantissa"] pub type DivMantissaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:3 - DIV_Fraction"]
#[inline (always)] pub fn div_fraction (& self) -> DivFractionR { DivFractionR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:15 - DIV_Mantissa"]
#[inline (always)] pub fn div_mantissa (& self) -> DivMantissaR { DivMantissaR :: new (((self . bits >> 4) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:3 - DIV_Fraction"]
#[inline (always)] pub fn div_fraction (& mut self) -> DivFractionW < '_ , BrrSpec > { DivFractionW :: new (self , 0) }
#[doc = "Bits 4:15 - DIV_Mantissa"]
#[inline (always)] pub fn div_mantissa (& mut self) -> DivMantissaW < '_ , BrrSpec > { DivMantissaW :: new (self , 4) } }
#[doc = "UART4_BRR\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`brr::R`](R) reader structure"] impl crate :: Readable for BrrSpec { }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } }
#[doc = "CR1 (rw) register accessor: UART4_CR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "UART4_CR1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `SBK` reader - Send break"] pub type SbkR = crate :: BitReader ;
#[doc = "Field `SBK` writer - Send break"] pub type SbkW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RWU` reader - Receiver wakeup"] pub type RwuR = crate :: BitReader ;
#[doc = "Field `RWU` writer - Receiver wakeup"] pub type RwuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RE` reader - Receiver enable"] pub type ReR = crate :: BitReader ;
#[doc = "Field `RE` writer - Receiver enable"] pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TE` reader - Transmitter enable"] pub type TeR = crate :: BitReader ;
#[doc = "Field `TE` writer - Transmitter enable"] pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDLEIE` reader - IDLE interrupt enable"] pub type IdleieR = crate :: BitReader ;
#[doc = "Field `IDLEIE` writer - IDLE interrupt enable"] pub type IdleieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXNEIE` reader - RXNE interrupt enable"] pub type RxneieR = crate :: BitReader ;
#[doc = "Field `RXNEIE` writer - RXNE interrupt enable"] pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transmission complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transmission complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEIE` reader - TXE interrupt enable"] pub type TxeieR = crate :: BitReader ;
#[doc = "Field `TXEIE` writer - TXE interrupt enable"] pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PEIE` reader - PE interrupt enable"] pub type PeieR = crate :: BitReader ;
#[doc = "Field `PEIE` writer - PE interrupt enable"] pub type PeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PS` reader - Parity selection"] pub type PsR = crate :: BitReader ;
#[doc = "Field `PS` writer - Parity selection"] pub type PsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PCE` reader - Parity control enable"] pub type PceR = crate :: BitReader ;
#[doc = "Field `PCE` writer - Parity control enable"] pub type PceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAKE` reader - Wakeup method"] pub type WakeR = crate :: BitReader ;
#[doc = "Field `WAKE` writer - Wakeup method"] pub type WakeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `M` reader - Word length"] pub type MR = crate :: BitReader ;
#[doc = "Field `M` writer - Word length"] pub type MW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UE` reader - USART enable"] pub type UeR = crate :: BitReader ;
#[doc = "Field `UE` writer - USART enable"] pub type UeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Send break"]
#[inline (always)] pub fn sbk (& self) -> SbkR { SbkR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receiver wakeup"]
#[inline (always)] pub fn rwu (& self) -> RwuR { RwuR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Receiver enable"]
#[inline (always)] pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmitter enable"]
#[inline (always)] pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IDLE interrupt enable"]
#[inline (always)] pub fn idleie (& self) -> IdleieR { IdleieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXNE interrupt enable"]
#[inline (always)] pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmission complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXE interrupt enable"]
#[inline (always)] pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - PE interrupt enable"]
#[inline (always)] pub fn peie (& self) -> PeieR { PeieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Parity selection"]
#[inline (always)] pub fn ps (& self) -> PsR { PsR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Parity control enable"]
#[inline (always)] pub fn pce (& self) -> PceR { PceR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Wakeup method"]
#[inline (always)] pub fn wake (& self) -> WakeR { WakeR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Word length"]
#[inline (always)] pub fn m (& self) -> MR { MR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - USART enable"]
#[inline (always)] pub fn ue (& self) -> UeR { UeR :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Send break"]
#[inline (always)] pub fn sbk (& mut self) -> SbkW < '_ , Cr1Spec > { SbkW :: new (self , 0) }
#[doc = "Bit 1 - Receiver wakeup"]
#[inline (always)] pub fn rwu (& mut self) -> RwuW < '_ , Cr1Spec > { RwuW :: new (self , 1) }
#[doc = "Bit 2 - Receiver enable"]
#[inline (always)] pub fn re (& mut self) -> ReW < '_ , Cr1Spec > { ReW :: new (self , 2) }
#[doc = "Bit 3 - Transmitter enable"]
#[inline (always)] pub fn te (& mut self) -> TeW < '_ , Cr1Spec > { TeW :: new (self , 3) }
#[doc = "Bit 4 - IDLE interrupt enable"]
#[inline (always)] pub fn idleie (& mut self) -> IdleieW < '_ , Cr1Spec > { IdleieW :: new (self , 4) }
#[doc = "Bit 5 - RXNE interrupt enable"]
#[inline (always)] pub fn rxneie (& mut self) -> RxneieW < '_ , Cr1Spec > { RxneieW :: new (self , 5) }
#[doc = "Bit 6 - Transmission complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Cr1Spec > { TcieW :: new (self , 6) }
#[doc = "Bit 7 - TXE interrupt enable"]
#[inline (always)] pub fn txeie (& mut self) -> TxeieW < '_ , Cr1Spec > { TxeieW :: new (self , 7) }
#[doc = "Bit 8 - PE interrupt enable"]
#[inline (always)] pub fn peie (& mut self) -> PeieW < '_ , Cr1Spec > { PeieW :: new (self , 8) }
#[doc = "Bit 9 - Parity selection"]
#[inline (always)] pub fn ps (& mut self) -> PsW < '_ , Cr1Spec > { PsW :: new (self , 9) }
#[doc = "Bit 10 - Parity control enable"]
#[inline (always)] pub fn pce (& mut self) -> PceW < '_ , Cr1Spec > { PceW :: new (self , 10) }
#[doc = "Bit 11 - Wakeup method"]
#[inline (always)] pub fn wake (& mut self) -> WakeW < '_ , Cr1Spec > { WakeW :: new (self , 11) }
#[doc = "Bit 12 - Word length"]
#[inline (always)] pub fn m (& mut self) -> MW < '_ , Cr1Spec > { MW :: new (self , 12) }
#[doc = "Bit 13 - USART enable"]
#[inline (always)] pub fn ue (& mut self) -> UeW < '_ , Cr1Spec > { UeW :: new (self , 13) } }
#[doc = "UART4_CR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: UART4_CR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "UART4_CR2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `ADD` reader - Address of the USART node"] pub type AddR = crate :: FieldReader ;
#[doc = "Field `ADD` writer - Address of the USART node"] pub type AddW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LBDL` reader - lin break detection length"] pub type LbdlR = crate :: BitReader ;
#[doc = "Field `LBDL` writer - lin break detection length"] pub type LbdlW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LBDIE` reader - LIN break detection interrupt enable"] pub type LbdieR = crate :: BitReader ;
#[doc = "Field `LBDIE` writer - LIN break detection interrupt enable"] pub type LbdieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOP` reader - STOP bits"] pub type StopR = crate :: FieldReader ;
#[doc = "Field `STOP` writer - STOP bits"] pub type StopW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LINEN` reader - LIN mode enable"] pub type LinenR = crate :: BitReader ;
#[doc = "Field `LINEN` writer - LIN mode enable"] pub type LinenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Address of the USART node"]
#[inline (always)] pub fn add (& self) -> AddR { AddR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 5 - lin break detection length"]
#[inline (always)] pub fn lbdl (& self) -> LbdlR { LbdlR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - LIN break detection interrupt enable"]
#[inline (always)] pub fn lbdie (& self) -> LbdieR { LbdieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 12:13 - STOP bits"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - LIN mode enable"]
#[inline (always)] pub fn linen (& self) -> LinenR { LinenR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Address of the USART node"]
#[inline (always)] pub fn add (& mut self) -> AddW < '_ , Cr2Spec > { AddW :: new (self , 0) }
#[doc = "Bit 5 - lin break detection length"]
#[inline (always)] pub fn lbdl (& mut self) -> LbdlW < '_ , Cr2Spec > { LbdlW :: new (self , 5) }
#[doc = "Bit 6 - LIN break detection interrupt enable"]
#[inline (always)] pub fn lbdie (& mut self) -> LbdieW < '_ , Cr2Spec > { LbdieW :: new (self , 6) }
#[doc = "Bits 12:13 - STOP bits"]
#[inline (always)] pub fn stop (& mut self) -> StopW < '_ , Cr2Spec > { StopW :: new (self , 12) }
#[doc = "Bit 14 - LIN mode enable"]
#[inline (always)] pub fn linen (& mut self) -> LinenW < '_ , Cr2Spec > { LinenW :: new (self , 14) } }
#[doc = "UART4_CR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "CR3 (rw) register accessor: UART4_CR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr3`] module"]
#[doc (alias = "CR3")] pub type Cr3 = crate :: Reg < cr3 :: Cr3Spec > ;
#[doc = "UART4_CR3"] pub mod cr3 {
#[doc = "Register `CR3` reader"] pub type R = crate :: R < Cr3Spec > ;
#[doc = "Register `CR3` writer"] pub type W = crate :: W < Cr3Spec > ;
#[doc = "Field `EIE` reader - Error interrupt enable"] pub type EieR = crate :: BitReader ;
#[doc = "Field `EIE` writer - Error interrupt enable"] pub type EieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IREN` reader - IrDA mode enable"] pub type IrenR = crate :: BitReader ;
#[doc = "Field `IREN` writer - IrDA mode enable"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IRLP` reader - IrDA low-power"] pub type IrlpR = crate :: BitReader ;
#[doc = "Field `IRLP` writer - IrDA low-power"] pub type IrlpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HDSEL` reader - Half-duplex selection"] pub type HdselR = crate :: BitReader ;
#[doc = "Field `HDSEL` writer - Half-duplex selection"] pub type HdselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAR` reader - DMA enable receiver"] pub type DmarR = crate :: BitReader ;
#[doc = "Field `DMAR` writer - DMA enable receiver"] pub type DmarW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAT` reader - DMA enable transmitter"] pub type DmatR = crate :: BitReader ;
#[doc = "Field `DMAT` writer - DMA enable transmitter"] pub type DmatW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Error interrupt enable"]
#[inline (always)] pub fn eie (& self) -> EieR { EieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - IrDA mode enable"]
#[inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IrDA low-power"]
#[inline (always)] pub fn irlp (& self) -> IrlpR { IrlpR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Half-duplex selection"]
#[inline (always)] pub fn hdsel (& self) -> HdselR { HdselR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 6 - DMA enable receiver"]
#[inline (always)] pub fn dmar (& self) -> DmarR { DmarR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - DMA enable transmitter"]
#[inline (always)] pub fn dmat (& self) -> DmatR { DmatR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Error interrupt enable"]
#[inline (always)] pub fn eie (& mut self) -> EieW < '_ , Cr3Spec > { EieW :: new (self , 0) }
#[doc = "Bit 1 - IrDA mode enable"]
#[inline (always)] pub fn iren (& mut self) -> IrenW < '_ , Cr3Spec > { IrenW :: new (self , 1) }
#[doc = "Bit 2 - IrDA low-power"]
#[inline (always)] pub fn irlp (& mut self) -> IrlpW < '_ , Cr3Spec > { IrlpW :: new (self , 2) }
#[doc = "Bit 3 - Half-duplex selection"]
#[inline (always)] pub fn hdsel (& mut self) -> HdselW < '_ , Cr3Spec > { HdselW :: new (self , 3) }
#[doc = "Bit 6 - DMA enable receiver"]
#[inline (always)] pub fn dmar (& mut self) -> DmarW < '_ , Cr3Spec > { DmarW :: new (self , 6) }
#[doc = "Bit 7 - DMA enable transmitter"]
#[inline (always)] pub fn dmat (& mut self) -> DmatW < '_ , Cr3Spec > { DmatW :: new (self , 7) } }
#[doc = "UART4_CR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr3Spec ; impl crate :: RegisterSpec for Cr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr3::R`](R) reader structure"] impl crate :: Readable for Cr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cr3::W`](W) writer structure"] impl crate :: Writable for Cr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR3 to value 0"] impl crate :: Resettable for Cr3Spec { } } }
#[doc = "Universal asynchronous receiver transmitter"] pub type Uart5 = crate :: Periph < uart5 :: RegisterBlock , 0x4000_5000 > ; impl core :: fmt :: Debug for Uart5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart5") . finish () } }
#[doc = "Universal asynchronous receiver transmitter"] pub mod uart5 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { sr : Sr , dr : Dr , brr : Brr , cr1 : Cr1 , cr2 : Cr2 , cr3 : Cr3 , } impl RegisterBlock {
#[doc = "0x00 - UART4_SR"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x04 - UART4_DR"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x08 - UART4_BRR"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr }
#[doc = "0x0c - UART4_CR1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x10 - UART4_CR2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x14 - UART4_CR3"]
#[inline (always)] pub const fn cr3 (& self) -> & Cr3 { & self . cr3 } }
#[doc = "SR (rw) register accessor: UART4_SR\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "UART4_SR"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `PE` reader - PE"] pub type PeR = crate :: BitReader ;
#[doc = "Field `FE` reader - FE"] pub type FeR = crate :: BitReader ;
#[doc = "Field `NE` reader - NE"] pub type NeR = crate :: BitReader ;
#[doc = "Field `ORE` reader - ORE"] pub type OreR = crate :: BitReader ;
#[doc = "Field `IDLE` reader - IDLE"] pub type IdleR = crate :: BitReader ;
#[doc = "Field `RXNE` reader - RXNE"] pub type RxneR = crate :: BitReader ;
#[doc = "Field `RXNE` writer - RXNE"] pub type RxneW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TC` reader - TC"] pub type TcR = crate :: BitReader ;
#[doc = "Field `TC` writer - TC"] pub type TcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXE` reader - TXE"] pub type TxeR = crate :: BitReader ;
#[doc = "Field `LBD` reader - LBD"] pub type LbdR = crate :: BitReader ;
#[doc = "Field `LBD` writer - LBD"] pub type LbdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - PE"]
#[inline (always)] pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - FE"]
#[inline (always)] pub fn fe (& self) -> FeR { FeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - NE"]
#[inline (always)] pub fn ne (& self) -> NeR { NeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - ORE"]
#[inline (always)] pub fn ore (& self) -> OreR { OreR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IDLE"]
#[inline (always)] pub fn idle (& self) -> IdleR { IdleR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXNE"]
#[inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - TC"]
#[inline (always)] pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXE"]
#[inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - LBD"]
#[inline (always)] pub fn lbd (& self) -> LbdR { LbdR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 5 - RXNE"]
#[inline (always)] pub fn rxne (& mut self) -> RxneW < '_ , SrSpec > { RxneW :: new (self , 5) }
#[doc = "Bit 6 - TC"]
#[inline (always)] pub fn tc (& mut self) -> TcW < '_ , SrSpec > { TcW :: new (self , 6) }
#[doc = "Bit 8 - LBD"]
#[inline (always)] pub fn lbd (& mut self) -> LbdW < '_ , SrSpec > { LbdW :: new (self , 8) } }
#[doc = "UART4_SR\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "DR (rw) register accessor: UART4_DR\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "UART4_DR"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - DR"] pub type DrR = crate :: FieldReader < u16 > ;
#[doc = "Field `DR` writer - DR"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R {
#[doc = "Bits 0:8 - DR"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new ((self . bits & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:8 - DR"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "UART4_DR\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "BRR (rw) register accessor: UART4_BRR\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "UART4_BRR"] pub mod brr {
#[doc = "Register `BRR` reader"] pub type R = crate :: R < BrrSpec > ;
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `DIV_Fraction` reader - DIV_Fraction"] pub type DivFractionR = crate :: FieldReader ;
#[doc = "Field `DIV_Fraction` writer - DIV_Fraction"] pub type DivFractionW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DIV_Mantissa` reader - DIV_Mantissa"] pub type DivMantissaR = crate :: FieldReader < u16 > ;
#[doc = "Field `DIV_Mantissa` writer - DIV_Mantissa"] pub type DivMantissaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:3 - DIV_Fraction"]
#[inline (always)] pub fn div_fraction (& self) -> DivFractionR { DivFractionR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:15 - DIV_Mantissa"]
#[inline (always)] pub fn div_mantissa (& self) -> DivMantissaR { DivMantissaR :: new (((self . bits >> 4) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:3 - DIV_Fraction"]
#[inline (always)] pub fn div_fraction (& mut self) -> DivFractionW < '_ , BrrSpec > { DivFractionW :: new (self , 0) }
#[doc = "Bits 4:15 - DIV_Mantissa"]
#[inline (always)] pub fn div_mantissa (& mut self) -> DivMantissaW < '_ , BrrSpec > { DivMantissaW :: new (self , 4) } }
#[doc = "UART4_BRR\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`brr::R`](R) reader structure"] impl crate :: Readable for BrrSpec { }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } }
#[doc = "CR1 (rw) register accessor: UART4_CR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "UART4_CR1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `SBK` reader - SBK"] pub type SbkR = crate :: BitReader ;
#[doc = "Field `SBK` writer - SBK"] pub type SbkW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RWU` reader - RWU"] pub type RwuR = crate :: BitReader ;
#[doc = "Field `RWU` writer - RWU"] pub type RwuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RE` reader - RE"] pub type ReR = crate :: BitReader ;
#[doc = "Field `RE` writer - RE"] pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TE` reader - TE"] pub type TeR = crate :: BitReader ;
#[doc = "Field `TE` writer - TE"] pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IDLEIE` reader - IDLEIE"] pub type IdleieR = crate :: BitReader ;
#[doc = "Field `IDLEIE` writer - IDLEIE"] pub type IdleieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXNEIE` reader - RXNEIE"] pub type RxneieR = crate :: BitReader ;
#[doc = "Field `RXNEIE` writer - RXNEIE"] pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - TCIE"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - TCIE"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEIE` reader - TXEIE"] pub type TxeieR = crate :: BitReader ;
#[doc = "Field `TXEIE` writer - TXEIE"] pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PEIE` reader - PEIE"] pub type PeieR = crate :: BitReader ;
#[doc = "Field `PEIE` writer - PEIE"] pub type PeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PS` reader - PS"] pub type PsR = crate :: BitReader ;
#[doc = "Field `PS` writer - PS"] pub type PsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PCE` reader - PCE"] pub type PceR = crate :: BitReader ;
#[doc = "Field `PCE` writer - PCE"] pub type PceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAKE` reader - WAKE"] pub type WakeR = crate :: BitReader ;
#[doc = "Field `WAKE` writer - WAKE"] pub type WakeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `M` reader - M"] pub type MR = crate :: BitReader ;
#[doc = "Field `M` writer - M"] pub type MW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UE` reader - UE"] pub type UeR = crate :: BitReader ;
#[doc = "Field `UE` writer - UE"] pub type UeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - SBK"]
#[inline (always)] pub fn sbk (& self) -> SbkR { SbkR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RWU"]
#[inline (always)] pub fn rwu (& self) -> RwuR { RwuR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RE"]
#[inline (always)] pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - TE"]
#[inline (always)] pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IDLEIE"]
#[inline (always)] pub fn idleie (& self) -> IdleieR { IdleieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RXNEIE"]
#[inline (always)] pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - TCIE"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXEIE"]
#[inline (always)] pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - PEIE"]
#[inline (always)] pub fn peie (& self) -> PeieR { PeieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - PS"]
#[inline (always)] pub fn ps (& self) -> PsR { PsR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - PCE"]
#[inline (always)] pub fn pce (& self) -> PceR { PceR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - WAKE"]
#[inline (always)] pub fn wake (& self) -> WakeR { WakeR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - M"]
#[inline (always)] pub fn m (& self) -> MR { MR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - UE"]
#[inline (always)] pub fn ue (& self) -> UeR { UeR :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - SBK"]
#[inline (always)] pub fn sbk (& mut self) -> SbkW < '_ , Cr1Spec > { SbkW :: new (self , 0) }
#[doc = "Bit 1 - RWU"]
#[inline (always)] pub fn rwu (& mut self) -> RwuW < '_ , Cr1Spec > { RwuW :: new (self , 1) }
#[doc = "Bit 2 - RE"]
#[inline (always)] pub fn re (& mut self) -> ReW < '_ , Cr1Spec > { ReW :: new (self , 2) }
#[doc = "Bit 3 - TE"]
#[inline (always)] pub fn te (& mut self) -> TeW < '_ , Cr1Spec > { TeW :: new (self , 3) }
#[doc = "Bit 4 - IDLEIE"]
#[inline (always)] pub fn idleie (& mut self) -> IdleieW < '_ , Cr1Spec > { IdleieW :: new (self , 4) }
#[doc = "Bit 5 - RXNEIE"]
#[inline (always)] pub fn rxneie (& mut self) -> RxneieW < '_ , Cr1Spec > { RxneieW :: new (self , 5) }
#[doc = "Bit 6 - TCIE"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Cr1Spec > { TcieW :: new (self , 6) }
#[doc = "Bit 7 - TXEIE"]
#[inline (always)] pub fn txeie (& mut self) -> TxeieW < '_ , Cr1Spec > { TxeieW :: new (self , 7) }
#[doc = "Bit 8 - PEIE"]
#[inline (always)] pub fn peie (& mut self) -> PeieW < '_ , Cr1Spec > { PeieW :: new (self , 8) }
#[doc = "Bit 9 - PS"]
#[inline (always)] pub fn ps (& mut self) -> PsW < '_ , Cr1Spec > { PsW :: new (self , 9) }
#[doc = "Bit 10 - PCE"]
#[inline (always)] pub fn pce (& mut self) -> PceW < '_ , Cr1Spec > { PceW :: new (self , 10) }
#[doc = "Bit 11 - WAKE"]
#[inline (always)] pub fn wake (& mut self) -> WakeW < '_ , Cr1Spec > { WakeW :: new (self , 11) }
#[doc = "Bit 12 - M"]
#[inline (always)] pub fn m (& mut self) -> MW < '_ , Cr1Spec > { MW :: new (self , 12) }
#[doc = "Bit 13 - UE"]
#[inline (always)] pub fn ue (& mut self) -> UeW < '_ , Cr1Spec > { UeW :: new (self , 13) } }
#[doc = "UART4_CR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: UART4_CR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "UART4_CR2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `ADD` reader - ADD"] pub type AddR = crate :: FieldReader ;
#[doc = "Field `ADD` writer - ADD"] pub type AddW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `LBDL` reader - LBDL"] pub type LbdlR = crate :: BitReader ;
#[doc = "Field `LBDL` writer - LBDL"] pub type LbdlW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LBDIE` reader - LBDIE"] pub type LbdieR = crate :: BitReader ;
#[doc = "Field `LBDIE` writer - LBDIE"] pub type LbdieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOP` reader - STOP"] pub type StopR = crate :: FieldReader ;
#[doc = "Field `STOP` writer - STOP"] pub type StopW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LINEN` reader - LINEN"] pub type LinenR = crate :: BitReader ;
#[doc = "Field `LINEN` writer - LINEN"] pub type LinenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - ADD"]
#[inline (always)] pub fn add (& self) -> AddR { AddR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 5 - LBDL"]
#[inline (always)] pub fn lbdl (& self) -> LbdlR { LbdlR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - LBDIE"]
#[inline (always)] pub fn lbdie (& self) -> LbdieR { LbdieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 12:13 - STOP"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - LINEN"]
#[inline (always)] pub fn linen (& self) -> LinenR { LinenR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - ADD"]
#[inline (always)] pub fn add (& mut self) -> AddW < '_ , Cr2Spec > { AddW :: new (self , 0) }
#[doc = "Bit 5 - LBDL"]
#[inline (always)] pub fn lbdl (& mut self) -> LbdlW < '_ , Cr2Spec > { LbdlW :: new (self , 5) }
#[doc = "Bit 6 - LBDIE"]
#[inline (always)] pub fn lbdie (& mut self) -> LbdieW < '_ , Cr2Spec > { LbdieW :: new (self , 6) }
#[doc = "Bits 12:13 - STOP"]
#[inline (always)] pub fn stop (& mut self) -> StopW < '_ , Cr2Spec > { StopW :: new (self , 12) }
#[doc = "Bit 14 - LINEN"]
#[inline (always)] pub fn linen (& mut self) -> LinenW < '_ , Cr2Spec > { LinenW :: new (self , 14) } }
#[doc = "UART4_CR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "CR3 (rw) register accessor: UART4_CR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr3`] module"]
#[doc (alias = "CR3")] pub type Cr3 = crate :: Reg < cr3 :: Cr3Spec > ;
#[doc = "UART4_CR3"] pub mod cr3 {
#[doc = "Register `CR3` reader"] pub type R = crate :: R < Cr3Spec > ;
#[doc = "Register `CR3` writer"] pub type W = crate :: W < Cr3Spec > ;
#[doc = "Field `EIE` reader - Error interrupt enable"] pub type EieR = crate :: BitReader ;
#[doc = "Field `EIE` writer - Error interrupt enable"] pub type EieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IREN` reader - IrDA mode enable"] pub type IrenR = crate :: BitReader ;
#[doc = "Field `IREN` writer - IrDA mode enable"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IRLP` reader - IrDA low-power"] pub type IrlpR = crate :: BitReader ;
#[doc = "Field `IRLP` writer - IrDA low-power"] pub type IrlpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HDSEL` reader - Half-duplex selection"] pub type HdselR = crate :: BitReader ;
#[doc = "Field `HDSEL` writer - Half-duplex selection"] pub type HdselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAT` reader - DMA enable transmitter"] pub type DmatR = crate :: BitReader ;
#[doc = "Field `DMAT` writer - DMA enable transmitter"] pub type DmatW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Error interrupt enable"]
#[inline (always)] pub fn eie (& self) -> EieR { EieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - IrDA mode enable"]
#[inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - IrDA low-power"]
#[inline (always)] pub fn irlp (& self) -> IrlpR { IrlpR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Half-duplex selection"]
#[inline (always)] pub fn hdsel (& self) -> HdselR { HdselR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - DMA enable transmitter"]
#[inline (always)] pub fn dmat (& self) -> DmatR { DmatR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Error interrupt enable"]
#[inline (always)] pub fn eie (& mut self) -> EieW < '_ , Cr3Spec > { EieW :: new (self , 0) }
#[doc = "Bit 1 - IrDA mode enable"]
#[inline (always)] pub fn iren (& mut self) -> IrenW < '_ , Cr3Spec > { IrenW :: new (self , 1) }
#[doc = "Bit 2 - IrDA low-power"]
#[inline (always)] pub fn irlp (& mut self) -> IrlpW < '_ , Cr3Spec > { IrlpW :: new (self , 2) }
#[doc = "Bit 3 - Half-duplex selection"]
#[inline (always)] pub fn hdsel (& mut self) -> HdselW < '_ , Cr3Spec > { HdselW :: new (self , 3) }
#[doc = "Bit 7 - DMA enable transmitter"]
#[inline (always)] pub fn dmat (& mut self) -> DmatW < '_ , Cr3Spec > { DmatW :: new (self , 7) } }
#[doc = "UART4_CR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr3Spec ; impl crate :: RegisterSpec for Cr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr3::R`](R) reader structure"] impl crate :: Readable for Cr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cr3::W`](W) writer structure"] impl crate :: Writable for Cr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR3 to value 0"] impl crate :: Resettable for Cr3Spec { } } }
#[doc = "CRC calculation unit"] pub type Crc = crate :: Periph < crc :: RegisterBlock , 0x4002_3000 > ; impl core :: fmt :: Debug for Crc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crc") . finish () } }
#[doc = "CRC calculation unit"] pub mod crc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { dr : Dr , idr : Idr , cr : Cr , } impl RegisterBlock {
#[doc = "0x00 - Data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x04 - Independent Data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x08 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr } }
#[doc = "DR (rw) register accessor: Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "Data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - Data Register"] pub type DrR = crate :: FieldReader < u32 > ;
#[doc = "Field `DR` writer - Data Register"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data Register"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data Register"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0xffff_ffff"] impl crate :: Resettable for DrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "IDR (rw) register accessor: Independent Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "Independent Data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Register `IDR` writer"] pub type W = crate :: W < IdrSpec > ;
#[doc = "Field `IDR` reader - Independent Data register"] pub type IdrR = crate :: FieldReader ;
#[doc = "Field `IDR` writer - Independent Data register"] pub type IdrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Independent Data register"]
#[inline (always)] pub fn idr (& self) -> IdrR { IdrR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Independent Data register"]
#[inline (always)] pub fn idr (& mut self) -> IdrW < '_ , IdrSpec > { IdrW :: new (self , 0) } }
#[doc = "Independent Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`write(|w| ..)` method takes [`idr::W`](W) writer structure"] impl crate :: Writable for IdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "CR (w) register accessor: Control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `RESET` writer - Reset bit"] pub type ResetW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Reset bit"]
#[inline (always)] pub fn reset (& mut self) -> ResetW < '_ , CrSpec > { ResetW :: new (self , 0) } }
#[doc = "Control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } } }
#[doc = "FLASH"] pub type Flash = crate :: Periph < flash :: RegisterBlock , 0x4002_2000 > ; impl core :: fmt :: Debug for Flash { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Flash") . finish () } }
#[doc = "FLASH"] pub mod flash {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { acr : Acr , keyr : Keyr , optkeyr : Optkeyr , sr : Sr , cr : Cr , ar : Ar , _reserved6 : [u8 ; 0x04] , obr : Obr , wrpr : Wrpr , } impl RegisterBlock {
#[doc = "0x00 - Flash access control register"]
#[inline (always)] pub const fn acr (& self) -> & Acr { & self . acr }
#[doc = "0x04 - Flash key register"]
#[inline (always)] pub const fn keyr (& self) -> & Keyr { & self . keyr }
#[doc = "0x08 - Flash option key register"]
#[inline (always)] pub const fn optkeyr (& self) -> & Optkeyr { & self . optkeyr }
#[doc = "0x0c - Status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x10 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x14 - Flash address register"]
#[inline (always)] pub const fn ar (& self) -> & Ar { & self . ar }
#[doc = "0x1c - Option byte register"]
#[inline (always)] pub const fn obr (& self) -> & Obr { & self . obr }
#[doc = "0x20 - Write protection register"]
#[inline (always)] pub const fn wrpr (& self) -> & Wrpr { & self . wrpr } }
#[doc = "ACR (rw) register accessor: Flash access control register\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@acr`] module"]
#[doc (alias = "ACR")] pub type Acr = crate :: Reg < acr :: AcrSpec > ;
#[doc = "Flash access control register"] pub mod acr {
#[doc = "Register `ACR` reader"] pub type R = crate :: R < AcrSpec > ;
#[doc = "Register `ACR` writer"] pub type W = crate :: W < AcrSpec > ;
#[doc = "Field `LATENCY` reader - Latency"] pub type LatencyR = crate :: FieldReader ;
#[doc = "Field `LATENCY` writer - Latency"] pub type LatencyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `HLFCYA` reader - Flash half cycle access enable"] pub type HlfcyaR = crate :: BitReader ;
#[doc = "Field `HLFCYA` writer - Flash half cycle access enable"] pub type HlfcyaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PRFTBE` reader - Prefetch buffer enable"] pub type PrftbeR = crate :: BitReader ;
#[doc = "Field `PRFTBE` writer - Prefetch buffer enable"] pub type PrftbeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PRFTBS` reader - Prefetch buffer status"] pub type PrftbsR = crate :: BitReader ; impl R {
#[doc = "Bits 0:2 - Latency"]
#[inline (always)] pub fn latency (& self) -> LatencyR { LatencyR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - Flash half cycle access enable"]
#[inline (always)] pub fn hlfcya (& self) -> HlfcyaR { HlfcyaR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Prefetch buffer enable"]
#[inline (always)] pub fn prftbe (& self) -> PrftbeR { PrftbeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Prefetch buffer status"]
#[inline (always)] pub fn prftbs (& self) -> PrftbsR { PrftbsR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Latency"]
#[inline (always)] pub fn latency (& mut self) -> LatencyW < '_ , AcrSpec > { LatencyW :: new (self , 0) }
#[doc = "Bit 3 - Flash half cycle access enable"]
#[inline (always)] pub fn hlfcya (& mut self) -> HlfcyaW < '_ , AcrSpec > { HlfcyaW :: new (self , 3) }
#[doc = "Bit 4 - Prefetch buffer enable"]
#[inline (always)] pub fn prftbe (& mut self) -> PrftbeW < '_ , AcrSpec > { PrftbeW :: new (self , 4) } }
#[doc = "Flash access control register\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AcrSpec ; impl crate :: RegisterSpec for AcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`acr::R`](R) reader structure"] impl crate :: Readable for AcrSpec { }
#[doc = "`write(|w| ..)` method takes [`acr::W`](W) writer structure"] impl crate :: Writable for AcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ACR to value 0x30"] impl crate :: Resettable for AcrSpec { const RESET_VALUE : u32 = 0x30 ; } }
#[doc = "KEYR (w) register accessor: Flash key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr`] module"]
#[doc (alias = "KEYR")] pub type Keyr = crate :: Reg < keyr :: KeyrSpec > ;
#[doc = "Flash key register"] pub mod keyr {
#[doc = "Register `KEYR` writer"] pub type W = crate :: W < KeyrSpec > ;
#[doc = "Field `KEY` writer - FPEC key"] pub type KeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - FPEC key"]
#[inline (always)] pub fn key (& mut self) -> KeyW < '_ , KeyrSpec > { KeyW :: new (self , 0) } }
#[doc = "Flash key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct KeyrSpec ; impl crate :: RegisterSpec for KeyrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`keyr::W`](W) writer structure"] impl crate :: Writable for KeyrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR to value 0"] impl crate :: Resettable for KeyrSpec { } }
#[doc = "OPTKEYR (w) register accessor: Flash option key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optkeyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@optkeyr`] module"]
#[doc (alias = "OPTKEYR")] pub type Optkeyr = crate :: Reg < optkeyr :: OptkeyrSpec > ;
#[doc = "Flash option key register"] pub mod optkeyr {
#[doc = "Register `OPTKEYR` writer"] pub type W = crate :: W < OptkeyrSpec > ;
#[doc = "Field `OPTKEY` writer - Option byte key"] pub type OptkeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - Option byte key"]
#[inline (always)] pub fn optkey (& mut self) -> OptkeyW < '_ , OptkeyrSpec > { OptkeyW :: new (self , 0) } }
#[doc = "Flash option key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optkeyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OptkeyrSpec ; impl crate :: RegisterSpec for OptkeyrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`optkeyr::W`](W) writer structure"] impl crate :: Writable for OptkeyrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OPTKEYR to value 0"] impl crate :: Resettable for OptkeyrSpec { } }
#[doc = "SR (rw) register accessor: Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `BSY` reader - Busy"] pub type BsyR = crate :: BitReader ;
#[doc = "Field `PGERR` reader - Programming error"] pub type PgerrR = crate :: BitReader ;
#[doc = "Field `PGERR` writer - Programming error"] pub type PgerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WRPRTERR` reader - Write protection error"] pub type WrprterrR = crate :: BitReader ;
#[doc = "Field `WRPRTERR` writer - Write protection error"] pub type WrprterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOP` reader - End of operation"] pub type EopR = crate :: BitReader ;
#[doc = "Field `EOP` writer - End of operation"] pub type EopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Busy"]
#[inline (always)] pub fn bsy (& self) -> BsyR { BsyR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - Programming error"]
#[inline (always)] pub fn pgerr (& self) -> PgerrR { PgerrR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - Write protection error"]
#[inline (always)] pub fn wrprterr (& self) -> WrprterrR { WrprterrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - End of operation"]
#[inline (always)] pub fn eop (& self) -> EopR { EopR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 2 - Programming error"]
#[inline (always)] pub fn pgerr (& mut self) -> PgerrW < '_ , SrSpec > { PgerrW :: new (self , 2) }
#[doc = "Bit 4 - Write protection error"]
#[inline (always)] pub fn wrprterr (& mut self) -> WrprterrW < '_ , SrSpec > { WrprterrW :: new (self , 4) }
#[doc = "Bit 5 - End of operation"]
#[inline (always)] pub fn eop (& mut self) -> EopW < '_ , SrSpec > { EopW :: new (self , 5) } }
#[doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CR (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `PG` reader - Programming"] pub type PgR = crate :: BitReader ;
#[doc = "Field `PG` writer - Programming"] pub type PgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PER` reader - Page Erase"] pub type PerR = crate :: BitReader ;
#[doc = "Field `PER` writer - Page Erase"] pub type PerW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MER` reader - Mass Erase"] pub type MerR = crate :: BitReader ;
#[doc = "Field `MER` writer - Mass Erase"] pub type MerW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTPG` reader - Option byte programming"] pub type OptpgR = crate :: BitReader ;
#[doc = "Field `OPTPG` writer - Option byte programming"] pub type OptpgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTER` reader - Option byte erase"] pub type OpterR = crate :: BitReader ;
#[doc = "Field `OPTER` writer - Option byte erase"] pub type OpterW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STRT` reader - Start"] pub type StrtR = crate :: BitReader ;
#[doc = "Field `STRT` writer - Start"] pub type StrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LOCK` reader - Lock"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - Lock"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTWRE` reader - Option bytes write enable"] pub type OptwreR = crate :: BitReader ;
#[doc = "Field `OPTWRE` writer - Option bytes write enable"] pub type OptwreW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOPIE` reader - End of operation interrupt enable"] pub type EopieR = crate :: BitReader ;
#[doc = "Field `EOPIE` writer - End of operation interrupt enable"] pub type EopieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Programming"]
#[inline (always)] pub fn pg (& self) -> PgR { PgR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Page Erase"]
#[inline (always)] pub fn per (& self) -> PerR { PerR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Mass Erase"]
#[inline (always)] pub fn mer (& self) -> MerR { MerR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - Option byte programming"]
#[inline (always)] pub fn optpg (& self) -> OptpgR { OptpgR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Option byte erase"]
#[inline (always)] pub fn opter (& self) -> OpterR { OpterR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Start"]
#[inline (always)] pub fn strt (& self) -> StrtR { StrtR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Lock"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - Option bytes write enable"]
#[inline (always)] pub fn optwre (& self) -> OptwreR { OptwreR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 12 - End of operation interrupt enable"]
#[inline (always)] pub fn eopie (& self) -> EopieR { EopieR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Programming"]
#[inline (always)] pub fn pg (& mut self) -> PgW < '_ , CrSpec > { PgW :: new (self , 0) }
#[doc = "Bit 1 - Page Erase"]
#[inline (always)] pub fn per (& mut self) -> PerW < '_ , CrSpec > { PerW :: new (self , 1) }
#[doc = "Bit 2 - Mass Erase"]
#[inline (always)] pub fn mer (& mut self) -> MerW < '_ , CrSpec > { MerW :: new (self , 2) }
#[doc = "Bit 4 - Option byte programming"]
#[inline (always)] pub fn optpg (& mut self) -> OptpgW < '_ , CrSpec > { OptpgW :: new (self , 4) }
#[doc = "Bit 5 - Option byte erase"]
#[inline (always)] pub fn opter (& mut self) -> OpterW < '_ , CrSpec > { OpterW :: new (self , 5) }
#[doc = "Bit 6 - Start"]
#[inline (always)] pub fn strt (& mut self) -> StrtW < '_ , CrSpec > { StrtW :: new (self , 6) }
#[doc = "Bit 7 - Lock"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , CrSpec > { LockW :: new (self , 7) }
#[doc = "Bit 9 - Option bytes write enable"]
#[inline (always)] pub fn optwre (& mut self) -> OptwreW < '_ , CrSpec > { OptwreW :: new (self , 9) }
#[doc = "Bit 10 - Error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , CrSpec > { ErrieW :: new (self , 10) }
#[doc = "Bit 12 - End of operation interrupt enable"]
#[inline (always)] pub fn eopie (& mut self) -> EopieW < '_ , CrSpec > { EopieW :: new (self , 12) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x80"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "AR (w) register accessor: Flash address register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ar::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ar`] module"]
#[doc (alias = "AR")] pub type Ar = crate :: Reg < ar :: ArSpec > ;
#[doc = "Flash address register"] pub mod ar {
#[doc = "Register `AR` writer"] pub type W = crate :: W < ArSpec > ;
#[doc = "Field `FAR` writer - Flash Address"] pub type FarW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - Flash Address"]
#[inline (always)] pub fn far (& mut self) -> FarW < '_ , ArSpec > { FarW :: new (self , 0) } }
#[doc = "Flash address register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ar::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArSpec ; impl crate :: RegisterSpec for ArSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ar::W`](W) writer structure"] impl crate :: Writable for ArSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AR to value 0"] impl crate :: Resettable for ArSpec { } }
#[doc = "OBR (r) register accessor: Option byte register\n\nYou can [`read`](crate::Reg::read) this register and get [`obr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@obr`] module"]
#[doc (alias = "OBR")] pub type Obr = crate :: Reg < obr :: ObrSpec > ;
#[doc = "Option byte register"] pub mod obr {
#[doc = "Register `OBR` reader"] pub type R = crate :: R < ObrSpec > ;
#[doc = "Field `OPTERR` reader - Option byte error"] pub type OpterrR = crate :: BitReader ;
#[doc = "Field `RDPRT` reader - Read protection"] pub type RdprtR = crate :: BitReader ;
#[doc = "Field `WDG_SW` reader - WDG_SW"] pub type WdgSwR = crate :: BitReader ;
#[doc = "Field `nRST_STOP` reader - nRST_STOP"] pub type NRstStopR = crate :: BitReader ;
#[doc = "Field `nRST_STDBY` reader - nRST_STDBY"] pub type NRstStdbyR = crate :: BitReader ;
#[doc = "Field `Data0` reader - Data0"] pub type Data0R = crate :: FieldReader ;
#[doc = "Field `Data1` reader - Data1"] pub type Data1R = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Option byte error"]
#[inline (always)] pub fn opterr (& self) -> OpterrR { OpterrR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Read protection"]
#[inline (always)] pub fn rdprt (& self) -> RdprtR { RdprtR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - WDG_SW"]
#[inline (always)] pub fn wdg_sw (& self) -> WdgSwR { WdgSwR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - nRST_STOP"]
#[inline (always)] pub fn n_rst_stop (& self) -> NRstStopR { NRstStopR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - nRST_STDBY"]
#[inline (always)] pub fn n_rst_stdby (& self) -> NRstStdbyR { NRstStdbyR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 10:17 - Data0"]
#[inline (always)] pub fn data0 (& self) -> Data0R { Data0R :: new (((self . bits >> 10) & 0xff) as u8) }
#[doc = "Bits 18:25 - Data1"]
#[inline (always)] pub fn data1 (& self) -> Data1R { Data1R :: new (((self . bits >> 18) & 0xff) as u8) } }
#[doc = "Option byte register\n\nYou can [`read`](crate::Reg::read) this register and get [`obr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ObrSpec ; impl crate :: RegisterSpec for ObrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`obr::R`](R) reader structure"] impl crate :: Readable for ObrSpec { }
#[doc = "`reset()` method sets OBR to value 0x03ff_fffc"] impl crate :: Resettable for ObrSpec { const RESET_VALUE : u32 = 0x03ff_fffc ; } }
#[doc = "WRPR (r) register accessor: Write protection register\n\nYou can [`read`](crate::Reg::read) this register and get [`wrpr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wrpr`] module"]
#[doc (alias = "WRPR")] pub type Wrpr = crate :: Reg < wrpr :: WrprSpec > ;
#[doc = "Write protection register"] pub mod wrpr {
#[doc = "Register `WRPR` reader"] pub type R = crate :: R < WrprSpec > ;
#[doc = "Field `WRP` reader - Write protect"] pub type WrpR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Write protect"]
#[inline (always)] pub fn wrp (& self) -> WrpR { WrpR :: new (self . bits) } }
#[doc = "Write protection register\n\nYou can [`read`](crate::Reg::read) this register and get [`wrpr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct WrprSpec ; impl crate :: RegisterSpec for WrprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`wrpr::R`](R) reader structure"] impl crate :: Readable for WrprSpec { }
#[doc = "`reset()` method sets WRPR to value 0xffff_ffff"] impl crate :: Resettable for WrprSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } }
#[doc = "Universal serial bus full-speed device interface"] pub type Usb = crate :: Periph < usb :: RegisterBlock , 0x4000_5c00 > ; impl core :: fmt :: Debug for Usb { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usb") . finish () } }
#[doc = "Universal serial bus full-speed device interface"] pub mod usb {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ep0r : Ep0r , ep1r : Ep1r , ep2r : Ep2r , ep3r : Ep3r , ep4r : Ep4r , ep5r : Ep5r , ep6r : Ep6r , ep7r : Ep7r , _reserved8 : [u8 ; 0x20] , cntr : Cntr , istr : Istr , fnr : Fnr , daddr : Daddr , btable : Btable , } impl RegisterBlock {
#[doc = "0x00 - endpoint 0 register"]
#[inline (always)] pub const fn ep0r (& self) -> & Ep0r { & self . ep0r }
#[doc = "0x04 - endpoint 1 register"]
#[inline (always)] pub const fn ep1r (& self) -> & Ep1r { & self . ep1r }
#[doc = "0x08 - endpoint 2 register"]
#[inline (always)] pub const fn ep2r (& self) -> & Ep2r { & self . ep2r }
#[doc = "0x0c - endpoint 3 register"]
#[inline (always)] pub const fn ep3r (& self) -> & Ep3r { & self . ep3r }
#[doc = "0x10 - endpoint 4 register"]
#[inline (always)] pub const fn ep4r (& self) -> & Ep4r { & self . ep4r }
#[doc = "0x14 - endpoint 5 register"]
#[inline (always)] pub const fn ep5r (& self) -> & Ep5r { & self . ep5r }
#[doc = "0x18 - endpoint 6 register"]
#[inline (always)] pub const fn ep6r (& self) -> & Ep6r { & self . ep6r }
#[doc = "0x1c - endpoint 7 register"]
#[inline (always)] pub const fn ep7r (& self) -> & Ep7r { & self . ep7r }
#[doc = "0x40 - control register"]
#[inline (always)] pub const fn cntr (& self) -> & Cntr { & self . cntr }
#[doc = "0x44 - interrupt status register"]
#[inline (always)] pub const fn istr (& self) -> & Istr { & self . istr }
#[doc = "0x48 - frame number register"]
#[inline (always)] pub const fn fnr (& self) -> & Fnr { & self . fnr }
#[doc = "0x4c - device address"]
#[inline (always)] pub const fn daddr (& self) -> & Daddr { & self . daddr }
#[doc = "0x50 - Buffer table address"]
#[inline (always)] pub const fn btable (& self) -> & Btable { & self . btable } }
#[doc = "EP0R (rw) register accessor: endpoint 0 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep0r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep0r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep0r`] module"]
#[doc (alias = "EP0R")] pub type Ep0r = crate :: Reg < ep0r :: Ep0rSpec > ;
#[doc = "endpoint 0 register"] pub mod ep0r {
#[doc = "Register `EP0R` reader"] pub type R = crate :: R < Ep0rSpec > ;
#[doc = "Register `EP0R` writer"] pub type W = crate :: W < Ep0rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep0rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep0rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep0rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep0rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep0rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep0rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep0rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep0rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep0rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep0rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 0 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep0r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep0r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep0rSpec ; impl crate :: RegisterSpec for Ep0rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ep0r::R`](R) reader structure"] impl crate :: Readable for Ep0rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep0r::W`](W) writer structure"] impl crate :: Writable for Ep0rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP0R to value 0"] impl crate :: Resettable for Ep0rSpec { } }
#[doc = "EP1R (rw) register accessor: endpoint 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep1r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep1r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep1r`] module"]
#[doc (alias = "EP1R")] pub type Ep1r = crate :: Reg < ep1r :: Ep1rSpec > ;
#[doc = "endpoint 1 register"] pub mod ep1r {
#[doc = "Register `EP1R` reader"] pub type R = crate :: R < Ep1rSpec > ;
#[doc = "Register `EP1R` writer"] pub type W = crate :: W < Ep1rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep1rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep1rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep1rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep1rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep1rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep1rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep1rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep1rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep1rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep1rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 1 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep1r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep1r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep1rSpec ; impl crate :: RegisterSpec for Ep1rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ep1r::R`](R) reader structure"] impl crate :: Readable for Ep1rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep1r::W`](W) writer structure"] impl crate :: Writable for Ep1rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP1R to value 0"] impl crate :: Resettable for Ep1rSpec { } }
#[doc = "EP2R (rw) register accessor: endpoint 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep2r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep2r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep2r`] module"]
#[doc (alias = "EP2R")] pub type Ep2r = crate :: Reg < ep2r :: Ep2rSpec > ;
#[doc = "endpoint 2 register"] pub mod ep2r {
#[doc = "Register `EP2R` reader"] pub type R = crate :: R < Ep2rSpec > ;
#[doc = "Register `EP2R` writer"] pub type W = crate :: W < Ep2rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep2rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep2rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep2rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep2rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep2rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep2rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep2rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep2rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep2rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep2rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 2 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep2r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep2r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep2rSpec ; impl crate :: RegisterSpec for Ep2rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ep2r::R`](R) reader structure"] impl crate :: Readable for Ep2rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep2r::W`](W) writer structure"] impl crate :: Writable for Ep2rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP2R to value 0"] impl crate :: Resettable for Ep2rSpec { } }
#[doc = "EP3R (rw) register accessor: endpoint 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep3r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep3r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep3r`] module"]
#[doc (alias = "EP3R")] pub type Ep3r = crate :: Reg < ep3r :: Ep3rSpec > ;
#[doc = "endpoint 3 register"] pub mod ep3r {
#[doc = "Register `EP3R` reader"] pub type R = crate :: R < Ep3rSpec > ;
#[doc = "Register `EP3R` writer"] pub type W = crate :: W < Ep3rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep3rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep3rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep3rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep3rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep3rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep3rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep3rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep3rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep3rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep3rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 3 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep3r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep3r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep3rSpec ; impl crate :: RegisterSpec for Ep3rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ep3r::R`](R) reader structure"] impl crate :: Readable for Ep3rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep3r::W`](W) writer structure"] impl crate :: Writable for Ep3rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP3R to value 0"] impl crate :: Resettable for Ep3rSpec { } }
#[doc = "EP4R (rw) register accessor: endpoint 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep4r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep4r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep4r`] module"]
#[doc (alias = "EP4R")] pub type Ep4r = crate :: Reg < ep4r :: Ep4rSpec > ;
#[doc = "endpoint 4 register"] pub mod ep4r {
#[doc = "Register `EP4R` reader"] pub type R = crate :: R < Ep4rSpec > ;
#[doc = "Register `EP4R` writer"] pub type W = crate :: W < Ep4rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep4rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep4rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep4rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep4rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep4rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep4rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep4rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep4rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep4rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep4rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 4 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep4r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep4r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep4rSpec ; impl crate :: RegisterSpec for Ep4rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ep4r::R`](R) reader structure"] impl crate :: Readable for Ep4rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep4r::W`](W) writer structure"] impl crate :: Writable for Ep4rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP4R to value 0"] impl crate :: Resettable for Ep4rSpec { } }
#[doc = "EP5R (rw) register accessor: endpoint 5 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep5r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep5r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep5r`] module"]
#[doc (alias = "EP5R")] pub type Ep5r = crate :: Reg < ep5r :: Ep5rSpec > ;
#[doc = "endpoint 5 register"] pub mod ep5r {
#[doc = "Register `EP5R` reader"] pub type R = crate :: R < Ep5rSpec > ;
#[doc = "Register `EP5R` writer"] pub type W = crate :: W < Ep5rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep5rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep5rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep5rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep5rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep5rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep5rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep5rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep5rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep5rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep5rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 5 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep5r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep5r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep5rSpec ; impl crate :: RegisterSpec for Ep5rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ep5r::R`](R) reader structure"] impl crate :: Readable for Ep5rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep5r::W`](W) writer structure"] impl crate :: Writable for Ep5rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP5R to value 0"] impl crate :: Resettable for Ep5rSpec { } }
#[doc = "EP6R (rw) register accessor: endpoint 6 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep6r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep6r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep6r`] module"]
#[doc (alias = "EP6R")] pub type Ep6r = crate :: Reg < ep6r :: Ep6rSpec > ;
#[doc = "endpoint 6 register"] pub mod ep6r {
#[doc = "Register `EP6R` reader"] pub type R = crate :: R < Ep6rSpec > ;
#[doc = "Register `EP6R` writer"] pub type W = crate :: W < Ep6rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep6rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep6rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep6rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep6rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep6rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep6rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep6rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep6rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep6rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep6rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 6 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep6r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep6r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep6rSpec ; impl crate :: RegisterSpec for Ep6rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ep6r::R`](R) reader structure"] impl crate :: Readable for Ep6rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep6r::W`](W) writer structure"] impl crate :: Writable for Ep6rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP6R to value 0"] impl crate :: Resettable for Ep6rSpec { } }
#[doc = "EP7R (rw) register accessor: endpoint 7 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep7r::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep7r::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ep7r`] module"]
#[doc (alias = "EP7R")] pub type Ep7r = crate :: Reg < ep7r :: Ep7rSpec > ;
#[doc = "endpoint 7 register"] pub mod ep7r {
#[doc = "Register `EP7R` reader"] pub type R = crate :: R < Ep7rSpec > ;
#[doc = "Register `EP7R` writer"] pub type W = crate :: W < Ep7rSpec > ;
#[doc = "Field `EA` reader - Endpoint address"] pub type EaR = crate :: FieldReader ;
#[doc = "Field `EA` writer - Endpoint address"] pub type EaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `STAT_TX` reader - Status bits, for transmission transfers"] pub type StatTxR = crate :: FieldReader ;
#[doc = "Field `STAT_TX` writer - Status bits, for transmission transfers"] pub type StatTxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_TX` reader - Data Toggle, for transmission transfers"] pub type DtogTxR = crate :: BitReader ;
#[doc = "Field `DTOG_TX` writer - Data Toggle, for transmission transfers"] pub type DtogTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_TX` reader - Correct Transfer for transmission"] pub type CtrTxR = crate :: BitReader ;
#[doc = "Field `CTR_TX` writer - Correct Transfer for transmission"] pub type CtrTxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_KIND` reader - Endpoint kind"] pub type EpKindR = crate :: BitReader ;
#[doc = "Field `EP_KIND` writer - Endpoint kind"] pub type EpKindW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EP_TYPE` reader - Endpoint type"] pub type EpTypeR = crate :: FieldReader ;
#[doc = "Field `EP_TYPE` writer - Endpoint type"] pub type EpTypeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SETUP` reader - Setup transaction completed"] pub type SetupR = crate :: BitReader ;
#[doc = "Field `SETUP` writer - Setup transaction completed"] pub type SetupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STAT_RX` reader - Status bits, for reception transfers"] pub type StatRxR = crate :: FieldReader ;
#[doc = "Field `STAT_RX` writer - Status bits, for reception transfers"] pub type StatRxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DTOG_RX` reader - Data Toggle, for reception transfers"] pub type DtogRxR = crate :: BitReader ;
#[doc = "Field `DTOG_RX` writer - Data Toggle, for reception transfers"] pub type DtogRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR_RX` reader - Correct transfer for reception"] pub type CtrRxR = crate :: BitReader ;
#[doc = "Field `CTR_RX` writer - Correct transfer for reception"] pub type CtrRxW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& self) -> EaR { EaR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& self) -> StatTxR { StatTxR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& self) -> DtogTxR { DtogTxR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& self) -> CtrTxR { CtrTxR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& self) -> EpKindR { EpKindR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& self) -> EpTypeR { EpTypeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& self) -> SetupR { SetupR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& self) -> StatRxR { StatRxR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& self) -> DtogRxR { DtogRxR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& self) -> CtrRxR { CtrRxR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint address"]
#[inline (always)] pub fn ea (& mut self) -> EaW < '_ , Ep7rSpec > { EaW :: new (self , 0) }
#[doc = "Bits 4:5 - Status bits, for transmission transfers"]
#[inline (always)] pub fn stat_tx (& mut self) -> StatTxW < '_ , Ep7rSpec > { StatTxW :: new (self , 4) }
#[doc = "Bit 6 - Data Toggle, for transmission transfers"]
#[inline (always)] pub fn dtog_tx (& mut self) -> DtogTxW < '_ , Ep7rSpec > { DtogTxW :: new (self , 6) }
#[doc = "Bit 7 - Correct Transfer for transmission"]
#[inline (always)] pub fn ctr_tx (& mut self) -> CtrTxW < '_ , Ep7rSpec > { CtrTxW :: new (self , 7) }
#[doc = "Bit 8 - Endpoint kind"]
#[inline (always)] pub fn ep_kind (& mut self) -> EpKindW < '_ , Ep7rSpec > { EpKindW :: new (self , 8) }
#[doc = "Bits 9:10 - Endpoint type"]
#[inline (always)] pub fn ep_type (& mut self) -> EpTypeW < '_ , Ep7rSpec > { EpTypeW :: new (self , 9) }
#[doc = "Bit 11 - Setup transaction completed"]
#[inline (always)] pub fn setup (& mut self) -> SetupW < '_ , Ep7rSpec > { SetupW :: new (self , 11) }
#[doc = "Bits 12:13 - Status bits, for reception transfers"]
#[inline (always)] pub fn stat_rx (& mut self) -> StatRxW < '_ , Ep7rSpec > { StatRxW :: new (self , 12) }
#[doc = "Bit 14 - Data Toggle, for reception transfers"]
#[inline (always)] pub fn dtog_rx (& mut self) -> DtogRxW < '_ , Ep7rSpec > { DtogRxW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer for reception"]
#[inline (always)] pub fn ctr_rx (& mut self) -> CtrRxW < '_ , Ep7rSpec > { CtrRxW :: new (self , 15) } }
#[doc = "endpoint 7 register\n\nYou can [`read`](crate::Reg::read) this register and get [`ep7r::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ep7r::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ep7rSpec ; impl crate :: RegisterSpec for Ep7rSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ep7r::R`](R) reader structure"] impl crate :: Readable for Ep7rSpec { }
#[doc = "`write(|w| ..)` method takes [`ep7r::W`](W) writer structure"] impl crate :: Writable for Ep7rSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EP7R to value 0"] impl crate :: Resettable for Ep7rSpec { } }
#[doc = "CNTR (rw) register accessor: control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cntr`] module"]
#[doc (alias = "CNTR")] pub type Cntr = crate :: Reg < cntr :: CntrSpec > ;
#[doc = "control register"] pub mod cntr {
#[doc = "Register `CNTR` reader"] pub type R = crate :: R < CntrSpec > ;
#[doc = "Register `CNTR` writer"] pub type W = crate :: W < CntrSpec > ;
#[doc = "Field `FRES` reader - Force USB Reset"] pub type FresR = crate :: BitReader ;
#[doc = "Field `FRES` writer - Force USB Reset"] pub type FresW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PDWN` reader - Power down"] pub type PdwnR = crate :: BitReader ;
#[doc = "Field `PDWN` writer - Power down"] pub type PdwnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LPMODE` reader - Low-power mode"] pub type LpmodeR = crate :: BitReader ;
#[doc = "Field `LPMODE` writer - Low-power mode"] pub type LpmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FSUSP` reader - Force suspend"] pub type FsuspR = crate :: BitReader ;
#[doc = "Field `FSUSP` writer - Force suspend"] pub type FsuspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RESUME` reader - Resume request"] pub type ResumeR = crate :: BitReader ;
#[doc = "Field `RESUME` writer - Resume request"] pub type ResumeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ESOFM` reader - Expected start of frame interrupt mask"] pub type EsofmR = crate :: BitReader ;
#[doc = "Field `ESOFM` writer - Expected start of frame interrupt mask"] pub type EsofmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SOFM` reader - Start of frame interrupt mask"] pub type SofmR = crate :: BitReader ;
#[doc = "Field `SOFM` writer - Start of frame interrupt mask"] pub type SofmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RESETM` reader - USB reset interrupt mask"] pub type ResetmR = crate :: BitReader ;
#[doc = "Field `RESETM` writer - USB reset interrupt mask"] pub type ResetmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SUSPM` reader - Suspend mode interrupt mask"] pub type SuspmR = crate :: BitReader ;
#[doc = "Field `SUSPM` writer - Suspend mode interrupt mask"] pub type SuspmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WKUPM` reader - Wakeup interrupt mask"] pub type WkupmR = crate :: BitReader ;
#[doc = "Field `WKUPM` writer - Wakeup interrupt mask"] pub type WkupmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRM` reader - Error interrupt mask"] pub type ErrmR = crate :: BitReader ;
#[doc = "Field `ERRM` writer - Error interrupt mask"] pub type ErrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PMAOVRM` reader - Packet memory area over / underrun interrupt mask"] pub type PmaovrmR = crate :: BitReader ;
#[doc = "Field `PMAOVRM` writer - Packet memory area over / underrun interrupt mask"] pub type PmaovrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTRM` reader - Correct transfer interrupt mask"] pub type CtrmR = crate :: BitReader ;
#[doc = "Field `CTRM` writer - Correct transfer interrupt mask"] pub type CtrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Force USB Reset"]
#[inline (always)] pub fn fres (& self) -> FresR { FresR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Power down"]
#[inline (always)] pub fn pdwn (& self) -> PdwnR { PdwnR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Low-power mode"]
#[inline (always)] pub fn lpmode (& self) -> LpmodeR { LpmodeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Force suspend"]
#[inline (always)] pub fn fsusp (& self) -> FsuspR { FsuspR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Resume request"]
#[inline (always)] pub fn resume (& self) -> ResumeR { ResumeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 8 - Expected start of frame interrupt mask"]
#[inline (always)] pub fn esofm (& self) -> EsofmR { EsofmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Start of frame interrupt mask"]
#[inline (always)] pub fn sofm (& self) -> SofmR { SofmR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - USB reset interrupt mask"]
#[inline (always)] pub fn resetm (& self) -> ResetmR { ResetmR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Suspend mode interrupt mask"]
#[inline (always)] pub fn suspm (& self) -> SuspmR { SuspmR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Wakeup interrupt mask"]
#[inline (always)] pub fn wkupm (& self) -> WkupmR { WkupmR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Error interrupt mask"]
#[inline (always)] pub fn errm (& self) -> ErrmR { ErrmR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Packet memory area over / underrun interrupt mask"]
#[inline (always)] pub fn pmaovrm (& self) -> PmaovrmR { PmaovrmR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer interrupt mask"]
#[inline (always)] pub fn ctrm (& self) -> CtrmR { CtrmR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Force USB Reset"]
#[inline (always)] pub fn fres (& mut self) -> FresW < '_ , CntrSpec > { FresW :: new (self , 0) }
#[doc = "Bit 1 - Power down"]
#[inline (always)] pub fn pdwn (& mut self) -> PdwnW < '_ , CntrSpec > { PdwnW :: new (self , 1) }
#[doc = "Bit 2 - Low-power mode"]
#[inline (always)] pub fn lpmode (& mut self) -> LpmodeW < '_ , CntrSpec > { LpmodeW :: new (self , 2) }
#[doc = "Bit 3 - Force suspend"]
#[inline (always)] pub fn fsusp (& mut self) -> FsuspW < '_ , CntrSpec > { FsuspW :: new (self , 3) }
#[doc = "Bit 4 - Resume request"]
#[inline (always)] pub fn resume (& mut self) -> ResumeW < '_ , CntrSpec > { ResumeW :: new (self , 4) }
#[doc = "Bit 8 - Expected start of frame interrupt mask"]
#[inline (always)] pub fn esofm (& mut self) -> EsofmW < '_ , CntrSpec > { EsofmW :: new (self , 8) }
#[doc = "Bit 9 - Start of frame interrupt mask"]
#[inline (always)] pub fn sofm (& mut self) -> SofmW < '_ , CntrSpec > { SofmW :: new (self , 9) }
#[doc = "Bit 10 - USB reset interrupt mask"]
#[inline (always)] pub fn resetm (& mut self) -> ResetmW < '_ , CntrSpec > { ResetmW :: new (self , 10) }
#[doc = "Bit 11 - Suspend mode interrupt mask"]
#[inline (always)] pub fn suspm (& mut self) -> SuspmW < '_ , CntrSpec > { SuspmW :: new (self , 11) }
#[doc = "Bit 12 - Wakeup interrupt mask"]
#[inline (always)] pub fn wkupm (& mut self) -> WkupmW < '_ , CntrSpec > { WkupmW :: new (self , 12) }
#[doc = "Bit 13 - Error interrupt mask"]
#[inline (always)] pub fn errm (& mut self) -> ErrmW < '_ , CntrSpec > { ErrmW :: new (self , 13) }
#[doc = "Bit 14 - Packet memory area over / underrun interrupt mask"]
#[inline (always)] pub fn pmaovrm (& mut self) -> PmaovrmW < '_ , CntrSpec > { PmaovrmW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer interrupt mask"]
#[inline (always)] pub fn ctrm (& mut self) -> CtrmW < '_ , CntrSpec > { CtrmW :: new (self , 15) } }
#[doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntrSpec ; impl crate :: RegisterSpec for CntrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cntr::R`](R) reader structure"] impl crate :: Readable for CntrSpec { }
#[doc = "`write(|w| ..)` method takes [`cntr::W`](W) writer structure"] impl crate :: Writable for CntrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNTR to value 0x03"] impl crate :: Resettable for CntrSpec { const RESET_VALUE : u32 = 0x03 ; } }
#[doc = "ISTR (rw) register accessor: interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`istr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`istr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@istr`] module"]
#[doc (alias = "ISTR")] pub type Istr = crate :: Reg < istr :: IstrSpec > ;
#[doc = "interrupt status register"] pub mod istr {
#[doc = "Register `ISTR` reader"] pub type R = crate :: R < IstrSpec > ;
#[doc = "Register `ISTR` writer"] pub type W = crate :: W < IstrSpec > ;
#[doc = "Field `EP_ID` reader - Endpoint Identifier"] pub type EpIdR = crate :: FieldReader ;
#[doc = "Field `EP_ID` writer - Endpoint Identifier"] pub type EpIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `DIR` reader - Direction of transaction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Direction of transaction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ESOF` reader - Expected start frame"] pub type EsofR = crate :: BitReader ;
#[doc = "Field `ESOF` writer - Expected start frame"] pub type EsofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SOF` reader - start of frame"] pub type SofR = crate :: BitReader ;
#[doc = "Field `SOF` writer - start of frame"] pub type SofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RESET` reader - reset request"] pub type ResetR = crate :: BitReader ;
#[doc = "Field `RESET` writer - reset request"] pub type ResetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SUSP` reader - Suspend mode request"] pub type SuspR = crate :: BitReader ;
#[doc = "Field `SUSP` writer - Suspend mode request"] pub type SuspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WKUP` reader - Wakeup"] pub type WkupR = crate :: BitReader ;
#[doc = "Field `WKUP` writer - Wakeup"] pub type WkupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERR` reader - Error"] pub type ErrR = crate :: BitReader ;
#[doc = "Field `ERR` writer - Error"] pub type ErrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PMAOVR` reader - Packet memory area over / underrun"] pub type PmaovrR = crate :: BitReader ;
#[doc = "Field `PMAOVR` writer - Packet memory area over / underrun"] pub type PmaovrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTR` reader - Correct transfer"] pub type CtrR = crate :: BitReader ;
#[doc = "Field `CTR` writer - Correct transfer"] pub type CtrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Endpoint Identifier"]
#[inline (always)] pub fn ep_id (& self) -> EpIdR { EpIdR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 4 - Direction of transaction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 8 - Expected start frame"]
#[inline (always)] pub fn esof (& self) -> EsofR { EsofR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - start of frame"]
#[inline (always)] pub fn sof (& self) -> SofR { SofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - reset request"]
#[inline (always)] pub fn reset (& self) -> ResetR { ResetR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Suspend mode request"]
#[inline (always)] pub fn susp (& self) -> SuspR { SuspR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Wakeup"]
#[inline (always)] pub fn wkup (& self) -> WkupR { WkupR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Error"]
#[inline (always)] pub fn err (& self) -> ErrR { ErrR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Packet memory area over / underrun"]
#[inline (always)] pub fn pmaovr (& self) -> PmaovrR { PmaovrR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Correct transfer"]
#[inline (always)] pub fn ctr (& self) -> CtrR { CtrR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Endpoint Identifier"]
#[inline (always)] pub fn ep_id (& mut self) -> EpIdW < '_ , IstrSpec > { EpIdW :: new (self , 0) }
#[doc = "Bit 4 - Direction of transaction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , IstrSpec > { DirW :: new (self , 4) }
#[doc = "Bit 8 - Expected start frame"]
#[inline (always)] pub fn esof (& mut self) -> EsofW < '_ , IstrSpec > { EsofW :: new (self , 8) }
#[doc = "Bit 9 - start of frame"]
#[inline (always)] pub fn sof (& mut self) -> SofW < '_ , IstrSpec > { SofW :: new (self , 9) }
#[doc = "Bit 10 - reset request"]
#[inline (always)] pub fn reset (& mut self) -> ResetW < '_ , IstrSpec > { ResetW :: new (self , 10) }
#[doc = "Bit 11 - Suspend mode request"]
#[inline (always)] pub fn susp (& mut self) -> SuspW < '_ , IstrSpec > { SuspW :: new (self , 11) }
#[doc = "Bit 12 - Wakeup"]
#[inline (always)] pub fn wkup (& mut self) -> WkupW < '_ , IstrSpec > { WkupW :: new (self , 12) }
#[doc = "Bit 13 - Error"]
#[inline (always)] pub fn err (& mut self) -> ErrW < '_ , IstrSpec > { ErrW :: new (self , 13) }
#[doc = "Bit 14 - Packet memory area over / underrun"]
#[inline (always)] pub fn pmaovr (& mut self) -> PmaovrW < '_ , IstrSpec > { PmaovrW :: new (self , 14) }
#[doc = "Bit 15 - Correct transfer"]
#[inline (always)] pub fn ctr (& mut self) -> CtrW < '_ , IstrSpec > { CtrW :: new (self , 15) } }
#[doc = "interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`istr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`istr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IstrSpec ; impl crate :: RegisterSpec for IstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`istr::R`](R) reader structure"] impl crate :: Readable for IstrSpec { }
#[doc = "`write(|w| ..)` method takes [`istr::W`](W) writer structure"] impl crate :: Writable for IstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ISTR to value 0"] impl crate :: Resettable for IstrSpec { } }
#[doc = "FNR (r) register accessor: frame number register\n\nYou can [`read`](crate::Reg::read) this register and get [`fnr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fnr`] module"]
#[doc (alias = "FNR")] pub type Fnr = crate :: Reg < fnr :: FnrSpec > ;
#[doc = "frame number register"] pub mod fnr {
#[doc = "Register `FNR` reader"] pub type R = crate :: R < FnrSpec > ;
#[doc = "Field `FN` reader - Frame number"] pub type FnR = crate :: FieldReader < u16 > ;
#[doc = "Field `LSOF` reader - Lost SOF"] pub type LsofR = crate :: FieldReader ;
#[doc = "Field `LCK` reader - Locked"] pub type LckR = crate :: BitReader ;
#[doc = "Field `RXDM` reader - Receive data - line status"] pub type RxdmR = crate :: BitReader ;
#[doc = "Field `RXDP` reader - Receive data + line status"] pub type RxdpR = crate :: BitReader ; impl R {
#[doc = "Bits 0:10 - Frame number"]
#[inline (always)] pub fn fn_ (& self) -> FnR { FnR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:12 - Lost SOF"]
#[inline (always)] pub fn lsof (& self) -> LsofR { LsofR :: new (((self . bits >> 11) & 3) as u8) }
#[doc = "Bit 13 - Locked"]
#[inline (always)] pub fn lck (& self) -> LckR { LckR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Receive data - line status"]
#[inline (always)] pub fn rxdm (& self) -> RxdmR { RxdmR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Receive data + line status"]
#[inline (always)] pub fn rxdp (& self) -> RxdpR { RxdpR :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "frame number register\n\nYou can [`read`](crate::Reg::read) this register and get [`fnr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FnrSpec ; impl crate :: RegisterSpec for FnrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fnr::R`](R) reader structure"] impl crate :: Readable for FnrSpec { }
#[doc = "`reset()` method sets FNR to value 0"] impl crate :: Resettable for FnrSpec { } }
#[doc = "DADDR (rw) register accessor: device address\n\nYou can [`read`](crate::Reg::read) this register and get [`daddr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`daddr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@daddr`] module"]
#[doc (alias = "DADDR")] pub type Daddr = crate :: Reg < daddr :: DaddrSpec > ;
#[doc = "device address"] pub mod daddr {
#[doc = "Register `DADDR` reader"] pub type R = crate :: R < DaddrSpec > ;
#[doc = "Register `DADDR` writer"] pub type W = crate :: W < DaddrSpec > ;
#[doc = "Field `ADD` reader - Device address"] pub type AddR = crate :: FieldReader ;
#[doc = "Field `ADD` writer - Device address"] pub type AddW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `EF` reader - Enable function"] pub type EfR = crate :: BitReader ;
#[doc = "Field `EF` writer - Enable function"] pub type EfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - Device address"]
#[inline (always)] pub fn add (& self) -> AddR { AddR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bit 7 - Enable function"]
#[inline (always)] pub fn ef (& self) -> EfR { EfR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - Device address"]
#[inline (always)] pub fn add (& mut self) -> AddW < '_ , DaddrSpec > { AddW :: new (self , 0) }
#[doc = "Bit 7 - Enable function"]
#[inline (always)] pub fn ef (& mut self) -> EfW < '_ , DaddrSpec > { EfW :: new (self , 7) } }
#[doc = "device address\n\nYou can [`read`](crate::Reg::read) this register and get [`daddr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`daddr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DaddrSpec ; impl crate :: RegisterSpec for DaddrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`daddr::R`](R) reader structure"] impl crate :: Readable for DaddrSpec { }
#[doc = "`write(|w| ..)` method takes [`daddr::W`](W) writer structure"] impl crate :: Writable for DaddrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DADDR to value 0"] impl crate :: Resettable for DaddrSpec { } }
#[doc = "BTABLE (rw) register accessor: Buffer table address\n\nYou can [`read`](crate::Reg::read) this register and get [`btable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@btable`] module"]
#[doc (alias = "BTABLE")] pub type Btable = crate :: Reg < btable :: BtableSpec > ;
#[doc = "Buffer table address"] pub mod btable {
#[doc = "Register `BTABLE` reader"] pub type R = crate :: R < BtableSpec > ;
#[doc = "Register `BTABLE` writer"] pub type W = crate :: W < BtableSpec > ;
#[doc = "Field `BTABLE` reader - Buffer table"] pub type BtableR = crate :: FieldReader < u16 > ;
#[doc = "Field `BTABLE` writer - Buffer table"] pub type BtableW < 'a , REG > = crate :: FieldWriter < 'a , REG , 13 , u16 > ; impl R {
#[doc = "Bits 3:15 - Buffer table"]
#[inline (always)] pub fn btable (& self) -> BtableR { BtableR :: new (((self . bits >> 3) & 0x1fff) as u16) } } impl W {
#[doc = "Bits 3:15 - Buffer table"]
#[inline (always)] pub fn btable (& mut self) -> BtableW < '_ , BtableSpec > { BtableW :: new (self , 3) } }
#[doc = "Buffer table address\n\nYou can [`read`](crate::Reg::read) this register and get [`btable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BtableSpec ; impl crate :: RegisterSpec for BtableSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`btable::R`](R) reader structure"] impl crate :: Readable for BtableSpec { }
#[doc = "`write(|w| ..)` method takes [`btable::W`](W) writer structure"] impl crate :: Writable for BtableSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BTABLE to value 0"] impl crate :: Resettable for BtableSpec { } } }
#[doc = "USB on the go full speed"] pub type OtgFsDevice = crate :: Periph < otg_fs_device :: RegisterBlock , 0x5000_0800 > ; impl core :: fmt :: Debug for OtgFsDevice { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgFsDevice") . finish () } }
#[doc = "USB on the go full speed"] pub mod otg_fs_device {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { fs_dcfg : FsDcfg , fs_dctl : FsDctl , fs_dsts : FsDsts , _reserved3 : [u8 ; 0x04] , fs_diepmsk : FsDiepmsk , fs_doepmsk : FsDoepmsk , fs_daint : FsDaint , fs_daintmsk : FsDaintmsk , _reserved7 : [u8 ; 0x08] , dvbusdis : Dvbusdis , dvbuspulse : Dvbuspulse , _reserved9 : [u8 ; 0x04] , diepempmsk : Diepempmsk , _reserved10 : [u8 ; 0xc8] , fs_diepctl0 : FsDiepctl0 , _reserved11 : [u8 ; 0x04] , diepint0 : Diepint0 , _reserved12 : [u8 ; 0x04] , dieptsiz0 : Dieptsiz0 , _reserved13 : [u8 ; 0x04] , dtxfsts0 : Dtxfsts0 , _reserved14 : [u8 ; 0x04] , diepctl1 : Diepctl1 , _reserved15 : [u8 ; 0x04] , diepint1 : Diepint1 , _reserved16 : [u8 ; 0x04] , dieptsiz1 : Dieptsiz1 , _reserved17 : [u8 ; 0x04] , dtxfsts1 : Dtxfsts1 , _reserved18 : [u8 ; 0x04] , diepctl2 : Diepctl2 , _reserved19 : [u8 ; 0x04] , diepint2 : Diepint2 , _reserved20 : [u8 ; 0x04] , dieptsiz2 : Dieptsiz2 , _reserved21 : [u8 ; 0x04] , dtxfsts2 : Dtxfsts2 , _reserved22 : [u8 ; 0x04] , diepctl3 : Diepctl3 , _reserved23 : [u8 ; 0x04] , diepint3 : Diepint3 , _reserved24 : [u8 ; 0x04] , dieptsiz3 : Dieptsiz3 , _reserved25 : [u8 ; 0x04] , dtxfsts3 : Dtxfsts3 , _reserved26 : [u8 ; 0x0184] , doepctl0 : Doepctl0 , _reserved27 : [u8 ; 0x04] , doepint0 : Doepint0 , _reserved28 : [u8 ; 0x04] , doeptsiz0 : Doeptsiz0 , _reserved29 : [u8 ; 0x0c] , doepctl1 : Doepctl1 , _reserved30 : [u8 ; 0x04] , doepint1 : Doepint1 , _reserved31 : [u8 ; 0x04] , doeptsiz1 : Doeptsiz1 , _reserved32 : [u8 ; 0x0c] , doepctl2 : Doepctl2 , _reserved33 : [u8 ; 0x04] , doepint2 : Doepint2 , _reserved34 : [u8 ; 0x04] , doeptsiz2 : Doeptsiz2 , _reserved35 : [u8 ; 0x0c] , doepctl3 : Doepctl3 , _reserved36 : [u8 ; 0x04] , doepint3 : Doepint3 , _reserved37 : [u8 ; 0x04] , doeptsiz3 : Doeptsiz3 , } impl RegisterBlock {
#[doc = "0x00 - OTG_FS device configuration register (OTG_FS_DCFG)"]
#[inline (always)] pub const fn fs_dcfg (& self) -> & FsDcfg { & self . fs_dcfg }
#[doc = "0x04 - OTG_FS device control register (OTG_FS_DCTL)"]
#[inline (always)] pub const fn fs_dctl (& self) -> & FsDctl { & self . fs_dctl }
#[doc = "0x08 - OTG_FS device status register (OTG_FS_DSTS)"]
#[inline (always)] pub const fn fs_dsts (& self) -> & FsDsts { & self . fs_dsts }
#[doc = "0x10 - OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)"]
#[inline (always)] pub const fn fs_diepmsk (& self) -> & FsDiepmsk { & self . fs_diepmsk }
#[doc = "0x14 - OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)"]
#[inline (always)] pub const fn fs_doepmsk (& self) -> & FsDoepmsk { & self . fs_doepmsk }
#[doc = "0x18 - OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)"]
#[inline (always)] pub const fn fs_daint (& self) -> & FsDaint { & self . fs_daint }
#[doc = "0x1c - OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)"]
#[inline (always)] pub const fn fs_daintmsk (& self) -> & FsDaintmsk { & self . fs_daintmsk }
#[doc = "0x28 - OTG_FS device VBUS discharge time register"]
#[inline (always)] pub const fn dvbusdis (& self) -> & Dvbusdis { & self . dvbusdis }
#[doc = "0x2c - OTG_FS device VBUS pulsing time register"]
#[inline (always)] pub const fn dvbuspulse (& self) -> & Dvbuspulse { & self . dvbuspulse }
#[doc = "0x34 - OTG_FS device IN endpoint FIFO empty interrupt mask register"]
#[inline (always)] pub const fn diepempmsk (& self) -> & Diepempmsk { & self . diepempmsk }
#[doc = "0x100 - OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)"]
#[inline (always)] pub const fn fs_diepctl0 (& self) -> & FsDiepctl0 { & self . fs_diepctl0 }
#[doc = "0x108 - device endpoint-x interrupt register"]
#[inline (always)] pub const fn diepint0 (& self) -> & Diepint0 { & self . diepint0 }
#[doc = "0x110 - device endpoint-0 transfer size register"]
#[inline (always)] pub const fn dieptsiz0 (& self) -> & Dieptsiz0 { & self . dieptsiz0 }
#[doc = "0x118 - OTG_FS device IN endpoint transmit FIFO status register"]
#[inline (always)] pub const fn dtxfsts0 (& self) -> & Dtxfsts0 { & self . dtxfsts0 }
#[doc = "0x120 - OTG device endpoint-1 control register"]
#[inline (always)] pub const fn diepctl1 (& self) -> & Diepctl1 { & self . diepctl1 }
#[doc = "0x128 - device endpoint-1 interrupt register"]
#[inline (always)] pub const fn diepint1 (& self) -> & Diepint1 { & self . diepint1 }
#[doc = "0x130 - device endpoint-1 transfer size register"]
#[inline (always)] pub const fn dieptsiz1 (& self) -> & Dieptsiz1 { & self . dieptsiz1 }
#[doc = "0x138 - OTG_FS device IN endpoint transmit FIFO status register"]
#[inline (always)] pub const fn dtxfsts1 (& self) -> & Dtxfsts1 { & self . dtxfsts1 }
#[doc = "0x140 - OTG device endpoint-2 control register"]
#[inline (always)] pub const fn diepctl2 (& self) -> & Diepctl2 { & self . diepctl2 }
#[doc = "0x148 - device endpoint-2 interrupt register"]
#[inline (always)] pub const fn diepint2 (& self) -> & Diepint2 { & self . diepint2 }
#[doc = "0x150 - device endpoint-2 transfer size register"]
#[inline (always)] pub const fn dieptsiz2 (& self) -> & Dieptsiz2 { & self . dieptsiz2 }
#[doc = "0x158 - OTG_FS device IN endpoint transmit FIFO status register"]
#[inline (always)] pub const fn dtxfsts2 (& self) -> & Dtxfsts2 { & self . dtxfsts2 }
#[doc = "0x160 - OTG device endpoint-3 control register"]
#[inline (always)] pub const fn diepctl3 (& self) -> & Diepctl3 { & self . diepctl3 }
#[doc = "0x168 - device endpoint-3 interrupt register"]
#[inline (always)] pub const fn diepint3 (& self) -> & Diepint3 { & self . diepint3 }
#[doc = "0x170 - device endpoint-3 transfer size register"]
#[inline (always)] pub const fn dieptsiz3 (& self) -> & Dieptsiz3 { & self . dieptsiz3 }
#[doc = "0x178 - OTG_FS device IN endpoint transmit FIFO status register"]
#[inline (always)] pub const fn dtxfsts3 (& self) -> & Dtxfsts3 { & self . dtxfsts3 }
#[doc = "0x300 - device endpoint-0 control register"]
#[inline (always)] pub const fn doepctl0 (& self) -> & Doepctl0 { & self . doepctl0 }
#[doc = "0x308 - device endpoint-0 interrupt register"]
#[inline (always)] pub const fn doepint0 (& self) -> & Doepint0 { & self . doepint0 }
#[doc = "0x310 - device OUT endpoint-0 transfer size register"]
#[inline (always)] pub const fn doeptsiz0 (& self) -> & Doeptsiz0 { & self . doeptsiz0 }
#[doc = "0x320 - device endpoint-1 control register"]
#[inline (always)] pub const fn doepctl1 (& self) -> & Doepctl1 { & self . doepctl1 }
#[doc = "0x328 - device endpoint-1 interrupt register"]
#[inline (always)] pub const fn doepint1 (& self) -> & Doepint1 { & self . doepint1 }
#[doc = "0x330 - device OUT endpoint-1 transfer size register"]
#[inline (always)] pub const fn doeptsiz1 (& self) -> & Doeptsiz1 { & self . doeptsiz1 }
#[doc = "0x340 - device endpoint-2 control register"]
#[inline (always)] pub const fn doepctl2 (& self) -> & Doepctl2 { & self . doepctl2 }
#[doc = "0x348 - device endpoint-2 interrupt register"]
#[inline (always)] pub const fn doepint2 (& self) -> & Doepint2 { & self . doepint2 }
#[doc = "0x350 - device OUT endpoint-2 transfer size register"]
#[inline (always)] pub const fn doeptsiz2 (& self) -> & Doeptsiz2 { & self . doeptsiz2 }
#[doc = "0x360 - device endpoint-3 control register"]
#[inline (always)] pub const fn doepctl3 (& self) -> & Doepctl3 { & self . doepctl3 }
#[doc = "0x368 - device endpoint-3 interrupt register"]
#[inline (always)] pub const fn doepint3 (& self) -> & Doepint3 { & self . doepint3 }
#[doc = "0x370 - device OUT endpoint-3 transfer size register"]
#[inline (always)] pub const fn doeptsiz3 (& self) -> & Doeptsiz3 { & self . doeptsiz3 } }
#[doc = "FS_DCFG (rw) register accessor: OTG_FS device configuration register (OTG_FS_DCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dcfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dcfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_dcfg`] module"]
#[doc (alias = "FS_DCFG")] pub type FsDcfg = crate :: Reg < fs_dcfg :: FsDcfgSpec > ;
#[doc = "OTG_FS device configuration register (OTG_FS_DCFG)"] pub mod fs_dcfg {
#[doc = "Register `FS_DCFG` reader"] pub type R = crate :: R < FsDcfgSpec > ;
#[doc = "Register `FS_DCFG` writer"] pub type W = crate :: W < FsDcfgSpec > ;
#[doc = "Field `DSPD` reader - Device speed"] pub type DspdR = crate :: FieldReader ;
#[doc = "Field `DSPD` writer - Device speed"] pub type DspdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `NZLSOHSK` reader - Non-zero-length status OUT handshake"] pub type NzlsohskR = crate :: BitReader ;
#[doc = "Field `NZLSOHSK` writer - Non-zero-length status OUT handshake"] pub type NzlsohskW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `PFIVL` reader - Periodic frame interval"] pub type PfivlR = crate :: FieldReader ;
#[doc = "Field `PFIVL` writer - Periodic frame interval"] pub type PfivlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Device speed"]
#[inline (always)] pub fn dspd (& self) -> DspdR { DspdR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Non-zero-length status OUT handshake"]
#[inline (always)] pub fn nzlsohsk (& self) -> NzlsohskR { NzlsohskR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 4:10 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 4) & 0x7f) as u8) }
#[doc = "Bits 11:12 - Periodic frame interval"]
#[inline (always)] pub fn pfivl (& self) -> PfivlR { PfivlR :: new (((self . bits >> 11) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Device speed"]
#[inline (always)] pub fn dspd (& mut self) -> DspdW < '_ , FsDcfgSpec > { DspdW :: new (self , 0) }
#[doc = "Bit 2 - Non-zero-length status OUT handshake"]
#[inline (always)] pub fn nzlsohsk (& mut self) -> NzlsohskW < '_ , FsDcfgSpec > { NzlsohskW :: new (self , 2) }
#[doc = "Bits 4:10 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsDcfgSpec > { DadW :: new (self , 4) }
#[doc = "Bits 11:12 - Periodic frame interval"]
#[inline (always)] pub fn pfivl (& mut self) -> PfivlW < '_ , FsDcfgSpec > { PfivlW :: new (self , 11) } }
#[doc = "OTG_FS device configuration register (OTG_FS_DCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dcfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dcfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDcfgSpec ; impl crate :: RegisterSpec for FsDcfgSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_dcfg::R`](R) reader structure"] impl crate :: Readable for FsDcfgSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_dcfg::W`](W) writer structure"] impl crate :: Writable for FsDcfgSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DCFG to value 0x0220_0000"] impl crate :: Resettable for FsDcfgSpec { const RESET_VALUE : u32 = 0x0220_0000 ; } }
#[doc = "FS_DCTL (rw) register accessor: OTG_FS device control register (OTG_FS_DCTL)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_dctl`] module"]
#[doc (alias = "FS_DCTL")] pub type FsDctl = crate :: Reg < fs_dctl :: FsDctlSpec > ;
#[doc = "OTG_FS device control register (OTG_FS_DCTL)"] pub mod fs_dctl {
#[doc = "Register `FS_DCTL` reader"] pub type R = crate :: R < FsDctlSpec > ;
#[doc = "Register `FS_DCTL` writer"] pub type W = crate :: W < FsDctlSpec > ;
#[doc = "Field `RWUSIG` reader - Remote wakeup signaling"] pub type RwusigR = crate :: BitReader ;
#[doc = "Field `RWUSIG` writer - Remote wakeup signaling"] pub type RwusigW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SDIS` reader - Soft disconnect"] pub type SdisR = crate :: BitReader ;
#[doc = "Field `SDIS` writer - Soft disconnect"] pub type SdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GINSTS` reader - Global IN NAK status"] pub type GinstsR = crate :: BitReader ;
#[doc = "Field `GONSTS` reader - Global OUT NAK status"] pub type GonstsR = crate :: BitReader ;
#[doc = "Field `TCTL` reader - Test control"] pub type TctlR = crate :: FieldReader ;
#[doc = "Field `TCTL` writer - Test control"] pub type TctlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SGINAK` reader - Set global IN NAK"] pub type SginakR = crate :: BitReader ;
#[doc = "Field `SGINAK` writer - Set global IN NAK"] pub type SginakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGINAK` reader - Clear global IN NAK"] pub type CginakR = crate :: BitReader ;
#[doc = "Field `CGINAK` writer - Clear global IN NAK"] pub type CginakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SGONAK` reader - Set global OUT NAK"] pub type SgonakR = crate :: BitReader ;
#[doc = "Field `SGONAK` writer - Set global OUT NAK"] pub type SgonakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGONAK` reader - Clear global OUT NAK"] pub type CgonakR = crate :: BitReader ;
#[doc = "Field `CGONAK` writer - Clear global OUT NAK"] pub type CgonakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `POPRGDNE` reader - Power-on programming done"] pub type PoprgdneR = crate :: BitReader ;
#[doc = "Field `POPRGDNE` writer - Power-on programming done"] pub type PoprgdneW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Remote wakeup signaling"]
#[inline (always)] pub fn rwusig (& self) -> RwusigR { RwusigR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Soft disconnect"]
#[inline (always)] pub fn sdis (& self) -> SdisR { SdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Global IN NAK status"]
#[inline (always)] pub fn ginsts (& self) -> GinstsR { GinstsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Global OUT NAK status"]
#[inline (always)] pub fn gonsts (& self) -> GonstsR { GonstsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Test control"]
#[inline (always)] pub fn tctl (& self) -> TctlR { TctlR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Set global IN NAK"]
#[inline (always)] pub fn sginak (& self) -> SginakR { SginakR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Clear global IN NAK"]
#[inline (always)] pub fn cginak (& self) -> CginakR { CginakR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Set global OUT NAK"]
#[inline (always)] pub fn sgonak (& self) -> SgonakR { SgonakR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Clear global OUT NAK"]
#[inline (always)] pub fn cgonak (& self) -> CgonakR { CgonakR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Power-on programming done"]
#[inline (always)] pub fn poprgdne (& self) -> PoprgdneR { PoprgdneR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Remote wakeup signaling"]
#[inline (always)] pub fn rwusig (& mut self) -> RwusigW < '_ , FsDctlSpec > { RwusigW :: new (self , 0) }
#[doc = "Bit 1 - Soft disconnect"]
#[inline (always)] pub fn sdis (& mut self) -> SdisW < '_ , FsDctlSpec > { SdisW :: new (self , 1) }
#[doc = "Bits 4:6 - Test control"]
#[inline (always)] pub fn tctl (& mut self) -> TctlW < '_ , FsDctlSpec > { TctlW :: new (self , 4) }
#[doc = "Bit 7 - Set global IN NAK"]
#[inline (always)] pub fn sginak (& mut self) -> SginakW < '_ , FsDctlSpec > { SginakW :: new (self , 7) }
#[doc = "Bit 8 - Clear global IN NAK"]
#[inline (always)] pub fn cginak (& mut self) -> CginakW < '_ , FsDctlSpec > { CginakW :: new (self , 8) }
#[doc = "Bit 9 - Set global OUT NAK"]
#[inline (always)] pub fn sgonak (& mut self) -> SgonakW < '_ , FsDctlSpec > { SgonakW :: new (self , 9) }
#[doc = "Bit 10 - Clear global OUT NAK"]
#[inline (always)] pub fn cgonak (& mut self) -> CgonakW < '_ , FsDctlSpec > { CgonakW :: new (self , 10) }
#[doc = "Bit 11 - Power-on programming done"]
#[inline (always)] pub fn poprgdne (& mut self) -> PoprgdneW < '_ , FsDctlSpec > { PoprgdneW :: new (self , 11) } }
#[doc = "OTG_FS device control register (OTG_FS_DCTL)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDctlSpec ; impl crate :: RegisterSpec for FsDctlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_dctl::R`](R) reader structure"] impl crate :: Readable for FsDctlSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_dctl::W`](W) writer structure"] impl crate :: Writable for FsDctlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DCTL to value 0"] impl crate :: Resettable for FsDctlSpec { } }
#[doc = "FS_DSTS (r) register accessor: OTG_FS device status register (OTG_FS_DSTS)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dsts::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_dsts`] module"]
#[doc (alias = "FS_DSTS")] pub type FsDsts = crate :: Reg < fs_dsts :: FsDstsSpec > ;
#[doc = "OTG_FS device status register (OTG_FS_DSTS)"] pub mod fs_dsts {
#[doc = "Register `FS_DSTS` reader"] pub type R = crate :: R < FsDstsSpec > ;
#[doc = "Field `SUSPSTS` reader - Suspend status"] pub type SuspstsR = crate :: BitReader ;
#[doc = "Field `ENUMSPD` reader - Enumerated speed"] pub type EnumspdR = crate :: FieldReader ;
#[doc = "Field `EERR` reader - Erratic error"] pub type EerrR = crate :: BitReader ;
#[doc = "Field `FNSOF` reader - Frame number of the received SOF"] pub type FnsofR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bit 0 - Suspend status"]
#[inline (always)] pub fn suspsts (& self) -> SuspstsR { SuspstsR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:2 - Enumerated speed"]
#[inline (always)] pub fn enumspd (& self) -> EnumspdR { EnumspdR :: new (((self . bits >> 1) & 3) as u8) }
#[doc = "Bit 3 - Erratic error"]
#[inline (always)] pub fn eerr (& self) -> EerrR { EerrR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 8:21 - Frame number of the received SOF"]
#[inline (always)] pub fn fnsof (& self) -> FnsofR { FnsofR :: new (((self . bits >> 8) & 0x3fff) as u16) } }
#[doc = "OTG_FS device status register (OTG_FS_DSTS)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dsts::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDstsSpec ; impl crate :: RegisterSpec for FsDstsSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_dsts::R`](R) reader structure"] impl crate :: Readable for FsDstsSpec { }
#[doc = "`reset()` method sets FS_DSTS to value 0x10"] impl crate :: Resettable for FsDstsSpec { const RESET_VALUE : u32 = 0x10 ; } }
#[doc = "FS_DIEPMSK (rw) register accessor: OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_diepmsk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_diepmsk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_diepmsk`] module"]
#[doc (alias = "FS_DIEPMSK")] pub type FsDiepmsk = crate :: Reg < fs_diepmsk :: FsDiepmskSpec > ;
#[doc = "OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)"] pub mod fs_diepmsk {
#[doc = "Register `FS_DIEPMSK` reader"] pub type R = crate :: R < FsDiepmskSpec > ;
#[doc = "Register `FS_DIEPMSK` writer"] pub type W = crate :: W < FsDiepmskSpec > ;
#[doc = "Field `XFRCM` reader - Transfer completed interrupt mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed interrupt mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDM` reader - Endpoint disabled interrupt mask"] pub type EpdmR = crate :: BitReader ;
#[doc = "Field `EPDM` writer - Endpoint disabled interrupt mask"] pub type EpdmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TOM` reader - Timeout condition mask (Non-isochronous endpoints)"] pub type TomR = crate :: BitReader ;
#[doc = "Field `TOM` writer - Timeout condition mask (Non-isochronous endpoints)"] pub type TomW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITTXFEMSK` reader - IN token received when TxFIFO empty mask"] pub type IttxfemskR = crate :: BitReader ;
#[doc = "Field `ITTXFEMSK` writer - IN token received when TxFIFO empty mask"] pub type IttxfemskW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INEPNMM` reader - IN token received with EP mismatch mask"] pub type InepnmmR = crate :: BitReader ;
#[doc = "Field `INEPNMM` writer - IN token received with EP mismatch mask"] pub type InepnmmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INEPNEM` reader - IN endpoint NAK effective mask"] pub type InepnemR = crate :: BitReader ;
#[doc = "Field `INEPNEM` writer - IN endpoint NAK effective mask"] pub type InepnemW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed interrupt mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Endpoint disabled interrupt mask"]
#[inline (always)] pub fn epdm (& self) -> EpdmR { EpdmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Timeout condition mask (Non-isochronous endpoints)"]
#[inline (always)] pub fn tom (& self) -> TomR { TomR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - IN token received when TxFIFO empty mask"]
#[inline (always)] pub fn ittxfemsk (& self) -> IttxfemskR { IttxfemskR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - IN token received with EP mismatch mask"]
#[inline (always)] pub fn inepnmm (& self) -> InepnmmR { InepnmmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - IN endpoint NAK effective mask"]
#[inline (always)] pub fn inepnem (& self) -> InepnemR { InepnemR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed interrupt mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsDiepmskSpec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Endpoint disabled interrupt mask"]
#[inline (always)] pub fn epdm (& mut self) -> EpdmW < '_ , FsDiepmskSpec > { EpdmW :: new (self , 1) }
#[doc = "Bit 3 - Timeout condition mask (Non-isochronous endpoints)"]
#[inline (always)] pub fn tom (& mut self) -> TomW < '_ , FsDiepmskSpec > { TomW :: new (self , 3) }
#[doc = "Bit 4 - IN token received when TxFIFO empty mask"]
#[inline (always)] pub fn ittxfemsk (& mut self) -> IttxfemskW < '_ , FsDiepmskSpec > { IttxfemskW :: new (self , 4) }
#[doc = "Bit 5 - IN token received with EP mismatch mask"]
#[inline (always)] pub fn inepnmm (& mut self) -> InepnmmW < '_ , FsDiepmskSpec > { InepnmmW :: new (self , 5) }
#[doc = "Bit 6 - IN endpoint NAK effective mask"]
#[inline (always)] pub fn inepnem (& mut self) -> InepnemW < '_ , FsDiepmskSpec > { InepnemW :: new (self , 6) } }
#[doc = "OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_diepmsk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_diepmsk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDiepmskSpec ; impl crate :: RegisterSpec for FsDiepmskSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_diepmsk::R`](R) reader structure"] impl crate :: Readable for FsDiepmskSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_diepmsk::W`](W) writer structure"] impl crate :: Writable for FsDiepmskSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DIEPMSK to value 0"] impl crate :: Resettable for FsDiepmskSpec { } }
#[doc = "FS_DOEPMSK (rw) register accessor: OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_doepmsk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_doepmsk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_doepmsk`] module"]
#[doc (alias = "FS_DOEPMSK")] pub type FsDoepmsk = crate :: Reg < fs_doepmsk :: FsDoepmskSpec > ;
#[doc = "OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)"] pub mod fs_doepmsk {
#[doc = "Register `FS_DOEPMSK` reader"] pub type R = crate :: R < FsDoepmskSpec > ;
#[doc = "Register `FS_DOEPMSK` writer"] pub type W = crate :: W < FsDoepmskSpec > ;
#[doc = "Field `XFRCM` reader - Transfer completed interrupt mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed interrupt mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDM` reader - Endpoint disabled interrupt mask"] pub type EpdmR = crate :: BitReader ;
#[doc = "Field `EPDM` writer - Endpoint disabled interrupt mask"] pub type EpdmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STUPM` reader - SETUP phase done mask"] pub type StupmR = crate :: BitReader ;
#[doc = "Field `STUPM` writer - SETUP phase done mask"] pub type StupmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OTEPDM` reader - OUT token received when endpoint disabled mask"] pub type OtepdmR = crate :: BitReader ;
#[doc = "Field `OTEPDM` writer - OUT token received when endpoint disabled mask"] pub type OtepdmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed interrupt mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Endpoint disabled interrupt mask"]
#[inline (always)] pub fn epdm (& self) -> EpdmR { EpdmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - SETUP phase done mask"]
#[inline (always)] pub fn stupm (& self) -> StupmR { StupmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - OUT token received when endpoint disabled mask"]
#[inline (always)] pub fn otepdm (& self) -> OtepdmR { OtepdmR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed interrupt mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsDoepmskSpec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Endpoint disabled interrupt mask"]
#[inline (always)] pub fn epdm (& mut self) -> EpdmW < '_ , FsDoepmskSpec > { EpdmW :: new (self , 1) }
#[doc = "Bit 3 - SETUP phase done mask"]
#[inline (always)] pub fn stupm (& mut self) -> StupmW < '_ , FsDoepmskSpec > { StupmW :: new (self , 3) }
#[doc = "Bit 4 - OUT token received when endpoint disabled mask"]
#[inline (always)] pub fn otepdm (& mut self) -> OtepdmW < '_ , FsDoepmskSpec > { OtepdmW :: new (self , 4) } }
#[doc = "OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_doepmsk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_doepmsk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDoepmskSpec ; impl crate :: RegisterSpec for FsDoepmskSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_doepmsk::R`](R) reader structure"] impl crate :: Readable for FsDoepmskSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_doepmsk::W`](W) writer structure"] impl crate :: Writable for FsDoepmskSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DOEPMSK to value 0"] impl crate :: Resettable for FsDoepmskSpec { } }
#[doc = "FS_DAINT (r) register accessor: OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_daint::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_daint`] module"]
#[doc (alias = "FS_DAINT")] pub type FsDaint = crate :: Reg < fs_daint :: FsDaintSpec > ;
#[doc = "OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)"] pub mod fs_daint {
#[doc = "Register `FS_DAINT` reader"] pub type R = crate :: R < FsDaintSpec > ;
#[doc = "Field `IEPINT` reader - IN endpoint interrupt bits"] pub type IepintR = crate :: FieldReader < u16 > ;
#[doc = "Field `OEPINT` reader - OUT endpoint interrupt bits"] pub type OepintR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - IN endpoint interrupt bits"]
#[inline (always)] pub fn iepint (& self) -> IepintR { IepintR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - OUT endpoint interrupt bits"]
#[inline (always)] pub fn oepint (& self) -> OepintR { OepintR :: new (((self . bits >> 16) & 0xffff) as u16) } }
#[doc = "OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_daint::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDaintSpec ; impl crate :: RegisterSpec for FsDaintSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_daint::R`](R) reader structure"] impl crate :: Readable for FsDaintSpec { }
#[doc = "`reset()` method sets FS_DAINT to value 0"] impl crate :: Resettable for FsDaintSpec { } }
#[doc = "FS_DAINTMSK (rw) register accessor: OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_daintmsk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_daintmsk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_daintmsk`] module"]
#[doc (alias = "FS_DAINTMSK")] pub type FsDaintmsk = crate :: Reg < fs_daintmsk :: FsDaintmskSpec > ;
#[doc = "OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)"] pub mod fs_daintmsk {
#[doc = "Register `FS_DAINTMSK` reader"] pub type R = crate :: R < FsDaintmskSpec > ;
#[doc = "Register `FS_DAINTMSK` writer"] pub type W = crate :: W < FsDaintmskSpec > ;
#[doc = "Field `IEPM` reader - IN EP interrupt mask bits"] pub type IepmR = crate :: FieldReader < u16 > ;
#[doc = "Field `IEPM` writer - IN EP interrupt mask bits"] pub type IepmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `OEPINT` reader - OUT endpoint interrupt bits"] pub type OepintR = crate :: FieldReader < u16 > ;
#[doc = "Field `OEPINT` writer - OUT endpoint interrupt bits"] pub type OepintW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - IN EP interrupt mask bits"]
#[inline (always)] pub fn iepm (& self) -> IepmR { IepmR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - OUT endpoint interrupt bits"]
#[inline (always)] pub fn oepint (& self) -> OepintR { OepintR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - IN EP interrupt mask bits"]
#[inline (always)] pub fn iepm (& mut self) -> IepmW < '_ , FsDaintmskSpec > { IepmW :: new (self , 0) }
#[doc = "Bits 16:31 - OUT endpoint interrupt bits"]
#[inline (always)] pub fn oepint (& mut self) -> OepintW < '_ , FsDaintmskSpec > { OepintW :: new (self , 16) } }
#[doc = "OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_daintmsk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_daintmsk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDaintmskSpec ; impl crate :: RegisterSpec for FsDaintmskSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_daintmsk::R`](R) reader structure"] impl crate :: Readable for FsDaintmskSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_daintmsk::W`](W) writer structure"] impl crate :: Writable for FsDaintmskSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DAINTMSK to value 0"] impl crate :: Resettable for FsDaintmskSpec { } }
#[doc = "DVBUSDIS (rw) register accessor: OTG_FS device VBUS discharge time register\n\nYou can [`read`](crate::Reg::read) this register and get [`dvbusdis::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dvbusdis::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dvbusdis`] module"]
#[doc (alias = "DVBUSDIS")] pub type Dvbusdis = crate :: Reg < dvbusdis :: DvbusdisSpec > ;
#[doc = "OTG_FS device VBUS discharge time register"] pub mod dvbusdis {
#[doc = "Register `DVBUSDIS` reader"] pub type R = crate :: R < DvbusdisSpec > ;
#[doc = "Register `DVBUSDIS` writer"] pub type W = crate :: W < DvbusdisSpec > ;
#[doc = "Field `VBUSDT` reader - Device VBUS discharge time"] pub type VbusdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `VBUSDT` writer - Device VBUS discharge time"] pub type VbusdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Device VBUS discharge time"]
#[inline (always)] pub fn vbusdt (& self) -> VbusdtR { VbusdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Device VBUS discharge time"]
#[inline (always)] pub fn vbusdt (& mut self) -> VbusdtW < '_ , DvbusdisSpec > { VbusdtW :: new (self , 0) } }
#[doc = "OTG_FS device VBUS discharge time register\n\nYou can [`read`](crate::Reg::read) this register and get [`dvbusdis::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dvbusdis::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DvbusdisSpec ; impl crate :: RegisterSpec for DvbusdisSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dvbusdis::R`](R) reader structure"] impl crate :: Readable for DvbusdisSpec { }
#[doc = "`write(|w| ..)` method takes [`dvbusdis::W`](W) writer structure"] impl crate :: Writable for DvbusdisSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DVBUSDIS to value 0x17d7"] impl crate :: Resettable for DvbusdisSpec { const RESET_VALUE : u32 = 0x17d7 ; } }
#[doc = "DVBUSPULSE (rw) register accessor: OTG_FS device VBUS pulsing time register\n\nYou can [`read`](crate::Reg::read) this register and get [`dvbuspulse::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dvbuspulse::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dvbuspulse`] module"]
#[doc (alias = "DVBUSPULSE")] pub type Dvbuspulse = crate :: Reg < dvbuspulse :: DvbuspulseSpec > ;
#[doc = "OTG_FS device VBUS pulsing time register"] pub mod dvbuspulse {
#[doc = "Register `DVBUSPULSE` reader"] pub type R = crate :: R < DvbuspulseSpec > ;
#[doc = "Register `DVBUSPULSE` writer"] pub type W = crate :: W < DvbuspulseSpec > ;
#[doc = "Field `DVBUSP` reader - Device VBUS pulsing time"] pub type DvbuspR = crate :: FieldReader < u16 > ;
#[doc = "Field `DVBUSP` writer - Device VBUS pulsing time"] pub type DvbuspW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Device VBUS pulsing time"]
#[inline (always)] pub fn dvbusp (& self) -> DvbuspR { DvbuspR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Device VBUS pulsing time"]
#[inline (always)] pub fn dvbusp (& mut self) -> DvbuspW < '_ , DvbuspulseSpec > { DvbuspW :: new (self , 0) } }
#[doc = "OTG_FS device VBUS pulsing time register\n\nYou can [`read`](crate::Reg::read) this register and get [`dvbuspulse::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dvbuspulse::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DvbuspulseSpec ; impl crate :: RegisterSpec for DvbuspulseSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dvbuspulse::R`](R) reader structure"] impl crate :: Readable for DvbuspulseSpec { }
#[doc = "`write(|w| ..)` method takes [`dvbuspulse::W`](W) writer structure"] impl crate :: Writable for DvbuspulseSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DVBUSPULSE to value 0x05b8"] impl crate :: Resettable for DvbuspulseSpec { const RESET_VALUE : u32 = 0x05b8 ; } }
#[doc = "DIEPEMPMSK (rw) register accessor: OTG_FS device IN endpoint FIFO empty interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepempmsk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepempmsk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepempmsk`] module"]
#[doc (alias = "DIEPEMPMSK")] pub type Diepempmsk = crate :: Reg < diepempmsk :: DiepempmskSpec > ;
#[doc = "OTG_FS device IN endpoint FIFO empty interrupt mask register"] pub mod diepempmsk {
#[doc = "Register `DIEPEMPMSK` reader"] pub type R = crate :: R < DiepempmskSpec > ;
#[doc = "Register `DIEPEMPMSK` writer"] pub type W = crate :: W < DiepempmskSpec > ;
#[doc = "Field `INEPTXFEM` reader - IN EP Tx FIFO empty interrupt mask bits"] pub type IneptxfemR = crate :: FieldReader < u16 > ;
#[doc = "Field `INEPTXFEM` writer - IN EP Tx FIFO empty interrupt mask bits"] pub type IneptxfemW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - IN EP Tx FIFO empty interrupt mask bits"]
#[inline (always)] pub fn ineptxfem (& self) -> IneptxfemR { IneptxfemR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - IN EP Tx FIFO empty interrupt mask bits"]
#[inline (always)] pub fn ineptxfem (& mut self) -> IneptxfemW < '_ , DiepempmskSpec > { IneptxfemW :: new (self , 0) } }
#[doc = "OTG_FS device IN endpoint FIFO empty interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepempmsk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepempmsk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DiepempmskSpec ; impl crate :: RegisterSpec for DiepempmskSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`diepempmsk::R`](R) reader structure"] impl crate :: Readable for DiepempmskSpec { }
#[doc = "`write(|w| ..)` method takes [`diepempmsk::W`](W) writer structure"] impl crate :: Writable for DiepempmskSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPEMPMSK to value 0"] impl crate :: Resettable for DiepempmskSpec { } }
#[doc = "FS_DIEPCTL0 (rw) register accessor: OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_diepctl0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_diepctl0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_diepctl0`] module"]
#[doc (alias = "FS_DIEPCTL0")] pub type FsDiepctl0 = crate :: Reg < fs_diepctl0 :: FsDiepctl0Spec > ;
#[doc = "OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)"] pub mod fs_diepctl0 {
#[doc = "Register `FS_DIEPCTL0` reader"] pub type R = crate :: R < FsDiepctl0Spec > ;
#[doc = "Register `FS_DIEPCTL0` writer"] pub type W = crate :: W < FsDiepctl0Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `USBAEP` reader - USB active endpoint"] pub type UsbaepR = crate :: BitReader ;
#[doc = "Field `NAKSTS` reader - NAK status"] pub type NakstsR = crate :: BitReader ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `STALL` reader - STALL handshake"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL handshake"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFNUM` reader - TxFIFO number"] pub type TxfnumR = crate :: FieldReader ;
#[doc = "Field `TXFNUM` writer - TxFIFO number"] pub type TxfnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CNAK` writer - Clear NAK"] pub type CnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNAK` writer - Set NAK"] pub type SnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDIS` reader - Endpoint disable"] pub type EpdisR = crate :: BitReader ;
#[doc = "Field `EPENA` reader - Endpoint enable"] pub type EpenaR = crate :: BitReader ; impl R {
#[doc = "Bits 0:1 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 15 - USB active endpoint"]
#[inline (always)] pub fn usbaep (& self) -> UsbaepR { UsbaepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - NAK status"]
#[inline (always)] pub fn naksts (& self) -> NakstsR { NakstsR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bit 21 - STALL handshake"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bits 22:25 - TxFIFO number"]
#[inline (always)] pub fn txfnum (& self) -> TxfnumR { TxfnumR :: new (((self . bits >> 22) & 0x0f) as u8) }
#[doc = "Bit 30 - Endpoint disable"]
#[inline (always)] pub fn epdis (& self) -> EpdisR { EpdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Endpoint enable"]
#[inline (always)] pub fn epena (& self) -> EpenaR { EpenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsDiepctl0Spec > { MpsizW :: new (self , 0) }
#[doc = "Bit 21 - STALL handshake"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsDiepctl0Spec > { StallW :: new (self , 21) }
#[doc = "Bits 22:25 - TxFIFO number"]
#[inline (always)] pub fn txfnum (& mut self) -> TxfnumW < '_ , FsDiepctl0Spec > { TxfnumW :: new (self , 22) }
#[doc = "Bit 26 - Clear NAK"]
#[inline (always)] pub fn cnak (& mut self) -> CnakW < '_ , FsDiepctl0Spec > { CnakW :: new (self , 26) }
#[doc = "Bit 27 - Set NAK"]
#[inline (always)] pub fn snak (& mut self) -> SnakW < '_ , FsDiepctl0Spec > { SnakW :: new (self , 27) } }
#[doc = "OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_diepctl0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_diepctl0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDiepctl0Spec ; impl crate :: RegisterSpec for FsDiepctl0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_diepctl0::R`](R) reader structure"] impl crate :: Readable for FsDiepctl0Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_diepctl0::W`](W) writer structure"] impl crate :: Writable for FsDiepctl0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DIEPCTL0 to value 0"] impl crate :: Resettable for FsDiepctl0Spec { } }
#[doc = "DIEPCTL1 (rw) register accessor: OTG device endpoint-1 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepctl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepctl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepctl1`] module"]
#[doc (alias = "DIEPCTL1")] pub type Diepctl1 = crate :: Reg < diepctl1 :: Diepctl1Spec > ;
#[doc = "OTG device endpoint-1 control register"] pub mod diepctl1 {
#[doc = "Register `DIEPCTL1` reader"] pub type R = crate :: R < Diepctl1Spec > ;
#[doc = "Register `DIEPCTL1` writer"] pub type W = crate :: W < Diepctl1Spec > ;
#[doc = "Field `MPSIZ` reader - MPSIZ"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - MPSIZ"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `USBAEP` reader - USBAEP"] pub type UsbaepR = crate :: BitReader ;
#[doc = "Field `USBAEP` writer - USBAEP"] pub type UsbaepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EONUM_DPID` reader - EONUM/DPID"] pub type EonumDpidR = crate :: BitReader ;
#[doc = "Field `NAKSTS` reader - NAKSTS"] pub type NakstsR = crate :: BitReader ;
#[doc = "Field `EPTYP` reader - EPTYP"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - EPTYP"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `Stall` reader - Stall"] pub type StallR = crate :: BitReader ;
#[doc = "Field `Stall` writer - Stall"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFNUM` reader - TXFNUM"] pub type TxfnumR = crate :: FieldReader ;
#[doc = "Field `TXFNUM` writer - TXFNUM"] pub type TxfnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CNAK` writer - CNAK"] pub type CnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNAK` writer - SNAK"] pub type SnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SD0PID_SEVNFRM` writer - SD0PID/SEVNFRM"] pub type Sd0pidSevnfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SODDFRM_SD1PID` writer - SODDFRM/SD1PID"] pub type SoddfrmSd1pidW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDIS` reader - EPDIS"] pub type EpdisR = crate :: BitReader ;
#[doc = "Field `EPDIS` writer - EPDIS"] pub type EpdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPENA` reader - EPENA"] pub type EpenaR = crate :: BitReader ;
#[doc = "Field `EPENA` writer - EPENA"] pub type EpenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& self) -> UsbaepR { UsbaepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - EONUM/DPID"]
#[inline (always)] pub fn eonum_dpid (& self) -> EonumDpidR { EonumDpidR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - NAKSTS"]
#[inline (always)] pub fn naksts (& self) -> NakstsR { NakstsR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bits 22:25 - TXFNUM"]
#[inline (always)] pub fn txfnum (& self) -> TxfnumR { TxfnumR :: new (((self . bits >> 22) & 0x0f) as u8) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& self) -> EpdisR { EpdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& self) -> EpenaR { EpenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , Diepctl1Spec > { MpsizW :: new (self , 0) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& mut self) -> UsbaepW < '_ , Diepctl1Spec > { UsbaepW :: new (self , 15) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , Diepctl1Spec > { EptypW :: new (self , 18) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , Diepctl1Spec > { StallW :: new (self , 21) }
#[doc = "Bits 22:25 - TXFNUM"]
#[inline (always)] pub fn txfnum (& mut self) -> TxfnumW < '_ , Diepctl1Spec > { TxfnumW :: new (self , 22) }
#[doc = "Bit 26 - CNAK"]
#[inline (always)] pub fn cnak (& mut self) -> CnakW < '_ , Diepctl1Spec > { CnakW :: new (self , 26) }
#[doc = "Bit 27 - SNAK"]
#[inline (always)] pub fn snak (& mut self) -> SnakW < '_ , Diepctl1Spec > { SnakW :: new (self , 27) }
#[doc = "Bit 28 - SD0PID/SEVNFRM"]
#[inline (always)] pub fn sd0pid_sevnfrm (& mut self) -> Sd0pidSevnfrmW < '_ , Diepctl1Spec > { Sd0pidSevnfrmW :: new (self , 28) }
#[doc = "Bit 29 - SODDFRM/SD1PID"]
#[inline (always)] pub fn soddfrm_sd1pid (& mut self) -> SoddfrmSd1pidW < '_ , Diepctl1Spec > { SoddfrmSd1pidW :: new (self , 29) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& mut self) -> EpdisW < '_ , Diepctl1Spec > { EpdisW :: new (self , 30) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& mut self) -> EpenaW < '_ , Diepctl1Spec > { EpenaW :: new (self , 31) } }
#[doc = "OTG device endpoint-1 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepctl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepctl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Diepctl1Spec ; impl crate :: RegisterSpec for Diepctl1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`diepctl1::R`](R) reader structure"] impl crate :: Readable for Diepctl1Spec { }
#[doc = "`write(|w| ..)` method takes [`diepctl1::W`](W) writer structure"] impl crate :: Writable for Diepctl1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPCTL1 to value 0"] impl crate :: Resettable for Diepctl1Spec { } }
#[doc = "DIEPCTL2 (rw) register accessor: OTG device endpoint-2 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepctl2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepctl2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepctl2`] module"]
#[doc (alias = "DIEPCTL2")] pub type Diepctl2 = crate :: Reg < diepctl2 :: Diepctl2Spec > ;
#[doc = "OTG device endpoint-2 control register"] pub mod diepctl2 {
#[doc = "Register `DIEPCTL2` reader"] pub type R = crate :: R < Diepctl2Spec > ;
#[doc = "Register `DIEPCTL2` writer"] pub type W = crate :: W < Diepctl2Spec > ;
#[doc = "Field `MPSIZ` reader - MPSIZ"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - MPSIZ"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `USBAEP` reader - USBAEP"] pub type UsbaepR = crate :: BitReader ;
#[doc = "Field `USBAEP` writer - USBAEP"] pub type UsbaepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EONUM_DPID` reader - EONUM/DPID"] pub type EonumDpidR = crate :: BitReader ;
#[doc = "Field `NAKSTS` reader - NAKSTS"] pub type NakstsR = crate :: BitReader ;
#[doc = "Field `EPTYP` reader - EPTYP"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - EPTYP"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `Stall` reader - Stall"] pub type StallR = crate :: BitReader ;
#[doc = "Field `Stall` writer - Stall"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFNUM` reader - TXFNUM"] pub type TxfnumR = crate :: FieldReader ;
#[doc = "Field `TXFNUM` writer - TXFNUM"] pub type TxfnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CNAK` writer - CNAK"] pub type CnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNAK` writer - SNAK"] pub type SnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SD0PID_SEVNFRM` writer - SD0PID/SEVNFRM"] pub type Sd0pidSevnfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SODDFRM` writer - SODDFRM"] pub type SoddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDIS` reader - EPDIS"] pub type EpdisR = crate :: BitReader ;
#[doc = "Field `EPDIS` writer - EPDIS"] pub type EpdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPENA` reader - EPENA"] pub type EpenaR = crate :: BitReader ;
#[doc = "Field `EPENA` writer - EPENA"] pub type EpenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& self) -> UsbaepR { UsbaepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - EONUM/DPID"]
#[inline (always)] pub fn eonum_dpid (& self) -> EonumDpidR { EonumDpidR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - NAKSTS"]
#[inline (always)] pub fn naksts (& self) -> NakstsR { NakstsR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bits 22:25 - TXFNUM"]
#[inline (always)] pub fn txfnum (& self) -> TxfnumR { TxfnumR :: new (((self . bits >> 22) & 0x0f) as u8) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& self) -> EpdisR { EpdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& self) -> EpenaR { EpenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , Diepctl2Spec > { MpsizW :: new (self , 0) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& mut self) -> UsbaepW < '_ , Diepctl2Spec > { UsbaepW :: new (self , 15) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , Diepctl2Spec > { EptypW :: new (self , 18) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , Diepctl2Spec > { StallW :: new (self , 21) }
#[doc = "Bits 22:25 - TXFNUM"]
#[inline (always)] pub fn txfnum (& mut self) -> TxfnumW < '_ , Diepctl2Spec > { TxfnumW :: new (self , 22) }
#[doc = "Bit 26 - CNAK"]
#[inline (always)] pub fn cnak (& mut self) -> CnakW < '_ , Diepctl2Spec > { CnakW :: new (self , 26) }
#[doc = "Bit 27 - SNAK"]
#[inline (always)] pub fn snak (& mut self) -> SnakW < '_ , Diepctl2Spec > { SnakW :: new (self , 27) }
#[doc = "Bit 28 - SD0PID/SEVNFRM"]
#[inline (always)] pub fn sd0pid_sevnfrm (& mut self) -> Sd0pidSevnfrmW < '_ , Diepctl2Spec > { Sd0pidSevnfrmW :: new (self , 28) }
#[doc = "Bit 29 - SODDFRM"]
#[inline (always)] pub fn soddfrm (& mut self) -> SoddfrmW < '_ , Diepctl2Spec > { SoddfrmW :: new (self , 29) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& mut self) -> EpdisW < '_ , Diepctl2Spec > { EpdisW :: new (self , 30) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& mut self) -> EpenaW < '_ , Diepctl2Spec > { EpenaW :: new (self , 31) } }
#[doc = "OTG device endpoint-2 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepctl2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepctl2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Diepctl2Spec ; impl crate :: RegisterSpec for Diepctl2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`diepctl2::R`](R) reader structure"] impl crate :: Readable for Diepctl2Spec { }
#[doc = "`write(|w| ..)` method takes [`diepctl2::W`](W) writer structure"] impl crate :: Writable for Diepctl2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPCTL2 to value 0"] impl crate :: Resettable for Diepctl2Spec { } }
#[doc = "DIEPCTL3 (rw) register accessor: OTG device endpoint-3 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepctl3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepctl3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepctl3`] module"]
#[doc (alias = "DIEPCTL3")] pub type Diepctl3 = crate :: Reg < diepctl3 :: Diepctl3Spec > ;
#[doc = "OTG device endpoint-3 control register"] pub mod diepctl3 {
#[doc = "Register `DIEPCTL3` reader"] pub type R = crate :: R < Diepctl3Spec > ;
#[doc = "Register `DIEPCTL3` writer"] pub type W = crate :: W < Diepctl3Spec > ;
#[doc = "Field `MPSIZ` reader - MPSIZ"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - MPSIZ"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `USBAEP` reader - USBAEP"] pub type UsbaepR = crate :: BitReader ;
#[doc = "Field `USBAEP` writer - USBAEP"] pub type UsbaepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EONUM_DPID` reader - EONUM/DPID"] pub type EonumDpidR = crate :: BitReader ;
#[doc = "Field `NAKSTS` reader - NAKSTS"] pub type NakstsR = crate :: BitReader ;
#[doc = "Field `EPTYP` reader - EPTYP"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - EPTYP"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `Stall` reader - Stall"] pub type StallR = crate :: BitReader ;
#[doc = "Field `Stall` writer - Stall"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFNUM` reader - TXFNUM"] pub type TxfnumR = crate :: FieldReader ;
#[doc = "Field `TXFNUM` writer - TXFNUM"] pub type TxfnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CNAK` writer - CNAK"] pub type CnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNAK` writer - SNAK"] pub type SnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SD0PID_SEVNFRM` writer - SD0PID/SEVNFRM"] pub type Sd0pidSevnfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SODDFRM` writer - SODDFRM"] pub type SoddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDIS` reader - EPDIS"] pub type EpdisR = crate :: BitReader ;
#[doc = "Field `EPDIS` writer - EPDIS"] pub type EpdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPENA` reader - EPENA"] pub type EpenaR = crate :: BitReader ;
#[doc = "Field `EPENA` writer - EPENA"] pub type EpenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& self) -> UsbaepR { UsbaepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - EONUM/DPID"]
#[inline (always)] pub fn eonum_dpid (& self) -> EonumDpidR { EonumDpidR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - NAKSTS"]
#[inline (always)] pub fn naksts (& self) -> NakstsR { NakstsR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bits 22:25 - TXFNUM"]
#[inline (always)] pub fn txfnum (& self) -> TxfnumR { TxfnumR :: new (((self . bits >> 22) & 0x0f) as u8) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& self) -> EpdisR { EpdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& self) -> EpenaR { EpenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , Diepctl3Spec > { MpsizW :: new (self , 0) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& mut self) -> UsbaepW < '_ , Diepctl3Spec > { UsbaepW :: new (self , 15) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , Diepctl3Spec > { EptypW :: new (self , 18) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , Diepctl3Spec > { StallW :: new (self , 21) }
#[doc = "Bits 22:25 - TXFNUM"]
#[inline (always)] pub fn txfnum (& mut self) -> TxfnumW < '_ , Diepctl3Spec > { TxfnumW :: new (self , 22) }
#[doc = "Bit 26 - CNAK"]
#[inline (always)] pub fn cnak (& mut self) -> CnakW < '_ , Diepctl3Spec > { CnakW :: new (self , 26) }
#[doc = "Bit 27 - SNAK"]
#[inline (always)] pub fn snak (& mut self) -> SnakW < '_ , Diepctl3Spec > { SnakW :: new (self , 27) }
#[doc = "Bit 28 - SD0PID/SEVNFRM"]
#[inline (always)] pub fn sd0pid_sevnfrm (& mut self) -> Sd0pidSevnfrmW < '_ , Diepctl3Spec > { Sd0pidSevnfrmW :: new (self , 28) }
#[doc = "Bit 29 - SODDFRM"]
#[inline (always)] pub fn soddfrm (& mut self) -> SoddfrmW < '_ , Diepctl3Spec > { SoddfrmW :: new (self , 29) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& mut self) -> EpdisW < '_ , Diepctl3Spec > { EpdisW :: new (self , 30) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& mut self) -> EpenaW < '_ , Diepctl3Spec > { EpenaW :: new (self , 31) } }
#[doc = "OTG device endpoint-3 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepctl3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepctl3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Diepctl3Spec ; impl crate :: RegisterSpec for Diepctl3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`diepctl3::R`](R) reader structure"] impl crate :: Readable for Diepctl3Spec { }
#[doc = "`write(|w| ..)` method takes [`diepctl3::W`](W) writer structure"] impl crate :: Writable for Diepctl3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPCTL3 to value 0"] impl crate :: Resettable for Diepctl3Spec { } }
#[doc = "DOEPCTL0 (rw) register accessor: device endpoint-0 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepctl0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepctl0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepctl0`] module"]
#[doc (alias = "DOEPCTL0")] pub type Doepctl0 = crate :: Reg < doepctl0 :: Doepctl0Spec > ;
#[doc = "device endpoint-0 control register"] pub mod doepctl0 {
#[doc = "Register `DOEPCTL0` reader"] pub type R = crate :: R < Doepctl0Spec > ;
#[doc = "Register `DOEPCTL0` writer"] pub type W = crate :: W < Doepctl0Spec > ;
#[doc = "Field `MPSIZ` reader - MPSIZ"] pub type MpsizR = crate :: FieldReader ;
#[doc = "Field `USBAEP` reader - USBAEP"] pub type UsbaepR = crate :: BitReader ;
#[doc = "Field `NAKSTS` reader - NAKSTS"] pub type NakstsR = crate :: BitReader ;
#[doc = "Field `EPTYP` reader - EPTYP"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `SNPM` reader - SNPM"] pub type SnpmR = crate :: BitReader ;
#[doc = "Field `SNPM` writer - SNPM"] pub type SnpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `Stall` reader - Stall"] pub type StallR = crate :: BitReader ;
#[doc = "Field `Stall` writer - Stall"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNAK` writer - CNAK"] pub type CnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNAK` writer - SNAK"] pub type SnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDIS` reader - EPDIS"] pub type EpdisR = crate :: BitReader ;
#[doc = "Field `EPENA` writer - EPENA"] pub type EpenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& self) -> UsbaepR { UsbaepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - NAKSTS"]
#[inline (always)] pub fn naksts (& self) -> NakstsR { NakstsR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bit 20 - SNPM"]
#[inline (always)] pub fn snpm (& self) -> SnpmR { SnpmR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& self) -> EpdisR { EpdisR :: new (((self . bits >> 30) & 1) != 0) } } impl W {
#[doc = "Bit 20 - SNPM"]
#[inline (always)] pub fn snpm (& mut self) -> SnpmW < '_ , Doepctl0Spec > { SnpmW :: new (self , 20) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , Doepctl0Spec > { StallW :: new (self , 21) }
#[doc = "Bit 26 - CNAK"]
#[inline (always)] pub fn cnak (& mut self) -> CnakW < '_ , Doepctl0Spec > { CnakW :: new (self , 26) }
#[doc = "Bit 27 - SNAK"]
#[inline (always)] pub fn snak (& mut self) -> SnakW < '_ , Doepctl0Spec > { SnakW :: new (self , 27) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& mut self) -> EpenaW < '_ , Doepctl0Spec > { EpenaW :: new (self , 31) } }
#[doc = "device endpoint-0 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepctl0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepctl0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doepctl0Spec ; impl crate :: RegisterSpec for Doepctl0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doepctl0::R`](R) reader structure"] impl crate :: Readable for Doepctl0Spec { }
#[doc = "`write(|w| ..)` method takes [`doepctl0::W`](W) writer structure"] impl crate :: Writable for Doepctl0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPCTL0 to value 0x8000"] impl crate :: Resettable for Doepctl0Spec { const RESET_VALUE : u32 = 0x8000 ; } }
#[doc = "DOEPCTL1 (rw) register accessor: device endpoint-1 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepctl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepctl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepctl1`] module"]
#[doc (alias = "DOEPCTL1")] pub type Doepctl1 = crate :: Reg < doepctl1 :: Doepctl1Spec > ;
#[doc = "device endpoint-1 control register"] pub mod doepctl1 {
#[doc = "Register `DOEPCTL1` reader"] pub type R = crate :: R < Doepctl1Spec > ;
#[doc = "Register `DOEPCTL1` writer"] pub type W = crate :: W < Doepctl1Spec > ;
#[doc = "Field `MPSIZ` reader - MPSIZ"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - MPSIZ"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `USBAEP` reader - USBAEP"] pub type UsbaepR = crate :: BitReader ;
#[doc = "Field `USBAEP` writer - USBAEP"] pub type UsbaepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EONUM_DPID` reader - EONUM/DPID"] pub type EonumDpidR = crate :: BitReader ;
#[doc = "Field `NAKSTS` reader - NAKSTS"] pub type NakstsR = crate :: BitReader ;
#[doc = "Field `EPTYP` reader - EPTYP"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - EPTYP"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SNPM` reader - SNPM"] pub type SnpmR = crate :: BitReader ;
#[doc = "Field `SNPM` writer - SNPM"] pub type SnpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `Stall` reader - Stall"] pub type StallR = crate :: BitReader ;
#[doc = "Field `Stall` writer - Stall"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNAK` writer - CNAK"] pub type CnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNAK` writer - SNAK"] pub type SnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SD0PID_SEVNFRM` writer - SD0PID/SEVNFRM"] pub type Sd0pidSevnfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SODDFRM` writer - SODDFRM"] pub type SoddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDIS` reader - EPDIS"] pub type EpdisR = crate :: BitReader ;
#[doc = "Field `EPDIS` writer - EPDIS"] pub type EpdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPENA` reader - EPENA"] pub type EpenaR = crate :: BitReader ;
#[doc = "Field `EPENA` writer - EPENA"] pub type EpenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& self) -> UsbaepR { UsbaepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - EONUM/DPID"]
#[inline (always)] pub fn eonum_dpid (& self) -> EonumDpidR { EonumDpidR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - NAKSTS"]
#[inline (always)] pub fn naksts (& self) -> NakstsR { NakstsR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bit 20 - SNPM"]
#[inline (always)] pub fn snpm (& self) -> SnpmR { SnpmR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& self) -> EpdisR { EpdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& self) -> EpenaR { EpenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , Doepctl1Spec > { MpsizW :: new (self , 0) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& mut self) -> UsbaepW < '_ , Doepctl1Spec > { UsbaepW :: new (self , 15) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , Doepctl1Spec > { EptypW :: new (self , 18) }
#[doc = "Bit 20 - SNPM"]
#[inline (always)] pub fn snpm (& mut self) -> SnpmW < '_ , Doepctl1Spec > { SnpmW :: new (self , 20) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , Doepctl1Spec > { StallW :: new (self , 21) }
#[doc = "Bit 26 - CNAK"]
#[inline (always)] pub fn cnak (& mut self) -> CnakW < '_ , Doepctl1Spec > { CnakW :: new (self , 26) }
#[doc = "Bit 27 - SNAK"]
#[inline (always)] pub fn snak (& mut self) -> SnakW < '_ , Doepctl1Spec > { SnakW :: new (self , 27) }
#[doc = "Bit 28 - SD0PID/SEVNFRM"]
#[inline (always)] pub fn sd0pid_sevnfrm (& mut self) -> Sd0pidSevnfrmW < '_ , Doepctl1Spec > { Sd0pidSevnfrmW :: new (self , 28) }
#[doc = "Bit 29 - SODDFRM"]
#[inline (always)] pub fn soddfrm (& mut self) -> SoddfrmW < '_ , Doepctl1Spec > { SoddfrmW :: new (self , 29) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& mut self) -> EpdisW < '_ , Doepctl1Spec > { EpdisW :: new (self , 30) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& mut self) -> EpenaW < '_ , Doepctl1Spec > { EpenaW :: new (self , 31) } }
#[doc = "device endpoint-1 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepctl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepctl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doepctl1Spec ; impl crate :: RegisterSpec for Doepctl1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doepctl1::R`](R) reader structure"] impl crate :: Readable for Doepctl1Spec { }
#[doc = "`write(|w| ..)` method takes [`doepctl1::W`](W) writer structure"] impl crate :: Writable for Doepctl1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPCTL1 to value 0"] impl crate :: Resettable for Doepctl1Spec { } }
#[doc = "DOEPCTL2 (rw) register accessor: device endpoint-2 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepctl2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepctl2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepctl2`] module"]
#[doc (alias = "DOEPCTL2")] pub type Doepctl2 = crate :: Reg < doepctl2 :: Doepctl2Spec > ;
#[doc = "device endpoint-2 control register"] pub mod doepctl2 {
#[doc = "Register `DOEPCTL2` reader"] pub type R = crate :: R < Doepctl2Spec > ;
#[doc = "Register `DOEPCTL2` writer"] pub type W = crate :: W < Doepctl2Spec > ;
#[doc = "Field `MPSIZ` reader - MPSIZ"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - MPSIZ"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `USBAEP` reader - USBAEP"] pub type UsbaepR = crate :: BitReader ;
#[doc = "Field `USBAEP` writer - USBAEP"] pub type UsbaepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EONUM_DPID` reader - EONUM/DPID"] pub type EonumDpidR = crate :: BitReader ;
#[doc = "Field `NAKSTS` reader - NAKSTS"] pub type NakstsR = crate :: BitReader ;
#[doc = "Field `EPTYP` reader - EPTYP"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - EPTYP"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SNPM` reader - SNPM"] pub type SnpmR = crate :: BitReader ;
#[doc = "Field `SNPM` writer - SNPM"] pub type SnpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `Stall` reader - Stall"] pub type StallR = crate :: BitReader ;
#[doc = "Field `Stall` writer - Stall"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNAK` writer - CNAK"] pub type CnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNAK` writer - SNAK"] pub type SnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SD0PID_SEVNFRM` writer - SD0PID/SEVNFRM"] pub type Sd0pidSevnfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SODDFRM` writer - SODDFRM"] pub type SoddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDIS` reader - EPDIS"] pub type EpdisR = crate :: BitReader ;
#[doc = "Field `EPDIS` writer - EPDIS"] pub type EpdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPENA` reader - EPENA"] pub type EpenaR = crate :: BitReader ;
#[doc = "Field `EPENA` writer - EPENA"] pub type EpenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& self) -> UsbaepR { UsbaepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - EONUM/DPID"]
#[inline (always)] pub fn eonum_dpid (& self) -> EonumDpidR { EonumDpidR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - NAKSTS"]
#[inline (always)] pub fn naksts (& self) -> NakstsR { NakstsR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bit 20 - SNPM"]
#[inline (always)] pub fn snpm (& self) -> SnpmR { SnpmR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& self) -> EpdisR { EpdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& self) -> EpenaR { EpenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , Doepctl2Spec > { MpsizW :: new (self , 0) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& mut self) -> UsbaepW < '_ , Doepctl2Spec > { UsbaepW :: new (self , 15) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , Doepctl2Spec > { EptypW :: new (self , 18) }
#[doc = "Bit 20 - SNPM"]
#[inline (always)] pub fn snpm (& mut self) -> SnpmW < '_ , Doepctl2Spec > { SnpmW :: new (self , 20) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , Doepctl2Spec > { StallW :: new (self , 21) }
#[doc = "Bit 26 - CNAK"]
#[inline (always)] pub fn cnak (& mut self) -> CnakW < '_ , Doepctl2Spec > { CnakW :: new (self , 26) }
#[doc = "Bit 27 - SNAK"]
#[inline (always)] pub fn snak (& mut self) -> SnakW < '_ , Doepctl2Spec > { SnakW :: new (self , 27) }
#[doc = "Bit 28 - SD0PID/SEVNFRM"]
#[inline (always)] pub fn sd0pid_sevnfrm (& mut self) -> Sd0pidSevnfrmW < '_ , Doepctl2Spec > { Sd0pidSevnfrmW :: new (self , 28) }
#[doc = "Bit 29 - SODDFRM"]
#[inline (always)] pub fn soddfrm (& mut self) -> SoddfrmW < '_ , Doepctl2Spec > { SoddfrmW :: new (self , 29) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& mut self) -> EpdisW < '_ , Doepctl2Spec > { EpdisW :: new (self , 30) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& mut self) -> EpenaW < '_ , Doepctl2Spec > { EpenaW :: new (self , 31) } }
#[doc = "device endpoint-2 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepctl2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepctl2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doepctl2Spec ; impl crate :: RegisterSpec for Doepctl2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doepctl2::R`](R) reader structure"] impl crate :: Readable for Doepctl2Spec { }
#[doc = "`write(|w| ..)` method takes [`doepctl2::W`](W) writer structure"] impl crate :: Writable for Doepctl2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPCTL2 to value 0"] impl crate :: Resettable for Doepctl2Spec { } }
#[doc = "DOEPCTL3 (rw) register accessor: device endpoint-3 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepctl3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepctl3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepctl3`] module"]
#[doc (alias = "DOEPCTL3")] pub type Doepctl3 = crate :: Reg < doepctl3 :: Doepctl3Spec > ;
#[doc = "device endpoint-3 control register"] pub mod doepctl3 {
#[doc = "Register `DOEPCTL3` reader"] pub type R = crate :: R < Doepctl3Spec > ;
#[doc = "Register `DOEPCTL3` writer"] pub type W = crate :: W < Doepctl3Spec > ;
#[doc = "Field `MPSIZ` reader - MPSIZ"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - MPSIZ"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `USBAEP` reader - USBAEP"] pub type UsbaepR = crate :: BitReader ;
#[doc = "Field `USBAEP` writer - USBAEP"] pub type UsbaepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EONUM_DPID` reader - EONUM/DPID"] pub type EonumDpidR = crate :: BitReader ;
#[doc = "Field `NAKSTS` reader - NAKSTS"] pub type NakstsR = crate :: BitReader ;
#[doc = "Field `EPTYP` reader - EPTYP"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - EPTYP"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SNPM` reader - SNPM"] pub type SnpmR = crate :: BitReader ;
#[doc = "Field `SNPM` writer - SNPM"] pub type SnpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `Stall` reader - Stall"] pub type StallR = crate :: BitReader ;
#[doc = "Field `Stall` writer - Stall"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CNAK` writer - CNAK"] pub type CnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SNAK` writer - SNAK"] pub type SnakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SD0PID_SEVNFRM` writer - SD0PID/SEVNFRM"] pub type Sd0pidSevnfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SODDFRM` writer - SODDFRM"] pub type SoddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDIS` reader - EPDIS"] pub type EpdisR = crate :: BitReader ;
#[doc = "Field `EPDIS` writer - EPDIS"] pub type EpdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPENA` reader - EPENA"] pub type EpenaR = crate :: BitReader ;
#[doc = "Field `EPENA` writer - EPENA"] pub type EpenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& self) -> UsbaepR { UsbaepR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - EONUM/DPID"]
#[inline (always)] pub fn eonum_dpid (& self) -> EonumDpidR { EonumDpidR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - NAKSTS"]
#[inline (always)] pub fn naksts (& self) -> NakstsR { NakstsR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bit 20 - SNPM"]
#[inline (always)] pub fn snpm (& self) -> SnpmR { SnpmR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& self) -> EpdisR { EpdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& self) -> EpenaR { EpenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - MPSIZ"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , Doepctl3Spec > { MpsizW :: new (self , 0) }
#[doc = "Bit 15 - USBAEP"]
#[inline (always)] pub fn usbaep (& mut self) -> UsbaepW < '_ , Doepctl3Spec > { UsbaepW :: new (self , 15) }
#[doc = "Bits 18:19 - EPTYP"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , Doepctl3Spec > { EptypW :: new (self , 18) }
#[doc = "Bit 20 - SNPM"]
#[inline (always)] pub fn snpm (& mut self) -> SnpmW < '_ , Doepctl3Spec > { SnpmW :: new (self , 20) }
#[doc = "Bit 21 - Stall"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , Doepctl3Spec > { StallW :: new (self , 21) }
#[doc = "Bit 26 - CNAK"]
#[inline (always)] pub fn cnak (& mut self) -> CnakW < '_ , Doepctl3Spec > { CnakW :: new (self , 26) }
#[doc = "Bit 27 - SNAK"]
#[inline (always)] pub fn snak (& mut self) -> SnakW < '_ , Doepctl3Spec > { SnakW :: new (self , 27) }
#[doc = "Bit 28 - SD0PID/SEVNFRM"]
#[inline (always)] pub fn sd0pid_sevnfrm (& mut self) -> Sd0pidSevnfrmW < '_ , Doepctl3Spec > { Sd0pidSevnfrmW :: new (self , 28) }
#[doc = "Bit 29 - SODDFRM"]
#[inline (always)] pub fn soddfrm (& mut self) -> SoddfrmW < '_ , Doepctl3Spec > { SoddfrmW :: new (self , 29) }
#[doc = "Bit 30 - EPDIS"]
#[inline (always)] pub fn epdis (& mut self) -> EpdisW < '_ , Doepctl3Spec > { EpdisW :: new (self , 30) }
#[doc = "Bit 31 - EPENA"]
#[inline (always)] pub fn epena (& mut self) -> EpenaW < '_ , Doepctl3Spec > { EpenaW :: new (self , 31) } }
#[doc = "device endpoint-3 control register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepctl3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepctl3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doepctl3Spec ; impl crate :: RegisterSpec for Doepctl3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doepctl3::R`](R) reader structure"] impl crate :: Readable for Doepctl3Spec { }
#[doc = "`write(|w| ..)` method takes [`doepctl3::W`](W) writer structure"] impl crate :: Writable for Doepctl3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPCTL3 to value 0"] impl crate :: Resettable for Doepctl3Spec { } }
#[doc = "DIEPINT0 (rw) register accessor: device endpoint-x interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepint0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepint0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepint0`] module"]
#[doc (alias = "DIEPINT0")] pub type Diepint0 = crate :: Reg < diepint0 :: Diepint0Spec > ;
#[doc = "device endpoint-x interrupt register"] pub mod diepint0 {
#[doc = "Register `DIEPINT0` reader"] pub type R = crate :: R < Diepint0Spec > ;
#[doc = "Register `DIEPINT0` writer"] pub type W = crate :: W < Diepint0Spec > ;
#[doc = "Field `XFRC` reader - XFRC"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - XFRC"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDISD` reader - EPDISD"] pub type EpdisdR = crate :: BitReader ;
#[doc = "Field `EPDISD` writer - EPDISD"] pub type EpdisdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TOC` reader - TOC"] pub type TocR = crate :: BitReader ;
#[doc = "Field `TOC` writer - TOC"] pub type TocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITTXFE` reader - ITTXFE"] pub type IttxfeR = crate :: BitReader ;
#[doc = "Field `ITTXFE` writer - ITTXFE"] pub type IttxfeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INEPNE` reader - INEPNE"] pub type InepneR = crate :: BitReader ;
#[doc = "Field `INEPNE` writer - INEPNE"] pub type InepneW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFE` reader - TXFE"] pub type TxfeR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& self) -> EpdisdR { EpdisdR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - TOC"]
#[inline (always)] pub fn toc (& self) -> TocR { TocR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ITTXFE"]
#[inline (always)] pub fn ittxfe (& self) -> IttxfeR { IttxfeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - INEPNE"]
#[inline (always)] pub fn inepne (& self) -> InepneR { InepneR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXFE"]
#[inline (always)] pub fn txfe (& self) -> TxfeR { TxfeR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , Diepint0Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& mut self) -> EpdisdW < '_ , Diepint0Spec > { EpdisdW :: new (self , 1) }
#[doc = "Bit 3 - TOC"]
#[inline (always)] pub fn toc (& mut self) -> TocW < '_ , Diepint0Spec > { TocW :: new (self , 3) }
#[doc = "Bit 4 - ITTXFE"]
#[inline (always)] pub fn ittxfe (& mut self) -> IttxfeW < '_ , Diepint0Spec > { IttxfeW :: new (self , 4) }
#[doc = "Bit 6 - INEPNE"]
#[inline (always)] pub fn inepne (& mut self) -> InepneW < '_ , Diepint0Spec > { InepneW :: new (self , 6) } }
#[doc = "device endpoint-x interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepint0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepint0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Diepint0Spec ; impl crate :: RegisterSpec for Diepint0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`diepint0::R`](R) reader structure"] impl crate :: Readable for Diepint0Spec { }
#[doc = "`write(|w| ..)` method takes [`diepint0::W`](W) writer structure"] impl crate :: Writable for Diepint0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPINT0 to value 0x80"] impl crate :: Resettable for Diepint0Spec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "DIEPINT1 (rw) register accessor: device endpoint-1 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepint1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepint1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepint1`] module"]
#[doc (alias = "DIEPINT1")] pub type Diepint1 = crate :: Reg < diepint1 :: Diepint1Spec > ;
#[doc = "device endpoint-1 interrupt register"] pub mod diepint1 {
#[doc = "Register `DIEPINT1` reader"] pub type R = crate :: R < Diepint1Spec > ;
#[doc = "Register `DIEPINT1` writer"] pub type W = crate :: W < Diepint1Spec > ;
#[doc = "Field `XFRC` reader - XFRC"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - XFRC"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDISD` reader - EPDISD"] pub type EpdisdR = crate :: BitReader ;
#[doc = "Field `EPDISD` writer - EPDISD"] pub type EpdisdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TOC` reader - TOC"] pub type TocR = crate :: BitReader ;
#[doc = "Field `TOC` writer - TOC"] pub type TocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITTXFE` reader - ITTXFE"] pub type IttxfeR = crate :: BitReader ;
#[doc = "Field `ITTXFE` writer - ITTXFE"] pub type IttxfeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INEPNE` reader - INEPNE"] pub type InepneR = crate :: BitReader ;
#[doc = "Field `INEPNE` writer - INEPNE"] pub type InepneW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFE` reader - TXFE"] pub type TxfeR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& self) -> EpdisdR { EpdisdR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - TOC"]
#[inline (always)] pub fn toc (& self) -> TocR { TocR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ITTXFE"]
#[inline (always)] pub fn ittxfe (& self) -> IttxfeR { IttxfeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - INEPNE"]
#[inline (always)] pub fn inepne (& self) -> InepneR { InepneR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXFE"]
#[inline (always)] pub fn txfe (& self) -> TxfeR { TxfeR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , Diepint1Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& mut self) -> EpdisdW < '_ , Diepint1Spec > { EpdisdW :: new (self , 1) }
#[doc = "Bit 3 - TOC"]
#[inline (always)] pub fn toc (& mut self) -> TocW < '_ , Diepint1Spec > { TocW :: new (self , 3) }
#[doc = "Bit 4 - ITTXFE"]
#[inline (always)] pub fn ittxfe (& mut self) -> IttxfeW < '_ , Diepint1Spec > { IttxfeW :: new (self , 4) }
#[doc = "Bit 6 - INEPNE"]
#[inline (always)] pub fn inepne (& mut self) -> InepneW < '_ , Diepint1Spec > { InepneW :: new (self , 6) } }
#[doc = "device endpoint-1 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepint1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepint1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Diepint1Spec ; impl crate :: RegisterSpec for Diepint1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`diepint1::R`](R) reader structure"] impl crate :: Readable for Diepint1Spec { }
#[doc = "`write(|w| ..)` method takes [`diepint1::W`](W) writer structure"] impl crate :: Writable for Diepint1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPINT1 to value 0x80"] impl crate :: Resettable for Diepint1Spec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "DIEPINT2 (rw) register accessor: device endpoint-2 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepint2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepint2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepint2`] module"]
#[doc (alias = "DIEPINT2")] pub type Diepint2 = crate :: Reg < diepint2 :: Diepint2Spec > ;
#[doc = "device endpoint-2 interrupt register"] pub mod diepint2 {
#[doc = "Register `DIEPINT2` reader"] pub type R = crate :: R < Diepint2Spec > ;
#[doc = "Register `DIEPINT2` writer"] pub type W = crate :: W < Diepint2Spec > ;
#[doc = "Field `XFRC` reader - XFRC"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - XFRC"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDISD` reader - EPDISD"] pub type EpdisdR = crate :: BitReader ;
#[doc = "Field `EPDISD` writer - EPDISD"] pub type EpdisdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TOC` reader - TOC"] pub type TocR = crate :: BitReader ;
#[doc = "Field `TOC` writer - TOC"] pub type TocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITTXFE` reader - ITTXFE"] pub type IttxfeR = crate :: BitReader ;
#[doc = "Field `ITTXFE` writer - ITTXFE"] pub type IttxfeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INEPNE` reader - INEPNE"] pub type InepneR = crate :: BitReader ;
#[doc = "Field `INEPNE` writer - INEPNE"] pub type InepneW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFE` reader - TXFE"] pub type TxfeR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& self) -> EpdisdR { EpdisdR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - TOC"]
#[inline (always)] pub fn toc (& self) -> TocR { TocR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ITTXFE"]
#[inline (always)] pub fn ittxfe (& self) -> IttxfeR { IttxfeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - INEPNE"]
#[inline (always)] pub fn inepne (& self) -> InepneR { InepneR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXFE"]
#[inline (always)] pub fn txfe (& self) -> TxfeR { TxfeR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , Diepint2Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& mut self) -> EpdisdW < '_ , Diepint2Spec > { EpdisdW :: new (self , 1) }
#[doc = "Bit 3 - TOC"]
#[inline (always)] pub fn toc (& mut self) -> TocW < '_ , Diepint2Spec > { TocW :: new (self , 3) }
#[doc = "Bit 4 - ITTXFE"]
#[inline (always)] pub fn ittxfe (& mut self) -> IttxfeW < '_ , Diepint2Spec > { IttxfeW :: new (self , 4) }
#[doc = "Bit 6 - INEPNE"]
#[inline (always)] pub fn inepne (& mut self) -> InepneW < '_ , Diepint2Spec > { InepneW :: new (self , 6) } }
#[doc = "device endpoint-2 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepint2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepint2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Diepint2Spec ; impl crate :: RegisterSpec for Diepint2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`diepint2::R`](R) reader structure"] impl crate :: Readable for Diepint2Spec { }
#[doc = "`write(|w| ..)` method takes [`diepint2::W`](W) writer structure"] impl crate :: Writable for Diepint2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPINT2 to value 0x80"] impl crate :: Resettable for Diepint2Spec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "DIEPINT3 (rw) register accessor: device endpoint-3 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepint3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepint3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@diepint3`] module"]
#[doc (alias = "DIEPINT3")] pub type Diepint3 = crate :: Reg < diepint3 :: Diepint3Spec > ;
#[doc = "device endpoint-3 interrupt register"] pub mod diepint3 {
#[doc = "Register `DIEPINT3` reader"] pub type R = crate :: R < Diepint3Spec > ;
#[doc = "Register `DIEPINT3` writer"] pub type W = crate :: W < Diepint3Spec > ;
#[doc = "Field `XFRC` reader - XFRC"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - XFRC"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDISD` reader - EPDISD"] pub type EpdisdR = crate :: BitReader ;
#[doc = "Field `EPDISD` writer - EPDISD"] pub type EpdisdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TOC` reader - TOC"] pub type TocR = crate :: BitReader ;
#[doc = "Field `TOC` writer - TOC"] pub type TocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITTXFE` reader - ITTXFE"] pub type IttxfeR = crate :: BitReader ;
#[doc = "Field `ITTXFE` writer - ITTXFE"] pub type IttxfeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INEPNE` reader - INEPNE"] pub type InepneR = crate :: BitReader ;
#[doc = "Field `INEPNE` writer - INEPNE"] pub type InepneW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFE` reader - TXFE"] pub type TxfeR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& self) -> EpdisdR { EpdisdR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - TOC"]
#[inline (always)] pub fn toc (& self) -> TocR { TocR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - ITTXFE"]
#[inline (always)] pub fn ittxfe (& self) -> IttxfeR { IttxfeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - INEPNE"]
#[inline (always)] pub fn inepne (& self) -> InepneR { InepneR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - TXFE"]
#[inline (always)] pub fn txfe (& self) -> TxfeR { TxfeR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , Diepint3Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& mut self) -> EpdisdW < '_ , Diepint3Spec > { EpdisdW :: new (self , 1) }
#[doc = "Bit 3 - TOC"]
#[inline (always)] pub fn toc (& mut self) -> TocW < '_ , Diepint3Spec > { TocW :: new (self , 3) }
#[doc = "Bit 4 - ITTXFE"]
#[inline (always)] pub fn ittxfe (& mut self) -> IttxfeW < '_ , Diepint3Spec > { IttxfeW :: new (self , 4) }
#[doc = "Bit 6 - INEPNE"]
#[inline (always)] pub fn inepne (& mut self) -> InepneW < '_ , Diepint3Spec > { InepneW :: new (self , 6) } }
#[doc = "device endpoint-3 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`diepint3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`diepint3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Diepint3Spec ; impl crate :: RegisterSpec for Diepint3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`diepint3::R`](R) reader structure"] impl crate :: Readable for Diepint3Spec { }
#[doc = "`write(|w| ..)` method takes [`diepint3::W`](W) writer structure"] impl crate :: Writable for Diepint3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPINT3 to value 0x80"] impl crate :: Resettable for Diepint3Spec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "DOEPINT0 (rw) register accessor: device endpoint-0 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepint0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepint0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepint0`] module"]
#[doc (alias = "DOEPINT0")] pub type Doepint0 = crate :: Reg < doepint0 :: Doepint0Spec > ;
#[doc = "device endpoint-0 interrupt register"] pub mod doepint0 {
#[doc = "Register `DOEPINT0` reader"] pub type R = crate :: R < Doepint0Spec > ;
#[doc = "Register `DOEPINT0` writer"] pub type W = crate :: W < Doepint0Spec > ;
#[doc = "Field `XFRC` reader - XFRC"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - XFRC"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDISD` reader - EPDISD"] pub type EpdisdR = crate :: BitReader ;
#[doc = "Field `EPDISD` writer - EPDISD"] pub type EpdisdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STUP` reader - STUP"] pub type StupR = crate :: BitReader ;
#[doc = "Field `STUP` writer - STUP"] pub type StupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OTEPDIS` reader - OTEPDIS"] pub type OtepdisR = crate :: BitReader ;
#[doc = "Field `OTEPDIS` writer - OTEPDIS"] pub type OtepdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B2BSTUP` reader - B2BSTUP"] pub type B2bstupR = crate :: BitReader ;
#[doc = "Field `B2BSTUP` writer - B2BSTUP"] pub type B2bstupW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& self) -> EpdisdR { EpdisdR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STUP"]
#[inline (always)] pub fn stup (& self) -> StupR { StupR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - OTEPDIS"]
#[inline (always)] pub fn otepdis (& self) -> OtepdisR { OtepdisR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - B2BSTUP"]
#[inline (always)] pub fn b2bstup (& self) -> B2bstupR { B2bstupR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , Doepint0Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& mut self) -> EpdisdW < '_ , Doepint0Spec > { EpdisdW :: new (self , 1) }
#[doc = "Bit 3 - STUP"]
#[inline (always)] pub fn stup (& mut self) -> StupW < '_ , Doepint0Spec > { StupW :: new (self , 3) }
#[doc = "Bit 4 - OTEPDIS"]
#[inline (always)] pub fn otepdis (& mut self) -> OtepdisW < '_ , Doepint0Spec > { OtepdisW :: new (self , 4) }
#[doc = "Bit 6 - B2BSTUP"]
#[inline (always)] pub fn b2bstup (& mut self) -> B2bstupW < '_ , Doepint0Spec > { B2bstupW :: new (self , 6) } }
#[doc = "device endpoint-0 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepint0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepint0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doepint0Spec ; impl crate :: RegisterSpec for Doepint0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doepint0::R`](R) reader structure"] impl crate :: Readable for Doepint0Spec { }
#[doc = "`write(|w| ..)` method takes [`doepint0::W`](W) writer structure"] impl crate :: Writable for Doepint0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPINT0 to value 0x80"] impl crate :: Resettable for Doepint0Spec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "DOEPINT1 (rw) register accessor: device endpoint-1 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepint1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepint1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepint1`] module"]
#[doc (alias = "DOEPINT1")] pub type Doepint1 = crate :: Reg < doepint1 :: Doepint1Spec > ;
#[doc = "device endpoint-1 interrupt register"] pub mod doepint1 {
#[doc = "Register `DOEPINT1` reader"] pub type R = crate :: R < Doepint1Spec > ;
#[doc = "Register `DOEPINT1` writer"] pub type W = crate :: W < Doepint1Spec > ;
#[doc = "Field `XFRC` reader - XFRC"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - XFRC"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDISD` reader - EPDISD"] pub type EpdisdR = crate :: BitReader ;
#[doc = "Field `EPDISD` writer - EPDISD"] pub type EpdisdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STUP` reader - STUP"] pub type StupR = crate :: BitReader ;
#[doc = "Field `STUP` writer - STUP"] pub type StupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OTEPDIS` reader - OTEPDIS"] pub type OtepdisR = crate :: BitReader ;
#[doc = "Field `OTEPDIS` writer - OTEPDIS"] pub type OtepdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B2BSTUP` reader - B2BSTUP"] pub type B2bstupR = crate :: BitReader ;
#[doc = "Field `B2BSTUP` writer - B2BSTUP"] pub type B2bstupW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& self) -> EpdisdR { EpdisdR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STUP"]
#[inline (always)] pub fn stup (& self) -> StupR { StupR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - OTEPDIS"]
#[inline (always)] pub fn otepdis (& self) -> OtepdisR { OtepdisR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - B2BSTUP"]
#[inline (always)] pub fn b2bstup (& self) -> B2bstupR { B2bstupR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , Doepint1Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& mut self) -> EpdisdW < '_ , Doepint1Spec > { EpdisdW :: new (self , 1) }
#[doc = "Bit 3 - STUP"]
#[inline (always)] pub fn stup (& mut self) -> StupW < '_ , Doepint1Spec > { StupW :: new (self , 3) }
#[doc = "Bit 4 - OTEPDIS"]
#[inline (always)] pub fn otepdis (& mut self) -> OtepdisW < '_ , Doepint1Spec > { OtepdisW :: new (self , 4) }
#[doc = "Bit 6 - B2BSTUP"]
#[inline (always)] pub fn b2bstup (& mut self) -> B2bstupW < '_ , Doepint1Spec > { B2bstupW :: new (self , 6) } }
#[doc = "device endpoint-1 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepint1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepint1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doepint1Spec ; impl crate :: RegisterSpec for Doepint1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doepint1::R`](R) reader structure"] impl crate :: Readable for Doepint1Spec { }
#[doc = "`write(|w| ..)` method takes [`doepint1::W`](W) writer structure"] impl crate :: Writable for Doepint1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPINT1 to value 0x80"] impl crate :: Resettable for Doepint1Spec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "DOEPINT2 (rw) register accessor: device endpoint-2 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepint2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepint2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepint2`] module"]
#[doc (alias = "DOEPINT2")] pub type Doepint2 = crate :: Reg < doepint2 :: Doepint2Spec > ;
#[doc = "device endpoint-2 interrupt register"] pub mod doepint2 {
#[doc = "Register `DOEPINT2` reader"] pub type R = crate :: R < Doepint2Spec > ;
#[doc = "Register `DOEPINT2` writer"] pub type W = crate :: W < Doepint2Spec > ;
#[doc = "Field `XFRC` reader - XFRC"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - XFRC"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDISD` reader - EPDISD"] pub type EpdisdR = crate :: BitReader ;
#[doc = "Field `EPDISD` writer - EPDISD"] pub type EpdisdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STUP` reader - STUP"] pub type StupR = crate :: BitReader ;
#[doc = "Field `STUP` writer - STUP"] pub type StupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OTEPDIS` reader - OTEPDIS"] pub type OtepdisR = crate :: BitReader ;
#[doc = "Field `OTEPDIS` writer - OTEPDIS"] pub type OtepdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B2BSTUP` reader - B2BSTUP"] pub type B2bstupR = crate :: BitReader ;
#[doc = "Field `B2BSTUP` writer - B2BSTUP"] pub type B2bstupW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& self) -> EpdisdR { EpdisdR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STUP"]
#[inline (always)] pub fn stup (& self) -> StupR { StupR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - OTEPDIS"]
#[inline (always)] pub fn otepdis (& self) -> OtepdisR { OtepdisR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - B2BSTUP"]
#[inline (always)] pub fn b2bstup (& self) -> B2bstupR { B2bstupR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , Doepint2Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& mut self) -> EpdisdW < '_ , Doepint2Spec > { EpdisdW :: new (self , 1) }
#[doc = "Bit 3 - STUP"]
#[inline (always)] pub fn stup (& mut self) -> StupW < '_ , Doepint2Spec > { StupW :: new (self , 3) }
#[doc = "Bit 4 - OTEPDIS"]
#[inline (always)] pub fn otepdis (& mut self) -> OtepdisW < '_ , Doepint2Spec > { OtepdisW :: new (self , 4) }
#[doc = "Bit 6 - B2BSTUP"]
#[inline (always)] pub fn b2bstup (& mut self) -> B2bstupW < '_ , Doepint2Spec > { B2bstupW :: new (self , 6) } }
#[doc = "device endpoint-2 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepint2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepint2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doepint2Spec ; impl crate :: RegisterSpec for Doepint2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doepint2::R`](R) reader structure"] impl crate :: Readable for Doepint2Spec { }
#[doc = "`write(|w| ..)` method takes [`doepint2::W`](W) writer structure"] impl crate :: Writable for Doepint2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPINT2 to value 0x80"] impl crate :: Resettable for Doepint2Spec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "DOEPINT3 (rw) register accessor: device endpoint-3 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepint3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepint3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doepint3`] module"]
#[doc (alias = "DOEPINT3")] pub type Doepint3 = crate :: Reg < doepint3 :: Doepint3Spec > ;
#[doc = "device endpoint-3 interrupt register"] pub mod doepint3 {
#[doc = "Register `DOEPINT3` reader"] pub type R = crate :: R < Doepint3Spec > ;
#[doc = "Register `DOEPINT3` writer"] pub type W = crate :: W < Doepint3Spec > ;
#[doc = "Field `XFRC` reader - XFRC"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - XFRC"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPDISD` reader - EPDISD"] pub type EpdisdR = crate :: BitReader ;
#[doc = "Field `EPDISD` writer - EPDISD"] pub type EpdisdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STUP` reader - STUP"] pub type StupR = crate :: BitReader ;
#[doc = "Field `STUP` writer - STUP"] pub type StupW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OTEPDIS` reader - OTEPDIS"] pub type OtepdisR = crate :: BitReader ;
#[doc = "Field `OTEPDIS` writer - OTEPDIS"] pub type OtepdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B2BSTUP` reader - B2BSTUP"] pub type B2bstupR = crate :: BitReader ;
#[doc = "Field `B2BSTUP` writer - B2BSTUP"] pub type B2bstupW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& self) -> EpdisdR { EpdisdR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STUP"]
#[inline (always)] pub fn stup (& self) -> StupR { StupR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - OTEPDIS"]
#[inline (always)] pub fn otepdis (& self) -> OtepdisR { OtepdisR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - B2BSTUP"]
#[inline (always)] pub fn b2bstup (& self) -> B2bstupR { B2bstupR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - XFRC"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , Doepint3Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - EPDISD"]
#[inline (always)] pub fn epdisd (& mut self) -> EpdisdW < '_ , Doepint3Spec > { EpdisdW :: new (self , 1) }
#[doc = "Bit 3 - STUP"]
#[inline (always)] pub fn stup (& mut self) -> StupW < '_ , Doepint3Spec > { StupW :: new (self , 3) }
#[doc = "Bit 4 - OTEPDIS"]
#[inline (always)] pub fn otepdis (& mut self) -> OtepdisW < '_ , Doepint3Spec > { OtepdisW :: new (self , 4) }
#[doc = "Bit 6 - B2BSTUP"]
#[inline (always)] pub fn b2bstup (& mut self) -> B2bstupW < '_ , Doepint3Spec > { B2bstupW :: new (self , 6) } }
#[doc = "device endpoint-3 interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`doepint3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doepint3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doepint3Spec ; impl crate :: RegisterSpec for Doepint3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doepint3::R`](R) reader structure"] impl crate :: Readable for Doepint3Spec { }
#[doc = "`write(|w| ..)` method takes [`doepint3::W`](W) writer structure"] impl crate :: Writable for Doepint3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPINT3 to value 0x80"] impl crate :: Resettable for Doepint3Spec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "DIEPTSIZ0 (rw) register accessor: device endpoint-0 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`dieptsiz0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dieptsiz0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptsiz0`] module"]
#[doc (alias = "DIEPTSIZ0")] pub type Dieptsiz0 = crate :: Reg < dieptsiz0 :: Dieptsiz0Spec > ;
#[doc = "device endpoint-0 transfer size register"] pub mod dieptsiz0 {
#[doc = "Register `DIEPTSIZ0` reader"] pub type R = crate :: R < Dieptsiz0Spec > ;
#[doc = "Register `DIEPTSIZ0` writer"] pub type W = crate :: W < Dieptsiz0Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:6 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bits 19:20 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 3) as u8) } } impl W {
#[doc = "Bits 0:6 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , Dieptsiz0Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:20 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , Dieptsiz0Spec > { PktcntW :: new (self , 19) } }
#[doc = "device endpoint-0 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`dieptsiz0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dieptsiz0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dieptsiz0Spec ; impl crate :: RegisterSpec for Dieptsiz0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dieptsiz0::R`](R) reader structure"] impl crate :: Readable for Dieptsiz0Spec { }
#[doc = "`write(|w| ..)` method takes [`dieptsiz0::W`](W) writer structure"] impl crate :: Writable for Dieptsiz0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPTSIZ0 to value 0"] impl crate :: Resettable for Dieptsiz0Spec { } }
#[doc = "DOEPTSIZ0 (rw) register accessor: device OUT endpoint-0 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`doeptsiz0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doeptsiz0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doeptsiz0`] module"]
#[doc (alias = "DOEPTSIZ0")] pub type Doeptsiz0 = crate :: Reg < doeptsiz0 :: Doeptsiz0Spec > ;
#[doc = "device OUT endpoint-0 transfer size register"] pub mod doeptsiz0 {
#[doc = "Register `DOEPTSIZ0` reader"] pub type R = crate :: R < Doeptsiz0Spec > ;
#[doc = "Register `DOEPTSIZ0` writer"] pub type W = crate :: W < Doeptsiz0Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: BitReader ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STUPCNT` reader - SETUP packet count"] pub type StupcntR = crate :: FieldReader ;
#[doc = "Field `STUPCNT` writer - SETUP packet count"] pub type StupcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:6 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bit 19 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bits 29:30 - SETUP packet count"]
#[inline (always)] pub fn stupcnt (& self) -> StupcntR { StupcntR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:6 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , Doeptsiz0Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bit 19 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , Doeptsiz0Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - SETUP packet count"]
#[inline (always)] pub fn stupcnt (& mut self) -> StupcntW < '_ , Doeptsiz0Spec > { StupcntW :: new (self , 29) } }
#[doc = "device OUT endpoint-0 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`doeptsiz0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doeptsiz0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doeptsiz0Spec ; impl crate :: RegisterSpec for Doeptsiz0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doeptsiz0::R`](R) reader structure"] impl crate :: Readable for Doeptsiz0Spec { }
#[doc = "`write(|w| ..)` method takes [`doeptsiz0::W`](W) writer structure"] impl crate :: Writable for Doeptsiz0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPTSIZ0 to value 0"] impl crate :: Resettable for Doeptsiz0Spec { } }
#[doc = "DIEPTSIZ1 (rw) register accessor: device endpoint-1 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`dieptsiz1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dieptsiz1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptsiz1`] module"]
#[doc (alias = "DIEPTSIZ1")] pub type Dieptsiz1 = crate :: Reg < dieptsiz1 :: Dieptsiz1Spec > ;
#[doc = "device endpoint-1 transfer size register"] pub mod dieptsiz1 {
#[doc = "Register `DIEPTSIZ1` reader"] pub type R = crate :: R < Dieptsiz1Spec > ;
#[doc = "Register `DIEPTSIZ1` writer"] pub type W = crate :: W < Dieptsiz1Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `MCNT` reader - Multi count"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multi count"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Multi count"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , Dieptsiz1Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , Dieptsiz1Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Multi count"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , Dieptsiz1Spec > { McntW :: new (self , 29) } }
#[doc = "device endpoint-1 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`dieptsiz1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dieptsiz1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dieptsiz1Spec ; impl crate :: RegisterSpec for Dieptsiz1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dieptsiz1::R`](R) reader structure"] impl crate :: Readable for Dieptsiz1Spec { }
#[doc = "`write(|w| ..)` method takes [`dieptsiz1::W`](W) writer structure"] impl crate :: Writable for Dieptsiz1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPTSIZ1 to value 0"] impl crate :: Resettable for Dieptsiz1Spec { } }
#[doc = "DIEPTSIZ2 (rw) register accessor: device endpoint-2 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`dieptsiz2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dieptsiz2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptsiz2`] module"]
#[doc (alias = "DIEPTSIZ2")] pub type Dieptsiz2 = crate :: Reg < dieptsiz2 :: Dieptsiz2Spec > ;
#[doc = "device endpoint-2 transfer size register"] pub mod dieptsiz2 {
#[doc = "Register `DIEPTSIZ2` reader"] pub type R = crate :: R < Dieptsiz2Spec > ;
#[doc = "Register `DIEPTSIZ2` writer"] pub type W = crate :: W < Dieptsiz2Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `MCNT` reader - Multi count"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multi count"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Multi count"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , Dieptsiz2Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , Dieptsiz2Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Multi count"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , Dieptsiz2Spec > { McntW :: new (self , 29) } }
#[doc = "device endpoint-2 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`dieptsiz2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dieptsiz2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dieptsiz2Spec ; impl crate :: RegisterSpec for Dieptsiz2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dieptsiz2::R`](R) reader structure"] impl crate :: Readable for Dieptsiz2Spec { }
#[doc = "`write(|w| ..)` method takes [`dieptsiz2::W`](W) writer structure"] impl crate :: Writable for Dieptsiz2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPTSIZ2 to value 0"] impl crate :: Resettable for Dieptsiz2Spec { } }
#[doc = "DIEPTSIZ3 (rw) register accessor: device endpoint-3 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`dieptsiz3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dieptsiz3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dieptsiz3`] module"]
#[doc (alias = "DIEPTSIZ3")] pub type Dieptsiz3 = crate :: Reg < dieptsiz3 :: Dieptsiz3Spec > ;
#[doc = "device endpoint-3 transfer size register"] pub mod dieptsiz3 {
#[doc = "Register `DIEPTSIZ3` reader"] pub type R = crate :: R < Dieptsiz3Spec > ;
#[doc = "Register `DIEPTSIZ3` writer"] pub type W = crate :: W < Dieptsiz3Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `MCNT` reader - Multi count"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multi count"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Multi count"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , Dieptsiz3Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , Dieptsiz3Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Multi count"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , Dieptsiz3Spec > { McntW :: new (self , 29) } }
#[doc = "device endpoint-3 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`dieptsiz3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dieptsiz3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dieptsiz3Spec ; impl crate :: RegisterSpec for Dieptsiz3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dieptsiz3::R`](R) reader structure"] impl crate :: Readable for Dieptsiz3Spec { }
#[doc = "`write(|w| ..)` method takes [`dieptsiz3::W`](W) writer structure"] impl crate :: Writable for Dieptsiz3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIEPTSIZ3 to value 0"] impl crate :: Resettable for Dieptsiz3Spec { } }
#[doc = "DTXFSTS0 (r) register accessor: OTG_FS device IN endpoint transmit FIFO status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dtxfsts0::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dtxfsts0`] module"]
#[doc (alias = "DTXFSTS0")] pub type Dtxfsts0 = crate :: Reg < dtxfsts0 :: Dtxfsts0Spec > ;
#[doc = "OTG_FS device IN endpoint transmit FIFO status register"] pub mod dtxfsts0 {
#[doc = "Register `DTXFSTS0` reader"] pub type R = crate :: R < Dtxfsts0Spec > ;
#[doc = "Field `INEPTFSAV` reader - IN endpoint TxFIFO space available"] pub type IneptfsavR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - IN endpoint TxFIFO space available"]
#[inline (always)] pub fn ineptfsav (& self) -> IneptfsavR { IneptfsavR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "OTG_FS device IN endpoint transmit FIFO status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dtxfsts0::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dtxfsts0Spec ; impl crate :: RegisterSpec for Dtxfsts0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dtxfsts0::R`](R) reader structure"] impl crate :: Readable for Dtxfsts0Spec { }
#[doc = "`reset()` method sets DTXFSTS0 to value 0"] impl crate :: Resettable for Dtxfsts0Spec { } }
#[doc = "DTXFSTS1 (r) register accessor: OTG_FS device IN endpoint transmit FIFO status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dtxfsts1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dtxfsts1`] module"]
#[doc (alias = "DTXFSTS1")] pub type Dtxfsts1 = crate :: Reg < dtxfsts1 :: Dtxfsts1Spec > ;
#[doc = "OTG_FS device IN endpoint transmit FIFO status register"] pub mod dtxfsts1 {
#[doc = "Register `DTXFSTS1` reader"] pub type R = crate :: R < Dtxfsts1Spec > ;
#[doc = "Field `INEPTFSAV` reader - IN endpoint TxFIFO space available"] pub type IneptfsavR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - IN endpoint TxFIFO space available"]
#[inline (always)] pub fn ineptfsav (& self) -> IneptfsavR { IneptfsavR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "OTG_FS device IN endpoint transmit FIFO status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dtxfsts1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dtxfsts1Spec ; impl crate :: RegisterSpec for Dtxfsts1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dtxfsts1::R`](R) reader structure"] impl crate :: Readable for Dtxfsts1Spec { }
#[doc = "`reset()` method sets DTXFSTS1 to value 0"] impl crate :: Resettable for Dtxfsts1Spec { } }
#[doc = "DTXFSTS2 (r) register accessor: OTG_FS device IN endpoint transmit FIFO status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dtxfsts2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dtxfsts2`] module"]
#[doc (alias = "DTXFSTS2")] pub type Dtxfsts2 = crate :: Reg < dtxfsts2 :: Dtxfsts2Spec > ;
#[doc = "OTG_FS device IN endpoint transmit FIFO status register"] pub mod dtxfsts2 {
#[doc = "Register `DTXFSTS2` reader"] pub type R = crate :: R < Dtxfsts2Spec > ;
#[doc = "Field `INEPTFSAV` reader - IN endpoint TxFIFO space available"] pub type IneptfsavR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - IN endpoint TxFIFO space available"]
#[inline (always)] pub fn ineptfsav (& self) -> IneptfsavR { IneptfsavR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "OTG_FS device IN endpoint transmit FIFO status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dtxfsts2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dtxfsts2Spec ; impl crate :: RegisterSpec for Dtxfsts2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dtxfsts2::R`](R) reader structure"] impl crate :: Readable for Dtxfsts2Spec { }
#[doc = "`reset()` method sets DTXFSTS2 to value 0"] impl crate :: Resettable for Dtxfsts2Spec { } }
#[doc = "DTXFSTS3 (r) register accessor: OTG_FS device IN endpoint transmit FIFO status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dtxfsts3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dtxfsts3`] module"]
#[doc (alias = "DTXFSTS3")] pub type Dtxfsts3 = crate :: Reg < dtxfsts3 :: Dtxfsts3Spec > ;
#[doc = "OTG_FS device IN endpoint transmit FIFO status register"] pub mod dtxfsts3 {
#[doc = "Register `DTXFSTS3` reader"] pub type R = crate :: R < Dtxfsts3Spec > ;
#[doc = "Field `INEPTFSAV` reader - IN endpoint TxFIFO space available"] pub type IneptfsavR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - IN endpoint TxFIFO space available"]
#[inline (always)] pub fn ineptfsav (& self) -> IneptfsavR { IneptfsavR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "OTG_FS device IN endpoint transmit FIFO status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dtxfsts3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Dtxfsts3Spec ; impl crate :: RegisterSpec for Dtxfsts3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dtxfsts3::R`](R) reader structure"] impl crate :: Readable for Dtxfsts3Spec { }
#[doc = "`reset()` method sets DTXFSTS3 to value 0"] impl crate :: Resettable for Dtxfsts3Spec { } }
#[doc = "DOEPTSIZ1 (rw) register accessor: device OUT endpoint-1 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`doeptsiz1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doeptsiz1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doeptsiz1`] module"]
#[doc (alias = "DOEPTSIZ1")] pub type Doeptsiz1 = crate :: Reg < doeptsiz1 :: Doeptsiz1Spec > ;
#[doc = "device OUT endpoint-1 transfer size register"] pub mod doeptsiz1 {
#[doc = "Register `DOEPTSIZ1` reader"] pub type R = crate :: R < Doeptsiz1Spec > ;
#[doc = "Register `DOEPTSIZ1` writer"] pub type W = crate :: W < Doeptsiz1Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `RXDPID_STUPCNT` reader - Received data PID/SETUP packet count"] pub type RxdpidStupcntR = crate :: FieldReader ;
#[doc = "Field `RXDPID_STUPCNT` writer - Received data PID/SETUP packet count"] pub type RxdpidStupcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Received data PID/SETUP packet count"]
#[inline (always)] pub fn rxdpid_stupcnt (& self) -> RxdpidStupcntR { RxdpidStupcntR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , Doeptsiz1Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , Doeptsiz1Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Received data PID/SETUP packet count"]
#[inline (always)] pub fn rxdpid_stupcnt (& mut self) -> RxdpidStupcntW < '_ , Doeptsiz1Spec > { RxdpidStupcntW :: new (self , 29) } }
#[doc = "device OUT endpoint-1 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`doeptsiz1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doeptsiz1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doeptsiz1Spec ; impl crate :: RegisterSpec for Doeptsiz1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doeptsiz1::R`](R) reader structure"] impl crate :: Readable for Doeptsiz1Spec { }
#[doc = "`write(|w| ..)` method takes [`doeptsiz1::W`](W) writer structure"] impl crate :: Writable for Doeptsiz1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPTSIZ1 to value 0"] impl crate :: Resettable for Doeptsiz1Spec { } }
#[doc = "DOEPTSIZ2 (rw) register accessor: device OUT endpoint-2 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`doeptsiz2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doeptsiz2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doeptsiz2`] module"]
#[doc (alias = "DOEPTSIZ2")] pub type Doeptsiz2 = crate :: Reg < doeptsiz2 :: Doeptsiz2Spec > ;
#[doc = "device OUT endpoint-2 transfer size register"] pub mod doeptsiz2 {
#[doc = "Register `DOEPTSIZ2` reader"] pub type R = crate :: R < Doeptsiz2Spec > ;
#[doc = "Register `DOEPTSIZ2` writer"] pub type W = crate :: W < Doeptsiz2Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `RXDPID_STUPCNT` reader - Received data PID/SETUP packet count"] pub type RxdpidStupcntR = crate :: FieldReader ;
#[doc = "Field `RXDPID_STUPCNT` writer - Received data PID/SETUP packet count"] pub type RxdpidStupcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Received data PID/SETUP packet count"]
#[inline (always)] pub fn rxdpid_stupcnt (& self) -> RxdpidStupcntR { RxdpidStupcntR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , Doeptsiz2Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , Doeptsiz2Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Received data PID/SETUP packet count"]
#[inline (always)] pub fn rxdpid_stupcnt (& mut self) -> RxdpidStupcntW < '_ , Doeptsiz2Spec > { RxdpidStupcntW :: new (self , 29) } }
#[doc = "device OUT endpoint-2 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`doeptsiz2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doeptsiz2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doeptsiz2Spec ; impl crate :: RegisterSpec for Doeptsiz2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doeptsiz2::R`](R) reader structure"] impl crate :: Readable for Doeptsiz2Spec { }
#[doc = "`write(|w| ..)` method takes [`doeptsiz2::W`](W) writer structure"] impl crate :: Writable for Doeptsiz2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPTSIZ2 to value 0"] impl crate :: Resettable for Doeptsiz2Spec { } }
#[doc = "DOEPTSIZ3 (rw) register accessor: device OUT endpoint-3 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`doeptsiz3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doeptsiz3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@doeptsiz3`] module"]
#[doc (alias = "DOEPTSIZ3")] pub type Doeptsiz3 = crate :: Reg < doeptsiz3 :: Doeptsiz3Spec > ;
#[doc = "device OUT endpoint-3 transfer size register"] pub mod doeptsiz3 {
#[doc = "Register `DOEPTSIZ3` reader"] pub type R = crate :: R < Doeptsiz3Spec > ;
#[doc = "Register `DOEPTSIZ3` writer"] pub type W = crate :: W < Doeptsiz3Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `RXDPID_STUPCNT` reader - Received data PID/SETUP packet count"] pub type RxdpidStupcntR = crate :: FieldReader ;
#[doc = "Field `RXDPID_STUPCNT` writer - Received data PID/SETUP packet count"] pub type RxdpidStupcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Received data PID/SETUP packet count"]
#[inline (always)] pub fn rxdpid_stupcnt (& self) -> RxdpidStupcntR { RxdpidStupcntR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , Doeptsiz3Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , Doeptsiz3Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Received data PID/SETUP packet count"]
#[inline (always)] pub fn rxdpid_stupcnt (& mut self) -> RxdpidStupcntW < '_ , Doeptsiz3Spec > { RxdpidStupcntW :: new (self , 29) } }
#[doc = "device OUT endpoint-3 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`doeptsiz3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`doeptsiz3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Doeptsiz3Spec ; impl crate :: RegisterSpec for Doeptsiz3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`doeptsiz3::R`](R) reader structure"] impl crate :: Readable for Doeptsiz3Spec { }
#[doc = "`write(|w| ..)` method takes [`doeptsiz3::W`](W) writer structure"] impl crate :: Writable for Doeptsiz3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DOEPTSIZ3 to value 0"] impl crate :: Resettable for Doeptsiz3Spec { } } }
#[doc = "USB on the go full speed"] pub type OtgFsGlobal = crate :: Periph < otg_fs_global :: RegisterBlock , 0x5000_0000 > ; impl core :: fmt :: Debug for OtgFsGlobal { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgFsGlobal") . finish () } }
#[doc = "USB on the go full speed"] pub mod otg_fs_global {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { fs_gotgctl : FsGotgctl , fs_gotgint : FsGotgint , fs_gahbcfg : FsGahbcfg , fs_gusbcfg : FsGusbcfg , fs_grstctl : FsGrstctl , fs_gintsts : FsGintsts , fs_gintmsk : FsGintmsk , _reserved_7_fs_grxstsr : [u8 ; 0x04] , _reserved8 : [u8 ; 0x04] , fs_grxfsiz : FsGrxfsiz , _reserved_9_fs_gnptxfsiz : [u8 ; 0x04] , fs_gnptxsts : FsGnptxsts , _reserved11 : [u8 ; 0x08] , fs_gccfg : FsGccfg , fs_cid : FsCid , _reserved13 : [u8 ; 0xc0] , fs_hptxfsiz : FsHptxfsiz , fs_dieptxf1 : FsDieptxf1 , fs_dieptxf2 : FsDieptxf2 , fs_dieptxf3 : FsDieptxf3 , } impl RegisterBlock {
#[doc = "0x00 - OTG_FS control and status register (OTG_FS_GOTGCTL)"]
#[inline (always)] pub const fn fs_gotgctl (& self) -> & FsGotgctl { & self . fs_gotgctl }
#[doc = "0x04 - OTG_FS interrupt register (OTG_FS_GOTGINT)"]
#[inline (always)] pub const fn fs_gotgint (& self) -> & FsGotgint { & self . fs_gotgint }
#[doc = "0x08 - OTG_FS AHB configuration register (OTG_FS_GAHBCFG)"]
#[inline (always)] pub const fn fs_gahbcfg (& self) -> & FsGahbcfg { & self . fs_gahbcfg }
#[doc = "0x0c - OTG_FS USB configuration register (OTG_FS_GUSBCFG)"]
#[inline (always)] pub const fn fs_gusbcfg (& self) -> & FsGusbcfg { & self . fs_gusbcfg }
#[doc = "0x10 - OTG_FS reset register (OTG_FS_GRSTCTL)"]
#[inline (always)] pub const fn fs_grstctl (& self) -> & FsGrstctl { & self . fs_grstctl }
#[doc = "0x14 - OTG_FS core interrupt register (OTG_FS_GINTSTS)"]
#[inline (always)] pub const fn fs_gintsts (& self) -> & FsGintsts { & self . fs_gintsts }
#[doc = "0x18 - OTG_FS interrupt mask register (OTG_FS_GINTMSK)"]
#[inline (always)] pub const fn fs_gintmsk (& self) -> & FsGintmsk { & self . fs_gintmsk }
#[doc = "0x1c - OTG_FS Receive status debug read(Host mode)"]
#[inline (always)] pub const fn fs_grxstsr_host (& self) -> & FsGrxstsrHost { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - OTG_FS Receive status debug read(Device mode)"]
#[inline (always)] pub const fn fs_grxstsr_device (& self) -> & FsGrxstsrDevice { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x24 - OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)"]
#[inline (always)] pub const fn fs_grxfsiz (& self) -> & FsGrxfsiz { & self . fs_grxfsiz }
#[doc = "0x28 - OTG_FS non-periodic transmit FIFO size register (Host mode)"]
#[inline (always)] pub const fn fs_gnptxfsiz_host (& self) -> & FsGnptxfsizHost { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (40) . cast () } }
#[doc = "0x28 - OTG_FS non-periodic transmit FIFO size register (Device mode)"]
#[inline (always)] pub const fn fs_gnptxfsiz_device (& self) -> & FsGnptxfsizDevice { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (40) . cast () } }
#[doc = "0x2c - OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)"]
#[inline (always)] pub const fn fs_gnptxsts (& self) -> & FsGnptxsts { & self . fs_gnptxsts }
#[doc = "0x38 - OTG_FS general core configuration register (OTG_FS_GCCFG)"]
#[inline (always)] pub const fn fs_gccfg (& self) -> & FsGccfg { & self . fs_gccfg }
#[doc = "0x3c - core ID register"]
#[inline (always)] pub const fn fs_cid (& self) -> & FsCid { & self . fs_cid }
#[doc = "0x100 - OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)"]
#[inline (always)] pub const fn fs_hptxfsiz (& self) -> & FsHptxfsiz { & self . fs_hptxfsiz }
#[doc = "0x104 - OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)"]
#[inline (always)] pub const fn fs_dieptxf1 (& self) -> & FsDieptxf1 { & self . fs_dieptxf1 }
#[doc = "0x108 - OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)"]
#[inline (always)] pub const fn fs_dieptxf2 (& self) -> & FsDieptxf2 { & self . fs_dieptxf2 }
#[doc = "0x10c - OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)"]
#[inline (always)] pub const fn fs_dieptxf3 (& self) -> & FsDieptxf3 { & self . fs_dieptxf3 } }
#[doc = "FS_GOTGCTL (rw) register accessor: OTG_FS control and status register (OTG_FS_GOTGCTL)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gotgctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gotgctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gotgctl`] module"]
#[doc (alias = "FS_GOTGCTL")] pub type FsGotgctl = crate :: Reg < fs_gotgctl :: FsGotgctlSpec > ;
#[doc = "OTG_FS control and status register (OTG_FS_GOTGCTL)"] pub mod fs_gotgctl {
#[doc = "Register `FS_GOTGCTL` reader"] pub type R = crate :: R < FsGotgctlSpec > ;
#[doc = "Register `FS_GOTGCTL` writer"] pub type W = crate :: W < FsGotgctlSpec > ;
#[doc = "Field `SRQSCS` reader - Session request success"] pub type SrqscsR = crate :: BitReader ;
#[doc = "Field `SRQ` reader - Session request"] pub type SrqR = crate :: BitReader ;
#[doc = "Field `SRQ` writer - Session request"] pub type SrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HNGSCS` reader - Host negotiation success"] pub type HngscsR = crate :: BitReader ;
#[doc = "Field `HNPRQ` reader - HNP request"] pub type HnprqR = crate :: BitReader ;
#[doc = "Field `HNPRQ` writer - HNP request"] pub type HnprqW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSHNPEN` reader - Host set HNP enable"] pub type HshnpenR = crate :: BitReader ;
#[doc = "Field `HSHNPEN` writer - Host set HNP enable"] pub type HshnpenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DHNPEN` reader - Device HNP enabled"] pub type DhnpenR = crate :: BitReader ;
#[doc = "Field `DHNPEN` writer - Device HNP enabled"] pub type DhnpenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIDSTS` reader - Connector ID status"] pub type CidstsR = crate :: BitReader ;
#[doc = "Field `DBCT` reader - Long/short debounce time"] pub type DbctR = crate :: BitReader ;
#[doc = "Field `ASVLD` reader - A-session valid"] pub type AsvldR = crate :: BitReader ;
#[doc = "Field `BSVLD` reader - B-session valid"] pub type BsvldR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Session request success"]
#[inline (always)] pub fn srqscs (& self) -> SrqscsR { SrqscsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Session request"]
#[inline (always)] pub fn srq (& self) -> SrqR { SrqR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 8 - Host negotiation success"]
#[inline (always)] pub fn hngscs (& self) -> HngscsR { HngscsR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - HNP request"]
#[inline (always)] pub fn hnprq (& self) -> HnprqR { HnprqR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Host set HNP enable"]
#[inline (always)] pub fn hshnpen (& self) -> HshnpenR { HshnpenR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Device HNP enabled"]
#[inline (always)] pub fn dhnpen (& self) -> DhnpenR { DhnpenR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 16 - Connector ID status"]
#[inline (always)] pub fn cidsts (& self) -> CidstsR { CidstsR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Long/short debounce time"]
#[inline (always)] pub fn dbct (& self) -> DbctR { DbctR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - A-session valid"]
#[inline (always)] pub fn asvld (& self) -> AsvldR { AsvldR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - B-session valid"]
#[inline (always)] pub fn bsvld (& self) -> BsvldR { BsvldR :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 1 - Session request"]
#[inline (always)] pub fn srq (& mut self) -> SrqW < '_ , FsGotgctlSpec > { SrqW :: new (self , 1) }
#[doc = "Bit 9 - HNP request"]
#[inline (always)] pub fn hnprq (& mut self) -> HnprqW < '_ , FsGotgctlSpec > { HnprqW :: new (self , 9) }
#[doc = "Bit 10 - Host set HNP enable"]
#[inline (always)] pub fn hshnpen (& mut self) -> HshnpenW < '_ , FsGotgctlSpec > { HshnpenW :: new (self , 10) }
#[doc = "Bit 11 - Device HNP enabled"]
#[inline (always)] pub fn dhnpen (& mut self) -> DhnpenW < '_ , FsGotgctlSpec > { DhnpenW :: new (self , 11) } }
#[doc = "OTG_FS control and status register (OTG_FS_GOTGCTL)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gotgctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gotgctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGotgctlSpec ; impl crate :: RegisterSpec for FsGotgctlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gotgctl::R`](R) reader structure"] impl crate :: Readable for FsGotgctlSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gotgctl::W`](W) writer structure"] impl crate :: Writable for FsGotgctlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GOTGCTL to value 0x0800"] impl crate :: Resettable for FsGotgctlSpec { const RESET_VALUE : u32 = 0x0800 ; } }
#[doc = "FS_GOTGINT (rw) register accessor: OTG_FS interrupt register (OTG_FS_GOTGINT)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gotgint::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gotgint::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gotgint`] module"]
#[doc (alias = "FS_GOTGINT")] pub type FsGotgint = crate :: Reg < fs_gotgint :: FsGotgintSpec > ;
#[doc = "OTG_FS interrupt register (OTG_FS_GOTGINT)"] pub mod fs_gotgint {
#[doc = "Register `FS_GOTGINT` reader"] pub type R = crate :: R < FsGotgintSpec > ;
#[doc = "Register `FS_GOTGINT` writer"] pub type W = crate :: W < FsGotgintSpec > ;
#[doc = "Field `SEDET` reader - Session end detected"] pub type SedetR = crate :: BitReader ;
#[doc = "Field `SEDET` writer - Session end detected"] pub type SedetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRSSCHG` reader - Session request success status change"] pub type SrsschgR = crate :: BitReader ;
#[doc = "Field `SRSSCHG` writer - Session request success status change"] pub type SrsschgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HNSSCHG` reader - Host negotiation success status change"] pub type HnsschgR = crate :: BitReader ;
#[doc = "Field `HNSSCHG` writer - Host negotiation success status change"] pub type HnsschgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HNGDET` reader - Host negotiation detected"] pub type HngdetR = crate :: BitReader ;
#[doc = "Field `HNGDET` writer - Host negotiation detected"] pub type HngdetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADTOCHG` reader - A-device timeout change"] pub type AdtochgR = crate :: BitReader ;
#[doc = "Field `ADTOCHG` writer - A-device timeout change"] pub type AdtochgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBCDNE` reader - Debounce done"] pub type DbcdneR = crate :: BitReader ;
#[doc = "Field `DBCDNE` writer - Debounce done"] pub type DbcdneW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - Session end detected"]
#[inline (always)] pub fn sedet (& self) -> SedetR { SedetR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 8 - Session request success status change"]
#[inline (always)] pub fn srsschg (& self) -> SrsschgR { SrsschgR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Host negotiation success status change"]
#[inline (always)] pub fn hnsschg (& self) -> HnsschgR { HnsschgR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 17 - Host negotiation detected"]
#[inline (always)] pub fn hngdet (& self) -> HngdetR { HngdetR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - A-device timeout change"]
#[inline (always)] pub fn adtochg (& self) -> AdtochgR { AdtochgR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Debounce done"]
#[inline (always)] pub fn dbcdne (& self) -> DbcdneR { DbcdneR :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 2 - Session end detected"]
#[inline (always)] pub fn sedet (& mut self) -> SedetW < '_ , FsGotgintSpec > { SedetW :: new (self , 2) }
#[doc = "Bit 8 - Session request success status change"]
#[inline (always)] pub fn srsschg (& mut self) -> SrsschgW < '_ , FsGotgintSpec > { SrsschgW :: new (self , 8) }
#[doc = "Bit 9 - Host negotiation success status change"]
#[inline (always)] pub fn hnsschg (& mut self) -> HnsschgW < '_ , FsGotgintSpec > { HnsschgW :: new (self , 9) }
#[doc = "Bit 17 - Host negotiation detected"]
#[inline (always)] pub fn hngdet (& mut self) -> HngdetW < '_ , FsGotgintSpec > { HngdetW :: new (self , 17) }
#[doc = "Bit 18 - A-device timeout change"]
#[inline (always)] pub fn adtochg (& mut self) -> AdtochgW < '_ , FsGotgintSpec > { AdtochgW :: new (self , 18) }
#[doc = "Bit 19 - Debounce done"]
#[inline (always)] pub fn dbcdne (& mut self) -> DbcdneW < '_ , FsGotgintSpec > { DbcdneW :: new (self , 19) } }
#[doc = "OTG_FS interrupt register (OTG_FS_GOTGINT)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gotgint::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gotgint::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGotgintSpec ; impl crate :: RegisterSpec for FsGotgintSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gotgint::R`](R) reader structure"] impl crate :: Readable for FsGotgintSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gotgint::W`](W) writer structure"] impl crate :: Writable for FsGotgintSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GOTGINT to value 0"] impl crate :: Resettable for FsGotgintSpec { } }
#[doc = "FS_GAHBCFG (rw) register accessor: OTG_FS AHB configuration register (OTG_FS_GAHBCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gahbcfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gahbcfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gahbcfg`] module"]
#[doc (alias = "FS_GAHBCFG")] pub type FsGahbcfg = crate :: Reg < fs_gahbcfg :: FsGahbcfgSpec > ;
#[doc = "OTG_FS AHB configuration register (OTG_FS_GAHBCFG)"] pub mod fs_gahbcfg {
#[doc = "Register `FS_GAHBCFG` reader"] pub type R = crate :: R < FsGahbcfgSpec > ;
#[doc = "Register `FS_GAHBCFG` writer"] pub type W = crate :: W < FsGahbcfgSpec > ;
#[doc = "Field `GINT` reader - Global interrupt mask"] pub type GintR = crate :: BitReader ;
#[doc = "Field `GINT` writer - Global interrupt mask"] pub type GintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFELVL` reader - TxFIFO empty level"] pub type TxfelvlR = crate :: BitReader ;
#[doc = "Field `TXFELVL` writer - TxFIFO empty level"] pub type TxfelvlW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PTXFELVL` reader - Periodic TxFIFO empty level"] pub type PtxfelvlR = crate :: BitReader ;
#[doc = "Field `PTXFELVL` writer - Periodic TxFIFO empty level"] pub type PtxfelvlW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Global interrupt mask"]
#[inline (always)] pub fn gint (& self) -> GintR { GintR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 7 - TxFIFO empty level"]
#[inline (always)] pub fn txfelvl (& self) -> TxfelvlR { TxfelvlR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Periodic TxFIFO empty level"]
#[inline (always)] pub fn ptxfelvl (& self) -> PtxfelvlR { PtxfelvlR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Global interrupt mask"]
#[inline (always)] pub fn gint (& mut self) -> GintW < '_ , FsGahbcfgSpec > { GintW :: new (self , 0) }
#[doc = "Bit 7 - TxFIFO empty level"]
#[inline (always)] pub fn txfelvl (& mut self) -> TxfelvlW < '_ , FsGahbcfgSpec > { TxfelvlW :: new (self , 7) }
#[doc = "Bit 8 - Periodic TxFIFO empty level"]
#[inline (always)] pub fn ptxfelvl (& mut self) -> PtxfelvlW < '_ , FsGahbcfgSpec > { PtxfelvlW :: new (self , 8) } }
#[doc = "OTG_FS AHB configuration register (OTG_FS_GAHBCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gahbcfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gahbcfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGahbcfgSpec ; impl crate :: RegisterSpec for FsGahbcfgSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gahbcfg::R`](R) reader structure"] impl crate :: Readable for FsGahbcfgSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gahbcfg::W`](W) writer structure"] impl crate :: Writable for FsGahbcfgSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GAHBCFG to value 0"] impl crate :: Resettable for FsGahbcfgSpec { } }
#[doc = "FS_GUSBCFG (rw) register accessor: OTG_FS USB configuration register (OTG_FS_GUSBCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gusbcfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gusbcfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gusbcfg`] module"]
#[doc (alias = "FS_GUSBCFG")] pub type FsGusbcfg = crate :: Reg < fs_gusbcfg :: FsGusbcfgSpec > ;
#[doc = "OTG_FS USB configuration register (OTG_FS_GUSBCFG)"] pub mod fs_gusbcfg {
#[doc = "Register `FS_GUSBCFG` reader"] pub type R = crate :: R < FsGusbcfgSpec > ;
#[doc = "Register `FS_GUSBCFG` writer"] pub type W = crate :: W < FsGusbcfgSpec > ;
#[doc = "Field `TOCAL` reader - FS timeout calibration"] pub type TocalR = crate :: FieldReader ;
#[doc = "Field `TOCAL` writer - FS timeout calibration"] pub type TocalW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PHYSEL` writer - Full Speed serial transceiver select"] pub type PhyselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRPCAP` reader - SRP-capable"] pub type SrpcapR = crate :: BitReader ;
#[doc = "Field `SRPCAP` writer - SRP-capable"] pub type SrpcapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HNPCAP` reader - HNP-capable"] pub type HnpcapR = crate :: BitReader ;
#[doc = "Field `HNPCAP` writer - HNP-capable"] pub type HnpcapW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRDT` reader - USB turnaround time"] pub type TrdtR = crate :: FieldReader ;
#[doc = "Field `TRDT` writer - USB turnaround time"] pub type TrdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `FHMOD` reader - Force host mode"] pub type FhmodR = crate :: BitReader ;
#[doc = "Field `FHMOD` writer - Force host mode"] pub type FhmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FDMOD` reader - Force device mode"] pub type FdmodR = crate :: BitReader ;
#[doc = "Field `FDMOD` writer - Force device mode"] pub type FdmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTXPKT` reader - Corrupt Tx packet"] pub type CtxpktR = crate :: BitReader ;
#[doc = "Field `CTXPKT` writer - Corrupt Tx packet"] pub type CtxpktW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - FS timeout calibration"]
#[inline (always)] pub fn tocal (& self) -> TocalR { TocalR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 8 - SRP-capable"]
#[inline (always)] pub fn srpcap (& self) -> SrpcapR { SrpcapR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - HNP-capable"]
#[inline (always)] pub fn hnpcap (& self) -> HnpcapR { HnpcapR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bits 10:13 - USB turnaround time"]
#[inline (always)] pub fn trdt (& self) -> TrdtR { TrdtR :: new (((self . bits >> 10) & 0x0f) as u8) }
#[doc = "Bit 29 - Force host mode"]
#[inline (always)] pub fn fhmod (& self) -> FhmodR { FhmodR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Force device mode"]
#[inline (always)] pub fn fdmod (& self) -> FdmodR { FdmodR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Corrupt Tx packet"]
#[inline (always)] pub fn ctxpkt (& self) -> CtxpktR { CtxpktR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - FS timeout calibration"]
#[inline (always)] pub fn tocal (& mut self) -> TocalW < '_ , FsGusbcfgSpec > { TocalW :: new (self , 0) }
#[doc = "Bit 6 - Full Speed serial transceiver select"]
#[inline (always)] pub fn physel (& mut self) -> PhyselW < '_ , FsGusbcfgSpec > { PhyselW :: new (self , 6) }
#[doc = "Bit 8 - SRP-capable"]
#[inline (always)] pub fn srpcap (& mut self) -> SrpcapW < '_ , FsGusbcfgSpec > { SrpcapW :: new (self , 8) }
#[doc = "Bit 9 - HNP-capable"]
#[inline (always)] pub fn hnpcap (& mut self) -> HnpcapW < '_ , FsGusbcfgSpec > { HnpcapW :: new (self , 9) }
#[doc = "Bits 10:13 - USB turnaround time"]
#[inline (always)] pub fn trdt (& mut self) -> TrdtW < '_ , FsGusbcfgSpec > { TrdtW :: new (self , 10) }
#[doc = "Bit 29 - Force host mode"]
#[inline (always)] pub fn fhmod (& mut self) -> FhmodW < '_ , FsGusbcfgSpec > { FhmodW :: new (self , 29) }
#[doc = "Bit 30 - Force device mode"]
#[inline (always)] pub fn fdmod (& mut self) -> FdmodW < '_ , FsGusbcfgSpec > { FdmodW :: new (self , 30) }
#[doc = "Bit 31 - Corrupt Tx packet"]
#[inline (always)] pub fn ctxpkt (& mut self) -> CtxpktW < '_ , FsGusbcfgSpec > { CtxpktW :: new (self , 31) } }
#[doc = "OTG_FS USB configuration register (OTG_FS_GUSBCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gusbcfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gusbcfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGusbcfgSpec ; impl crate :: RegisterSpec for FsGusbcfgSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gusbcfg::R`](R) reader structure"] impl crate :: Readable for FsGusbcfgSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gusbcfg::W`](W) writer structure"] impl crate :: Writable for FsGusbcfgSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GUSBCFG to value 0x0a00"] impl crate :: Resettable for FsGusbcfgSpec { const RESET_VALUE : u32 = 0x0a00 ; } }
#[doc = "FS_GRSTCTL (rw) register accessor: OTG_FS reset register (OTG_FS_GRSTCTL)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_grstctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_grstctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_grstctl`] module"]
#[doc (alias = "FS_GRSTCTL")] pub type FsGrstctl = crate :: Reg < fs_grstctl :: FsGrstctlSpec > ;
#[doc = "OTG_FS reset register (OTG_FS_GRSTCTL)"] pub mod fs_grstctl {
#[doc = "Register `FS_GRSTCTL` reader"] pub type R = crate :: R < FsGrstctlSpec > ;
#[doc = "Register `FS_GRSTCTL` writer"] pub type W = crate :: W < FsGrstctlSpec > ;
#[doc = "Field `CSRST` reader - Core soft reset"] pub type CsrstR = crate :: BitReader ;
#[doc = "Field `CSRST` writer - Core soft reset"] pub type CsrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSRST` reader - HCLK soft reset"] pub type HsrstR = crate :: BitReader ;
#[doc = "Field `HSRST` writer - HCLK soft reset"] pub type HsrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCRST` reader - Host frame counter reset"] pub type FcrstR = crate :: BitReader ;
#[doc = "Field `FCRST` writer - Host frame counter reset"] pub type FcrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFFLSH` reader - RxFIFO flush"] pub type RxfflshR = crate :: BitReader ;
#[doc = "Field `RXFFLSH` writer - RxFIFO flush"] pub type RxfflshW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFFLSH` reader - TxFIFO flush"] pub type TxfflshR = crate :: BitReader ;
#[doc = "Field `TXFFLSH` writer - TxFIFO flush"] pub type TxfflshW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXFNUM` reader - TxFIFO number"] pub type TxfnumR = crate :: FieldReader ;
#[doc = "Field `TXFNUM` writer - TxFIFO number"] pub type TxfnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `AHBIDL` reader - AHB master idle"] pub type AhbidlR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Core soft reset"]
#[inline (always)] pub fn csrst (& self) -> CsrstR { CsrstR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - HCLK soft reset"]
#[inline (always)] pub fn hsrst (& self) -> HsrstR { HsrstR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Host frame counter reset"]
#[inline (always)] pub fn fcrst (& self) -> FcrstR { FcrstR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - RxFIFO flush"]
#[inline (always)] pub fn rxfflsh (& self) -> RxfflshR { RxfflshR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - TxFIFO flush"]
#[inline (always)] pub fn txfflsh (& self) -> TxfflshR { TxfflshR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bits 6:10 - TxFIFO number"]
#[inline (always)] pub fn txfnum (& self) -> TxfnumR { TxfnumR :: new (((self . bits >> 6) & 0x1f) as u8) }
#[doc = "Bit 31 - AHB master idle"]
#[inline (always)] pub fn ahbidl (& self) -> AhbidlR { AhbidlR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Core soft reset"]
#[inline (always)] pub fn csrst (& mut self) -> CsrstW < '_ , FsGrstctlSpec > { CsrstW :: new (self , 0) }
#[doc = "Bit 1 - HCLK soft reset"]
#[inline (always)] pub fn hsrst (& mut self) -> HsrstW < '_ , FsGrstctlSpec > { HsrstW :: new (self , 1) }
#[doc = "Bit 2 - Host frame counter reset"]
#[inline (always)] pub fn fcrst (& mut self) -> FcrstW < '_ , FsGrstctlSpec > { FcrstW :: new (self , 2) }
#[doc = "Bit 4 - RxFIFO flush"]
#[inline (always)] pub fn rxfflsh (& mut self) -> RxfflshW < '_ , FsGrstctlSpec > { RxfflshW :: new (self , 4) }
#[doc = "Bit 5 - TxFIFO flush"]
#[inline (always)] pub fn txfflsh (& mut self) -> TxfflshW < '_ , FsGrstctlSpec > { TxfflshW :: new (self , 5) }
#[doc = "Bits 6:10 - TxFIFO number"]
#[inline (always)] pub fn txfnum (& mut self) -> TxfnumW < '_ , FsGrstctlSpec > { TxfnumW :: new (self , 6) } }
#[doc = "OTG_FS reset register (OTG_FS_GRSTCTL)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_grstctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_grstctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGrstctlSpec ; impl crate :: RegisterSpec for FsGrstctlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_grstctl::R`](R) reader structure"] impl crate :: Readable for FsGrstctlSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_grstctl::W`](W) writer structure"] impl crate :: Writable for FsGrstctlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GRSTCTL to value 0x2000_0000"] impl crate :: Resettable for FsGrstctlSpec { const RESET_VALUE : u32 = 0x2000_0000 ; } }
#[doc = "FS_GINTSTS (rw) register accessor: OTG_FS core interrupt register (OTG_FS_GINTSTS)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gintsts::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gintsts::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gintsts`] module"]
#[doc (alias = "FS_GINTSTS")] pub type FsGintsts = crate :: Reg < fs_gintsts :: FsGintstsSpec > ;
#[doc = "OTG_FS core interrupt register (OTG_FS_GINTSTS)"] pub mod fs_gintsts {
#[doc = "Register `FS_GINTSTS` reader"] pub type R = crate :: R < FsGintstsSpec > ;
#[doc = "Register `FS_GINTSTS` writer"] pub type W = crate :: W < FsGintstsSpec > ;
#[doc = "Field `CMOD` reader - Current mode of operation"] pub type CmodR = crate :: BitReader ;
#[doc = "Field `MMIS` reader - Mode mismatch interrupt"] pub type MmisR = crate :: BitReader ;
#[doc = "Field `MMIS` writer - Mode mismatch interrupt"] pub type MmisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OTGINT` reader - OTG interrupt"] pub type OtgintR = crate :: BitReader ;
#[doc = "Field `SOF` reader - Start of frame"] pub type SofR = crate :: BitReader ;
#[doc = "Field `SOF` writer - Start of frame"] pub type SofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFLVL` reader - RxFIFO non-empty"] pub type RxflvlR = crate :: BitReader ;
#[doc = "Field `NPTXFE` reader - Non-periodic TxFIFO empty"] pub type NptxfeR = crate :: BitReader ;
#[doc = "Field `GINAKEFF` reader - Global IN non-periodic NAK effective"] pub type GinakeffR = crate :: BitReader ;
#[doc = "Field `GOUTNAKEFF` reader - Global OUT NAK effective"] pub type GoutnakeffR = crate :: BitReader ;
#[doc = "Field `ESUSP` reader - Early suspend"] pub type EsuspR = crate :: BitReader ;
#[doc = "Field `ESUSP` writer - Early suspend"] pub type EsuspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBSUSP` reader - USB suspend"] pub type UsbsuspR = crate :: BitReader ;
#[doc = "Field `USBSUSP` writer - USB suspend"] pub type UsbsuspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBRST` reader - USB reset"] pub type UsbrstR = crate :: BitReader ;
#[doc = "Field `USBRST` writer - USB reset"] pub type UsbrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENUMDNE` reader - Enumeration done"] pub type EnumdneR = crate :: BitReader ;
#[doc = "Field `ENUMDNE` writer - Enumeration done"] pub type EnumdneW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ISOODRP` reader - Isochronous OUT packet dropped interrupt"] pub type IsoodrpR = crate :: BitReader ;
#[doc = "Field `ISOODRP` writer - Isochronous OUT packet dropped interrupt"] pub type IsoodrpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOPF` reader - End of periodic frame interrupt"] pub type EopfR = crate :: BitReader ;
#[doc = "Field `EOPF` writer - End of periodic frame interrupt"] pub type EopfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IEPINT` reader - IN endpoint interrupt"] pub type IepintR = crate :: BitReader ;
#[doc = "Field `OEPINT` reader - OUT endpoint interrupt"] pub type OepintR = crate :: BitReader ;
#[doc = "Field `IISOIXFR` reader - Incomplete isochronous IN transfer"] pub type IisoixfrR = crate :: BitReader ;
#[doc = "Field `IISOIXFR` writer - Incomplete isochronous IN transfer"] pub type IisoixfrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IPXFR_INCOMPISOOUT` reader - Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)"] pub type IpxfrIncompisooutR = crate :: BitReader ;
#[doc = "Field `IPXFR_INCOMPISOOUT` writer - Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)"] pub type IpxfrIncompisooutW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HPRTINT` reader - Host port interrupt"] pub type HprtintR = crate :: BitReader ;
#[doc = "Field `HCINT` reader - Host channels interrupt"] pub type HcintR = crate :: BitReader ;
#[doc = "Field `PTXFE` reader - Periodic TxFIFO empty"] pub type PtxfeR = crate :: BitReader ;
#[doc = "Field `CIDSCHG` reader - Connector ID status change"] pub type CidschgR = crate :: BitReader ;
#[doc = "Field `CIDSCHG` writer - Connector ID status change"] pub type CidschgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISCINT` reader - Disconnect detected interrupt"] pub type DiscintR = crate :: BitReader ;
#[doc = "Field `DISCINT` writer - Disconnect detected interrupt"] pub type DiscintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRQINT` reader - Session request/new session detected interrupt"] pub type SrqintR = crate :: BitReader ;
#[doc = "Field `SRQINT` writer - Session request/new session detected interrupt"] pub type SrqintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WKUPINT` reader - Resume/remote wakeup detected interrupt"] pub type WkupintR = crate :: BitReader ;
#[doc = "Field `WKUPINT` writer - Resume/remote wakeup detected interrupt"] pub type WkupintW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Current mode of operation"]
#[inline (always)] pub fn cmod (& self) -> CmodR { CmodR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Mode mismatch interrupt"]
#[inline (always)] pub fn mmis (& self) -> MmisR { MmisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - OTG interrupt"]
#[inline (always)] pub fn otgint (& self) -> OtgintR { OtgintR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Start of frame"]
#[inline (always)] pub fn sof (& self) -> SofR { SofR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RxFIFO non-empty"]
#[inline (always)] pub fn rxflvl (& self) -> RxflvlR { RxflvlR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Non-periodic TxFIFO empty"]
#[inline (always)] pub fn nptxfe (& self) -> NptxfeR { NptxfeR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Global IN non-periodic NAK effective"]
#[inline (always)] pub fn ginakeff (& self) -> GinakeffR { GinakeffR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Global OUT NAK effective"]
#[inline (always)] pub fn goutnakeff (& self) -> GoutnakeffR { GoutnakeffR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 10 - Early suspend"]
#[inline (always)] pub fn esusp (& self) -> EsuspR { EsuspR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - USB suspend"]
#[inline (always)] pub fn usbsusp (& self) -> UsbsuspR { UsbsuspR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - USB reset"]
#[inline (always)] pub fn usbrst (& self) -> UsbrstR { UsbrstR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Enumeration done"]
#[inline (always)] pub fn enumdne (& self) -> EnumdneR { EnumdneR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Isochronous OUT packet dropped interrupt"]
#[inline (always)] pub fn isoodrp (& self) -> IsoodrpR { IsoodrpR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - End of periodic frame interrupt"]
#[inline (always)] pub fn eopf (& self) -> EopfR { EopfR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 18 - IN endpoint interrupt"]
#[inline (always)] pub fn iepint (& self) -> IepintR { IepintR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - OUT endpoint interrupt"]
#[inline (always)] pub fn oepint (& self) -> OepintR { OepintR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Incomplete isochronous IN transfer"]
#[inline (always)] pub fn iisoixfr (& self) -> IisoixfrR { IisoixfrR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)"]
#[inline (always)] pub fn ipxfr_incompisoout (& self) -> IpxfrIncompisooutR { IpxfrIncompisooutR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 24 - Host port interrupt"]
#[inline (always)] pub fn hprtint (& self) -> HprtintR { HprtintR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Host channels interrupt"]
#[inline (always)] pub fn hcint (& self) -> HcintR { HcintR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Periodic TxFIFO empty"]
#[inline (always)] pub fn ptxfe (& self) -> PtxfeR { PtxfeR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 28 - Connector ID status change"]
#[inline (always)] pub fn cidschg (& self) -> CidschgR { CidschgR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Disconnect detected interrupt"]
#[inline (always)] pub fn discint (& self) -> DiscintR { DiscintR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Session request/new session detected interrupt"]
#[inline (always)] pub fn srqint (& self) -> SrqintR { SrqintR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Resume/remote wakeup detected interrupt"]
#[inline (always)] pub fn wkupint (& self) -> WkupintR { WkupintR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 1 - Mode mismatch interrupt"]
#[inline (always)] pub fn mmis (& mut self) -> MmisW < '_ , FsGintstsSpec > { MmisW :: new (self , 1) }
#[doc = "Bit 3 - Start of frame"]
#[inline (always)] pub fn sof (& mut self) -> SofW < '_ , FsGintstsSpec > { SofW :: new (self , 3) }
#[doc = "Bit 10 - Early suspend"]
#[inline (always)] pub fn esusp (& mut self) -> EsuspW < '_ , FsGintstsSpec > { EsuspW :: new (self , 10) }
#[doc = "Bit 11 - USB suspend"]
#[inline (always)] pub fn usbsusp (& mut self) -> UsbsuspW < '_ , FsGintstsSpec > { UsbsuspW :: new (self , 11) }
#[doc = "Bit 12 - USB reset"]
#[inline (always)] pub fn usbrst (& mut self) -> UsbrstW < '_ , FsGintstsSpec > { UsbrstW :: new (self , 12) }
#[doc = "Bit 13 - Enumeration done"]
#[inline (always)] pub fn enumdne (& mut self) -> EnumdneW < '_ , FsGintstsSpec > { EnumdneW :: new (self , 13) }
#[doc = "Bit 14 - Isochronous OUT packet dropped interrupt"]
#[inline (always)] pub fn isoodrp (& mut self) -> IsoodrpW < '_ , FsGintstsSpec > { IsoodrpW :: new (self , 14) }
#[doc = "Bit 15 - End of periodic frame interrupt"]
#[inline (always)] pub fn eopf (& mut self) -> EopfW < '_ , FsGintstsSpec > { EopfW :: new (self , 15) }
#[doc = "Bit 20 - Incomplete isochronous IN transfer"]
#[inline (always)] pub fn iisoixfr (& mut self) -> IisoixfrW < '_ , FsGintstsSpec > { IisoixfrW :: new (self , 20) }
#[doc = "Bit 21 - Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)"]
#[inline (always)] pub fn ipxfr_incompisoout (& mut self) -> IpxfrIncompisooutW < '_ , FsGintstsSpec > { IpxfrIncompisooutW :: new (self , 21) }
#[doc = "Bit 28 - Connector ID status change"]
#[inline (always)] pub fn cidschg (& mut self) -> CidschgW < '_ , FsGintstsSpec > { CidschgW :: new (self , 28) }
#[doc = "Bit 29 - Disconnect detected interrupt"]
#[inline (always)] pub fn discint (& mut self) -> DiscintW < '_ , FsGintstsSpec > { DiscintW :: new (self , 29) }
#[doc = "Bit 30 - Session request/new session detected interrupt"]
#[inline (always)] pub fn srqint (& mut self) -> SrqintW < '_ , FsGintstsSpec > { SrqintW :: new (self , 30) }
#[doc = "Bit 31 - Resume/remote wakeup detected interrupt"]
#[inline (always)] pub fn wkupint (& mut self) -> WkupintW < '_ , FsGintstsSpec > { WkupintW :: new (self , 31) } }
#[doc = "OTG_FS core interrupt register (OTG_FS_GINTSTS)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gintsts::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gintsts::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGintstsSpec ; impl crate :: RegisterSpec for FsGintstsSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gintsts::R`](R) reader structure"] impl crate :: Readable for FsGintstsSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gintsts::W`](W) writer structure"] impl crate :: Writable for FsGintstsSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GINTSTS to value 0x0400_0020"] impl crate :: Resettable for FsGintstsSpec { const RESET_VALUE : u32 = 0x0400_0020 ; } }
#[doc = "FS_GINTMSK (rw) register accessor: OTG_FS interrupt mask register (OTG_FS_GINTMSK)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gintmsk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gintmsk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gintmsk`] module"]
#[doc (alias = "FS_GINTMSK")] pub type FsGintmsk = crate :: Reg < fs_gintmsk :: FsGintmskSpec > ;
#[doc = "OTG_FS interrupt mask register (OTG_FS_GINTMSK)"] pub mod fs_gintmsk {
#[doc = "Register `FS_GINTMSK` reader"] pub type R = crate :: R < FsGintmskSpec > ;
#[doc = "Register `FS_GINTMSK` writer"] pub type W = crate :: W < FsGintmskSpec > ;
#[doc = "Field `MMISM` reader - Mode mismatch interrupt mask"] pub type MmismR = crate :: BitReader ;
#[doc = "Field `MMISM` writer - Mode mismatch interrupt mask"] pub type MmismW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OTGINT` reader - OTG interrupt mask"] pub type OtgintR = crate :: BitReader ;
#[doc = "Field `OTGINT` writer - OTG interrupt mask"] pub type OtgintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SOFM` reader - Start of frame mask"] pub type SofmR = crate :: BitReader ;
#[doc = "Field `SOFM` writer - Start of frame mask"] pub type SofmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFLVLM` reader - Receive FIFO non-empty mask"] pub type RxflvlmR = crate :: BitReader ;
#[doc = "Field `RXFLVLM` writer - Receive FIFO non-empty mask"] pub type RxflvlmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NPTXFEM` reader - Non-periodic TxFIFO empty mask"] pub type NptxfemR = crate :: BitReader ;
#[doc = "Field `NPTXFEM` writer - Non-periodic TxFIFO empty mask"] pub type NptxfemW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GINAKEFFM` reader - Global non-periodic IN NAK effective mask"] pub type GinakeffmR = crate :: BitReader ;
#[doc = "Field `GINAKEFFM` writer - Global non-periodic IN NAK effective mask"] pub type GinakeffmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GONAKEFFM` reader - Global OUT NAK effective mask"] pub type GonakeffmR = crate :: BitReader ;
#[doc = "Field `GONAKEFFM` writer - Global OUT NAK effective mask"] pub type GonakeffmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ESUSPM` reader - Early suspend mask"] pub type EsuspmR = crate :: BitReader ;
#[doc = "Field `ESUSPM` writer - Early suspend mask"] pub type EsuspmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBSUSPM` reader - USB suspend mask"] pub type UsbsuspmR = crate :: BitReader ;
#[doc = "Field `USBSUSPM` writer - USB suspend mask"] pub type UsbsuspmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `USBRST` reader - USB reset mask"] pub type UsbrstR = crate :: BitReader ;
#[doc = "Field `USBRST` writer - USB reset mask"] pub type UsbrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENUMDNEM` reader - Enumeration done mask"] pub type EnumdnemR = crate :: BitReader ;
#[doc = "Field `ENUMDNEM` writer - Enumeration done mask"] pub type EnumdnemW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ISOODRPM` reader - Isochronous OUT packet dropped interrupt mask"] pub type IsoodrpmR = crate :: BitReader ;
#[doc = "Field `ISOODRPM` writer - Isochronous OUT packet dropped interrupt mask"] pub type IsoodrpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOPFM` reader - End of periodic frame interrupt mask"] pub type EopfmR = crate :: BitReader ;
#[doc = "Field `EOPFM` writer - End of periodic frame interrupt mask"] pub type EopfmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPMISM` reader - Endpoint mismatch interrupt mask"] pub type EpmismR = crate :: BitReader ;
#[doc = "Field `EPMISM` writer - Endpoint mismatch interrupt mask"] pub type EpmismW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IEPINT` reader - IN endpoints interrupt mask"] pub type IepintR = crate :: BitReader ;
#[doc = "Field `IEPINT` writer - IN endpoints interrupt mask"] pub type IepintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OEPINT` reader - OUT endpoints interrupt mask"] pub type OepintR = crate :: BitReader ;
#[doc = "Field `OEPINT` writer - OUT endpoints interrupt mask"] pub type OepintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IISOIXFRM` reader - Incomplete isochronous IN transfer mask"] pub type IisoixfrmR = crate :: BitReader ;
#[doc = "Field `IISOIXFRM` writer - Incomplete isochronous IN transfer mask"] pub type IisoixfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IPXFRM_IISOOXFRM` reader - Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)"] pub type IpxfrmIisooxfrmR = crate :: BitReader ;
#[doc = "Field `IPXFRM_IISOOXFRM` writer - Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)"] pub type IpxfrmIisooxfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PRTIM` reader - Host port interrupt mask"] pub type PrtimR = crate :: BitReader ;
#[doc = "Field `HCIM` reader - Host channels interrupt mask"] pub type HcimR = crate :: BitReader ;
#[doc = "Field `HCIM` writer - Host channels interrupt mask"] pub type HcimW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PTXFEM` reader - Periodic TxFIFO empty mask"] pub type PtxfemR = crate :: BitReader ;
#[doc = "Field `PTXFEM` writer - Periodic TxFIFO empty mask"] pub type PtxfemW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIDSCHGM` reader - Connector ID status change mask"] pub type CidschgmR = crate :: BitReader ;
#[doc = "Field `CIDSCHGM` writer - Connector ID status change mask"] pub type CidschgmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISCINT` reader - Disconnect detected interrupt mask"] pub type DiscintR = crate :: BitReader ;
#[doc = "Field `DISCINT` writer - Disconnect detected interrupt mask"] pub type DiscintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRQIM` reader - Session request/new session detected interrupt mask"] pub type SrqimR = crate :: BitReader ;
#[doc = "Field `SRQIM` writer - Session request/new session detected interrupt mask"] pub type SrqimW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WUIM` reader - Resume/remote wakeup detected interrupt mask"] pub type WuimR = crate :: BitReader ;
#[doc = "Field `WUIM` writer - Resume/remote wakeup detected interrupt mask"] pub type WuimW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 1 - Mode mismatch interrupt mask"]
#[inline (always)] pub fn mmism (& self) -> MmismR { MmismR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - OTG interrupt mask"]
#[inline (always)] pub fn otgint (& self) -> OtgintR { OtgintR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Start of frame mask"]
#[inline (always)] pub fn sofm (& self) -> SofmR { SofmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Receive FIFO non-empty mask"]
#[inline (always)] pub fn rxflvlm (& self) -> RxflvlmR { RxflvlmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Non-periodic TxFIFO empty mask"]
#[inline (always)] pub fn nptxfem (& self) -> NptxfemR { NptxfemR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Global non-periodic IN NAK effective mask"]
#[inline (always)] pub fn ginakeffm (& self) -> GinakeffmR { GinakeffmR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Global OUT NAK effective mask"]
#[inline (always)] pub fn gonakeffm (& self) -> GonakeffmR { GonakeffmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 10 - Early suspend mask"]
#[inline (always)] pub fn esuspm (& self) -> EsuspmR { EsuspmR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - USB suspend mask"]
#[inline (always)] pub fn usbsuspm (& self) -> UsbsuspmR { UsbsuspmR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - USB reset mask"]
#[inline (always)] pub fn usbrst (& self) -> UsbrstR { UsbrstR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Enumeration done mask"]
#[inline (always)] pub fn enumdnem (& self) -> EnumdnemR { EnumdnemR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Isochronous OUT packet dropped interrupt mask"]
#[inline (always)] pub fn isoodrpm (& self) -> IsoodrpmR { IsoodrpmR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - End of periodic frame interrupt mask"]
#[inline (always)] pub fn eopfm (& self) -> EopfmR { EopfmR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Endpoint mismatch interrupt mask"]
#[inline (always)] pub fn epmism (& self) -> EpmismR { EpmismR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - IN endpoints interrupt mask"]
#[inline (always)] pub fn iepint (& self) -> IepintR { IepintR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - OUT endpoints interrupt mask"]
#[inline (always)] pub fn oepint (& self) -> OepintR { OepintR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - Incomplete isochronous IN transfer mask"]
#[inline (always)] pub fn iisoixfrm (& self) -> IisoixfrmR { IisoixfrmR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)"]
#[inline (always)] pub fn ipxfrm_iisooxfrm (& self) -> IpxfrmIisooxfrmR { IpxfrmIisooxfrmR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 24 - Host port interrupt mask"]
#[inline (always)] pub fn prtim (& self) -> PrtimR { PrtimR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Host channels interrupt mask"]
#[inline (always)] pub fn hcim (& self) -> HcimR { HcimR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - Periodic TxFIFO empty mask"]
#[inline (always)] pub fn ptxfem (& self) -> PtxfemR { PtxfemR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 28 - Connector ID status change mask"]
#[inline (always)] pub fn cidschgm (& self) -> CidschgmR { CidschgmR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Disconnect detected interrupt mask"]
#[inline (always)] pub fn discint (& self) -> DiscintR { DiscintR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Session request/new session detected interrupt mask"]
#[inline (always)] pub fn srqim (& self) -> SrqimR { SrqimR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Resume/remote wakeup detected interrupt mask"]
#[inline (always)] pub fn wuim (& self) -> WuimR { WuimR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 1 - Mode mismatch interrupt mask"]
#[inline (always)] pub fn mmism (& mut self) -> MmismW < '_ , FsGintmskSpec > { MmismW :: new (self , 1) }
#[doc = "Bit 2 - OTG interrupt mask"]
#[inline (always)] pub fn otgint (& mut self) -> OtgintW < '_ , FsGintmskSpec > { OtgintW :: new (self , 2) }
#[doc = "Bit 3 - Start of frame mask"]
#[inline (always)] pub fn sofm (& mut self) -> SofmW < '_ , FsGintmskSpec > { SofmW :: new (self , 3) }
#[doc = "Bit 4 - Receive FIFO non-empty mask"]
#[inline (always)] pub fn rxflvlm (& mut self) -> RxflvlmW < '_ , FsGintmskSpec > { RxflvlmW :: new (self , 4) }
#[doc = "Bit 5 - Non-periodic TxFIFO empty mask"]
#[inline (always)] pub fn nptxfem (& mut self) -> NptxfemW < '_ , FsGintmskSpec > { NptxfemW :: new (self , 5) }
#[doc = "Bit 6 - Global non-periodic IN NAK effective mask"]
#[inline (always)] pub fn ginakeffm (& mut self) -> GinakeffmW < '_ , FsGintmskSpec > { GinakeffmW :: new (self , 6) }
#[doc = "Bit 7 - Global OUT NAK effective mask"]
#[inline (always)] pub fn gonakeffm (& mut self) -> GonakeffmW < '_ , FsGintmskSpec > { GonakeffmW :: new (self , 7) }
#[doc = "Bit 10 - Early suspend mask"]
#[inline (always)] pub fn esuspm (& mut self) -> EsuspmW < '_ , FsGintmskSpec > { EsuspmW :: new (self , 10) }
#[doc = "Bit 11 - USB suspend mask"]
#[inline (always)] pub fn usbsuspm (& mut self) -> UsbsuspmW < '_ , FsGintmskSpec > { UsbsuspmW :: new (self , 11) }
#[doc = "Bit 12 - USB reset mask"]
#[inline (always)] pub fn usbrst (& mut self) -> UsbrstW < '_ , FsGintmskSpec > { UsbrstW :: new (self , 12) }
#[doc = "Bit 13 - Enumeration done mask"]
#[inline (always)] pub fn enumdnem (& mut self) -> EnumdnemW < '_ , FsGintmskSpec > { EnumdnemW :: new (self , 13) }
#[doc = "Bit 14 - Isochronous OUT packet dropped interrupt mask"]
#[inline (always)] pub fn isoodrpm (& mut self) -> IsoodrpmW < '_ , FsGintmskSpec > { IsoodrpmW :: new (self , 14) }
#[doc = "Bit 15 - End of periodic frame interrupt mask"]
#[inline (always)] pub fn eopfm (& mut self) -> EopfmW < '_ , FsGintmskSpec > { EopfmW :: new (self , 15) }
#[doc = "Bit 17 - Endpoint mismatch interrupt mask"]
#[inline (always)] pub fn epmism (& mut self) -> EpmismW < '_ , FsGintmskSpec > { EpmismW :: new (self , 17) }
#[doc = "Bit 18 - IN endpoints interrupt mask"]
#[inline (always)] pub fn iepint (& mut self) -> IepintW < '_ , FsGintmskSpec > { IepintW :: new (self , 18) }
#[doc = "Bit 19 - OUT endpoints interrupt mask"]
#[inline (always)] pub fn oepint (& mut self) -> OepintW < '_ , FsGintmskSpec > { OepintW :: new (self , 19) }
#[doc = "Bit 20 - Incomplete isochronous IN transfer mask"]
#[inline (always)] pub fn iisoixfrm (& mut self) -> IisoixfrmW < '_ , FsGintmskSpec > { IisoixfrmW :: new (self , 20) }
#[doc = "Bit 21 - Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)"]
#[inline (always)] pub fn ipxfrm_iisooxfrm (& mut self) -> IpxfrmIisooxfrmW < '_ , FsGintmskSpec > { IpxfrmIisooxfrmW :: new (self , 21) }
#[doc = "Bit 25 - Host channels interrupt mask"]
#[inline (always)] pub fn hcim (& mut self) -> HcimW < '_ , FsGintmskSpec > { HcimW :: new (self , 25) }
#[doc = "Bit 26 - Periodic TxFIFO empty mask"]
#[inline (always)] pub fn ptxfem (& mut self) -> PtxfemW < '_ , FsGintmskSpec > { PtxfemW :: new (self , 26) }
#[doc = "Bit 28 - Connector ID status change mask"]
#[inline (always)] pub fn cidschgm (& mut self) -> CidschgmW < '_ , FsGintmskSpec > { CidschgmW :: new (self , 28) }
#[doc = "Bit 29 - Disconnect detected interrupt mask"]
#[inline (always)] pub fn discint (& mut self) -> DiscintW < '_ , FsGintmskSpec > { DiscintW :: new (self , 29) }
#[doc = "Bit 30 - Session request/new session detected interrupt mask"]
#[inline (always)] pub fn srqim (& mut self) -> SrqimW < '_ , FsGintmskSpec > { SrqimW :: new (self , 30) }
#[doc = "Bit 31 - Resume/remote wakeup detected interrupt mask"]
#[inline (always)] pub fn wuim (& mut self) -> WuimW < '_ , FsGintmskSpec > { WuimW :: new (self , 31) } }
#[doc = "OTG_FS interrupt mask register (OTG_FS_GINTMSK)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gintmsk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gintmsk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGintmskSpec ; impl crate :: RegisterSpec for FsGintmskSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gintmsk::R`](R) reader structure"] impl crate :: Readable for FsGintmskSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gintmsk::W`](W) writer structure"] impl crate :: Writable for FsGintmskSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GINTMSK to value 0"] impl crate :: Resettable for FsGintmskSpec { } }
#[doc = "FS_GRXSTSR_Device (r) register accessor: OTG_FS Receive status debug read(Device mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_grxstsr_device::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_grxstsr_device`] module"]
#[doc (alias = "FS_GRXSTSR_Device")] pub type FsGrxstsrDevice = crate :: Reg < fs_grxstsr_device :: FsGrxstsrDeviceSpec > ;
#[doc = "OTG_FS Receive status debug read(Device mode)"] pub mod fs_grxstsr_device {
#[doc = "Register `FS_GRXSTSR_Device` reader"] pub type R = crate :: R < FsGrxstsrDeviceSpec > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `BCNT` reader - Byte count"] pub type BcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `PKTSTS` reader - Packet status"] pub type PktstsR = crate :: FieldReader ;
#[doc = "Field `FRMNUM` reader - Frame number"] pub type FrmnumR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:14 - Byte count"]
#[inline (always)] pub fn bcnt (& self) -> BcntR { BcntR :: new (((self . bits >> 4) & 0x07ff) as u16) }
#[doc = "Bits 15:16 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 15) & 3) as u8) }
#[doc = "Bits 17:20 - Packet status"]
#[inline (always)] pub fn pktsts (& self) -> PktstsR { PktstsR :: new (((self . bits >> 17) & 0x0f) as u8) }
#[doc = "Bits 21:24 - Frame number"]
#[inline (always)] pub fn frmnum (& self) -> FrmnumR { FrmnumR :: new (((self . bits >> 21) & 0x0f) as u8) } }
#[doc = "OTG_FS Receive status debug read(Device mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_grxstsr_device::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGrxstsrDeviceSpec ; impl crate :: RegisterSpec for FsGrxstsrDeviceSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_grxstsr_device::R`](R) reader structure"] impl crate :: Readable for FsGrxstsrDeviceSpec { }
#[doc = "`reset()` method sets FS_GRXSTSR_Device to value 0"] impl crate :: Resettable for FsGrxstsrDeviceSpec { } }
#[doc = "FS_GRXSTSR_Host (r) register accessor: OTG_FS Receive status debug read(Host mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_grxstsr_host::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_grxstsr_host`] module"]
#[doc (alias = "FS_GRXSTSR_Host")] pub type FsGrxstsrHost = crate :: Reg < fs_grxstsr_host :: FsGrxstsrHostSpec > ;
#[doc = "OTG_FS Receive status debug read(Host mode)"] pub mod fs_grxstsr_host {
#[doc = "Register `FS_GRXSTSR_Host` reader"] pub type R = crate :: R < FsGrxstsrHostSpec > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `BCNT` reader - Byte count"] pub type BcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `PKTSTS` reader - Packet status"] pub type PktstsR = crate :: FieldReader ;
#[doc = "Field `FRMNUM` reader - Frame number"] pub type FrmnumR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:14 - Byte count"]
#[inline (always)] pub fn bcnt (& self) -> BcntR { BcntR :: new (((self . bits >> 4) & 0x07ff) as u16) }
#[doc = "Bits 15:16 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 15) & 3) as u8) }
#[doc = "Bits 17:20 - Packet status"]
#[inline (always)] pub fn pktsts (& self) -> PktstsR { PktstsR :: new (((self . bits >> 17) & 0x0f) as u8) }
#[doc = "Bits 21:24 - Frame number"]
#[inline (always)] pub fn frmnum (& self) -> FrmnumR { FrmnumR :: new (((self . bits >> 21) & 0x0f) as u8) } }
#[doc = "OTG_FS Receive status debug read(Host mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_grxstsr_host::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGrxstsrHostSpec ; impl crate :: RegisterSpec for FsGrxstsrHostSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_grxstsr_host::R`](R) reader structure"] impl crate :: Readable for FsGrxstsrHostSpec { }
#[doc = "`reset()` method sets FS_GRXSTSR_Host to value 0"] impl crate :: Resettable for FsGrxstsrHostSpec { } }
#[doc = "FS_GRXFSIZ (rw) register accessor: OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_grxfsiz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_grxfsiz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_grxfsiz`] module"]
#[doc (alias = "FS_GRXFSIZ")] pub type FsGrxfsiz = crate :: Reg < fs_grxfsiz :: FsGrxfsizSpec > ;
#[doc = "OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)"] pub mod fs_grxfsiz {
#[doc = "Register `FS_GRXFSIZ` reader"] pub type R = crate :: R < FsGrxfsizSpec > ;
#[doc = "Register `FS_GRXFSIZ` writer"] pub type W = crate :: W < FsGrxfsizSpec > ;
#[doc = "Field `RXFD` reader - RxFIFO depth"] pub type RxfdR = crate :: FieldReader < u16 > ;
#[doc = "Field `RXFD` writer - RxFIFO depth"] pub type RxfdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RxFIFO depth"]
#[inline (always)] pub fn rxfd (& self) -> RxfdR { RxfdR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - RxFIFO depth"]
#[inline (always)] pub fn rxfd (& mut self) -> RxfdW < '_ , FsGrxfsizSpec > { RxfdW :: new (self , 0) } }
#[doc = "OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_grxfsiz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_grxfsiz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGrxfsizSpec ; impl crate :: RegisterSpec for FsGrxfsizSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_grxfsiz::R`](R) reader structure"] impl crate :: Readable for FsGrxfsizSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_grxfsiz::W`](W) writer structure"] impl crate :: Writable for FsGrxfsizSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GRXFSIZ to value 0x0200"] impl crate :: Resettable for FsGrxfsizSpec { const RESET_VALUE : u32 = 0x0200 ; } }
#[doc = "FS_GNPTXFSIZ_Device (rw) register accessor: OTG_FS non-periodic transmit FIFO size register (Device mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gnptxfsiz_device::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gnptxfsiz_device::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gnptxfsiz_device`] module"]
#[doc (alias = "FS_GNPTXFSIZ_Device")] pub type FsGnptxfsizDevice = crate :: Reg < fs_gnptxfsiz_device :: FsGnptxfsizDeviceSpec > ;
#[doc = "OTG_FS non-periodic transmit FIFO size register (Device mode)"] pub mod fs_gnptxfsiz_device {
#[doc = "Register `FS_GNPTXFSIZ_Device` reader"] pub type R = crate :: R < FsGnptxfsizDeviceSpec > ;
#[doc = "Register `FS_GNPTXFSIZ_Device` writer"] pub type W = crate :: W < FsGnptxfsizDeviceSpec > ;
#[doc = "Field `TX0FSA` reader - Endpoint 0 transmit RAM start address"] pub type Tx0fsaR = crate :: FieldReader < u16 > ;
#[doc = "Field `TX0FSA` writer - Endpoint 0 transmit RAM start address"] pub type Tx0fsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `TX0FD` reader - Endpoint 0 TxFIFO depth"] pub type Tx0fdR = crate :: FieldReader < u16 > ;
#[doc = "Field `TX0FD` writer - Endpoint 0 TxFIFO depth"] pub type Tx0fdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Endpoint 0 transmit RAM start address"]
#[inline (always)] pub fn tx0fsa (& self) -> Tx0fsaR { Tx0fsaR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - Endpoint 0 TxFIFO depth"]
#[inline (always)] pub fn tx0fd (& self) -> Tx0fdR { Tx0fdR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Endpoint 0 transmit RAM start address"]
#[inline (always)] pub fn tx0fsa (& mut self) -> Tx0fsaW < '_ , FsGnptxfsizDeviceSpec > { Tx0fsaW :: new (self , 0) }
#[doc = "Bits 16:31 - Endpoint 0 TxFIFO depth"]
#[inline (always)] pub fn tx0fd (& mut self) -> Tx0fdW < '_ , FsGnptxfsizDeviceSpec > { Tx0fdW :: new (self , 16) } }
#[doc = "OTG_FS non-periodic transmit FIFO size register (Device mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gnptxfsiz_device::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gnptxfsiz_device::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGnptxfsizDeviceSpec ; impl crate :: RegisterSpec for FsGnptxfsizDeviceSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gnptxfsiz_device::R`](R) reader structure"] impl crate :: Readable for FsGnptxfsizDeviceSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gnptxfsiz_device::W`](W) writer structure"] impl crate :: Writable for FsGnptxfsizDeviceSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GNPTXFSIZ_Device to value 0x0200"] impl crate :: Resettable for FsGnptxfsizDeviceSpec { const RESET_VALUE : u32 = 0x0200 ; } }
#[doc = "FS_GNPTXFSIZ_Host (rw) register accessor: OTG_FS non-periodic transmit FIFO size register (Host mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gnptxfsiz_host::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gnptxfsiz_host::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gnptxfsiz_host`] module"]
#[doc (alias = "FS_GNPTXFSIZ_Host")] pub type FsGnptxfsizHost = crate :: Reg < fs_gnptxfsiz_host :: FsGnptxfsizHostSpec > ;
#[doc = "OTG_FS non-periodic transmit FIFO size register (Host mode)"] pub mod fs_gnptxfsiz_host {
#[doc = "Register `FS_GNPTXFSIZ_Host` reader"] pub type R = crate :: R < FsGnptxfsizHostSpec > ;
#[doc = "Register `FS_GNPTXFSIZ_Host` writer"] pub type W = crate :: W < FsGnptxfsizHostSpec > ;
#[doc = "Field `NPTXFSA` reader - Non-periodic transmit RAM start address"] pub type NptxfsaR = crate :: FieldReader < u16 > ;
#[doc = "Field `NPTXFSA` writer - Non-periodic transmit RAM start address"] pub type NptxfsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `NPTXFD` reader - Non-periodic TxFIFO depth"] pub type NptxfdR = crate :: FieldReader < u16 > ;
#[doc = "Field `NPTXFD` writer - Non-periodic TxFIFO depth"] pub type NptxfdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Non-periodic transmit RAM start address"]
#[inline (always)] pub fn nptxfsa (& self) -> NptxfsaR { NptxfsaR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - Non-periodic TxFIFO depth"]
#[inline (always)] pub fn nptxfd (& self) -> NptxfdR { NptxfdR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Non-periodic transmit RAM start address"]
#[inline (always)] pub fn nptxfsa (& mut self) -> NptxfsaW < '_ , FsGnptxfsizHostSpec > { NptxfsaW :: new (self , 0) }
#[doc = "Bits 16:31 - Non-periodic TxFIFO depth"]
#[inline (always)] pub fn nptxfd (& mut self) -> NptxfdW < '_ , FsGnptxfsizHostSpec > { NptxfdW :: new (self , 16) } }
#[doc = "OTG_FS non-periodic transmit FIFO size register (Host mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gnptxfsiz_host::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gnptxfsiz_host::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGnptxfsizHostSpec ; impl crate :: RegisterSpec for FsGnptxfsizHostSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gnptxfsiz_host::R`](R) reader structure"] impl crate :: Readable for FsGnptxfsizHostSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gnptxfsiz_host::W`](W) writer structure"] impl crate :: Writable for FsGnptxfsizHostSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GNPTXFSIZ_Host to value 0x0200"] impl crate :: Resettable for FsGnptxfsizHostSpec { const RESET_VALUE : u32 = 0x0200 ; } }
#[doc = "FS_GNPTXSTS (r) register accessor: OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gnptxsts::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gnptxsts`] module"]
#[doc (alias = "FS_GNPTXSTS")] pub type FsGnptxsts = crate :: Reg < fs_gnptxsts :: FsGnptxstsSpec > ;
#[doc = "OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)"] pub mod fs_gnptxsts {
#[doc = "Register `FS_GNPTXSTS` reader"] pub type R = crate :: R < FsGnptxstsSpec > ;
#[doc = "Field `NPTXFSAV` reader - Non-periodic TxFIFO space available"] pub type NptxfsavR = crate :: FieldReader < u16 > ;
#[doc = "Field `NPTQXSAV` reader - Non-periodic transmit request queue space available"] pub type NptqxsavR = crate :: FieldReader ;
#[doc = "Field `NPTXQTOP` reader - Top of the non-periodic transmit request queue"] pub type NptxqtopR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:15 - Non-periodic TxFIFO space available"]
#[inline (always)] pub fn nptxfsav (& self) -> NptxfsavR { NptxfsavR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:23 - Non-periodic transmit request queue space available"]
#[inline (always)] pub fn nptqxsav (& self) -> NptqxsavR { NptqxsavR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:30 - Top of the non-periodic transmit request queue"]
#[inline (always)] pub fn nptxqtop (& self) -> NptxqtopR { NptxqtopR :: new (((self . bits >> 24) & 0x7f) as u8) } }
#[doc = "OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gnptxsts::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGnptxstsSpec ; impl crate :: RegisterSpec for FsGnptxstsSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gnptxsts::R`](R) reader structure"] impl crate :: Readable for FsGnptxstsSpec { }
#[doc = "`reset()` method sets FS_GNPTXSTS to value 0x0008_0200"] impl crate :: Resettable for FsGnptxstsSpec { const RESET_VALUE : u32 = 0x0008_0200 ; } }
#[doc = "FS_GCCFG (rw) register accessor: OTG_FS general core configuration register (OTG_FS_GCCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gccfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gccfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_gccfg`] module"]
#[doc (alias = "FS_GCCFG")] pub type FsGccfg = crate :: Reg < fs_gccfg :: FsGccfgSpec > ;
#[doc = "OTG_FS general core configuration register (OTG_FS_GCCFG)"] pub mod fs_gccfg {
#[doc = "Register `FS_GCCFG` reader"] pub type R = crate :: R < FsGccfgSpec > ;
#[doc = "Register `FS_GCCFG` writer"] pub type W = crate :: W < FsGccfgSpec > ;
#[doc = "Field `PWRDWN` reader - Power down"] pub type PwrdwnR = crate :: BitReader ;
#[doc = "Field `PWRDWN` writer - Power down"] pub type PwrdwnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VBUSASEN` reader - Enable the VBUS sensing device"] pub type VbusasenR = crate :: BitReader ;
#[doc = "Field `VBUSASEN` writer - Enable the VBUS sensing device"] pub type VbusasenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VBUSBSEN` reader - Enable the VBUS sensing device"] pub type VbusbsenR = crate :: BitReader ;
#[doc = "Field `VBUSBSEN` writer - Enable the VBUS sensing device"] pub type VbusbsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SOFOUTEN` reader - SOF output enable"] pub type SofoutenR = crate :: BitReader ;
#[doc = "Field `SOFOUTEN` writer - SOF output enable"] pub type SofoutenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 16 - Power down"]
#[inline (always)] pub fn pwrdwn (& self) -> PwrdwnR { PwrdwnR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - Enable the VBUS sensing device"]
#[inline (always)] pub fn vbusasen (& self) -> VbusasenR { VbusasenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Enable the VBUS sensing device"]
#[inline (always)] pub fn vbusbsen (& self) -> VbusbsenR { VbusbsenR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - SOF output enable"]
#[inline (always)] pub fn sofouten (& self) -> SofoutenR { SofoutenR :: new (((self . bits >> 20) & 1) != 0) } } impl W {
#[doc = "Bit 16 - Power down"]
#[inline (always)] pub fn pwrdwn (& mut self) -> PwrdwnW < '_ , FsGccfgSpec > { PwrdwnW :: new (self , 16) }
#[doc = "Bit 18 - Enable the VBUS sensing device"]
#[inline (always)] pub fn vbusasen (& mut self) -> VbusasenW < '_ , FsGccfgSpec > { VbusasenW :: new (self , 18) }
#[doc = "Bit 19 - Enable the VBUS sensing device"]
#[inline (always)] pub fn vbusbsen (& mut self) -> VbusbsenW < '_ , FsGccfgSpec > { VbusbsenW :: new (self , 19) }
#[doc = "Bit 20 - SOF output enable"]
#[inline (always)] pub fn sofouten (& mut self) -> SofoutenW < '_ , FsGccfgSpec > { SofoutenW :: new (self , 20) } }
#[doc = "OTG_FS general core configuration register (OTG_FS_GCCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_gccfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_gccfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsGccfgSpec ; impl crate :: RegisterSpec for FsGccfgSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_gccfg::R`](R) reader structure"] impl crate :: Readable for FsGccfgSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_gccfg::W`](W) writer structure"] impl crate :: Writable for FsGccfgSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_GCCFG to value 0"] impl crate :: Resettable for FsGccfgSpec { } }
#[doc = "FS_CID (rw) register accessor: core ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_cid::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_cid::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_cid`] module"]
#[doc (alias = "FS_CID")] pub type FsCid = crate :: Reg < fs_cid :: FsCidSpec > ;
#[doc = "core ID register"] pub mod fs_cid {
#[doc = "Register `FS_CID` reader"] pub type R = crate :: R < FsCidSpec > ;
#[doc = "Register `FS_CID` writer"] pub type W = crate :: W < FsCidSpec > ;
#[doc = "Field `PRODUCT_ID` reader - Product ID field"] pub type ProductIdR = crate :: FieldReader < u32 > ;
#[doc = "Field `PRODUCT_ID` writer - Product ID field"] pub type ProductIdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Product ID field"]
#[inline (always)] pub fn product_id (& self) -> ProductIdR { ProductIdR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Product ID field"]
#[inline (always)] pub fn product_id (& mut self) -> ProductIdW < '_ , FsCidSpec > { ProductIdW :: new (self , 0) } }
#[doc = "core ID register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_cid::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_cid::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsCidSpec ; impl crate :: RegisterSpec for FsCidSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_cid::R`](R) reader structure"] impl crate :: Readable for FsCidSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_cid::W`](W) writer structure"] impl crate :: Writable for FsCidSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_CID to value 0x1000"] impl crate :: Resettable for FsCidSpec { const RESET_VALUE : u32 = 0x1000 ; } }
#[doc = "FS_HPTXFSIZ (rw) register accessor: OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hptxfsiz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hptxfsiz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hptxfsiz`] module"]
#[doc (alias = "FS_HPTXFSIZ")] pub type FsHptxfsiz = crate :: Reg < fs_hptxfsiz :: FsHptxfsizSpec > ;
#[doc = "OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)"] pub mod fs_hptxfsiz {
#[doc = "Register `FS_HPTXFSIZ` reader"] pub type R = crate :: R < FsHptxfsizSpec > ;
#[doc = "Register `FS_HPTXFSIZ` writer"] pub type W = crate :: W < FsHptxfsizSpec > ;
#[doc = "Field `PTXSA` reader - Host periodic TxFIFO start address"] pub type PtxsaR = crate :: FieldReader < u16 > ;
#[doc = "Field `PTXSA` writer - Host periodic TxFIFO start address"] pub type PtxsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `PTXFSIZ` reader - Host periodic TxFIFO depth"] pub type PtxfsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `PTXFSIZ` writer - Host periodic TxFIFO depth"] pub type PtxfsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Host periodic TxFIFO start address"]
#[inline (always)] pub fn ptxsa (& self) -> PtxsaR { PtxsaR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - Host periodic TxFIFO depth"]
#[inline (always)] pub fn ptxfsiz (& self) -> PtxfsizR { PtxfsizR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Host periodic TxFIFO start address"]
#[inline (always)] pub fn ptxsa (& mut self) -> PtxsaW < '_ , FsHptxfsizSpec > { PtxsaW :: new (self , 0) }
#[doc = "Bits 16:31 - Host periodic TxFIFO depth"]
#[inline (always)] pub fn ptxfsiz (& mut self) -> PtxfsizW < '_ , FsHptxfsizSpec > { PtxfsizW :: new (self , 16) } }
#[doc = "OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hptxfsiz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hptxfsiz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHptxfsizSpec ; impl crate :: RegisterSpec for FsHptxfsizSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hptxfsiz::R`](R) reader structure"] impl crate :: Readable for FsHptxfsizSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_hptxfsiz::W`](W) writer structure"] impl crate :: Writable for FsHptxfsizSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HPTXFSIZ to value 0x0200_0600"] impl crate :: Resettable for FsHptxfsizSpec { const RESET_VALUE : u32 = 0x0200_0600 ; } }
#[doc = "FS_DIEPTXF1 (rw) register accessor: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dieptxf1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dieptxf1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_dieptxf1`] module"]
#[doc (alias = "FS_DIEPTXF1")] pub type FsDieptxf1 = crate :: Reg < fs_dieptxf1 :: FsDieptxf1Spec > ;
#[doc = "OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)"] pub mod fs_dieptxf1 {
#[doc = "Register `FS_DIEPTXF1` reader"] pub type R = crate :: R < FsDieptxf1Spec > ;
#[doc = "Register `FS_DIEPTXF1` writer"] pub type W = crate :: W < FsDieptxf1Spec > ;
#[doc = "Field `INEPTXSA` reader - IN endpoint FIFO2 transmit RAM start address"] pub type IneptxsaR = crate :: FieldReader < u16 > ;
#[doc = "Field `INEPTXSA` writer - IN endpoint FIFO2 transmit RAM start address"] pub type IneptxsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"] pub type IneptxfdR = crate :: FieldReader < u16 > ;
#[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"] pub type IneptxfdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - IN endpoint FIFO2 transmit RAM start address"]
#[inline (always)] pub fn ineptxsa (& self) -> IneptxsaR { IneptxsaR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
#[inline (always)] pub fn ineptxfd (& self) -> IneptxfdR { IneptxfdR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - IN endpoint FIFO2 transmit RAM start address"]
#[inline (always)] pub fn ineptxsa (& mut self) -> IneptxsaW < '_ , FsDieptxf1Spec > { IneptxsaW :: new (self , 0) }
#[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
#[inline (always)] pub fn ineptxfd (& mut self) -> IneptxfdW < '_ , FsDieptxf1Spec > { IneptxfdW :: new (self , 16) } }
#[doc = "OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dieptxf1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dieptxf1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDieptxf1Spec ; impl crate :: RegisterSpec for FsDieptxf1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_dieptxf1::R`](R) reader structure"] impl crate :: Readable for FsDieptxf1Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_dieptxf1::W`](W) writer structure"] impl crate :: Writable for FsDieptxf1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DIEPTXF1 to value 0x0200_0400"] impl crate :: Resettable for FsDieptxf1Spec { const RESET_VALUE : u32 = 0x0200_0400 ; } }
#[doc = "FS_DIEPTXF2 (rw) register accessor: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dieptxf2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dieptxf2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_dieptxf2`] module"]
#[doc (alias = "FS_DIEPTXF2")] pub type FsDieptxf2 = crate :: Reg < fs_dieptxf2 :: FsDieptxf2Spec > ;
#[doc = "OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)"] pub mod fs_dieptxf2 {
#[doc = "Register `FS_DIEPTXF2` reader"] pub type R = crate :: R < FsDieptxf2Spec > ;
#[doc = "Register `FS_DIEPTXF2` writer"] pub type W = crate :: W < FsDieptxf2Spec > ;
#[doc = "Field `INEPTXSA` reader - IN endpoint FIFO3 transmit RAM start address"] pub type IneptxsaR = crate :: FieldReader < u16 > ;
#[doc = "Field `INEPTXSA` writer - IN endpoint FIFO3 transmit RAM start address"] pub type IneptxsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"] pub type IneptxfdR = crate :: FieldReader < u16 > ;
#[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"] pub type IneptxfdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - IN endpoint FIFO3 transmit RAM start address"]
#[inline (always)] pub fn ineptxsa (& self) -> IneptxsaR { IneptxsaR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
#[inline (always)] pub fn ineptxfd (& self) -> IneptxfdR { IneptxfdR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - IN endpoint FIFO3 transmit RAM start address"]
#[inline (always)] pub fn ineptxsa (& mut self) -> IneptxsaW < '_ , FsDieptxf2Spec > { IneptxsaW :: new (self , 0) }
#[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
#[inline (always)] pub fn ineptxfd (& mut self) -> IneptxfdW < '_ , FsDieptxf2Spec > { IneptxfdW :: new (self , 16) } }
#[doc = "OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dieptxf2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dieptxf2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDieptxf2Spec ; impl crate :: RegisterSpec for FsDieptxf2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_dieptxf2::R`](R) reader structure"] impl crate :: Readable for FsDieptxf2Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_dieptxf2::W`](W) writer structure"] impl crate :: Writable for FsDieptxf2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DIEPTXF2 to value 0x0200_0400"] impl crate :: Resettable for FsDieptxf2Spec { const RESET_VALUE : u32 = 0x0200_0400 ; } }
#[doc = "FS_DIEPTXF3 (rw) register accessor: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dieptxf3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dieptxf3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_dieptxf3`] module"]
#[doc (alias = "FS_DIEPTXF3")] pub type FsDieptxf3 = crate :: Reg < fs_dieptxf3 :: FsDieptxf3Spec > ;
#[doc = "OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)"] pub mod fs_dieptxf3 {
#[doc = "Register `FS_DIEPTXF3` reader"] pub type R = crate :: R < FsDieptxf3Spec > ;
#[doc = "Register `FS_DIEPTXF3` writer"] pub type W = crate :: W < FsDieptxf3Spec > ;
#[doc = "Field `INEPTXSA` reader - IN endpoint FIFO4 transmit RAM start address"] pub type IneptxsaR = crate :: FieldReader < u16 > ;
#[doc = "Field `INEPTXSA` writer - IN endpoint FIFO4 transmit RAM start address"] pub type IneptxsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `INEPTXFD` reader - IN endpoint TxFIFO depth"] pub type IneptxfdR = crate :: FieldReader < u16 > ;
#[doc = "Field `INEPTXFD` writer - IN endpoint TxFIFO depth"] pub type IneptxfdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - IN endpoint FIFO4 transmit RAM start address"]
#[inline (always)] pub fn ineptxsa (& self) -> IneptxsaR { IneptxsaR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
#[inline (always)] pub fn ineptxfd (& self) -> IneptxfdR { IneptxfdR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - IN endpoint FIFO4 transmit RAM start address"]
#[inline (always)] pub fn ineptxsa (& mut self) -> IneptxsaW < '_ , FsDieptxf3Spec > { IneptxsaW :: new (self , 0) }
#[doc = "Bits 16:31 - IN endpoint TxFIFO depth"]
#[inline (always)] pub fn ineptxfd (& mut self) -> IneptxfdW < '_ , FsDieptxf3Spec > { IneptxfdW :: new (self , 16) } }
#[doc = "OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_dieptxf3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_dieptxf3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsDieptxf3Spec ; impl crate :: RegisterSpec for FsDieptxf3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_dieptxf3::R`](R) reader structure"] impl crate :: Readable for FsDieptxf3Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_dieptxf3::W`](W) writer structure"] impl crate :: Writable for FsDieptxf3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_DIEPTXF3 to value 0x0200_0400"] impl crate :: Resettable for FsDieptxf3Spec { const RESET_VALUE : u32 = 0x0200_0400 ; } } }
#[doc = "USB on the go full speed"] pub type OtgFsHost = crate :: Periph < otg_fs_host :: RegisterBlock , 0x5000_0400 > ; impl core :: fmt :: Debug for OtgFsHost { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgFsHost") . finish () } }
#[doc = "USB on the go full speed"] pub mod otg_fs_host {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { fs_hcfg : FsHcfg , hfir : Hfir , fs_hfnum : FsHfnum , _reserved3 : [u8 ; 0x04] , fs_hptxsts : FsHptxsts , haint : Haint , haintmsk : Haintmsk , _reserved6 : [u8 ; 0x24] , fs_hprt : FsHprt , _reserved7 : [u8 ; 0xbc] , fs_hcchar0 : FsHcchar0 , _reserved8 : [u8 ; 0x04] , fs_hcint0 : FsHcint0 , fs_hcintmsk0 : FsHcintmsk0 , fs_hctsiz0 : FsHctsiz0 , _reserved11 : [u8 ; 0x0c] , fs_hcchar1 : FsHcchar1 , _reserved12 : [u8 ; 0x04] , fs_hcint1 : FsHcint1 , fs_hcintmsk1 : FsHcintmsk1 , fs_hctsiz1 : FsHctsiz1 , _reserved15 : [u8 ; 0x0c] , fs_hcchar2 : FsHcchar2 , _reserved16 : [u8 ; 0x04] , fs_hcint2 : FsHcint2 , fs_hcintmsk2 : FsHcintmsk2 , fs_hctsiz2 : FsHctsiz2 , _reserved19 : [u8 ; 0x0c] , fs_hcchar3 : FsHcchar3 , _reserved20 : [u8 ; 0x04] , fs_hcint3 : FsHcint3 , fs_hcintmsk3 : FsHcintmsk3 , fs_hctsiz3 : FsHctsiz3 , _reserved23 : [u8 ; 0x0c] , fs_hcchar4 : FsHcchar4 , _reserved24 : [u8 ; 0x04] , fs_hcint4 : FsHcint4 , fs_hcintmsk4 : FsHcintmsk4 , fs_hctsiz4 : FsHctsiz4 , _reserved27 : [u8 ; 0x0c] , fs_hcchar5 : FsHcchar5 , _reserved28 : [u8 ; 0x04] , fs_hcint5 : FsHcint5 , fs_hcintmsk5 : FsHcintmsk5 , fs_hctsiz5 : FsHctsiz5 , _reserved31 : [u8 ; 0x0c] , fs_hcchar6 : FsHcchar6 , _reserved32 : [u8 ; 0x04] , fs_hcint6 : FsHcint6 , fs_hcintmsk6 : FsHcintmsk6 , fs_hctsiz6 : FsHctsiz6 , _reserved35 : [u8 ; 0x0c] , fs_hcchar7 : FsHcchar7 , _reserved36 : [u8 ; 0x04] , fs_hcint7 : FsHcint7 , fs_hcintmsk7 : FsHcintmsk7 , fs_hctsiz7 : FsHctsiz7 , } impl RegisterBlock {
#[doc = "0x00 - OTG_FS host configuration register (OTG_FS_HCFG)"]
#[inline (always)] pub const fn fs_hcfg (& self) -> & FsHcfg { & self . fs_hcfg }
#[doc = "0x04 - OTG_FS Host frame interval register"]
#[inline (always)] pub const fn hfir (& self) -> & Hfir { & self . hfir }
#[doc = "0x08 - OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)"]
#[inline (always)] pub const fn fs_hfnum (& self) -> & FsHfnum { & self . fs_hfnum }
#[doc = "0x10 - OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)"]
#[inline (always)] pub const fn fs_hptxsts (& self) -> & FsHptxsts { & self . fs_hptxsts }
#[doc = "0x14 - OTG_FS Host all channels interrupt register"]
#[inline (always)] pub const fn haint (& self) -> & Haint { & self . haint }
#[doc = "0x18 - OTG_FS host all channels interrupt mask register"]
#[inline (always)] pub const fn haintmsk (& self) -> & Haintmsk { & self . haintmsk }
#[doc = "0x40 - OTG_FS host port control and status register (OTG_FS_HPRT)"]
#[inline (always)] pub const fn fs_hprt (& self) -> & FsHprt { & self . fs_hprt }
#[doc = "0x100 - OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)"]
#[inline (always)] pub const fn fs_hcchar0 (& self) -> & FsHcchar0 { & self . fs_hcchar0 }
#[doc = "0x108 - OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)"]
#[inline (always)] pub const fn fs_hcint0 (& self) -> & FsHcint0 { & self . fs_hcint0 }
#[doc = "0x10c - OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)"]
#[inline (always)] pub const fn fs_hcintmsk0 (& self) -> & FsHcintmsk0 { & self . fs_hcintmsk0 }
#[doc = "0x110 - OTG_FS host channel-0 transfer size register"]
#[inline (always)] pub const fn fs_hctsiz0 (& self) -> & FsHctsiz0 { & self . fs_hctsiz0 }
#[doc = "0x120 - OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)"]
#[inline (always)] pub const fn fs_hcchar1 (& self) -> & FsHcchar1 { & self . fs_hcchar1 }
#[doc = "0x128 - OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)"]
#[inline (always)] pub const fn fs_hcint1 (& self) -> & FsHcint1 { & self . fs_hcint1 }
#[doc = "0x12c - OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)"]
#[inline (always)] pub const fn fs_hcintmsk1 (& self) -> & FsHcintmsk1 { & self . fs_hcintmsk1 }
#[doc = "0x130 - OTG_FS host channel-1 transfer size register"]
#[inline (always)] pub const fn fs_hctsiz1 (& self) -> & FsHctsiz1 { & self . fs_hctsiz1 }
#[doc = "0x140 - OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)"]
#[inline (always)] pub const fn fs_hcchar2 (& self) -> & FsHcchar2 { & self . fs_hcchar2 }
#[doc = "0x148 - OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)"]
#[inline (always)] pub const fn fs_hcint2 (& self) -> & FsHcint2 { & self . fs_hcint2 }
#[doc = "0x14c - OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)"]
#[inline (always)] pub const fn fs_hcintmsk2 (& self) -> & FsHcintmsk2 { & self . fs_hcintmsk2 }
#[doc = "0x150 - OTG_FS host channel-2 transfer size register"]
#[inline (always)] pub const fn fs_hctsiz2 (& self) -> & FsHctsiz2 { & self . fs_hctsiz2 }
#[doc = "0x160 - OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)"]
#[inline (always)] pub const fn fs_hcchar3 (& self) -> & FsHcchar3 { & self . fs_hcchar3 }
#[doc = "0x168 - OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)"]
#[inline (always)] pub const fn fs_hcint3 (& self) -> & FsHcint3 { & self . fs_hcint3 }
#[doc = "0x16c - OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)"]
#[inline (always)] pub const fn fs_hcintmsk3 (& self) -> & FsHcintmsk3 { & self . fs_hcintmsk3 }
#[doc = "0x170 - OTG_FS host channel-3 transfer size register"]
#[inline (always)] pub const fn fs_hctsiz3 (& self) -> & FsHctsiz3 { & self . fs_hctsiz3 }
#[doc = "0x180 - OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)"]
#[inline (always)] pub const fn fs_hcchar4 (& self) -> & FsHcchar4 { & self . fs_hcchar4 }
#[doc = "0x188 - OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)"]
#[inline (always)] pub const fn fs_hcint4 (& self) -> & FsHcint4 { & self . fs_hcint4 }
#[doc = "0x18c - OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)"]
#[inline (always)] pub const fn fs_hcintmsk4 (& self) -> & FsHcintmsk4 { & self . fs_hcintmsk4 }
#[doc = "0x190 - OTG_FS host channel-x transfer size register"]
#[inline (always)] pub const fn fs_hctsiz4 (& self) -> & FsHctsiz4 { & self . fs_hctsiz4 }
#[doc = "0x1a0 - OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)"]
#[inline (always)] pub const fn fs_hcchar5 (& self) -> & FsHcchar5 { & self . fs_hcchar5 }
#[doc = "0x1a8 - OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)"]
#[inline (always)] pub const fn fs_hcint5 (& self) -> & FsHcint5 { & self . fs_hcint5 }
#[doc = "0x1ac - OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)"]
#[inline (always)] pub const fn fs_hcintmsk5 (& self) -> & FsHcintmsk5 { & self . fs_hcintmsk5 }
#[doc = "0x1b0 - OTG_FS host channel-5 transfer size register"]
#[inline (always)] pub const fn fs_hctsiz5 (& self) -> & FsHctsiz5 { & self . fs_hctsiz5 }
#[doc = "0x1c0 - OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)"]
#[inline (always)] pub const fn fs_hcchar6 (& self) -> & FsHcchar6 { & self . fs_hcchar6 }
#[doc = "0x1c8 - OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)"]
#[inline (always)] pub const fn fs_hcint6 (& self) -> & FsHcint6 { & self . fs_hcint6 }
#[doc = "0x1cc - OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)"]
#[inline (always)] pub const fn fs_hcintmsk6 (& self) -> & FsHcintmsk6 { & self . fs_hcintmsk6 }
#[doc = "0x1d0 - OTG_FS host channel-6 transfer size register"]
#[inline (always)] pub const fn fs_hctsiz6 (& self) -> & FsHctsiz6 { & self . fs_hctsiz6 }
#[doc = "0x1e0 - OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)"]
#[inline (always)] pub const fn fs_hcchar7 (& self) -> & FsHcchar7 { & self . fs_hcchar7 }
#[doc = "0x1e8 - OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)"]
#[inline (always)] pub const fn fs_hcint7 (& self) -> & FsHcint7 { & self . fs_hcint7 }
#[doc = "0x1ec - OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)"]
#[inline (always)] pub const fn fs_hcintmsk7 (& self) -> & FsHcintmsk7 { & self . fs_hcintmsk7 }
#[doc = "0x1f0 - OTG_FS host channel-7 transfer size register"]
#[inline (always)] pub const fn fs_hctsiz7 (& self) -> & FsHctsiz7 { & self . fs_hctsiz7 } }
#[doc = "FS_HCFG (rw) register accessor: OTG_FS host configuration register (OTG_FS_HCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcfg`] module"]
#[doc (alias = "FS_HCFG")] pub type FsHcfg = crate :: Reg < fs_hcfg :: FsHcfgSpec > ;
#[doc = "OTG_FS host configuration register (OTG_FS_HCFG)"] pub mod fs_hcfg {
#[doc = "Register `FS_HCFG` reader"] pub type R = crate :: R < FsHcfgSpec > ;
#[doc = "Register `FS_HCFG` writer"] pub type W = crate :: W < FsHcfgSpec > ;
#[doc = "Field `FSLSPCS` reader - FS/LS PHY clock select"] pub type FslspcsR = crate :: FieldReader ;
#[doc = "Field `FSLSPCS` writer - FS/LS PHY clock select"] pub type FslspcsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `FSLSS` reader - FS- and LS-only support"] pub type FslssR = crate :: BitReader ; impl R {
#[doc = "Bits 0:1 - FS/LS PHY clock select"]
#[inline (always)] pub fn fslspcs (& self) -> FslspcsR { FslspcsR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - FS- and LS-only support"]
#[inline (always)] pub fn fslss (& self) -> FslssR { FslssR :: new (((self . bits >> 2) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - FS/LS PHY clock select"]
#[inline (always)] pub fn fslspcs (& mut self) -> FslspcsW < '_ , FsHcfgSpec > { FslspcsW :: new (self , 0) } }
#[doc = "OTG_FS host configuration register (OTG_FS_HCFG)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcfgSpec ; impl crate :: RegisterSpec for FsHcfgSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcfg::R`](R) reader structure"] impl crate :: Readable for FsHcfgSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcfg::W`](W) writer structure"] impl crate :: Writable for FsHcfgSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCFG to value 0"] impl crate :: Resettable for FsHcfgSpec { } }
#[doc = "HFIR (rw) register accessor: OTG_FS Host frame interval register\n\nYou can [`read`](crate::Reg::read) this register and get [`hfir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hfir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hfir`] module"]
#[doc (alias = "HFIR")] pub type Hfir = crate :: Reg < hfir :: HfirSpec > ;
#[doc = "OTG_FS Host frame interval register"] pub mod hfir {
#[doc = "Register `HFIR` reader"] pub type R = crate :: R < HfirSpec > ;
#[doc = "Register `HFIR` writer"] pub type W = crate :: W < HfirSpec > ;
#[doc = "Field `FRIVL` reader - Frame interval"] pub type FrivlR = crate :: FieldReader < u16 > ;
#[doc = "Field `FRIVL` writer - Frame interval"] pub type FrivlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Frame interval"]
#[inline (always)] pub fn frivl (& self) -> FrivlR { FrivlR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Frame interval"]
#[inline (always)] pub fn frivl (& mut self) -> FrivlW < '_ , HfirSpec > { FrivlW :: new (self , 0) } }
#[doc = "OTG_FS Host frame interval register\n\nYou can [`read`](crate::Reg::read) this register and get [`hfir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hfir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HfirSpec ; impl crate :: RegisterSpec for HfirSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hfir::R`](R) reader structure"] impl crate :: Readable for HfirSpec { }
#[doc = "`write(|w| ..)` method takes [`hfir::W`](W) writer structure"] impl crate :: Writable for HfirSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets HFIR to value 0xea60"] impl crate :: Resettable for HfirSpec { const RESET_VALUE : u32 = 0xea60 ; } }
#[doc = "FS_HFNUM (r) register accessor: OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hfnum::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hfnum`] module"]
#[doc (alias = "FS_HFNUM")] pub type FsHfnum = crate :: Reg < fs_hfnum :: FsHfnumSpec > ;
#[doc = "OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)"] pub mod fs_hfnum {
#[doc = "Register `FS_HFNUM` reader"] pub type R = crate :: R < FsHfnumSpec > ;
#[doc = "Field `FRNUM` reader - Frame number"] pub type FrnumR = crate :: FieldReader < u16 > ;
#[doc = "Field `FTREM` reader - Frame time remaining"] pub type FtremR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Frame number"]
#[inline (always)] pub fn frnum (& self) -> FrnumR { FrnumR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:31 - Frame time remaining"]
#[inline (always)] pub fn ftrem (& self) -> FtremR { FtremR :: new (((self . bits >> 16) & 0xffff) as u16) } }
#[doc = "OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hfnum::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHfnumSpec ; impl crate :: RegisterSpec for FsHfnumSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hfnum::R`](R) reader structure"] impl crate :: Readable for FsHfnumSpec { }
#[doc = "`reset()` method sets FS_HFNUM to value 0x3fff"] impl crate :: Resettable for FsHfnumSpec { const RESET_VALUE : u32 = 0x3fff ; } }
#[doc = "FS_HPTXSTS (rw) register accessor: OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hptxsts::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hptxsts::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hptxsts`] module"]
#[doc (alias = "FS_HPTXSTS")] pub type FsHptxsts = crate :: Reg < fs_hptxsts :: FsHptxstsSpec > ;
#[doc = "OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)"] pub mod fs_hptxsts {
#[doc = "Register `FS_HPTXSTS` reader"] pub type R = crate :: R < FsHptxstsSpec > ;
#[doc = "Register `FS_HPTXSTS` writer"] pub type W = crate :: W < FsHptxstsSpec > ;
#[doc = "Field `PTXFSAVL` reader - Periodic transmit data FIFO space available"] pub type PtxfsavlR = crate :: FieldReader < u16 > ;
#[doc = "Field `PTXFSAVL` writer - Periodic transmit data FIFO space available"] pub type PtxfsavlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `PTXQSAV` reader - Periodic transmit request queue space available"] pub type PtxqsavR = crate :: FieldReader ;
#[doc = "Field `PTXQTOP` reader - Top of the periodic transmit request queue"] pub type PtxqtopR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:15 - Periodic transmit data FIFO space available"]
#[inline (always)] pub fn ptxfsavl (& self) -> PtxfsavlR { PtxfsavlR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:23 - Periodic transmit request queue space available"]
#[inline (always)] pub fn ptxqsav (& self) -> PtxqsavR { PtxqsavR :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - Top of the periodic transmit request queue"]
#[inline (always)] pub fn ptxqtop (& self) -> PtxqtopR { PtxqtopR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:15 - Periodic transmit data FIFO space available"]
#[inline (always)] pub fn ptxfsavl (& mut self) -> PtxfsavlW < '_ , FsHptxstsSpec > { PtxfsavlW :: new (self , 0) } }
#[doc = "OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hptxsts::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hptxsts::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHptxstsSpec ; impl crate :: RegisterSpec for FsHptxstsSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hptxsts::R`](R) reader structure"] impl crate :: Readable for FsHptxstsSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_hptxsts::W`](W) writer structure"] impl crate :: Writable for FsHptxstsSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HPTXSTS to value 0x0008_0100"] impl crate :: Resettable for FsHptxstsSpec { const RESET_VALUE : u32 = 0x0008_0100 ; } }
#[doc = "HAINT (r) register accessor: OTG_FS Host all channels interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`haint::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@haint`] module"]
#[doc (alias = "HAINT")] pub type Haint = crate :: Reg < haint :: HaintSpec > ;
#[doc = "OTG_FS Host all channels interrupt register"] pub mod haint {
#[doc = "Register `HAINT` reader"] pub type R = crate :: R < HaintSpec > ;
#[doc = "Field `HAINT` reader - Channel interrupts"] pub type HaintR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Channel interrupts"]
#[inline (always)] pub fn haint (& self) -> HaintR { HaintR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "OTG_FS Host all channels interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`haint::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HaintSpec ; impl crate :: RegisterSpec for HaintSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`haint::R`](R) reader structure"] impl crate :: Readable for HaintSpec { }
#[doc = "`reset()` method sets HAINT to value 0"] impl crate :: Resettable for HaintSpec { } }
#[doc = "HAINTMSK (rw) register accessor: OTG_FS host all channels interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`haintmsk::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`haintmsk::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@haintmsk`] module"]
#[doc (alias = "HAINTMSK")] pub type Haintmsk = crate :: Reg < haintmsk :: HaintmskSpec > ;
#[doc = "OTG_FS host all channels interrupt mask register"] pub mod haintmsk {
#[doc = "Register `HAINTMSK` reader"] pub type R = crate :: R < HaintmskSpec > ;
#[doc = "Register `HAINTMSK` writer"] pub type W = crate :: W < HaintmskSpec > ;
#[doc = "Field `HAINTM` reader - Channel interrupt mask"] pub type HaintmR = crate :: FieldReader < u16 > ;
#[doc = "Field `HAINTM` writer - Channel interrupt mask"] pub type HaintmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Channel interrupt mask"]
#[inline (always)] pub fn haintm (& self) -> HaintmR { HaintmR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Channel interrupt mask"]
#[inline (always)] pub fn haintm (& mut self) -> HaintmW < '_ , HaintmskSpec > { HaintmW :: new (self , 0) } }
#[doc = "OTG_FS host all channels interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`haintmsk::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`haintmsk::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HaintmskSpec ; impl crate :: RegisterSpec for HaintmskSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`haintmsk::R`](R) reader structure"] impl crate :: Readable for HaintmskSpec { }
#[doc = "`write(|w| ..)` method takes [`haintmsk::W`](W) writer structure"] impl crate :: Writable for HaintmskSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets HAINTMSK to value 0"] impl crate :: Resettable for HaintmskSpec { } }
#[doc = "FS_HPRT (rw) register accessor: OTG_FS host port control and status register (OTG_FS_HPRT)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hprt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hprt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hprt`] module"]
#[doc (alias = "FS_HPRT")] pub type FsHprt = crate :: Reg < fs_hprt :: FsHprtSpec > ;
#[doc = "OTG_FS host port control and status register (OTG_FS_HPRT)"] pub mod fs_hprt {
#[doc = "Register `FS_HPRT` reader"] pub type R = crate :: R < FsHprtSpec > ;
#[doc = "Register `FS_HPRT` writer"] pub type W = crate :: W < FsHprtSpec > ;
#[doc = "Field `PCSTS` reader - Port connect status"] pub type PcstsR = crate :: BitReader ;
#[doc = "Field `PCDET` reader - Port connect detected"] pub type PcdetR = crate :: BitReader ;
#[doc = "Field `PCDET` writer - Port connect detected"] pub type PcdetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PENA` reader - Port enable"] pub type PenaR = crate :: BitReader ;
#[doc = "Field `PENA` writer - Port enable"] pub type PenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PENCHNG` reader - Port enable/disable change"] pub type PenchngR = crate :: BitReader ;
#[doc = "Field `PENCHNG` writer - Port enable/disable change"] pub type PenchngW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `POCA` reader - Port overcurrent active"] pub type PocaR = crate :: BitReader ;
#[doc = "Field `POCCHNG` reader - Port overcurrent change"] pub type PocchngR = crate :: BitReader ;
#[doc = "Field `POCCHNG` writer - Port overcurrent change"] pub type PocchngW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PRES` reader - Port resume"] pub type PresR = crate :: BitReader ;
#[doc = "Field `PRES` writer - Port resume"] pub type PresW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSUSP` reader - Port suspend"] pub type PsuspR = crate :: BitReader ;
#[doc = "Field `PSUSP` writer - Port suspend"] pub type PsuspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PRST` reader - Port reset"] pub type PrstR = crate :: BitReader ;
#[doc = "Field `PRST` writer - Port reset"] pub type PrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLSTS` reader - Port line status"] pub type PlstsR = crate :: FieldReader ;
#[doc = "Field `PPWR` reader - Port power"] pub type PpwrR = crate :: BitReader ;
#[doc = "Field `PPWR` writer - Port power"] pub type PpwrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PTCTL` reader - Port test control"] pub type PtctlR = crate :: FieldReader ;
#[doc = "Field `PTCTL` writer - Port test control"] pub type PtctlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PSPD` reader - Port speed"] pub type PspdR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Port connect status"]
#[inline (always)] pub fn pcsts (& self) -> PcstsR { PcstsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Port connect detected"]
#[inline (always)] pub fn pcdet (& self) -> PcdetR { PcdetR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Port enable"]
#[inline (always)] pub fn pena (& self) -> PenaR { PenaR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Port enable/disable change"]
#[inline (always)] pub fn penchng (& self) -> PenchngR { PenchngR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Port overcurrent active"]
#[inline (always)] pub fn poca (& self) -> PocaR { PocaR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Port overcurrent change"]
#[inline (always)] pub fn pocchng (& self) -> PocchngR { PocchngR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Port resume"]
#[inline (always)] pub fn pres (& self) -> PresR { PresR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Port suspend"]
#[inline (always)] pub fn psusp (& self) -> PsuspR { PsuspR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Port reset"]
#[inline (always)] pub fn prst (& self) -> PrstR { PrstR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 10:11 - Port line status"]
#[inline (always)] pub fn plsts (& self) -> PlstsR { PlstsR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bit 12 - Port power"]
#[inline (always)] pub fn ppwr (& self) -> PpwrR { PpwrR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:16 - Port test control"]
#[inline (always)] pub fn ptctl (& self) -> PtctlR { PtctlR :: new (((self . bits >> 13) & 0x0f) as u8) }
#[doc = "Bits 17:18 - Port speed"]
#[inline (always)] pub fn pspd (& self) -> PspdR { PspdR :: new (((self . bits >> 17) & 3) as u8) } } impl W {
#[doc = "Bit 1 - Port connect detected"]
#[inline (always)] pub fn pcdet (& mut self) -> PcdetW < '_ , FsHprtSpec > { PcdetW :: new (self , 1) }
#[doc = "Bit 2 - Port enable"]
#[inline (always)] pub fn pena (& mut self) -> PenaW < '_ , FsHprtSpec > { PenaW :: new (self , 2) }
#[doc = "Bit 3 - Port enable/disable change"]
#[inline (always)] pub fn penchng (& mut self) -> PenchngW < '_ , FsHprtSpec > { PenchngW :: new (self , 3) }
#[doc = "Bit 5 - Port overcurrent change"]
#[inline (always)] pub fn pocchng (& mut self) -> PocchngW < '_ , FsHprtSpec > { PocchngW :: new (self , 5) }
#[doc = "Bit 6 - Port resume"]
#[inline (always)] pub fn pres (& mut self) -> PresW < '_ , FsHprtSpec > { PresW :: new (self , 6) }
#[doc = "Bit 7 - Port suspend"]
#[inline (always)] pub fn psusp (& mut self) -> PsuspW < '_ , FsHprtSpec > { PsuspW :: new (self , 7) }
#[doc = "Bit 8 - Port reset"]
#[inline (always)] pub fn prst (& mut self) -> PrstW < '_ , FsHprtSpec > { PrstW :: new (self , 8) }
#[doc = "Bit 12 - Port power"]
#[inline (always)] pub fn ppwr (& mut self) -> PpwrW < '_ , FsHprtSpec > { PpwrW :: new (self , 12) }
#[doc = "Bits 13:16 - Port test control"]
#[inline (always)] pub fn ptctl (& mut self) -> PtctlW < '_ , FsHprtSpec > { PtctlW :: new (self , 13) } }
#[doc = "OTG_FS host port control and status register (OTG_FS_HPRT)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hprt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hprt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHprtSpec ; impl crate :: RegisterSpec for FsHprtSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hprt::R`](R) reader structure"] impl crate :: Readable for FsHprtSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_hprt::W`](W) writer structure"] impl crate :: Writable for FsHprtSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HPRT to value 0"] impl crate :: Resettable for FsHprtSpec { } }
#[doc = "FS_HCCHAR0 (rw) register accessor: OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcchar0`] module"]
#[doc (alias = "FS_HCCHAR0")] pub type FsHcchar0 = crate :: Reg < fs_hcchar0 :: FsHcchar0Spec > ;
#[doc = "OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)"] pub mod fs_hcchar0 {
#[doc = "Register `FS_HCCHAR0` reader"] pub type R = crate :: R < FsHcchar0Spec > ;
#[doc = "Register `FS_HCCHAR0` writer"] pub type W = crate :: W < FsHcchar0Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `EPNUM` writer - Endpoint number"] pub type EpnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EPDIR` reader - Endpoint direction"] pub type EpdirR = crate :: BitReader ;
#[doc = "Field `EPDIR` writer - Endpoint direction"] pub type EpdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSDEV` reader - Low-speed device"] pub type LsdevR = crate :: BitReader ;
#[doc = "Field `LSDEV` writer - Low-speed device"] pub type LsdevW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - Endpoint type"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MCNT` reader - Multicount"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multicount"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ODDFRM` reader - Odd frame"] pub type OddfrmR = crate :: BitReader ;
#[doc = "Field `ODDFRM` writer - Odd frame"] pub type OddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHDIS` reader - Channel disable"] pub type ChdisR = crate :: BitReader ;
#[doc = "Field `CHDIS` writer - Channel disable"] pub type ChdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHENA` reader - Channel enable"] pub type ChenaR = crate :: BitReader ;
#[doc = "Field `CHENA` writer - Channel enable"] pub type ChenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& self) -> EpdirR { EpdirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& self) -> LsdevR { LsdevR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 22) & 0x7f) as u8) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& self) -> OddfrmR { OddfrmR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& self) -> ChdisR { ChdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& self) -> ChenaR { ChenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsHcchar0Spec > { MpsizW :: new (self , 0) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& mut self) -> EpnumW < '_ , FsHcchar0Spec > { EpnumW :: new (self , 11) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& mut self) -> EpdirW < '_ , FsHcchar0Spec > { EpdirW :: new (self , 15) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& mut self) -> LsdevW < '_ , FsHcchar0Spec > { LsdevW :: new (self , 17) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , FsHcchar0Spec > { EptypW :: new (self , 18) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , FsHcchar0Spec > { McntW :: new (self , 20) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsHcchar0Spec > { DadW :: new (self , 22) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& mut self) -> OddfrmW < '_ , FsHcchar0Spec > { OddfrmW :: new (self , 29) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& mut self) -> ChdisW < '_ , FsHcchar0Spec > { ChdisW :: new (self , 30) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& mut self) -> ChenaW < '_ , FsHcchar0Spec > { ChenaW :: new (self , 31) } }
#[doc = "OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcchar0Spec ; impl crate :: RegisterSpec for FsHcchar0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcchar0::R`](R) reader structure"] impl crate :: Readable for FsHcchar0Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcchar0::W`](W) writer structure"] impl crate :: Writable for FsHcchar0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCCHAR0 to value 0"] impl crate :: Resettable for FsHcchar0Spec { } }
#[doc = "FS_HCCHAR1 (rw) register accessor: OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcchar1`] module"]
#[doc (alias = "FS_HCCHAR1")] pub type FsHcchar1 = crate :: Reg < fs_hcchar1 :: FsHcchar1Spec > ;
#[doc = "OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)"] pub mod fs_hcchar1 {
#[doc = "Register `FS_HCCHAR1` reader"] pub type R = crate :: R < FsHcchar1Spec > ;
#[doc = "Register `FS_HCCHAR1` writer"] pub type W = crate :: W < FsHcchar1Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `EPNUM` writer - Endpoint number"] pub type EpnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EPDIR` reader - Endpoint direction"] pub type EpdirR = crate :: BitReader ;
#[doc = "Field `EPDIR` writer - Endpoint direction"] pub type EpdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSDEV` reader - Low-speed device"] pub type LsdevR = crate :: BitReader ;
#[doc = "Field `LSDEV` writer - Low-speed device"] pub type LsdevW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - Endpoint type"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MCNT` reader - Multicount"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multicount"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ODDFRM` reader - Odd frame"] pub type OddfrmR = crate :: BitReader ;
#[doc = "Field `ODDFRM` writer - Odd frame"] pub type OddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHDIS` reader - Channel disable"] pub type ChdisR = crate :: BitReader ;
#[doc = "Field `CHDIS` writer - Channel disable"] pub type ChdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHENA` reader - Channel enable"] pub type ChenaR = crate :: BitReader ;
#[doc = "Field `CHENA` writer - Channel enable"] pub type ChenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& self) -> EpdirR { EpdirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& self) -> LsdevR { LsdevR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 22) & 0x7f) as u8) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& self) -> OddfrmR { OddfrmR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& self) -> ChdisR { ChdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& self) -> ChenaR { ChenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsHcchar1Spec > { MpsizW :: new (self , 0) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& mut self) -> EpnumW < '_ , FsHcchar1Spec > { EpnumW :: new (self , 11) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& mut self) -> EpdirW < '_ , FsHcchar1Spec > { EpdirW :: new (self , 15) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& mut self) -> LsdevW < '_ , FsHcchar1Spec > { LsdevW :: new (self , 17) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , FsHcchar1Spec > { EptypW :: new (self , 18) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , FsHcchar1Spec > { McntW :: new (self , 20) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsHcchar1Spec > { DadW :: new (self , 22) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& mut self) -> OddfrmW < '_ , FsHcchar1Spec > { OddfrmW :: new (self , 29) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& mut self) -> ChdisW < '_ , FsHcchar1Spec > { ChdisW :: new (self , 30) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& mut self) -> ChenaW < '_ , FsHcchar1Spec > { ChenaW :: new (self , 31) } }
#[doc = "OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcchar1Spec ; impl crate :: RegisterSpec for FsHcchar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcchar1::R`](R) reader structure"] impl crate :: Readable for FsHcchar1Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcchar1::W`](W) writer structure"] impl crate :: Writable for FsHcchar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCCHAR1 to value 0"] impl crate :: Resettable for FsHcchar1Spec { } }
#[doc = "FS_HCCHAR2 (rw) register accessor: OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcchar2`] module"]
#[doc (alias = "FS_HCCHAR2")] pub type FsHcchar2 = crate :: Reg < fs_hcchar2 :: FsHcchar2Spec > ;
#[doc = "OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)"] pub mod fs_hcchar2 {
#[doc = "Register `FS_HCCHAR2` reader"] pub type R = crate :: R < FsHcchar2Spec > ;
#[doc = "Register `FS_HCCHAR2` writer"] pub type W = crate :: W < FsHcchar2Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `EPNUM` writer - Endpoint number"] pub type EpnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EPDIR` reader - Endpoint direction"] pub type EpdirR = crate :: BitReader ;
#[doc = "Field `EPDIR` writer - Endpoint direction"] pub type EpdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSDEV` reader - Low-speed device"] pub type LsdevR = crate :: BitReader ;
#[doc = "Field `LSDEV` writer - Low-speed device"] pub type LsdevW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - Endpoint type"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MCNT` reader - Multicount"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multicount"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ODDFRM` reader - Odd frame"] pub type OddfrmR = crate :: BitReader ;
#[doc = "Field `ODDFRM` writer - Odd frame"] pub type OddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHDIS` reader - Channel disable"] pub type ChdisR = crate :: BitReader ;
#[doc = "Field `CHDIS` writer - Channel disable"] pub type ChdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHENA` reader - Channel enable"] pub type ChenaR = crate :: BitReader ;
#[doc = "Field `CHENA` writer - Channel enable"] pub type ChenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& self) -> EpdirR { EpdirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& self) -> LsdevR { LsdevR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 22) & 0x7f) as u8) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& self) -> OddfrmR { OddfrmR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& self) -> ChdisR { ChdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& self) -> ChenaR { ChenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsHcchar2Spec > { MpsizW :: new (self , 0) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& mut self) -> EpnumW < '_ , FsHcchar2Spec > { EpnumW :: new (self , 11) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& mut self) -> EpdirW < '_ , FsHcchar2Spec > { EpdirW :: new (self , 15) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& mut self) -> LsdevW < '_ , FsHcchar2Spec > { LsdevW :: new (self , 17) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , FsHcchar2Spec > { EptypW :: new (self , 18) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , FsHcchar2Spec > { McntW :: new (self , 20) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsHcchar2Spec > { DadW :: new (self , 22) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& mut self) -> OddfrmW < '_ , FsHcchar2Spec > { OddfrmW :: new (self , 29) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& mut self) -> ChdisW < '_ , FsHcchar2Spec > { ChdisW :: new (self , 30) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& mut self) -> ChenaW < '_ , FsHcchar2Spec > { ChenaW :: new (self , 31) } }
#[doc = "OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcchar2Spec ; impl crate :: RegisterSpec for FsHcchar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcchar2::R`](R) reader structure"] impl crate :: Readable for FsHcchar2Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcchar2::W`](W) writer structure"] impl crate :: Writable for FsHcchar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCCHAR2 to value 0"] impl crate :: Resettable for FsHcchar2Spec { } }
#[doc = "FS_HCCHAR3 (rw) register accessor: OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcchar3`] module"]
#[doc (alias = "FS_HCCHAR3")] pub type FsHcchar3 = crate :: Reg < fs_hcchar3 :: FsHcchar3Spec > ;
#[doc = "OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)"] pub mod fs_hcchar3 {
#[doc = "Register `FS_HCCHAR3` reader"] pub type R = crate :: R < FsHcchar3Spec > ;
#[doc = "Register `FS_HCCHAR3` writer"] pub type W = crate :: W < FsHcchar3Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `EPNUM` writer - Endpoint number"] pub type EpnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EPDIR` reader - Endpoint direction"] pub type EpdirR = crate :: BitReader ;
#[doc = "Field `EPDIR` writer - Endpoint direction"] pub type EpdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSDEV` reader - Low-speed device"] pub type LsdevR = crate :: BitReader ;
#[doc = "Field `LSDEV` writer - Low-speed device"] pub type LsdevW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - Endpoint type"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MCNT` reader - Multicount"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multicount"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ODDFRM` reader - Odd frame"] pub type OddfrmR = crate :: BitReader ;
#[doc = "Field `ODDFRM` writer - Odd frame"] pub type OddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHDIS` reader - Channel disable"] pub type ChdisR = crate :: BitReader ;
#[doc = "Field `CHDIS` writer - Channel disable"] pub type ChdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHENA` reader - Channel enable"] pub type ChenaR = crate :: BitReader ;
#[doc = "Field `CHENA` writer - Channel enable"] pub type ChenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& self) -> EpdirR { EpdirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& self) -> LsdevR { LsdevR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 22) & 0x7f) as u8) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& self) -> OddfrmR { OddfrmR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& self) -> ChdisR { ChdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& self) -> ChenaR { ChenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsHcchar3Spec > { MpsizW :: new (self , 0) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& mut self) -> EpnumW < '_ , FsHcchar3Spec > { EpnumW :: new (self , 11) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& mut self) -> EpdirW < '_ , FsHcchar3Spec > { EpdirW :: new (self , 15) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& mut self) -> LsdevW < '_ , FsHcchar3Spec > { LsdevW :: new (self , 17) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , FsHcchar3Spec > { EptypW :: new (self , 18) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , FsHcchar3Spec > { McntW :: new (self , 20) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsHcchar3Spec > { DadW :: new (self , 22) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& mut self) -> OddfrmW < '_ , FsHcchar3Spec > { OddfrmW :: new (self , 29) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& mut self) -> ChdisW < '_ , FsHcchar3Spec > { ChdisW :: new (self , 30) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& mut self) -> ChenaW < '_ , FsHcchar3Spec > { ChenaW :: new (self , 31) } }
#[doc = "OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcchar3Spec ; impl crate :: RegisterSpec for FsHcchar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcchar3::R`](R) reader structure"] impl crate :: Readable for FsHcchar3Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcchar3::W`](W) writer structure"] impl crate :: Writable for FsHcchar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCCHAR3 to value 0"] impl crate :: Resettable for FsHcchar3Spec { } }
#[doc = "FS_HCCHAR4 (rw) register accessor: OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcchar4`] module"]
#[doc (alias = "FS_HCCHAR4")] pub type FsHcchar4 = crate :: Reg < fs_hcchar4 :: FsHcchar4Spec > ;
#[doc = "OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)"] pub mod fs_hcchar4 {
#[doc = "Register `FS_HCCHAR4` reader"] pub type R = crate :: R < FsHcchar4Spec > ;
#[doc = "Register `FS_HCCHAR4` writer"] pub type W = crate :: W < FsHcchar4Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `EPNUM` writer - Endpoint number"] pub type EpnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EPDIR` reader - Endpoint direction"] pub type EpdirR = crate :: BitReader ;
#[doc = "Field `EPDIR` writer - Endpoint direction"] pub type EpdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSDEV` reader - Low-speed device"] pub type LsdevR = crate :: BitReader ;
#[doc = "Field `LSDEV` writer - Low-speed device"] pub type LsdevW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - Endpoint type"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MCNT` reader - Multicount"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multicount"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ODDFRM` reader - Odd frame"] pub type OddfrmR = crate :: BitReader ;
#[doc = "Field `ODDFRM` writer - Odd frame"] pub type OddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHDIS` reader - Channel disable"] pub type ChdisR = crate :: BitReader ;
#[doc = "Field `CHDIS` writer - Channel disable"] pub type ChdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHENA` reader - Channel enable"] pub type ChenaR = crate :: BitReader ;
#[doc = "Field `CHENA` writer - Channel enable"] pub type ChenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& self) -> EpdirR { EpdirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& self) -> LsdevR { LsdevR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 22) & 0x7f) as u8) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& self) -> OddfrmR { OddfrmR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& self) -> ChdisR { ChdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& self) -> ChenaR { ChenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsHcchar4Spec > { MpsizW :: new (self , 0) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& mut self) -> EpnumW < '_ , FsHcchar4Spec > { EpnumW :: new (self , 11) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& mut self) -> EpdirW < '_ , FsHcchar4Spec > { EpdirW :: new (self , 15) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& mut self) -> LsdevW < '_ , FsHcchar4Spec > { LsdevW :: new (self , 17) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , FsHcchar4Spec > { EptypW :: new (self , 18) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , FsHcchar4Spec > { McntW :: new (self , 20) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsHcchar4Spec > { DadW :: new (self , 22) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& mut self) -> OddfrmW < '_ , FsHcchar4Spec > { OddfrmW :: new (self , 29) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& mut self) -> ChdisW < '_ , FsHcchar4Spec > { ChdisW :: new (self , 30) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& mut self) -> ChenaW < '_ , FsHcchar4Spec > { ChenaW :: new (self , 31) } }
#[doc = "OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcchar4Spec ; impl crate :: RegisterSpec for FsHcchar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcchar4::R`](R) reader structure"] impl crate :: Readable for FsHcchar4Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcchar4::W`](W) writer structure"] impl crate :: Writable for FsHcchar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCCHAR4 to value 0"] impl crate :: Resettable for FsHcchar4Spec { } }
#[doc = "FS_HCCHAR5 (rw) register accessor: OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcchar5`] module"]
#[doc (alias = "FS_HCCHAR5")] pub type FsHcchar5 = crate :: Reg < fs_hcchar5 :: FsHcchar5Spec > ;
#[doc = "OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)"] pub mod fs_hcchar5 {
#[doc = "Register `FS_HCCHAR5` reader"] pub type R = crate :: R < FsHcchar5Spec > ;
#[doc = "Register `FS_HCCHAR5` writer"] pub type W = crate :: W < FsHcchar5Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `EPNUM` writer - Endpoint number"] pub type EpnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EPDIR` reader - Endpoint direction"] pub type EpdirR = crate :: BitReader ;
#[doc = "Field `EPDIR` writer - Endpoint direction"] pub type EpdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSDEV` reader - Low-speed device"] pub type LsdevR = crate :: BitReader ;
#[doc = "Field `LSDEV` writer - Low-speed device"] pub type LsdevW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - Endpoint type"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MCNT` reader - Multicount"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multicount"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ODDFRM` reader - Odd frame"] pub type OddfrmR = crate :: BitReader ;
#[doc = "Field `ODDFRM` writer - Odd frame"] pub type OddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHDIS` reader - Channel disable"] pub type ChdisR = crate :: BitReader ;
#[doc = "Field `CHDIS` writer - Channel disable"] pub type ChdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHENA` reader - Channel enable"] pub type ChenaR = crate :: BitReader ;
#[doc = "Field `CHENA` writer - Channel enable"] pub type ChenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& self) -> EpdirR { EpdirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& self) -> LsdevR { LsdevR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 22) & 0x7f) as u8) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& self) -> OddfrmR { OddfrmR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& self) -> ChdisR { ChdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& self) -> ChenaR { ChenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsHcchar5Spec > { MpsizW :: new (self , 0) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& mut self) -> EpnumW < '_ , FsHcchar5Spec > { EpnumW :: new (self , 11) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& mut self) -> EpdirW < '_ , FsHcchar5Spec > { EpdirW :: new (self , 15) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& mut self) -> LsdevW < '_ , FsHcchar5Spec > { LsdevW :: new (self , 17) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , FsHcchar5Spec > { EptypW :: new (self , 18) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , FsHcchar5Spec > { McntW :: new (self , 20) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsHcchar5Spec > { DadW :: new (self , 22) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& mut self) -> OddfrmW < '_ , FsHcchar5Spec > { OddfrmW :: new (self , 29) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& mut self) -> ChdisW < '_ , FsHcchar5Spec > { ChdisW :: new (self , 30) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& mut self) -> ChenaW < '_ , FsHcchar5Spec > { ChenaW :: new (self , 31) } }
#[doc = "OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcchar5Spec ; impl crate :: RegisterSpec for FsHcchar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcchar5::R`](R) reader structure"] impl crate :: Readable for FsHcchar5Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcchar5::W`](W) writer structure"] impl crate :: Writable for FsHcchar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCCHAR5 to value 0"] impl crate :: Resettable for FsHcchar5Spec { } }
#[doc = "FS_HCCHAR6 (rw) register accessor: OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcchar6`] module"]
#[doc (alias = "FS_HCCHAR6")] pub type FsHcchar6 = crate :: Reg < fs_hcchar6 :: FsHcchar6Spec > ;
#[doc = "OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)"] pub mod fs_hcchar6 {
#[doc = "Register `FS_HCCHAR6` reader"] pub type R = crate :: R < FsHcchar6Spec > ;
#[doc = "Register `FS_HCCHAR6` writer"] pub type W = crate :: W < FsHcchar6Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `EPNUM` writer - Endpoint number"] pub type EpnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EPDIR` reader - Endpoint direction"] pub type EpdirR = crate :: BitReader ;
#[doc = "Field `EPDIR` writer - Endpoint direction"] pub type EpdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSDEV` reader - Low-speed device"] pub type LsdevR = crate :: BitReader ;
#[doc = "Field `LSDEV` writer - Low-speed device"] pub type LsdevW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - Endpoint type"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MCNT` reader - Multicount"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multicount"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ODDFRM` reader - Odd frame"] pub type OddfrmR = crate :: BitReader ;
#[doc = "Field `ODDFRM` writer - Odd frame"] pub type OddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHDIS` reader - Channel disable"] pub type ChdisR = crate :: BitReader ;
#[doc = "Field `CHDIS` writer - Channel disable"] pub type ChdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHENA` reader - Channel enable"] pub type ChenaR = crate :: BitReader ;
#[doc = "Field `CHENA` writer - Channel enable"] pub type ChenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& self) -> EpdirR { EpdirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& self) -> LsdevR { LsdevR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 22) & 0x7f) as u8) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& self) -> OddfrmR { OddfrmR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& self) -> ChdisR { ChdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& self) -> ChenaR { ChenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsHcchar6Spec > { MpsizW :: new (self , 0) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& mut self) -> EpnumW < '_ , FsHcchar6Spec > { EpnumW :: new (self , 11) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& mut self) -> EpdirW < '_ , FsHcchar6Spec > { EpdirW :: new (self , 15) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& mut self) -> LsdevW < '_ , FsHcchar6Spec > { LsdevW :: new (self , 17) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , FsHcchar6Spec > { EptypW :: new (self , 18) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , FsHcchar6Spec > { McntW :: new (self , 20) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsHcchar6Spec > { DadW :: new (self , 22) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& mut self) -> OddfrmW < '_ , FsHcchar6Spec > { OddfrmW :: new (self , 29) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& mut self) -> ChdisW < '_ , FsHcchar6Spec > { ChdisW :: new (self , 30) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& mut self) -> ChenaW < '_ , FsHcchar6Spec > { ChenaW :: new (self , 31) } }
#[doc = "OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcchar6Spec ; impl crate :: RegisterSpec for FsHcchar6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcchar6::R`](R) reader structure"] impl crate :: Readable for FsHcchar6Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcchar6::W`](W) writer structure"] impl crate :: Writable for FsHcchar6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCCHAR6 to value 0"] impl crate :: Resettable for FsHcchar6Spec { } }
#[doc = "FS_HCCHAR7 (rw) register accessor: OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcchar7`] module"]
#[doc (alias = "FS_HCCHAR7")] pub type FsHcchar7 = crate :: Reg < fs_hcchar7 :: FsHcchar7Spec > ;
#[doc = "OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)"] pub mod fs_hcchar7 {
#[doc = "Register `FS_HCCHAR7` reader"] pub type R = crate :: R < FsHcchar7Spec > ;
#[doc = "Register `FS_HCCHAR7` writer"] pub type W = crate :: W < FsHcchar7Spec > ;
#[doc = "Field `MPSIZ` reader - Maximum packet size"] pub type MpsizR = crate :: FieldReader < u16 > ;
#[doc = "Field `MPSIZ` writer - Maximum packet size"] pub type MpsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ;
#[doc = "Field `EPNUM` reader - Endpoint number"] pub type EpnumR = crate :: FieldReader ;
#[doc = "Field `EPNUM` writer - Endpoint number"] pub type EpnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EPDIR` reader - Endpoint direction"] pub type EpdirR = crate :: BitReader ;
#[doc = "Field `EPDIR` writer - Endpoint direction"] pub type EpdirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSDEV` reader - Low-speed device"] pub type LsdevR = crate :: BitReader ;
#[doc = "Field `LSDEV` writer - Low-speed device"] pub type LsdevW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EPTYP` reader - Endpoint type"] pub type EptypR = crate :: FieldReader ;
#[doc = "Field `EPTYP` writer - Endpoint type"] pub type EptypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MCNT` reader - Multicount"] pub type McntR = crate :: FieldReader ;
#[doc = "Field `MCNT` writer - Multicount"] pub type McntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DAD` reader - Device address"] pub type DadR = crate :: FieldReader ;
#[doc = "Field `DAD` writer - Device address"] pub type DadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ODDFRM` reader - Odd frame"] pub type OddfrmR = crate :: BitReader ;
#[doc = "Field `ODDFRM` writer - Odd frame"] pub type OddfrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHDIS` reader - Channel disable"] pub type ChdisR = crate :: BitReader ;
#[doc = "Field `CHDIS` writer - Channel disable"] pub type ChdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHENA` reader - Channel enable"] pub type ChenaR = crate :: BitReader ;
#[doc = "Field `CHENA` writer - Channel enable"] pub type ChenaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& self) -> MpsizR { MpsizR :: new ((self . bits & 0x07ff) as u16) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& self) -> EpnumR { EpnumR :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& self) -> EpdirR { EpdirR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& self) -> LsdevR { LsdevR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& self) -> EptypR { EptypR :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& self) -> McntR { McntR :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& self) -> DadR { DadR :: new (((self . bits >> 22) & 0x7f) as u8) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& self) -> OddfrmR { OddfrmR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& self) -> ChdisR { ChdisR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& self) -> ChenaR { ChenaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:10 - Maximum packet size"]
#[inline (always)] pub fn mpsiz (& mut self) -> MpsizW < '_ , FsHcchar7Spec > { MpsizW :: new (self , 0) }
#[doc = "Bits 11:14 - Endpoint number"]
#[inline (always)] pub fn epnum (& mut self) -> EpnumW < '_ , FsHcchar7Spec > { EpnumW :: new (self , 11) }
#[doc = "Bit 15 - Endpoint direction"]
#[inline (always)] pub fn epdir (& mut self) -> EpdirW < '_ , FsHcchar7Spec > { EpdirW :: new (self , 15) }
#[doc = "Bit 17 - Low-speed device"]
#[inline (always)] pub fn lsdev (& mut self) -> LsdevW < '_ , FsHcchar7Spec > { LsdevW :: new (self , 17) }
#[doc = "Bits 18:19 - Endpoint type"]
#[inline (always)] pub fn eptyp (& mut self) -> EptypW < '_ , FsHcchar7Spec > { EptypW :: new (self , 18) }
#[doc = "Bits 20:21 - Multicount"]
#[inline (always)] pub fn mcnt (& mut self) -> McntW < '_ , FsHcchar7Spec > { McntW :: new (self , 20) }
#[doc = "Bits 22:28 - Device address"]
#[inline (always)] pub fn dad (& mut self) -> DadW < '_ , FsHcchar7Spec > { DadW :: new (self , 22) }
#[doc = "Bit 29 - Odd frame"]
#[inline (always)] pub fn oddfrm (& mut self) -> OddfrmW < '_ , FsHcchar7Spec > { OddfrmW :: new (self , 29) }
#[doc = "Bit 30 - Channel disable"]
#[inline (always)] pub fn chdis (& mut self) -> ChdisW < '_ , FsHcchar7Spec > { ChdisW :: new (self , 30) }
#[doc = "Bit 31 - Channel enable"]
#[inline (always)] pub fn chena (& mut self) -> ChenaW < '_ , FsHcchar7Spec > { ChenaW :: new (self , 31) } }
#[doc = "OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcchar7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcchar7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcchar7Spec ; impl crate :: RegisterSpec for FsHcchar7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcchar7::R`](R) reader structure"] impl crate :: Readable for FsHcchar7Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcchar7::W`](W) writer structure"] impl crate :: Writable for FsHcchar7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCCHAR7 to value 0"] impl crate :: Resettable for FsHcchar7Spec { } }
#[doc = "FS_HCINT0 (rw) register accessor: OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcint0`] module"]
#[doc (alias = "FS_HCINT0")] pub type FsHcint0 = crate :: Reg < fs_hcint0 :: FsHcint0Spec > ;
#[doc = "OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)"] pub mod fs_hcint0 {
#[doc = "Register `FS_HCINT0` reader"] pub type R = crate :: R < FsHcint0Spec > ;
#[doc = "Register `FS_HCINT0` writer"] pub type W = crate :: W < FsHcint0Spec > ;
#[doc = "Field `XFRC` reader - Transfer completed"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - Transfer completed"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHH` reader - Channel halted"] pub type ChhR = crate :: BitReader ;
#[doc = "Field `CHH` writer - Channel halted"] pub type ChhW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALL` reader - STALL response received interrupt"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL response received interrupt"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAK` reader - NAK response received interrupt"] pub type NakR = crate :: BitReader ;
#[doc = "Field `NAK` writer - NAK response received interrupt"] pub type NakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERR` reader - Transaction error"] pub type TxerrR = crate :: BitReader ;
#[doc = "Field `TXERR` writer - Transaction error"] pub type TxerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERR` reader - Babble error"] pub type BberrR = crate :: BitReader ;
#[doc = "Field `BBERR` writer - Babble error"] pub type BberrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMOR` reader - Frame overrun"] pub type FrmorR = crate :: BitReader ;
#[doc = "Field `FRMOR` writer - Frame overrun"] pub type FrmorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERR` reader - Data toggle error"] pub type DterrR = crate :: BitReader ;
#[doc = "Field `DTERR` writer - Data toggle error"] pub type DterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& self) -> ChhR { ChhR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& self) -> NakR { NakR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& self) -> TxerrR { TxerrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& self) -> BberrR { BberrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& self) -> FrmorR { FrmorR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& self) -> DterrR { DterrR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , FsHcint0Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& mut self) -> ChhW < '_ , FsHcint0Spec > { ChhW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsHcint0Spec > { StallW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& mut self) -> NakW < '_ , FsHcint0Spec > { NakW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , FsHcint0Spec > { AckW :: new (self , 5) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& mut self) -> TxerrW < '_ , FsHcint0Spec > { TxerrW :: new (self , 7) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& mut self) -> BberrW < '_ , FsHcint0Spec > { BberrW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& mut self) -> FrmorW < '_ , FsHcint0Spec > { FrmorW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& mut self) -> DterrW < '_ , FsHcint0Spec > { DterrW :: new (self , 10) } }
#[doc = "OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcint0Spec ; impl crate :: RegisterSpec for FsHcint0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcint0::R`](R) reader structure"] impl crate :: Readable for FsHcint0Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcint0::W`](W) writer structure"] impl crate :: Writable for FsHcint0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINT0 to value 0"] impl crate :: Resettable for FsHcint0Spec { } }
#[doc = "FS_HCINT1 (rw) register accessor: OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcint1`] module"]
#[doc (alias = "FS_HCINT1")] pub type FsHcint1 = crate :: Reg < fs_hcint1 :: FsHcint1Spec > ;
#[doc = "OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)"] pub mod fs_hcint1 {
#[doc = "Register `FS_HCINT1` reader"] pub type R = crate :: R < FsHcint1Spec > ;
#[doc = "Register `FS_HCINT1` writer"] pub type W = crate :: W < FsHcint1Spec > ;
#[doc = "Field `XFRC` reader - Transfer completed"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - Transfer completed"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHH` reader - Channel halted"] pub type ChhR = crate :: BitReader ;
#[doc = "Field `CHH` writer - Channel halted"] pub type ChhW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALL` reader - STALL response received interrupt"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL response received interrupt"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAK` reader - NAK response received interrupt"] pub type NakR = crate :: BitReader ;
#[doc = "Field `NAK` writer - NAK response received interrupt"] pub type NakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERR` reader - Transaction error"] pub type TxerrR = crate :: BitReader ;
#[doc = "Field `TXERR` writer - Transaction error"] pub type TxerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERR` reader - Babble error"] pub type BberrR = crate :: BitReader ;
#[doc = "Field `BBERR` writer - Babble error"] pub type BberrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMOR` reader - Frame overrun"] pub type FrmorR = crate :: BitReader ;
#[doc = "Field `FRMOR` writer - Frame overrun"] pub type FrmorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERR` reader - Data toggle error"] pub type DterrR = crate :: BitReader ;
#[doc = "Field `DTERR` writer - Data toggle error"] pub type DterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& self) -> ChhR { ChhR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& self) -> NakR { NakR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& self) -> TxerrR { TxerrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& self) -> BberrR { BberrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& self) -> FrmorR { FrmorR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& self) -> DterrR { DterrR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , FsHcint1Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& mut self) -> ChhW < '_ , FsHcint1Spec > { ChhW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsHcint1Spec > { StallW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& mut self) -> NakW < '_ , FsHcint1Spec > { NakW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , FsHcint1Spec > { AckW :: new (self , 5) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& mut self) -> TxerrW < '_ , FsHcint1Spec > { TxerrW :: new (self , 7) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& mut self) -> BberrW < '_ , FsHcint1Spec > { BberrW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& mut self) -> FrmorW < '_ , FsHcint1Spec > { FrmorW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& mut self) -> DterrW < '_ , FsHcint1Spec > { DterrW :: new (self , 10) } }
#[doc = "OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcint1Spec ; impl crate :: RegisterSpec for FsHcint1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcint1::R`](R) reader structure"] impl crate :: Readable for FsHcint1Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcint1::W`](W) writer structure"] impl crate :: Writable for FsHcint1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINT1 to value 0"] impl crate :: Resettable for FsHcint1Spec { } }
#[doc = "FS_HCINT2 (rw) register accessor: OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcint2`] module"]
#[doc (alias = "FS_HCINT2")] pub type FsHcint2 = crate :: Reg < fs_hcint2 :: FsHcint2Spec > ;
#[doc = "OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)"] pub mod fs_hcint2 {
#[doc = "Register `FS_HCINT2` reader"] pub type R = crate :: R < FsHcint2Spec > ;
#[doc = "Register `FS_HCINT2` writer"] pub type W = crate :: W < FsHcint2Spec > ;
#[doc = "Field `XFRC` reader - Transfer completed"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - Transfer completed"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHH` reader - Channel halted"] pub type ChhR = crate :: BitReader ;
#[doc = "Field `CHH` writer - Channel halted"] pub type ChhW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALL` reader - STALL response received interrupt"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL response received interrupt"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAK` reader - NAK response received interrupt"] pub type NakR = crate :: BitReader ;
#[doc = "Field `NAK` writer - NAK response received interrupt"] pub type NakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERR` reader - Transaction error"] pub type TxerrR = crate :: BitReader ;
#[doc = "Field `TXERR` writer - Transaction error"] pub type TxerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERR` reader - Babble error"] pub type BberrR = crate :: BitReader ;
#[doc = "Field `BBERR` writer - Babble error"] pub type BberrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMOR` reader - Frame overrun"] pub type FrmorR = crate :: BitReader ;
#[doc = "Field `FRMOR` writer - Frame overrun"] pub type FrmorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERR` reader - Data toggle error"] pub type DterrR = crate :: BitReader ;
#[doc = "Field `DTERR` writer - Data toggle error"] pub type DterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& self) -> ChhR { ChhR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& self) -> NakR { NakR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& self) -> TxerrR { TxerrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& self) -> BberrR { BberrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& self) -> FrmorR { FrmorR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& self) -> DterrR { DterrR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , FsHcint2Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& mut self) -> ChhW < '_ , FsHcint2Spec > { ChhW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsHcint2Spec > { StallW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& mut self) -> NakW < '_ , FsHcint2Spec > { NakW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , FsHcint2Spec > { AckW :: new (self , 5) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& mut self) -> TxerrW < '_ , FsHcint2Spec > { TxerrW :: new (self , 7) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& mut self) -> BberrW < '_ , FsHcint2Spec > { BberrW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& mut self) -> FrmorW < '_ , FsHcint2Spec > { FrmorW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& mut self) -> DterrW < '_ , FsHcint2Spec > { DterrW :: new (self , 10) } }
#[doc = "OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcint2Spec ; impl crate :: RegisterSpec for FsHcint2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcint2::R`](R) reader structure"] impl crate :: Readable for FsHcint2Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcint2::W`](W) writer structure"] impl crate :: Writable for FsHcint2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINT2 to value 0"] impl crate :: Resettable for FsHcint2Spec { } }
#[doc = "FS_HCINT3 (rw) register accessor: OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcint3`] module"]
#[doc (alias = "FS_HCINT3")] pub type FsHcint3 = crate :: Reg < fs_hcint3 :: FsHcint3Spec > ;
#[doc = "OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)"] pub mod fs_hcint3 {
#[doc = "Register `FS_HCINT3` reader"] pub type R = crate :: R < FsHcint3Spec > ;
#[doc = "Register `FS_HCINT3` writer"] pub type W = crate :: W < FsHcint3Spec > ;
#[doc = "Field `XFRC` reader - Transfer completed"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - Transfer completed"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHH` reader - Channel halted"] pub type ChhR = crate :: BitReader ;
#[doc = "Field `CHH` writer - Channel halted"] pub type ChhW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALL` reader - STALL response received interrupt"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL response received interrupt"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAK` reader - NAK response received interrupt"] pub type NakR = crate :: BitReader ;
#[doc = "Field `NAK` writer - NAK response received interrupt"] pub type NakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERR` reader - Transaction error"] pub type TxerrR = crate :: BitReader ;
#[doc = "Field `TXERR` writer - Transaction error"] pub type TxerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERR` reader - Babble error"] pub type BberrR = crate :: BitReader ;
#[doc = "Field `BBERR` writer - Babble error"] pub type BberrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMOR` reader - Frame overrun"] pub type FrmorR = crate :: BitReader ;
#[doc = "Field `FRMOR` writer - Frame overrun"] pub type FrmorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERR` reader - Data toggle error"] pub type DterrR = crate :: BitReader ;
#[doc = "Field `DTERR` writer - Data toggle error"] pub type DterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& self) -> ChhR { ChhR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& self) -> NakR { NakR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& self) -> TxerrR { TxerrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& self) -> BberrR { BberrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& self) -> FrmorR { FrmorR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& self) -> DterrR { DterrR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , FsHcint3Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& mut self) -> ChhW < '_ , FsHcint3Spec > { ChhW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsHcint3Spec > { StallW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& mut self) -> NakW < '_ , FsHcint3Spec > { NakW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , FsHcint3Spec > { AckW :: new (self , 5) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& mut self) -> TxerrW < '_ , FsHcint3Spec > { TxerrW :: new (self , 7) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& mut self) -> BberrW < '_ , FsHcint3Spec > { BberrW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& mut self) -> FrmorW < '_ , FsHcint3Spec > { FrmorW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& mut self) -> DterrW < '_ , FsHcint3Spec > { DterrW :: new (self , 10) } }
#[doc = "OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcint3Spec ; impl crate :: RegisterSpec for FsHcint3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcint3::R`](R) reader structure"] impl crate :: Readable for FsHcint3Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcint3::W`](W) writer structure"] impl crate :: Writable for FsHcint3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINT3 to value 0"] impl crate :: Resettable for FsHcint3Spec { } }
#[doc = "FS_HCINT4 (rw) register accessor: OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcint4`] module"]
#[doc (alias = "FS_HCINT4")] pub type FsHcint4 = crate :: Reg < fs_hcint4 :: FsHcint4Spec > ;
#[doc = "OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)"] pub mod fs_hcint4 {
#[doc = "Register `FS_HCINT4` reader"] pub type R = crate :: R < FsHcint4Spec > ;
#[doc = "Register `FS_HCINT4` writer"] pub type W = crate :: W < FsHcint4Spec > ;
#[doc = "Field `XFRC` reader - Transfer completed"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - Transfer completed"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHH` reader - Channel halted"] pub type ChhR = crate :: BitReader ;
#[doc = "Field `CHH` writer - Channel halted"] pub type ChhW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALL` reader - STALL response received interrupt"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL response received interrupt"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAK` reader - NAK response received interrupt"] pub type NakR = crate :: BitReader ;
#[doc = "Field `NAK` writer - NAK response received interrupt"] pub type NakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERR` reader - Transaction error"] pub type TxerrR = crate :: BitReader ;
#[doc = "Field `TXERR` writer - Transaction error"] pub type TxerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERR` reader - Babble error"] pub type BberrR = crate :: BitReader ;
#[doc = "Field `BBERR` writer - Babble error"] pub type BberrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMOR` reader - Frame overrun"] pub type FrmorR = crate :: BitReader ;
#[doc = "Field `FRMOR` writer - Frame overrun"] pub type FrmorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERR` reader - Data toggle error"] pub type DterrR = crate :: BitReader ;
#[doc = "Field `DTERR` writer - Data toggle error"] pub type DterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& self) -> ChhR { ChhR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& self) -> NakR { NakR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& self) -> TxerrR { TxerrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& self) -> BberrR { BberrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& self) -> FrmorR { FrmorR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& self) -> DterrR { DterrR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , FsHcint4Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& mut self) -> ChhW < '_ , FsHcint4Spec > { ChhW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsHcint4Spec > { StallW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& mut self) -> NakW < '_ , FsHcint4Spec > { NakW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , FsHcint4Spec > { AckW :: new (self , 5) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& mut self) -> TxerrW < '_ , FsHcint4Spec > { TxerrW :: new (self , 7) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& mut self) -> BberrW < '_ , FsHcint4Spec > { BberrW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& mut self) -> FrmorW < '_ , FsHcint4Spec > { FrmorW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& mut self) -> DterrW < '_ , FsHcint4Spec > { DterrW :: new (self , 10) } }
#[doc = "OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcint4Spec ; impl crate :: RegisterSpec for FsHcint4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcint4::R`](R) reader structure"] impl crate :: Readable for FsHcint4Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcint4::W`](W) writer structure"] impl crate :: Writable for FsHcint4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINT4 to value 0"] impl crate :: Resettable for FsHcint4Spec { } }
#[doc = "FS_HCINT5 (rw) register accessor: OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcint5`] module"]
#[doc (alias = "FS_HCINT5")] pub type FsHcint5 = crate :: Reg < fs_hcint5 :: FsHcint5Spec > ;
#[doc = "OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)"] pub mod fs_hcint5 {
#[doc = "Register `FS_HCINT5` reader"] pub type R = crate :: R < FsHcint5Spec > ;
#[doc = "Register `FS_HCINT5` writer"] pub type W = crate :: W < FsHcint5Spec > ;
#[doc = "Field `XFRC` reader - Transfer completed"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - Transfer completed"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHH` reader - Channel halted"] pub type ChhR = crate :: BitReader ;
#[doc = "Field `CHH` writer - Channel halted"] pub type ChhW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALL` reader - STALL response received interrupt"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL response received interrupt"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAK` reader - NAK response received interrupt"] pub type NakR = crate :: BitReader ;
#[doc = "Field `NAK` writer - NAK response received interrupt"] pub type NakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERR` reader - Transaction error"] pub type TxerrR = crate :: BitReader ;
#[doc = "Field `TXERR` writer - Transaction error"] pub type TxerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERR` reader - Babble error"] pub type BberrR = crate :: BitReader ;
#[doc = "Field `BBERR` writer - Babble error"] pub type BberrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMOR` reader - Frame overrun"] pub type FrmorR = crate :: BitReader ;
#[doc = "Field `FRMOR` writer - Frame overrun"] pub type FrmorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERR` reader - Data toggle error"] pub type DterrR = crate :: BitReader ;
#[doc = "Field `DTERR` writer - Data toggle error"] pub type DterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& self) -> ChhR { ChhR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& self) -> NakR { NakR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& self) -> TxerrR { TxerrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& self) -> BberrR { BberrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& self) -> FrmorR { FrmorR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& self) -> DterrR { DterrR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , FsHcint5Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& mut self) -> ChhW < '_ , FsHcint5Spec > { ChhW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsHcint5Spec > { StallW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& mut self) -> NakW < '_ , FsHcint5Spec > { NakW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , FsHcint5Spec > { AckW :: new (self , 5) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& mut self) -> TxerrW < '_ , FsHcint5Spec > { TxerrW :: new (self , 7) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& mut self) -> BberrW < '_ , FsHcint5Spec > { BberrW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& mut self) -> FrmorW < '_ , FsHcint5Spec > { FrmorW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& mut self) -> DterrW < '_ , FsHcint5Spec > { DterrW :: new (self , 10) } }
#[doc = "OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcint5Spec ; impl crate :: RegisterSpec for FsHcint5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcint5::R`](R) reader structure"] impl crate :: Readable for FsHcint5Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcint5::W`](W) writer structure"] impl crate :: Writable for FsHcint5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINT5 to value 0"] impl crate :: Resettable for FsHcint5Spec { } }
#[doc = "FS_HCINT6 (rw) register accessor: OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcint6`] module"]
#[doc (alias = "FS_HCINT6")] pub type FsHcint6 = crate :: Reg < fs_hcint6 :: FsHcint6Spec > ;
#[doc = "OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)"] pub mod fs_hcint6 {
#[doc = "Register `FS_HCINT6` reader"] pub type R = crate :: R < FsHcint6Spec > ;
#[doc = "Register `FS_HCINT6` writer"] pub type W = crate :: W < FsHcint6Spec > ;
#[doc = "Field `XFRC` reader - Transfer completed"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - Transfer completed"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHH` reader - Channel halted"] pub type ChhR = crate :: BitReader ;
#[doc = "Field `CHH` writer - Channel halted"] pub type ChhW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALL` reader - STALL response received interrupt"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL response received interrupt"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAK` reader - NAK response received interrupt"] pub type NakR = crate :: BitReader ;
#[doc = "Field `NAK` writer - NAK response received interrupt"] pub type NakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERR` reader - Transaction error"] pub type TxerrR = crate :: BitReader ;
#[doc = "Field `TXERR` writer - Transaction error"] pub type TxerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERR` reader - Babble error"] pub type BberrR = crate :: BitReader ;
#[doc = "Field `BBERR` writer - Babble error"] pub type BberrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMOR` reader - Frame overrun"] pub type FrmorR = crate :: BitReader ;
#[doc = "Field `FRMOR` writer - Frame overrun"] pub type FrmorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERR` reader - Data toggle error"] pub type DterrR = crate :: BitReader ;
#[doc = "Field `DTERR` writer - Data toggle error"] pub type DterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& self) -> ChhR { ChhR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& self) -> NakR { NakR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& self) -> TxerrR { TxerrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& self) -> BberrR { BberrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& self) -> FrmorR { FrmorR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& self) -> DterrR { DterrR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , FsHcint6Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& mut self) -> ChhW < '_ , FsHcint6Spec > { ChhW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsHcint6Spec > { StallW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& mut self) -> NakW < '_ , FsHcint6Spec > { NakW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , FsHcint6Spec > { AckW :: new (self , 5) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& mut self) -> TxerrW < '_ , FsHcint6Spec > { TxerrW :: new (self , 7) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& mut self) -> BberrW < '_ , FsHcint6Spec > { BberrW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& mut self) -> FrmorW < '_ , FsHcint6Spec > { FrmorW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& mut self) -> DterrW < '_ , FsHcint6Spec > { DterrW :: new (self , 10) } }
#[doc = "OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcint6Spec ; impl crate :: RegisterSpec for FsHcint6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcint6::R`](R) reader structure"] impl crate :: Readable for FsHcint6Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcint6::W`](W) writer structure"] impl crate :: Writable for FsHcint6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINT6 to value 0"] impl crate :: Resettable for FsHcint6Spec { } }
#[doc = "FS_HCINT7 (rw) register accessor: OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcint7`] module"]
#[doc (alias = "FS_HCINT7")] pub type FsHcint7 = crate :: Reg < fs_hcint7 :: FsHcint7Spec > ;
#[doc = "OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)"] pub mod fs_hcint7 {
#[doc = "Register `FS_HCINT7` reader"] pub type R = crate :: R < FsHcint7Spec > ;
#[doc = "Register `FS_HCINT7` writer"] pub type W = crate :: W < FsHcint7Spec > ;
#[doc = "Field `XFRC` reader - Transfer completed"] pub type XfrcR = crate :: BitReader ;
#[doc = "Field `XFRC` writer - Transfer completed"] pub type XfrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHH` reader - Channel halted"] pub type ChhR = crate :: BitReader ;
#[doc = "Field `CHH` writer - Channel halted"] pub type ChhW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALL` reader - STALL response received interrupt"] pub type StallR = crate :: BitReader ;
#[doc = "Field `STALL` writer - STALL response received interrupt"] pub type StallW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAK` reader - NAK response received interrupt"] pub type NakR = crate :: BitReader ;
#[doc = "Field `NAK` writer - NAK response received interrupt"] pub type NakW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - ACK response received/transmitted interrupt"] pub type AckR = crate :: BitReader ;
#[doc = "Field `ACK` writer - ACK response received/transmitted interrupt"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERR` reader - Transaction error"] pub type TxerrR = crate :: BitReader ;
#[doc = "Field `TXERR` writer - Transaction error"] pub type TxerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERR` reader - Babble error"] pub type BberrR = crate :: BitReader ;
#[doc = "Field `BBERR` writer - Babble error"] pub type BberrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMOR` reader - Frame overrun"] pub type FrmorR = crate :: BitReader ;
#[doc = "Field `FRMOR` writer - Frame overrun"] pub type FrmorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERR` reader - Data toggle error"] pub type DterrR = crate :: BitReader ;
#[doc = "Field `DTERR` writer - Data toggle error"] pub type DterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& self) -> XfrcR { XfrcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& self) -> ChhR { ChhR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& self) -> StallR { StallR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& self) -> NakR { NakR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& self) -> TxerrR { TxerrR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& self) -> BberrR { BberrR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& self) -> FrmorR { FrmorR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& self) -> DterrR { DterrR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed"]
#[inline (always)] pub fn xfrc (& mut self) -> XfrcW < '_ , FsHcint7Spec > { XfrcW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted"]
#[inline (always)] pub fn chh (& mut self) -> ChhW < '_ , FsHcint7Spec > { ChhW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt"]
#[inline (always)] pub fn stall (& mut self) -> StallW < '_ , FsHcint7Spec > { StallW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt"]
#[inline (always)] pub fn nak (& mut self) -> NakW < '_ , FsHcint7Spec > { NakW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt"]
#[inline (always)] pub fn ack (& mut self) -> AckW < '_ , FsHcint7Spec > { AckW :: new (self , 5) }
#[doc = "Bit 7 - Transaction error"]
#[inline (always)] pub fn txerr (& mut self) -> TxerrW < '_ , FsHcint7Spec > { TxerrW :: new (self , 7) }
#[doc = "Bit 8 - Babble error"]
#[inline (always)] pub fn bberr (& mut self) -> BberrW < '_ , FsHcint7Spec > { BberrW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun"]
#[inline (always)] pub fn frmor (& mut self) -> FrmorW < '_ , FsHcint7Spec > { FrmorW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error"]
#[inline (always)] pub fn dterr (& mut self) -> DterrW < '_ , FsHcint7Spec > { DterrW :: new (self , 10) } }
#[doc = "OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcint7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcint7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcint7Spec ; impl crate :: RegisterSpec for FsHcint7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcint7::R`](R) reader structure"] impl crate :: Readable for FsHcint7Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcint7::W`](W) writer structure"] impl crate :: Writable for FsHcint7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINT7 to value 0"] impl crate :: Resettable for FsHcint7Spec { } }
#[doc = "FS_HCINTMSK0 (rw) register accessor: OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcintmsk0`] module"]
#[doc (alias = "FS_HCINTMSK0")] pub type FsHcintmsk0 = crate :: Reg < fs_hcintmsk0 :: FsHcintmsk0Spec > ;
#[doc = "OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)"] pub mod fs_hcintmsk0 {
#[doc = "Register `FS_HCINTMSK0` reader"] pub type R = crate :: R < FsHcintmsk0Spec > ;
#[doc = "Register `FS_HCINTMSK0` writer"] pub type W = crate :: W < FsHcintmsk0Spec > ;
#[doc = "Field `XFRCM` reader - Transfer completed mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHHM` reader - Channel halted mask"] pub type ChhmR = crate :: BitReader ;
#[doc = "Field `CHHM` writer - Channel halted mask"] pub type ChhmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALLM` reader - STALL response received interrupt mask"] pub type StallmR = crate :: BitReader ;
#[doc = "Field `STALLM` writer - STALL response received interrupt mask"] pub type StallmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAKM` reader - NAK response received interrupt mask"] pub type NakmR = crate :: BitReader ;
#[doc = "Field `NAKM` writer - NAK response received interrupt mask"] pub type NakmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"] pub type AckmR = crate :: BitReader ;
#[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"] pub type AckmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NYET` reader - response received interrupt mask"] pub type NyetR = crate :: BitReader ;
#[doc = "Field `NYET` writer - response received interrupt mask"] pub type NyetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERRM` reader - Transaction error mask"] pub type TxerrmR = crate :: BitReader ;
#[doc = "Field `TXERRM` writer - Transaction error mask"] pub type TxerrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERRM` reader - Babble error mask"] pub type BberrmR = crate :: BitReader ;
#[doc = "Field `BBERRM` writer - Babble error mask"] pub type BberrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMORM` reader - Frame overrun mask"] pub type FrmormR = crate :: BitReader ;
#[doc = "Field `FRMORM` writer - Frame overrun mask"] pub type FrmormW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERRM` reader - Data toggle error mask"] pub type DterrmR = crate :: BitReader ;
#[doc = "Field `DTERRM` writer - Data toggle error mask"] pub type DterrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& self) -> ChhmR { ChhmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& self) -> StallmR { StallmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& self) -> NakmR { NakmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& self) -> AckmR { AckmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& self) -> NyetR { NyetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& self) -> TxerrmR { TxerrmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& self) -> BberrmR { BberrmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& self) -> FrmormR { FrmormR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& self) -> DterrmR { DterrmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsHcintmsk0Spec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& mut self) -> ChhmW < '_ , FsHcintmsk0Spec > { ChhmW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& mut self) -> StallmW < '_ , FsHcintmsk0Spec > { StallmW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& mut self) -> NakmW < '_ , FsHcintmsk0Spec > { NakmW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& mut self) -> AckmW < '_ , FsHcintmsk0Spec > { AckmW :: new (self , 5) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& mut self) -> NyetW < '_ , FsHcintmsk0Spec > { NyetW :: new (self , 6) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& mut self) -> TxerrmW < '_ , FsHcintmsk0Spec > { TxerrmW :: new (self , 7) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& mut self) -> BberrmW < '_ , FsHcintmsk0Spec > { BberrmW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& mut self) -> FrmormW < '_ , FsHcintmsk0Spec > { FrmormW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& mut self) -> DterrmW < '_ , FsHcintmsk0Spec > { DterrmW :: new (self , 10) } }
#[doc = "OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcintmsk0Spec ; impl crate :: RegisterSpec for FsHcintmsk0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcintmsk0::R`](R) reader structure"] impl crate :: Readable for FsHcintmsk0Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcintmsk0::W`](W) writer structure"] impl crate :: Writable for FsHcintmsk0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINTMSK0 to value 0"] impl crate :: Resettable for FsHcintmsk0Spec { } }
#[doc = "FS_HCINTMSK1 (rw) register accessor: OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcintmsk1`] module"]
#[doc (alias = "FS_HCINTMSK1")] pub type FsHcintmsk1 = crate :: Reg < fs_hcintmsk1 :: FsHcintmsk1Spec > ;
#[doc = "OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)"] pub mod fs_hcintmsk1 {
#[doc = "Register `FS_HCINTMSK1` reader"] pub type R = crate :: R < FsHcintmsk1Spec > ;
#[doc = "Register `FS_HCINTMSK1` writer"] pub type W = crate :: W < FsHcintmsk1Spec > ;
#[doc = "Field `XFRCM` reader - Transfer completed mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHHM` reader - Channel halted mask"] pub type ChhmR = crate :: BitReader ;
#[doc = "Field `CHHM` writer - Channel halted mask"] pub type ChhmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALLM` reader - STALL response received interrupt mask"] pub type StallmR = crate :: BitReader ;
#[doc = "Field `STALLM` writer - STALL response received interrupt mask"] pub type StallmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAKM` reader - NAK response received interrupt mask"] pub type NakmR = crate :: BitReader ;
#[doc = "Field `NAKM` writer - NAK response received interrupt mask"] pub type NakmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"] pub type AckmR = crate :: BitReader ;
#[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"] pub type AckmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NYET` reader - response received interrupt mask"] pub type NyetR = crate :: BitReader ;
#[doc = "Field `NYET` writer - response received interrupt mask"] pub type NyetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERRM` reader - Transaction error mask"] pub type TxerrmR = crate :: BitReader ;
#[doc = "Field `TXERRM` writer - Transaction error mask"] pub type TxerrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERRM` reader - Babble error mask"] pub type BberrmR = crate :: BitReader ;
#[doc = "Field `BBERRM` writer - Babble error mask"] pub type BberrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMORM` reader - Frame overrun mask"] pub type FrmormR = crate :: BitReader ;
#[doc = "Field `FRMORM` writer - Frame overrun mask"] pub type FrmormW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERRM` reader - Data toggle error mask"] pub type DterrmR = crate :: BitReader ;
#[doc = "Field `DTERRM` writer - Data toggle error mask"] pub type DterrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& self) -> ChhmR { ChhmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& self) -> StallmR { StallmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& self) -> NakmR { NakmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& self) -> AckmR { AckmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& self) -> NyetR { NyetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& self) -> TxerrmR { TxerrmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& self) -> BberrmR { BberrmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& self) -> FrmormR { FrmormR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& self) -> DterrmR { DterrmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsHcintmsk1Spec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& mut self) -> ChhmW < '_ , FsHcintmsk1Spec > { ChhmW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& mut self) -> StallmW < '_ , FsHcintmsk1Spec > { StallmW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& mut self) -> NakmW < '_ , FsHcintmsk1Spec > { NakmW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& mut self) -> AckmW < '_ , FsHcintmsk1Spec > { AckmW :: new (self , 5) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& mut self) -> NyetW < '_ , FsHcintmsk1Spec > { NyetW :: new (self , 6) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& mut self) -> TxerrmW < '_ , FsHcintmsk1Spec > { TxerrmW :: new (self , 7) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& mut self) -> BberrmW < '_ , FsHcintmsk1Spec > { BberrmW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& mut self) -> FrmormW < '_ , FsHcintmsk1Spec > { FrmormW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& mut self) -> DterrmW < '_ , FsHcintmsk1Spec > { DterrmW :: new (self , 10) } }
#[doc = "OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcintmsk1Spec ; impl crate :: RegisterSpec for FsHcintmsk1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcintmsk1::R`](R) reader structure"] impl crate :: Readable for FsHcintmsk1Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcintmsk1::W`](W) writer structure"] impl crate :: Writable for FsHcintmsk1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINTMSK1 to value 0"] impl crate :: Resettable for FsHcintmsk1Spec { } }
#[doc = "FS_HCINTMSK2 (rw) register accessor: OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcintmsk2`] module"]
#[doc (alias = "FS_HCINTMSK2")] pub type FsHcintmsk2 = crate :: Reg < fs_hcintmsk2 :: FsHcintmsk2Spec > ;
#[doc = "OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)"] pub mod fs_hcintmsk2 {
#[doc = "Register `FS_HCINTMSK2` reader"] pub type R = crate :: R < FsHcintmsk2Spec > ;
#[doc = "Register `FS_HCINTMSK2` writer"] pub type W = crate :: W < FsHcintmsk2Spec > ;
#[doc = "Field `XFRCM` reader - Transfer completed mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHHM` reader - Channel halted mask"] pub type ChhmR = crate :: BitReader ;
#[doc = "Field `CHHM` writer - Channel halted mask"] pub type ChhmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALLM` reader - STALL response received interrupt mask"] pub type StallmR = crate :: BitReader ;
#[doc = "Field `STALLM` writer - STALL response received interrupt mask"] pub type StallmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAKM` reader - NAK response received interrupt mask"] pub type NakmR = crate :: BitReader ;
#[doc = "Field `NAKM` writer - NAK response received interrupt mask"] pub type NakmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"] pub type AckmR = crate :: BitReader ;
#[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"] pub type AckmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NYET` reader - response received interrupt mask"] pub type NyetR = crate :: BitReader ;
#[doc = "Field `NYET` writer - response received interrupt mask"] pub type NyetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERRM` reader - Transaction error mask"] pub type TxerrmR = crate :: BitReader ;
#[doc = "Field `TXERRM` writer - Transaction error mask"] pub type TxerrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERRM` reader - Babble error mask"] pub type BberrmR = crate :: BitReader ;
#[doc = "Field `BBERRM` writer - Babble error mask"] pub type BberrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMORM` reader - Frame overrun mask"] pub type FrmormR = crate :: BitReader ;
#[doc = "Field `FRMORM` writer - Frame overrun mask"] pub type FrmormW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERRM` reader - Data toggle error mask"] pub type DterrmR = crate :: BitReader ;
#[doc = "Field `DTERRM` writer - Data toggle error mask"] pub type DterrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& self) -> ChhmR { ChhmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& self) -> StallmR { StallmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& self) -> NakmR { NakmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& self) -> AckmR { AckmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& self) -> NyetR { NyetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& self) -> TxerrmR { TxerrmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& self) -> BberrmR { BberrmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& self) -> FrmormR { FrmormR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& self) -> DterrmR { DterrmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsHcintmsk2Spec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& mut self) -> ChhmW < '_ , FsHcintmsk2Spec > { ChhmW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& mut self) -> StallmW < '_ , FsHcintmsk2Spec > { StallmW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& mut self) -> NakmW < '_ , FsHcintmsk2Spec > { NakmW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& mut self) -> AckmW < '_ , FsHcintmsk2Spec > { AckmW :: new (self , 5) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& mut self) -> NyetW < '_ , FsHcintmsk2Spec > { NyetW :: new (self , 6) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& mut self) -> TxerrmW < '_ , FsHcintmsk2Spec > { TxerrmW :: new (self , 7) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& mut self) -> BberrmW < '_ , FsHcintmsk2Spec > { BberrmW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& mut self) -> FrmormW < '_ , FsHcintmsk2Spec > { FrmormW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& mut self) -> DterrmW < '_ , FsHcintmsk2Spec > { DterrmW :: new (self , 10) } }
#[doc = "OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcintmsk2Spec ; impl crate :: RegisterSpec for FsHcintmsk2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcintmsk2::R`](R) reader structure"] impl crate :: Readable for FsHcintmsk2Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcintmsk2::W`](W) writer structure"] impl crate :: Writable for FsHcintmsk2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINTMSK2 to value 0"] impl crate :: Resettable for FsHcintmsk2Spec { } }
#[doc = "FS_HCINTMSK3 (rw) register accessor: OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcintmsk3`] module"]
#[doc (alias = "FS_HCINTMSK3")] pub type FsHcintmsk3 = crate :: Reg < fs_hcintmsk3 :: FsHcintmsk3Spec > ;
#[doc = "OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)"] pub mod fs_hcintmsk3 {
#[doc = "Register `FS_HCINTMSK3` reader"] pub type R = crate :: R < FsHcintmsk3Spec > ;
#[doc = "Register `FS_HCINTMSK3` writer"] pub type W = crate :: W < FsHcintmsk3Spec > ;
#[doc = "Field `XFRCM` reader - Transfer completed mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHHM` reader - Channel halted mask"] pub type ChhmR = crate :: BitReader ;
#[doc = "Field `CHHM` writer - Channel halted mask"] pub type ChhmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALLM` reader - STALL response received interrupt mask"] pub type StallmR = crate :: BitReader ;
#[doc = "Field `STALLM` writer - STALL response received interrupt mask"] pub type StallmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAKM` reader - NAK response received interrupt mask"] pub type NakmR = crate :: BitReader ;
#[doc = "Field `NAKM` writer - NAK response received interrupt mask"] pub type NakmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"] pub type AckmR = crate :: BitReader ;
#[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"] pub type AckmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NYET` reader - response received interrupt mask"] pub type NyetR = crate :: BitReader ;
#[doc = "Field `NYET` writer - response received interrupt mask"] pub type NyetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERRM` reader - Transaction error mask"] pub type TxerrmR = crate :: BitReader ;
#[doc = "Field `TXERRM` writer - Transaction error mask"] pub type TxerrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERRM` reader - Babble error mask"] pub type BberrmR = crate :: BitReader ;
#[doc = "Field `BBERRM` writer - Babble error mask"] pub type BberrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMORM` reader - Frame overrun mask"] pub type FrmormR = crate :: BitReader ;
#[doc = "Field `FRMORM` writer - Frame overrun mask"] pub type FrmormW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERRM` reader - Data toggle error mask"] pub type DterrmR = crate :: BitReader ;
#[doc = "Field `DTERRM` writer - Data toggle error mask"] pub type DterrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& self) -> ChhmR { ChhmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& self) -> StallmR { StallmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& self) -> NakmR { NakmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& self) -> AckmR { AckmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& self) -> NyetR { NyetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& self) -> TxerrmR { TxerrmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& self) -> BberrmR { BberrmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& self) -> FrmormR { FrmormR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& self) -> DterrmR { DterrmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsHcintmsk3Spec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& mut self) -> ChhmW < '_ , FsHcintmsk3Spec > { ChhmW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& mut self) -> StallmW < '_ , FsHcintmsk3Spec > { StallmW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& mut self) -> NakmW < '_ , FsHcintmsk3Spec > { NakmW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& mut self) -> AckmW < '_ , FsHcintmsk3Spec > { AckmW :: new (self , 5) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& mut self) -> NyetW < '_ , FsHcintmsk3Spec > { NyetW :: new (self , 6) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& mut self) -> TxerrmW < '_ , FsHcintmsk3Spec > { TxerrmW :: new (self , 7) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& mut self) -> BberrmW < '_ , FsHcintmsk3Spec > { BberrmW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& mut self) -> FrmormW < '_ , FsHcintmsk3Spec > { FrmormW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& mut self) -> DterrmW < '_ , FsHcintmsk3Spec > { DterrmW :: new (self , 10) } }
#[doc = "OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcintmsk3Spec ; impl crate :: RegisterSpec for FsHcintmsk3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcintmsk3::R`](R) reader structure"] impl crate :: Readable for FsHcintmsk3Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcintmsk3::W`](W) writer structure"] impl crate :: Writable for FsHcintmsk3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINTMSK3 to value 0"] impl crate :: Resettable for FsHcintmsk3Spec { } }
#[doc = "FS_HCINTMSK4 (rw) register accessor: OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcintmsk4`] module"]
#[doc (alias = "FS_HCINTMSK4")] pub type FsHcintmsk4 = crate :: Reg < fs_hcintmsk4 :: FsHcintmsk4Spec > ;
#[doc = "OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)"] pub mod fs_hcintmsk4 {
#[doc = "Register `FS_HCINTMSK4` reader"] pub type R = crate :: R < FsHcintmsk4Spec > ;
#[doc = "Register `FS_HCINTMSK4` writer"] pub type W = crate :: W < FsHcintmsk4Spec > ;
#[doc = "Field `XFRCM` reader - Transfer completed mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHHM` reader - Channel halted mask"] pub type ChhmR = crate :: BitReader ;
#[doc = "Field `CHHM` writer - Channel halted mask"] pub type ChhmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALLM` reader - STALL response received interrupt mask"] pub type StallmR = crate :: BitReader ;
#[doc = "Field `STALLM` writer - STALL response received interrupt mask"] pub type StallmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAKM` reader - NAK response received interrupt mask"] pub type NakmR = crate :: BitReader ;
#[doc = "Field `NAKM` writer - NAK response received interrupt mask"] pub type NakmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"] pub type AckmR = crate :: BitReader ;
#[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"] pub type AckmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NYET` reader - response received interrupt mask"] pub type NyetR = crate :: BitReader ;
#[doc = "Field `NYET` writer - response received interrupt mask"] pub type NyetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERRM` reader - Transaction error mask"] pub type TxerrmR = crate :: BitReader ;
#[doc = "Field `TXERRM` writer - Transaction error mask"] pub type TxerrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERRM` reader - Babble error mask"] pub type BberrmR = crate :: BitReader ;
#[doc = "Field `BBERRM` writer - Babble error mask"] pub type BberrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMORM` reader - Frame overrun mask"] pub type FrmormR = crate :: BitReader ;
#[doc = "Field `FRMORM` writer - Frame overrun mask"] pub type FrmormW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERRM` reader - Data toggle error mask"] pub type DterrmR = crate :: BitReader ;
#[doc = "Field `DTERRM` writer - Data toggle error mask"] pub type DterrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& self) -> ChhmR { ChhmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& self) -> StallmR { StallmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& self) -> NakmR { NakmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& self) -> AckmR { AckmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& self) -> NyetR { NyetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& self) -> TxerrmR { TxerrmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& self) -> BberrmR { BberrmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& self) -> FrmormR { FrmormR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& self) -> DterrmR { DterrmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsHcintmsk4Spec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& mut self) -> ChhmW < '_ , FsHcintmsk4Spec > { ChhmW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& mut self) -> StallmW < '_ , FsHcintmsk4Spec > { StallmW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& mut self) -> NakmW < '_ , FsHcintmsk4Spec > { NakmW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& mut self) -> AckmW < '_ , FsHcintmsk4Spec > { AckmW :: new (self , 5) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& mut self) -> NyetW < '_ , FsHcintmsk4Spec > { NyetW :: new (self , 6) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& mut self) -> TxerrmW < '_ , FsHcintmsk4Spec > { TxerrmW :: new (self , 7) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& mut self) -> BberrmW < '_ , FsHcintmsk4Spec > { BberrmW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& mut self) -> FrmormW < '_ , FsHcintmsk4Spec > { FrmormW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& mut self) -> DterrmW < '_ , FsHcintmsk4Spec > { DterrmW :: new (self , 10) } }
#[doc = "OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcintmsk4Spec ; impl crate :: RegisterSpec for FsHcintmsk4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcintmsk4::R`](R) reader structure"] impl crate :: Readable for FsHcintmsk4Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcintmsk4::W`](W) writer structure"] impl crate :: Writable for FsHcintmsk4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINTMSK4 to value 0"] impl crate :: Resettable for FsHcintmsk4Spec { } }
#[doc = "FS_HCINTMSK5 (rw) register accessor: OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcintmsk5`] module"]
#[doc (alias = "FS_HCINTMSK5")] pub type FsHcintmsk5 = crate :: Reg < fs_hcintmsk5 :: FsHcintmsk5Spec > ;
#[doc = "OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)"] pub mod fs_hcintmsk5 {
#[doc = "Register `FS_HCINTMSK5` reader"] pub type R = crate :: R < FsHcintmsk5Spec > ;
#[doc = "Register `FS_HCINTMSK5` writer"] pub type W = crate :: W < FsHcintmsk5Spec > ;
#[doc = "Field `XFRCM` reader - Transfer completed mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHHM` reader - Channel halted mask"] pub type ChhmR = crate :: BitReader ;
#[doc = "Field `CHHM` writer - Channel halted mask"] pub type ChhmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALLM` reader - STALL response received interrupt mask"] pub type StallmR = crate :: BitReader ;
#[doc = "Field `STALLM` writer - STALL response received interrupt mask"] pub type StallmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAKM` reader - NAK response received interrupt mask"] pub type NakmR = crate :: BitReader ;
#[doc = "Field `NAKM` writer - NAK response received interrupt mask"] pub type NakmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"] pub type AckmR = crate :: BitReader ;
#[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"] pub type AckmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NYET` reader - response received interrupt mask"] pub type NyetR = crate :: BitReader ;
#[doc = "Field `NYET` writer - response received interrupt mask"] pub type NyetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERRM` reader - Transaction error mask"] pub type TxerrmR = crate :: BitReader ;
#[doc = "Field `TXERRM` writer - Transaction error mask"] pub type TxerrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERRM` reader - Babble error mask"] pub type BberrmR = crate :: BitReader ;
#[doc = "Field `BBERRM` writer - Babble error mask"] pub type BberrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMORM` reader - Frame overrun mask"] pub type FrmormR = crate :: BitReader ;
#[doc = "Field `FRMORM` writer - Frame overrun mask"] pub type FrmormW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERRM` reader - Data toggle error mask"] pub type DterrmR = crate :: BitReader ;
#[doc = "Field `DTERRM` writer - Data toggle error mask"] pub type DterrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& self) -> ChhmR { ChhmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& self) -> StallmR { StallmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& self) -> NakmR { NakmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& self) -> AckmR { AckmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& self) -> NyetR { NyetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& self) -> TxerrmR { TxerrmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& self) -> BberrmR { BberrmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& self) -> FrmormR { FrmormR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& self) -> DterrmR { DterrmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsHcintmsk5Spec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& mut self) -> ChhmW < '_ , FsHcintmsk5Spec > { ChhmW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& mut self) -> StallmW < '_ , FsHcintmsk5Spec > { StallmW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& mut self) -> NakmW < '_ , FsHcintmsk5Spec > { NakmW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& mut self) -> AckmW < '_ , FsHcintmsk5Spec > { AckmW :: new (self , 5) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& mut self) -> NyetW < '_ , FsHcintmsk5Spec > { NyetW :: new (self , 6) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& mut self) -> TxerrmW < '_ , FsHcintmsk5Spec > { TxerrmW :: new (self , 7) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& mut self) -> BberrmW < '_ , FsHcintmsk5Spec > { BberrmW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& mut self) -> FrmormW < '_ , FsHcintmsk5Spec > { FrmormW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& mut self) -> DterrmW < '_ , FsHcintmsk5Spec > { DterrmW :: new (self , 10) } }
#[doc = "OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcintmsk5Spec ; impl crate :: RegisterSpec for FsHcintmsk5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcintmsk5::R`](R) reader structure"] impl crate :: Readable for FsHcintmsk5Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcintmsk5::W`](W) writer structure"] impl crate :: Writable for FsHcintmsk5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINTMSK5 to value 0"] impl crate :: Resettable for FsHcintmsk5Spec { } }
#[doc = "FS_HCINTMSK6 (rw) register accessor: OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcintmsk6`] module"]
#[doc (alias = "FS_HCINTMSK6")] pub type FsHcintmsk6 = crate :: Reg < fs_hcintmsk6 :: FsHcintmsk6Spec > ;
#[doc = "OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)"] pub mod fs_hcintmsk6 {
#[doc = "Register `FS_HCINTMSK6` reader"] pub type R = crate :: R < FsHcintmsk6Spec > ;
#[doc = "Register `FS_HCINTMSK6` writer"] pub type W = crate :: W < FsHcintmsk6Spec > ;
#[doc = "Field `XFRCM` reader - Transfer completed mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHHM` reader - Channel halted mask"] pub type ChhmR = crate :: BitReader ;
#[doc = "Field `CHHM` writer - Channel halted mask"] pub type ChhmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALLM` reader - STALL response received interrupt mask"] pub type StallmR = crate :: BitReader ;
#[doc = "Field `STALLM` writer - STALL response received interrupt mask"] pub type StallmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAKM` reader - NAK response received interrupt mask"] pub type NakmR = crate :: BitReader ;
#[doc = "Field `NAKM` writer - NAK response received interrupt mask"] pub type NakmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"] pub type AckmR = crate :: BitReader ;
#[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"] pub type AckmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NYET` reader - response received interrupt mask"] pub type NyetR = crate :: BitReader ;
#[doc = "Field `NYET` writer - response received interrupt mask"] pub type NyetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERRM` reader - Transaction error mask"] pub type TxerrmR = crate :: BitReader ;
#[doc = "Field `TXERRM` writer - Transaction error mask"] pub type TxerrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERRM` reader - Babble error mask"] pub type BberrmR = crate :: BitReader ;
#[doc = "Field `BBERRM` writer - Babble error mask"] pub type BberrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMORM` reader - Frame overrun mask"] pub type FrmormR = crate :: BitReader ;
#[doc = "Field `FRMORM` writer - Frame overrun mask"] pub type FrmormW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERRM` reader - Data toggle error mask"] pub type DterrmR = crate :: BitReader ;
#[doc = "Field `DTERRM` writer - Data toggle error mask"] pub type DterrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& self) -> ChhmR { ChhmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& self) -> StallmR { StallmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& self) -> NakmR { NakmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& self) -> AckmR { AckmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& self) -> NyetR { NyetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& self) -> TxerrmR { TxerrmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& self) -> BberrmR { BberrmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& self) -> FrmormR { FrmormR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& self) -> DterrmR { DterrmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsHcintmsk6Spec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& mut self) -> ChhmW < '_ , FsHcintmsk6Spec > { ChhmW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& mut self) -> StallmW < '_ , FsHcintmsk6Spec > { StallmW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& mut self) -> NakmW < '_ , FsHcintmsk6Spec > { NakmW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& mut self) -> AckmW < '_ , FsHcintmsk6Spec > { AckmW :: new (self , 5) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& mut self) -> NyetW < '_ , FsHcintmsk6Spec > { NyetW :: new (self , 6) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& mut self) -> TxerrmW < '_ , FsHcintmsk6Spec > { TxerrmW :: new (self , 7) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& mut self) -> BberrmW < '_ , FsHcintmsk6Spec > { BberrmW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& mut self) -> FrmormW < '_ , FsHcintmsk6Spec > { FrmormW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& mut self) -> DterrmW < '_ , FsHcintmsk6Spec > { DterrmW :: new (self , 10) } }
#[doc = "OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcintmsk6Spec ; impl crate :: RegisterSpec for FsHcintmsk6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcintmsk6::R`](R) reader structure"] impl crate :: Readable for FsHcintmsk6Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcintmsk6::W`](W) writer structure"] impl crate :: Writable for FsHcintmsk6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINTMSK6 to value 0"] impl crate :: Resettable for FsHcintmsk6Spec { } }
#[doc = "FS_HCINTMSK7 (rw) register accessor: OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hcintmsk7`] module"]
#[doc (alias = "FS_HCINTMSK7")] pub type FsHcintmsk7 = crate :: Reg < fs_hcintmsk7 :: FsHcintmsk7Spec > ;
#[doc = "OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)"] pub mod fs_hcintmsk7 {
#[doc = "Register `FS_HCINTMSK7` reader"] pub type R = crate :: R < FsHcintmsk7Spec > ;
#[doc = "Register `FS_HCINTMSK7` writer"] pub type W = crate :: W < FsHcintmsk7Spec > ;
#[doc = "Field `XFRCM` reader - Transfer completed mask"] pub type XfrcmR = crate :: BitReader ;
#[doc = "Field `XFRCM` writer - Transfer completed mask"] pub type XfrcmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHHM` reader - Channel halted mask"] pub type ChhmR = crate :: BitReader ;
#[doc = "Field `CHHM` writer - Channel halted mask"] pub type ChhmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STALLM` reader - STALL response received interrupt mask"] pub type StallmR = crate :: BitReader ;
#[doc = "Field `STALLM` writer - STALL response received interrupt mask"] pub type StallmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NAKM` reader - NAK response received interrupt mask"] pub type NakmR = crate :: BitReader ;
#[doc = "Field `NAKM` writer - NAK response received interrupt mask"] pub type NakmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACKM` reader - ACK response received/transmitted interrupt mask"] pub type AckmR = crate :: BitReader ;
#[doc = "Field `ACKM` writer - ACK response received/transmitted interrupt mask"] pub type AckmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NYET` reader - response received interrupt mask"] pub type NyetR = crate :: BitReader ;
#[doc = "Field `NYET` writer - response received interrupt mask"] pub type NyetW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXERRM` reader - Transaction error mask"] pub type TxerrmR = crate :: BitReader ;
#[doc = "Field `TXERRM` writer - Transaction error mask"] pub type TxerrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BBERRM` reader - Babble error mask"] pub type BberrmR = crate :: BitReader ;
#[doc = "Field `BBERRM` writer - Babble error mask"] pub type BberrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FRMORM` reader - Frame overrun mask"] pub type FrmormR = crate :: BitReader ;
#[doc = "Field `FRMORM` writer - Frame overrun mask"] pub type FrmormW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTERRM` reader - Data toggle error mask"] pub type DterrmR = crate :: BitReader ;
#[doc = "Field `DTERRM` writer - Data toggle error mask"] pub type DterrmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& self) -> XfrcmR { XfrcmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& self) -> ChhmR { ChhmR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& self) -> StallmR { StallmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& self) -> NakmR { NakmR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& self) -> AckmR { AckmR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& self) -> NyetR { NyetR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& self) -> TxerrmR { TxerrmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& self) -> BberrmR { BberrmR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& self) -> FrmormR { FrmormR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& self) -> DterrmR { DterrmR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transfer completed mask"]
#[inline (always)] pub fn xfrcm (& mut self) -> XfrcmW < '_ , FsHcintmsk7Spec > { XfrcmW :: new (self , 0) }
#[doc = "Bit 1 - Channel halted mask"]
#[inline (always)] pub fn chhm (& mut self) -> ChhmW < '_ , FsHcintmsk7Spec > { ChhmW :: new (self , 1) }
#[doc = "Bit 3 - STALL response received interrupt mask"]
#[inline (always)] pub fn stallm (& mut self) -> StallmW < '_ , FsHcintmsk7Spec > { StallmW :: new (self , 3) }
#[doc = "Bit 4 - NAK response received interrupt mask"]
#[inline (always)] pub fn nakm (& mut self) -> NakmW < '_ , FsHcintmsk7Spec > { NakmW :: new (self , 4) }
#[doc = "Bit 5 - ACK response received/transmitted interrupt mask"]
#[inline (always)] pub fn ackm (& mut self) -> AckmW < '_ , FsHcintmsk7Spec > { AckmW :: new (self , 5) }
#[doc = "Bit 6 - response received interrupt mask"]
#[inline (always)] pub fn nyet (& mut self) -> NyetW < '_ , FsHcintmsk7Spec > { NyetW :: new (self , 6) }
#[doc = "Bit 7 - Transaction error mask"]
#[inline (always)] pub fn txerrm (& mut self) -> TxerrmW < '_ , FsHcintmsk7Spec > { TxerrmW :: new (self , 7) }
#[doc = "Bit 8 - Babble error mask"]
#[inline (always)] pub fn bberrm (& mut self) -> BberrmW < '_ , FsHcintmsk7Spec > { BberrmW :: new (self , 8) }
#[doc = "Bit 9 - Frame overrun mask"]
#[inline (always)] pub fn frmorm (& mut self) -> FrmormW < '_ , FsHcintmsk7Spec > { FrmormW :: new (self , 9) }
#[doc = "Bit 10 - Data toggle error mask"]
#[inline (always)] pub fn dterrm (& mut self) -> DterrmW < '_ , FsHcintmsk7Spec > { DterrmW :: new (self , 10) } }
#[doc = "OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hcintmsk7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hcintmsk7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHcintmsk7Spec ; impl crate :: RegisterSpec for FsHcintmsk7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hcintmsk7::R`](R) reader structure"] impl crate :: Readable for FsHcintmsk7Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hcintmsk7::W`](W) writer structure"] impl crate :: Writable for FsHcintmsk7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCINTMSK7 to value 0"] impl crate :: Resettable for FsHcintmsk7Spec { } }
#[doc = "FS_HCTSIZ0 (rw) register accessor: OTG_FS host channel-0 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hctsiz0`] module"]
#[doc (alias = "FS_HCTSIZ0")] pub type FsHctsiz0 = crate :: Reg < fs_hctsiz0 :: FsHctsiz0Spec > ;
#[doc = "OTG_FS host channel-0 transfer size register"] pub mod fs_hctsiz0 {
#[doc = "Register `FS_HCTSIZ0` reader"] pub type R = crate :: R < FsHctsiz0Spec > ;
#[doc = "Register `FS_HCTSIZ0` writer"] pub type W = crate :: W < FsHctsiz0Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `DPID` writer - Data PID"] pub type DpidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , FsHctsiz0Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , FsHctsiz0Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& mut self) -> DpidW < '_ , FsHctsiz0Spec > { DpidW :: new (self , 29) } }
#[doc = "OTG_FS host channel-0 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHctsiz0Spec ; impl crate :: RegisterSpec for FsHctsiz0Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hctsiz0::R`](R) reader structure"] impl crate :: Readable for FsHctsiz0Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hctsiz0::W`](W) writer structure"] impl crate :: Writable for FsHctsiz0Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCTSIZ0 to value 0"] impl crate :: Resettable for FsHctsiz0Spec { } }
#[doc = "FS_HCTSIZ1 (rw) register accessor: OTG_FS host channel-1 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hctsiz1`] module"]
#[doc (alias = "FS_HCTSIZ1")] pub type FsHctsiz1 = crate :: Reg < fs_hctsiz1 :: FsHctsiz1Spec > ;
#[doc = "OTG_FS host channel-1 transfer size register"] pub mod fs_hctsiz1 {
#[doc = "Register `FS_HCTSIZ1` reader"] pub type R = crate :: R < FsHctsiz1Spec > ;
#[doc = "Register `FS_HCTSIZ1` writer"] pub type W = crate :: W < FsHctsiz1Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `DPID` writer - Data PID"] pub type DpidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , FsHctsiz1Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , FsHctsiz1Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& mut self) -> DpidW < '_ , FsHctsiz1Spec > { DpidW :: new (self , 29) } }
#[doc = "OTG_FS host channel-1 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHctsiz1Spec ; impl crate :: RegisterSpec for FsHctsiz1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hctsiz1::R`](R) reader structure"] impl crate :: Readable for FsHctsiz1Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hctsiz1::W`](W) writer structure"] impl crate :: Writable for FsHctsiz1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCTSIZ1 to value 0"] impl crate :: Resettable for FsHctsiz1Spec { } }
#[doc = "FS_HCTSIZ2 (rw) register accessor: OTG_FS host channel-2 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hctsiz2`] module"]
#[doc (alias = "FS_HCTSIZ2")] pub type FsHctsiz2 = crate :: Reg < fs_hctsiz2 :: FsHctsiz2Spec > ;
#[doc = "OTG_FS host channel-2 transfer size register"] pub mod fs_hctsiz2 {
#[doc = "Register `FS_HCTSIZ2` reader"] pub type R = crate :: R < FsHctsiz2Spec > ;
#[doc = "Register `FS_HCTSIZ2` writer"] pub type W = crate :: W < FsHctsiz2Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `DPID` writer - Data PID"] pub type DpidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , FsHctsiz2Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , FsHctsiz2Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& mut self) -> DpidW < '_ , FsHctsiz2Spec > { DpidW :: new (self , 29) } }
#[doc = "OTG_FS host channel-2 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHctsiz2Spec ; impl crate :: RegisterSpec for FsHctsiz2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hctsiz2::R`](R) reader structure"] impl crate :: Readable for FsHctsiz2Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hctsiz2::W`](W) writer structure"] impl crate :: Writable for FsHctsiz2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCTSIZ2 to value 0"] impl crate :: Resettable for FsHctsiz2Spec { } }
#[doc = "FS_HCTSIZ3 (rw) register accessor: OTG_FS host channel-3 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hctsiz3`] module"]
#[doc (alias = "FS_HCTSIZ3")] pub type FsHctsiz3 = crate :: Reg < fs_hctsiz3 :: FsHctsiz3Spec > ;
#[doc = "OTG_FS host channel-3 transfer size register"] pub mod fs_hctsiz3 {
#[doc = "Register `FS_HCTSIZ3` reader"] pub type R = crate :: R < FsHctsiz3Spec > ;
#[doc = "Register `FS_HCTSIZ3` writer"] pub type W = crate :: W < FsHctsiz3Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `DPID` writer - Data PID"] pub type DpidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , FsHctsiz3Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , FsHctsiz3Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& mut self) -> DpidW < '_ , FsHctsiz3Spec > { DpidW :: new (self , 29) } }
#[doc = "OTG_FS host channel-3 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHctsiz3Spec ; impl crate :: RegisterSpec for FsHctsiz3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hctsiz3::R`](R) reader structure"] impl crate :: Readable for FsHctsiz3Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hctsiz3::W`](W) writer structure"] impl crate :: Writable for FsHctsiz3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCTSIZ3 to value 0"] impl crate :: Resettable for FsHctsiz3Spec { } }
#[doc = "FS_HCTSIZ4 (rw) register accessor: OTG_FS host channel-x transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hctsiz4`] module"]
#[doc (alias = "FS_HCTSIZ4")] pub type FsHctsiz4 = crate :: Reg < fs_hctsiz4 :: FsHctsiz4Spec > ;
#[doc = "OTG_FS host channel-x transfer size register"] pub mod fs_hctsiz4 {
#[doc = "Register `FS_HCTSIZ4` reader"] pub type R = crate :: R < FsHctsiz4Spec > ;
#[doc = "Register `FS_HCTSIZ4` writer"] pub type W = crate :: W < FsHctsiz4Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `DPID` writer - Data PID"] pub type DpidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , FsHctsiz4Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , FsHctsiz4Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& mut self) -> DpidW < '_ , FsHctsiz4Spec > { DpidW :: new (self , 29) } }
#[doc = "OTG_FS host channel-x transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHctsiz4Spec ; impl crate :: RegisterSpec for FsHctsiz4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hctsiz4::R`](R) reader structure"] impl crate :: Readable for FsHctsiz4Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hctsiz4::W`](W) writer structure"] impl crate :: Writable for FsHctsiz4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCTSIZ4 to value 0"] impl crate :: Resettable for FsHctsiz4Spec { } }
#[doc = "FS_HCTSIZ5 (rw) register accessor: OTG_FS host channel-5 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hctsiz5`] module"]
#[doc (alias = "FS_HCTSIZ5")] pub type FsHctsiz5 = crate :: Reg < fs_hctsiz5 :: FsHctsiz5Spec > ;
#[doc = "OTG_FS host channel-5 transfer size register"] pub mod fs_hctsiz5 {
#[doc = "Register `FS_HCTSIZ5` reader"] pub type R = crate :: R < FsHctsiz5Spec > ;
#[doc = "Register `FS_HCTSIZ5` writer"] pub type W = crate :: W < FsHctsiz5Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `DPID` writer - Data PID"] pub type DpidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , FsHctsiz5Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , FsHctsiz5Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& mut self) -> DpidW < '_ , FsHctsiz5Spec > { DpidW :: new (self , 29) } }
#[doc = "OTG_FS host channel-5 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHctsiz5Spec ; impl crate :: RegisterSpec for FsHctsiz5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hctsiz5::R`](R) reader structure"] impl crate :: Readable for FsHctsiz5Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hctsiz5::W`](W) writer structure"] impl crate :: Writable for FsHctsiz5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCTSIZ5 to value 0"] impl crate :: Resettable for FsHctsiz5Spec { } }
#[doc = "FS_HCTSIZ6 (rw) register accessor: OTG_FS host channel-6 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hctsiz6`] module"]
#[doc (alias = "FS_HCTSIZ6")] pub type FsHctsiz6 = crate :: Reg < fs_hctsiz6 :: FsHctsiz6Spec > ;
#[doc = "OTG_FS host channel-6 transfer size register"] pub mod fs_hctsiz6 {
#[doc = "Register `FS_HCTSIZ6` reader"] pub type R = crate :: R < FsHctsiz6Spec > ;
#[doc = "Register `FS_HCTSIZ6` writer"] pub type W = crate :: W < FsHctsiz6Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `DPID` writer - Data PID"] pub type DpidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , FsHctsiz6Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , FsHctsiz6Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& mut self) -> DpidW < '_ , FsHctsiz6Spec > { DpidW :: new (self , 29) } }
#[doc = "OTG_FS host channel-6 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHctsiz6Spec ; impl crate :: RegisterSpec for FsHctsiz6Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hctsiz6::R`](R) reader structure"] impl crate :: Readable for FsHctsiz6Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hctsiz6::W`](W) writer structure"] impl crate :: Writable for FsHctsiz6Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCTSIZ6 to value 0"] impl crate :: Resettable for FsHctsiz6Spec { } }
#[doc = "FS_HCTSIZ7 (rw) register accessor: OTG_FS host channel-7 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_hctsiz7`] module"]
#[doc (alias = "FS_HCTSIZ7")] pub type FsHctsiz7 = crate :: Reg < fs_hctsiz7 :: FsHctsiz7Spec > ;
#[doc = "OTG_FS host channel-7 transfer size register"] pub mod fs_hctsiz7 {
#[doc = "Register `FS_HCTSIZ7` reader"] pub type R = crate :: R < FsHctsiz7Spec > ;
#[doc = "Register `FS_HCTSIZ7` writer"] pub type W = crate :: W < FsHctsiz7Spec > ;
#[doc = "Field `XFRSIZ` reader - Transfer size"] pub type XfrsizR = crate :: FieldReader < u32 > ;
#[doc = "Field `XFRSIZ` writer - Transfer size"] pub type XfrsizW < 'a , REG > = crate :: FieldWriter < 'a , REG , 19 , u32 > ;
#[doc = "Field `PKTCNT` reader - Packet count"] pub type PktcntR = crate :: FieldReader < u16 > ;
#[doc = "Field `PKTCNT` writer - Packet count"] pub type PktcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `DPID` reader - Data PID"] pub type DpidR = crate :: FieldReader ;
#[doc = "Field `DPID` writer - Data PID"] pub type DpidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& self) -> XfrsizR { XfrsizR :: new (self . bits & 0x0007_ffff) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& self) -> PktcntR { PktcntR :: new (((self . bits >> 19) & 0x03ff) as u16) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& self) -> DpidR { DpidR :: new (((self . bits >> 29) & 3) as u8) } } impl W {
#[doc = "Bits 0:18 - Transfer size"]
#[inline (always)] pub fn xfrsiz (& mut self) -> XfrsizW < '_ , FsHctsiz7Spec > { XfrsizW :: new (self , 0) }
#[doc = "Bits 19:28 - Packet count"]
#[inline (always)] pub fn pktcnt (& mut self) -> PktcntW < '_ , FsHctsiz7Spec > { PktcntW :: new (self , 19) }
#[doc = "Bits 29:30 - Data PID"]
#[inline (always)] pub fn dpid (& mut self) -> DpidW < '_ , FsHctsiz7Spec > { DpidW :: new (self , 29) } }
#[doc = "OTG_FS host channel-7 transfer size register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_hctsiz7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_hctsiz7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsHctsiz7Spec ; impl crate :: RegisterSpec for FsHctsiz7Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_hctsiz7::R`](R) reader structure"] impl crate :: Readable for FsHctsiz7Spec { }
#[doc = "`write(|w| ..)` method takes [`fs_hctsiz7::W`](W) writer structure"] impl crate :: Writable for FsHctsiz7Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_HCTSIZ7 to value 0"] impl crate :: Resettable for FsHctsiz7Spec { } } }
#[doc = "USB on the go full speed"] pub type OtgFsPwrclk = crate :: Periph < otg_fs_pwrclk :: RegisterBlock , 0x5000_0e00 > ; impl core :: fmt :: Debug for OtgFsPwrclk { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgFsPwrclk") . finish () } }
#[doc = "USB on the go full speed"] pub mod otg_fs_pwrclk {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { fs_pcgcctl : FsPcgcctl , } impl RegisterBlock {
#[doc = "0x00 - OTG_FS power and clock gating control register"]
#[inline (always)] pub const fn fs_pcgcctl (& self) -> & FsPcgcctl { & self . fs_pcgcctl } }
#[doc = "FS_PCGCCTL (rw) register accessor: OTG_FS power and clock gating control register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_pcgcctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_pcgcctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fs_pcgcctl`] module"]
#[doc (alias = "FS_PCGCCTL")] pub type FsPcgcctl = crate :: Reg < fs_pcgcctl :: FsPcgcctlSpec > ;
#[doc = "OTG_FS power and clock gating control register"] pub mod fs_pcgcctl {
#[doc = "Register `FS_PCGCCTL` reader"] pub type R = crate :: R < FsPcgcctlSpec > ;
#[doc = "Register `FS_PCGCCTL` writer"] pub type W = crate :: W < FsPcgcctlSpec > ;
#[doc = "Field `STPPCLK` reader - Stop PHY clock"] pub type StppclkR = crate :: BitReader ;
#[doc = "Field `STPPCLK` writer - Stop PHY clock"] pub type StppclkW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GATEHCLK` reader - Gate HCLK"] pub type GatehclkR = crate :: BitReader ;
#[doc = "Field `GATEHCLK` writer - Gate HCLK"] pub type GatehclkW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PHYSUSP` reader - PHY Suspended"] pub type PhysuspR = crate :: BitReader ;
#[doc = "Field `PHYSUSP` writer - PHY Suspended"] pub type PhysuspW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Stop PHY clock"]
#[inline (always)] pub fn stppclk (& self) -> StppclkR { StppclkR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Gate HCLK"]
#[inline (always)] pub fn gatehclk (& self) -> GatehclkR { GatehclkR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 4 - PHY Suspended"]
#[inline (always)] pub fn physusp (& self) -> PhysuspR { PhysuspR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Stop PHY clock"]
#[inline (always)] pub fn stppclk (& mut self) -> StppclkW < '_ , FsPcgcctlSpec > { StppclkW :: new (self , 0) }
#[doc = "Bit 1 - Gate HCLK"]
#[inline (always)] pub fn gatehclk (& mut self) -> GatehclkW < '_ , FsPcgcctlSpec > { GatehclkW :: new (self , 1) }
#[doc = "Bit 4 - PHY Suspended"]
#[inline (always)] pub fn physusp (& mut self) -> PhysuspW < '_ , FsPcgcctlSpec > { PhysuspW :: new (self , 4) } }
#[doc = "OTG_FS power and clock gating control register\n\nYou can [`read`](crate::Reg::read) this register and get [`fs_pcgcctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fs_pcgcctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FsPcgcctlSpec ; impl crate :: RegisterSpec for FsPcgcctlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fs_pcgcctl::R`](R) reader structure"] impl crate :: Readable for FsPcgcctlSpec { }
#[doc = "`write(|w| ..)` method takes [`fs_pcgcctl::W`](W) writer structure"] impl crate :: Writable for FsPcgcctlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FS_PCGCCTL to value 0"] impl crate :: Resettable for FsPcgcctlSpec { } } }
#[doc = "Ethernet: MAC management counters"] pub type EthernetMmc = crate :: Periph < ethernet_mmc :: RegisterBlock , 0x4002_8100 > ; impl core :: fmt :: Debug for EthernetMmc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EthernetMmc") . finish () } }
#[doc = "Ethernet: MAC management counters"] pub mod ethernet_mmc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { mmccr : Mmccr , mmcrir : Mmcrir , mmctir : Mmctir , mmcrimr : Mmcrimr , mmctimr : Mmctimr , _reserved5 : [u8 ; 0x38] , mmctgfsccr : Mmctgfsccr , mmctgfmsccr : Mmctgfmsccr , _reserved7 : [u8 ; 0x14] , mmctgfcr : Mmctgfcr , _reserved8 : [u8 ; 0x28] , mmcrfcecr : Mmcrfcecr , mmcrfaecr : Mmcrfaecr , _reserved10 : [u8 ; 0x28] , mmcrgufcr : Mmcrgufcr , } impl RegisterBlock {
#[doc = "0x00 - Ethernet MMC control register (ETH_MMCCR)"]
#[inline (always)] pub const fn mmccr (& self) -> & Mmccr { & self . mmccr }
#[doc = "0x04 - Ethernet MMC receive interrupt register (ETH_MMCRIR)"]
#[inline (always)] pub const fn mmcrir (& self) -> & Mmcrir { & self . mmcrir }
#[doc = "0x08 - Ethernet MMC transmit interrupt register (ETH_MMCTIR)"]
#[inline (always)] pub const fn mmctir (& self) -> & Mmctir { & self . mmctir }
#[doc = "0x0c - Ethernet MMC receive interrupt mask register (ETH_MMCRIMR)"]
#[inline (always)] pub const fn mmcrimr (& self) -> & Mmcrimr { & self . mmcrimr }
#[doc = "0x10 - Ethernet MMC transmit interrupt mask register (ETH_MMCTIMR)"]
#[inline (always)] pub const fn mmctimr (& self) -> & Mmctimr { & self . mmctimr }
#[doc = "0x4c - Ethernet MMC transmitted good frames after a single collision counter"]
#[inline (always)] pub const fn mmctgfsccr (& self) -> & Mmctgfsccr { & self . mmctgfsccr }
#[doc = "0x50 - Ethernet MMC transmitted good frames after more than a single collision"]
#[inline (always)] pub const fn mmctgfmsccr (& self) -> & Mmctgfmsccr { & self . mmctgfmsccr }
#[doc = "0x68 - Ethernet MMC transmitted good frames counter register"]
#[inline (always)] pub const fn mmctgfcr (& self) -> & Mmctgfcr { & self . mmctgfcr }
#[doc = "0x94 - Ethernet MMC received frames with CRC error counter register"]
#[inline (always)] pub const fn mmcrfcecr (& self) -> & Mmcrfcecr { & self . mmcrfcecr }
#[doc = "0x98 - Ethernet MMC received frames with alignment error counter register"]
#[inline (always)] pub const fn mmcrfaecr (& self) -> & Mmcrfaecr { & self . mmcrfaecr }
#[doc = "0xc4 - MMC received good unicast frames counter register"]
#[inline (always)] pub const fn mmcrgufcr (& self) -> & Mmcrgufcr { & self . mmcrgufcr } }
#[doc = "MMCCR (rw) register accessor: Ethernet MMC control register (ETH_MMCCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmccr`] module"]
#[doc (alias = "MMCCR")] pub type Mmccr = crate :: Reg < mmccr :: MmccrSpec > ;
#[doc = "Ethernet MMC control register (ETH_MMCCR)"] pub mod mmccr {
#[doc = "Register `MMCCR` reader"] pub type R = crate :: R < MmccrSpec > ;
#[doc = "Register `MMCCR` writer"] pub type W = crate :: W < MmccrSpec > ;
#[doc = "Field `CR` reader - Counter reset"] pub type CrR = crate :: BitReader ;
#[doc = "Field `CR` writer - Counter reset"] pub type CrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSR` reader - Counter stop rollover"] pub type CsrR = crate :: BitReader ;
#[doc = "Field `CSR` writer - Counter stop rollover"] pub type CsrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ROR` reader - Reset on read"] pub type RorR = crate :: BitReader ;
#[doc = "Field `ROR` writer - Reset on read"] pub type RorW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCF` reader - MMC counter freeze"] pub type McfR = crate :: BitReader ;
#[doc = "Field `MCF` writer - MMC counter freeze"] pub type McfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Counter reset"]
#[inline (always)] pub fn cr (& self) -> CrR { CrR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Counter stop rollover"]
#[inline (always)] pub fn csr (& self) -> CsrR { CsrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Reset on read"]
#[inline (always)] pub fn ror (& self) -> RorR { RorR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 31 - MMC counter freeze"]
#[inline (always)] pub fn mcf (& self) -> McfR { McfR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Counter reset"]
#[inline (always)] pub fn cr (& mut self) -> CrW < '_ , MmccrSpec > { CrW :: new (self , 0) }
#[doc = "Bit 1 - Counter stop rollover"]
#[inline (always)] pub fn csr (& mut self) -> CsrW < '_ , MmccrSpec > { CsrW :: new (self , 1) }
#[doc = "Bit 2 - Reset on read"]
#[inline (always)] pub fn ror (& mut self) -> RorW < '_ , MmccrSpec > { RorW :: new (self , 2) }
#[doc = "Bit 31 - MMC counter freeze"]
#[inline (always)] pub fn mcf (& mut self) -> McfW < '_ , MmccrSpec > { McfW :: new (self , 31) } }
#[doc = "Ethernet MMC control register (ETH_MMCCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmccrSpec ; impl crate :: RegisterSpec for MmccrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmccr::R`](R) reader structure"] impl crate :: Readable for MmccrSpec { }
#[doc = "`write(|w| ..)` method takes [`mmccr::W`](W) writer structure"] impl crate :: Writable for MmccrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MMCCR to value 0"] impl crate :: Resettable for MmccrSpec { } }
#[doc = "MMCRIR (rw) register accessor: Ethernet MMC receive interrupt register (ETH_MMCRIR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmcrir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmcrir`] module"]
#[doc (alias = "MMCRIR")] pub type Mmcrir = crate :: Reg < mmcrir :: MmcrirSpec > ;
#[doc = "Ethernet MMC receive interrupt register (ETH_MMCRIR)"] pub mod mmcrir {
#[doc = "Register `MMCRIR` reader"] pub type R = crate :: R < MmcrirSpec > ;
#[doc = "Register `MMCRIR` writer"] pub type W = crate :: W < MmcrirSpec > ;
#[doc = "Field `RFCES` reader - Received frames CRC error status"] pub type RfcesR = crate :: BitReader ;
#[doc = "Field `RFCES` writer - Received frames CRC error status"] pub type RfcesW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RFAES` reader - Received frames alignment error status"] pub type RfaesR = crate :: BitReader ;
#[doc = "Field `RFAES` writer - Received frames alignment error status"] pub type RfaesW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RGUFS` reader - Received Good Unicast Frames Status"] pub type RgufsR = crate :: BitReader ;
#[doc = "Field `RGUFS` writer - Received Good Unicast Frames Status"] pub type RgufsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 5 - Received frames CRC error status"]
#[inline (always)] pub fn rfces (& self) -> RfcesR { RfcesR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Received frames alignment error status"]
#[inline (always)] pub fn rfaes (& self) -> RfaesR { RfaesR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 17 - Received Good Unicast Frames Status"]
#[inline (always)] pub fn rgufs (& self) -> RgufsR { RgufsR :: new (((self . bits >> 17) & 1) != 0) } } impl W {
#[doc = "Bit 5 - Received frames CRC error status"]
#[inline (always)] pub fn rfces (& mut self) -> RfcesW < '_ , MmcrirSpec > { RfcesW :: new (self , 5) }
#[doc = "Bit 6 - Received frames alignment error status"]
#[inline (always)] pub fn rfaes (& mut self) -> RfaesW < '_ , MmcrirSpec > { RfaesW :: new (self , 6) }
#[doc = "Bit 17 - Received Good Unicast Frames Status"]
#[inline (always)] pub fn rgufs (& mut self) -> RgufsW < '_ , MmcrirSpec > { RgufsW :: new (self , 17) } }
#[doc = "Ethernet MMC receive interrupt register (ETH_MMCRIR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmcrir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmcrirSpec ; impl crate :: RegisterSpec for MmcrirSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmcrir::R`](R) reader structure"] impl crate :: Readable for MmcrirSpec { }
#[doc = "`write(|w| ..)` method takes [`mmcrir::W`](W) writer structure"] impl crate :: Writable for MmcrirSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MMCRIR to value 0"] impl crate :: Resettable for MmcrirSpec { } }
#[doc = "MMCTIR (rw) register accessor: Ethernet MMC transmit interrupt register (ETH_MMCTIR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmctir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmctir`] module"]
#[doc (alias = "MMCTIR")] pub type Mmctir = crate :: Reg < mmctir :: MmctirSpec > ;
#[doc = "Ethernet MMC transmit interrupt register (ETH_MMCTIR)"] pub mod mmctir {
#[doc = "Register `MMCTIR` reader"] pub type R = crate :: R < MmctirSpec > ;
#[doc = "Register `MMCTIR` writer"] pub type W = crate :: W < MmctirSpec > ;
#[doc = "Field `TGFSCS` reader - Transmitted good frames single collision status"] pub type TgfscsR = crate :: BitReader ;
#[doc = "Field `TGFSCS` writer - Transmitted good frames single collision status"] pub type TgfscsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TGFMSCS` reader - Transmitted good frames more single collision status"] pub type TgfmscsR = crate :: BitReader ;
#[doc = "Field `TGFMSCS` writer - Transmitted good frames more single collision status"] pub type TgfmscsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TGFS` reader - Transmitted good frames status"] pub type TgfsR = crate :: BitReader ;
#[doc = "Field `TGFS` writer - Transmitted good frames status"] pub type TgfsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 14 - Transmitted good frames single collision status"]
#[inline (always)] pub fn tgfscs (& self) -> TgfscsR { TgfscsR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Transmitted good frames more single collision status"]
#[inline (always)] pub fn tgfmscs (& self) -> TgfmscsR { TgfmscsR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 21 - Transmitted good frames status"]
#[inline (always)] pub fn tgfs (& self) -> TgfsR { TgfsR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 14 - Transmitted good frames single collision status"]
#[inline (always)] pub fn tgfscs (& mut self) -> TgfscsW < '_ , MmctirSpec > { TgfscsW :: new (self , 14) }
#[doc = "Bit 15 - Transmitted good frames more single collision status"]
#[inline (always)] pub fn tgfmscs (& mut self) -> TgfmscsW < '_ , MmctirSpec > { TgfmscsW :: new (self , 15) }
#[doc = "Bit 21 - Transmitted good frames status"]
#[inline (always)] pub fn tgfs (& mut self) -> TgfsW < '_ , MmctirSpec > { TgfsW :: new (self , 21) } }
#[doc = "Ethernet MMC transmit interrupt register (ETH_MMCTIR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmctir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmctirSpec ; impl crate :: RegisterSpec for MmctirSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmctir::R`](R) reader structure"] impl crate :: Readable for MmctirSpec { }
#[doc = "`write(|w| ..)` method takes [`mmctir::W`](W) writer structure"] impl crate :: Writable for MmctirSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MMCTIR to value 0"] impl crate :: Resettable for MmctirSpec { } }
#[doc = "MMCRIMR (rw) register accessor: Ethernet MMC receive interrupt mask register (ETH_MMCRIMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrimr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmcrimr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmcrimr`] module"]
#[doc (alias = "MMCRIMR")] pub type Mmcrimr = crate :: Reg < mmcrimr :: MmcrimrSpec > ;
#[doc = "Ethernet MMC receive interrupt mask register (ETH_MMCRIMR)"] pub mod mmcrimr {
#[doc = "Register `MMCRIMR` reader"] pub type R = crate :: R < MmcrimrSpec > ;
#[doc = "Register `MMCRIMR` writer"] pub type W = crate :: W < MmcrimrSpec > ;
#[doc = "Field `RFCEM` reader - Received frame CRC error mask"] pub type RfcemR = crate :: BitReader ;
#[doc = "Field `RFCEM` writer - Received frame CRC error mask"] pub type RfcemW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RFAEM` reader - Received frames alignment error mask"] pub type RfaemR = crate :: BitReader ;
#[doc = "Field `RFAEM` writer - Received frames alignment error mask"] pub type RfaemW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RGUFM` reader - Received good unicast frames mask"] pub type RgufmR = crate :: BitReader ;
#[doc = "Field `RGUFM` writer - Received good unicast frames mask"] pub type RgufmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 5 - Received frame CRC error mask"]
#[inline (always)] pub fn rfcem (& self) -> RfcemR { RfcemR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Received frames alignment error mask"]
#[inline (always)] pub fn rfaem (& self) -> RfaemR { RfaemR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 17 - Received good unicast frames mask"]
#[inline (always)] pub fn rgufm (& self) -> RgufmR { RgufmR :: new (((self . bits >> 17) & 1) != 0) } } impl W {
#[doc = "Bit 5 - Received frame CRC error mask"]
#[inline (always)] pub fn rfcem (& mut self) -> RfcemW < '_ , MmcrimrSpec > { RfcemW :: new (self , 5) }
#[doc = "Bit 6 - Received frames alignment error mask"]
#[inline (always)] pub fn rfaem (& mut self) -> RfaemW < '_ , MmcrimrSpec > { RfaemW :: new (self , 6) }
#[doc = "Bit 17 - Received good unicast frames mask"]
#[inline (always)] pub fn rgufm (& mut self) -> RgufmW < '_ , MmcrimrSpec > { RgufmW :: new (self , 17) } }
#[doc = "Ethernet MMC receive interrupt mask register (ETH_MMCRIMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrimr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmcrimr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmcrimrSpec ; impl crate :: RegisterSpec for MmcrimrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmcrimr::R`](R) reader structure"] impl crate :: Readable for MmcrimrSpec { }
#[doc = "`write(|w| ..)` method takes [`mmcrimr::W`](W) writer structure"] impl crate :: Writable for MmcrimrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MMCRIMR to value 0"] impl crate :: Resettable for MmcrimrSpec { } }
#[doc = "MMCTIMR (rw) register accessor: Ethernet MMC transmit interrupt mask register (ETH_MMCTIMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctimr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmctimr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmctimr`] module"]
#[doc (alias = "MMCTIMR")] pub type Mmctimr = crate :: Reg < mmctimr :: MmctimrSpec > ;
#[doc = "Ethernet MMC transmit interrupt mask register (ETH_MMCTIMR)"] pub mod mmctimr {
#[doc = "Register `MMCTIMR` reader"] pub type R = crate :: R < MmctimrSpec > ;
#[doc = "Register `MMCTIMR` writer"] pub type W = crate :: W < MmctimrSpec > ;
#[doc = "Field `TGFSCM` reader - Transmitted good frames single collision mask"] pub type TgfscmR = crate :: BitReader ;
#[doc = "Field `TGFSCM` writer - Transmitted good frames single collision mask"] pub type TgfscmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TGFMSCM` reader - Transmitted good frames more single collision mask"] pub type TgfmscmR = crate :: BitReader ;
#[doc = "Field `TGFMSCM` writer - Transmitted good frames more single collision mask"] pub type TgfmscmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TGFM` reader - Transmitted good frames mask"] pub type TgfmR = crate :: BitReader ;
#[doc = "Field `TGFM` writer - Transmitted good frames mask"] pub type TgfmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 14 - Transmitted good frames single collision mask"]
#[inline (always)] pub fn tgfscm (& self) -> TgfscmR { TgfscmR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Transmitted good frames more single collision mask"]
#[inline (always)] pub fn tgfmscm (& self) -> TgfmscmR { TgfmscmR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 21 - Transmitted good frames mask"]
#[inline (always)] pub fn tgfm (& self) -> TgfmR { TgfmR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 14 - Transmitted good frames single collision mask"]
#[inline (always)] pub fn tgfscm (& mut self) -> TgfscmW < '_ , MmctimrSpec > { TgfscmW :: new (self , 14) }
#[doc = "Bit 15 - Transmitted good frames more single collision mask"]
#[inline (always)] pub fn tgfmscm (& mut self) -> TgfmscmW < '_ , MmctimrSpec > { TgfmscmW :: new (self , 15) }
#[doc = "Bit 21 - Transmitted good frames mask"]
#[inline (always)] pub fn tgfm (& mut self) -> TgfmW < '_ , MmctimrSpec > { TgfmW :: new (self , 21) } }
#[doc = "Ethernet MMC transmit interrupt mask register (ETH_MMCTIMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctimr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmctimr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmctimrSpec ; impl crate :: RegisterSpec for MmctimrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmctimr::R`](R) reader structure"] impl crate :: Readable for MmctimrSpec { }
#[doc = "`write(|w| ..)` method takes [`mmctimr::W`](W) writer structure"] impl crate :: Writable for MmctimrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MMCTIMR to value 0"] impl crate :: Resettable for MmctimrSpec { } }
#[doc = "MMCTGFSCCR (r) register accessor: Ethernet MMC transmitted good frames after a single collision counter\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctgfsccr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmctgfsccr`] module"]
#[doc (alias = "MMCTGFSCCR")] pub type Mmctgfsccr = crate :: Reg < mmctgfsccr :: MmctgfsccrSpec > ;
#[doc = "Ethernet MMC transmitted good frames after a single collision counter"] pub mod mmctgfsccr {
#[doc = "Register `MMCTGFSCCR` reader"] pub type R = crate :: R < MmctgfsccrSpec > ;
#[doc = "Field `TGFSCC` reader - Transmitted good frames after a single collision counter"] pub type TgfsccR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Transmitted good frames after a single collision counter"]
#[inline (always)] pub fn tgfscc (& self) -> TgfsccR { TgfsccR :: new (self . bits) } }
#[doc = "Ethernet MMC transmitted good frames after a single collision counter\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctgfsccr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmctgfsccrSpec ; impl crate :: RegisterSpec for MmctgfsccrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmctgfsccr::R`](R) reader structure"] impl crate :: Readable for MmctgfsccrSpec { }
#[doc = "`reset()` method sets MMCTGFSCCR to value 0"] impl crate :: Resettable for MmctgfsccrSpec { } }
#[doc = "MMCTGFMSCCR (r) register accessor: Ethernet MMC transmitted good frames after more than a single collision\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctgfmsccr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmctgfmsccr`] module"]
#[doc (alias = "MMCTGFMSCCR")] pub type Mmctgfmsccr = crate :: Reg < mmctgfmsccr :: MmctgfmsccrSpec > ;
#[doc = "Ethernet MMC transmitted good frames after more than a single collision"] pub mod mmctgfmsccr {
#[doc = "Register `MMCTGFMSCCR` reader"] pub type R = crate :: R < MmctgfmsccrSpec > ;
#[doc = "Field `TGFMSCC` reader - Transmitted good frames after more than a single collision counter"] pub type TgfmsccR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Transmitted good frames after more than a single collision counter"]
#[inline (always)] pub fn tgfmscc (& self) -> TgfmsccR { TgfmsccR :: new (self . bits) } }
#[doc = "Ethernet MMC transmitted good frames after more than a single collision\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctgfmsccr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmctgfmsccrSpec ; impl crate :: RegisterSpec for MmctgfmsccrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmctgfmsccr::R`](R) reader structure"] impl crate :: Readable for MmctgfmsccrSpec { }
#[doc = "`reset()` method sets MMCTGFMSCCR to value 0"] impl crate :: Resettable for MmctgfmsccrSpec { } }
#[doc = "MMCTGFCR (r) register accessor: Ethernet MMC transmitted good frames counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctgfcr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmctgfcr`] module"]
#[doc (alias = "MMCTGFCR")] pub type Mmctgfcr = crate :: Reg < mmctgfcr :: MmctgfcrSpec > ;
#[doc = "Ethernet MMC transmitted good frames counter register"] pub mod mmctgfcr {
#[doc = "Register `MMCTGFCR` reader"] pub type R = crate :: R < MmctgfcrSpec > ;
#[doc = "Field `TGFC` reader - Transmitted good frames counter"] pub type TgfcR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Transmitted good frames counter"]
#[inline (always)] pub fn tgfc (& self) -> TgfcR { TgfcR :: new (self . bits) } }
#[doc = "Ethernet MMC transmitted good frames counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmctgfcr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmctgfcrSpec ; impl crate :: RegisterSpec for MmctgfcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmctgfcr::R`](R) reader structure"] impl crate :: Readable for MmctgfcrSpec { }
#[doc = "`reset()` method sets MMCTGFCR to value 0"] impl crate :: Resettable for MmctgfcrSpec { } }
#[doc = "MMCRFCECR (r) register accessor: Ethernet MMC received frames with CRC error counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrfcecr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmcrfcecr`] module"]
#[doc (alias = "MMCRFCECR")] pub type Mmcrfcecr = crate :: Reg < mmcrfcecr :: MmcrfcecrSpec > ;
#[doc = "Ethernet MMC received frames with CRC error counter register"] pub mod mmcrfcecr {
#[doc = "Register `MMCRFCECR` reader"] pub type R = crate :: R < MmcrfcecrSpec > ;
#[doc = "Field `RFCFC` reader - Received frames with CRC error counter"] pub type RfcfcR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Received frames with CRC error counter"]
#[inline (always)] pub fn rfcfc (& self) -> RfcfcR { RfcfcR :: new (self . bits) } }
#[doc = "Ethernet MMC received frames with CRC error counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrfcecr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmcrfcecrSpec ; impl crate :: RegisterSpec for MmcrfcecrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmcrfcecr::R`](R) reader structure"] impl crate :: Readable for MmcrfcecrSpec { }
#[doc = "`reset()` method sets MMCRFCECR to value 0"] impl crate :: Resettable for MmcrfcecrSpec { } }
#[doc = "MMCRFAECR (r) register accessor: Ethernet MMC received frames with alignment error counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrfaecr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmcrfaecr`] module"]
#[doc (alias = "MMCRFAECR")] pub type Mmcrfaecr = crate :: Reg < mmcrfaecr :: MmcrfaecrSpec > ;
#[doc = "Ethernet MMC received frames with alignment error counter register"] pub mod mmcrfaecr {
#[doc = "Register `MMCRFAECR` reader"] pub type R = crate :: R < MmcrfaecrSpec > ;
#[doc = "Field `RFAEC` reader - Received frames with alignment error counter"] pub type RfaecR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Received frames with alignment error counter"]
#[inline (always)] pub fn rfaec (& self) -> RfaecR { RfaecR :: new (self . bits) } }
#[doc = "Ethernet MMC received frames with alignment error counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrfaecr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmcrfaecrSpec ; impl crate :: RegisterSpec for MmcrfaecrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmcrfaecr::R`](R) reader structure"] impl crate :: Readable for MmcrfaecrSpec { }
#[doc = "`reset()` method sets MMCRFAECR to value 0"] impl crate :: Resettable for MmcrfaecrSpec { } }
#[doc = "MMCRGUFCR (r) register accessor: MMC received good unicast frames counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrgufcr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mmcrgufcr`] module"]
#[doc (alias = "MMCRGUFCR")] pub type Mmcrgufcr = crate :: Reg < mmcrgufcr :: MmcrgufcrSpec > ;
#[doc = "MMC received good unicast frames counter register"] pub mod mmcrgufcr {
#[doc = "Register `MMCRGUFCR` reader"] pub type R = crate :: R < MmcrgufcrSpec > ;
#[doc = "Field `RGUFC` reader - Received good unicast frames counter"] pub type RgufcR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Received good unicast frames counter"]
#[inline (always)] pub fn rgufc (& self) -> RgufcR { RgufcR :: new (self . bits) } }
#[doc = "MMC received good unicast frames counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmcrgufcr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmcrgufcrSpec ; impl crate :: RegisterSpec for MmcrgufcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`mmcrgufcr::R`](R) reader structure"] impl crate :: Readable for MmcrgufcrSpec { }
#[doc = "`reset()` method sets MMCRGUFCR to value 0"] impl crate :: Resettable for MmcrgufcrSpec { } } }
#[doc = "Ethernet: media access control"] pub type EthernetMac = crate :: Periph < ethernet_mac :: RegisterBlock , 0x4002_8000 > ; impl core :: fmt :: Debug for EthernetMac { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EthernetMac") . finish () } }
#[doc = "Ethernet: media access control"] pub mod ethernet_mac {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { maccr : Maccr , macffr : Macffr , machthr : Machthr , machtlr : Machtlr , macmiiar : Macmiiar , macmiidr : Macmiidr , macfcr : Macfcr , macvlantr : Macvlantr , _reserved8 : [u8 ; 0x08] , macrwuffr : Macrwuffr , macpmtcsr : Macpmtcsr , _reserved10 : [u8 ; 0x08] , macsr : Macsr , macimr : Macimr , maca0hr : Maca0hr , maca0lr : Maca0lr , maca1hr : Maca1hr , maca1lr : Maca1lr , maca2hr : Maca2hr , maca2lr : Maca2lr , maca3hr : Maca3hr , maca3lr : Maca3lr , } impl RegisterBlock {
#[doc = "0x00 - Ethernet MAC configuration register (ETH_MACCR)"]
#[inline (always)] pub const fn maccr (& self) -> & Maccr { & self . maccr }
#[doc = "0x04 - Ethernet MAC frame filter register (ETH_MACCFFR)"]
#[inline (always)] pub const fn macffr (& self) -> & Macffr { & self . macffr }
#[doc = "0x08 - Ethernet MAC hash table high register"]
#[inline (always)] pub const fn machthr (& self) -> & Machthr { & self . machthr }
#[doc = "0x0c - Ethernet MAC hash table low register"]
#[inline (always)] pub const fn machtlr (& self) -> & Machtlr { & self . machtlr }
#[doc = "0x10 - Ethernet MAC MII address register (ETH_MACMIIAR)"]
#[inline (always)] pub const fn macmiiar (& self) -> & Macmiiar { & self . macmiiar }
#[doc = "0x14 - Ethernet MAC MII data register (ETH_MACMIIDR)"]
#[inline (always)] pub const fn macmiidr (& self) -> & Macmiidr { & self . macmiidr }
#[doc = "0x18 - Ethernet MAC flow control register (ETH_MACFCR)"]
#[inline (always)] pub const fn macfcr (& self) -> & Macfcr { & self . macfcr }
#[doc = "0x1c - Ethernet MAC VLAN tag register (ETH_MACVLANTR)"]
#[inline (always)] pub const fn macvlantr (& self) -> & Macvlantr { & self . macvlantr }
#[doc = "0x28 - Ethernet MAC remote wakeup frame filter register (ETH_MACRWUFFR)"]
#[inline (always)] pub const fn macrwuffr (& self) -> & Macrwuffr { & self . macrwuffr }
#[doc = "0x2c - Ethernet MAC PMT control and status register (ETH_MACPMTCSR)"]
#[inline (always)] pub const fn macpmtcsr (& self) -> & Macpmtcsr { & self . macpmtcsr }
#[doc = "0x38 - Ethernet MAC interrupt status register (ETH_MACSR)"]
#[inline (always)] pub const fn macsr (& self) -> & Macsr { & self . macsr }
#[doc = "0x3c - Ethernet MAC interrupt mask register (ETH_MACIMR)"]
#[inline (always)] pub const fn macimr (& self) -> & Macimr { & self . macimr }
#[doc = "0x40 - Ethernet MAC address 0 high register (ETH_MACA0HR)"]
#[inline (always)] pub const fn maca0hr (& self) -> & Maca0hr { & self . maca0hr }
#[doc = "0x44 - Ethernet MAC address 0 low register"]
#[inline (always)] pub const fn maca0lr (& self) -> & Maca0lr { & self . maca0lr }
#[doc = "0x48 - Ethernet MAC address 1 high register (ETH_MACA1HR)"]
#[inline (always)] pub const fn maca1hr (& self) -> & Maca1hr { & self . maca1hr }
#[doc = "0x4c - Ethernet MAC address1 low register"]
#[inline (always)] pub const fn maca1lr (& self) -> & Maca1lr { & self . maca1lr }
#[doc = "0x50 - Ethernet MAC address 2 high register (ETH_MACA2HR)"]
#[inline (always)] pub const fn maca2hr (& self) -> & Maca2hr { & self . maca2hr }
#[doc = "0x54 - Ethernet MAC address 2 low register"]
#[inline (always)] pub const fn maca2lr (& self) -> & Maca2lr { & self . maca2lr }
#[doc = "0x58 - Ethernet MAC address 3 high register (ETH_MACA3HR)"]
#[inline (always)] pub const fn maca3hr (& self) -> & Maca3hr { & self . maca3hr }
#[doc = "0x5c - Ethernet MAC address 3 low register"]
#[inline (always)] pub const fn maca3lr (& self) -> & Maca3lr { & self . maca3lr } }
#[doc = "MACCR (rw) register accessor: Ethernet MAC configuration register (ETH_MACCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maccr`] module"]
#[doc (alias = "MACCR")] pub type Maccr = crate :: Reg < maccr :: MaccrSpec > ;
#[doc = "Ethernet MAC configuration register (ETH_MACCR)"] pub mod maccr {
#[doc = "Register `MACCR` reader"] pub type R = crate :: R < MaccrSpec > ;
#[doc = "Register `MACCR` writer"] pub type W = crate :: W < MaccrSpec > ;
#[doc = "Field `RE` reader - Receiver enable"] pub type ReR = crate :: BitReader ;
#[doc = "Field `RE` writer - Receiver enable"] pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TE` reader - Transmitter enable"] pub type TeR = crate :: BitReader ;
#[doc = "Field `TE` writer - Transmitter enable"] pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DC` reader - Deferral check"] pub type DcR = crate :: BitReader ;
#[doc = "Field `DC` writer - Deferral check"] pub type DcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BL` reader - Back-off limit"] pub type BlR = crate :: FieldReader ;
#[doc = "Field `BL` writer - Back-off limit"] pub type BlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `APCS` reader - Automatic pad/CRC stripping"] pub type ApcsR = crate :: BitReader ;
#[doc = "Field `APCS` writer - Automatic pad/CRC stripping"] pub type ApcsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RD` reader - Retry disable"] pub type RdR = crate :: BitReader ;
#[doc = "Field `RD` writer - Retry disable"] pub type RdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IPCO` reader - IPv4 checksum offload"] pub type IpcoR = crate :: BitReader ;
#[doc = "Field `IPCO` writer - IPv4 checksum offload"] pub type IpcoW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DM` reader - Duplex mode"] pub type DmR = crate :: BitReader ;
#[doc = "Field `DM` writer - Duplex mode"] pub type DmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LM` reader - Loopback mode"] pub type LmR = crate :: BitReader ;
#[doc = "Field `LM` writer - Loopback mode"] pub type LmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ROD` reader - Receive own disable"] pub type RodR = crate :: BitReader ;
#[doc = "Field `ROD` writer - Receive own disable"] pub type RodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FES` reader - Fast Ethernet speed"] pub type FesR = crate :: BitReader ;
#[doc = "Field `FES` writer - Fast Ethernet speed"] pub type FesW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSD` reader - Carrier sense disable"] pub type CsdR = crate :: BitReader ;
#[doc = "Field `CSD` writer - Carrier sense disable"] pub type CsdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFG` reader - Interframe gap"] pub type IfgR = crate :: FieldReader ;
#[doc = "Field `IFG` writer - Interframe gap"] pub type IfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `JD` reader - Jabber disable"] pub type JdR = crate :: BitReader ;
#[doc = "Field `JD` writer - Jabber disable"] pub type JdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WD` reader - Watchdog disable"] pub type WdR = crate :: BitReader ;
#[doc = "Field `WD` writer - Watchdog disable"] pub type WdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - Receiver enable"]
#[inline (always)] pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmitter enable"]
#[inline (always)] pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Deferral check"]
#[inline (always)] pub fn dc (& self) -> DcR { DcR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - Back-off limit"]
#[inline (always)] pub fn bl (& self) -> BlR { BlR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Automatic pad/CRC stripping"]
#[inline (always)] pub fn apcs (& self) -> ApcsR { ApcsR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - Retry disable"]
#[inline (always)] pub fn rd (& self) -> RdR { RdR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - IPv4 checksum offload"]
#[inline (always)] pub fn ipco (& self) -> IpcoR { IpcoR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Duplex mode"]
#[inline (always)] pub fn dm (& self) -> DmR { DmR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Loopback mode"]
#[inline (always)] pub fn lm (& self) -> LmR { LmR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Receive own disable"]
#[inline (always)] pub fn rod (& self) -> RodR { RodR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Fast Ethernet speed"]
#[inline (always)] pub fn fes (& self) -> FesR { FesR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 16 - Carrier sense disable"]
#[inline (always)] pub fn csd (& self) -> CsdR { CsdR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:19 - Interframe gap"]
#[inline (always)] pub fn ifg (& self) -> IfgR { IfgR :: new (((self . bits >> 17) & 7) as u8) }
#[doc = "Bit 22 - Jabber disable"]
#[inline (always)] pub fn jd (& self) -> JdR { JdR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Watchdog disable"]
#[inline (always)] pub fn wd (& self) -> WdR { WdR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 2 - Receiver enable"]
#[inline (always)] pub fn re (& mut self) -> ReW < '_ , MaccrSpec > { ReW :: new (self , 2) }
#[doc = "Bit 3 - Transmitter enable"]
#[inline (always)] pub fn te (& mut self) -> TeW < '_ , MaccrSpec > { TeW :: new (self , 3) }
#[doc = "Bit 4 - Deferral check"]
#[inline (always)] pub fn dc (& mut self) -> DcW < '_ , MaccrSpec > { DcW :: new (self , 4) }
#[doc = "Bits 5:6 - Back-off limit"]
#[inline (always)] pub fn bl (& mut self) -> BlW < '_ , MaccrSpec > { BlW :: new (self , 5) }
#[doc = "Bit 7 - Automatic pad/CRC stripping"]
#[inline (always)] pub fn apcs (& mut self) -> ApcsW < '_ , MaccrSpec > { ApcsW :: new (self , 7) }
#[doc = "Bit 9 - Retry disable"]
#[inline (always)] pub fn rd (& mut self) -> RdW < '_ , MaccrSpec > { RdW :: new (self , 9) }
#[doc = "Bit 10 - IPv4 checksum offload"]
#[inline (always)] pub fn ipco (& mut self) -> IpcoW < '_ , MaccrSpec > { IpcoW :: new (self , 10) }
#[doc = "Bit 11 - Duplex mode"]
#[inline (always)] pub fn dm (& mut self) -> DmW < '_ , MaccrSpec > { DmW :: new (self , 11) }
#[doc = "Bit 12 - Loopback mode"]
#[inline (always)] pub fn lm (& mut self) -> LmW < '_ , MaccrSpec > { LmW :: new (self , 12) }
#[doc = "Bit 13 - Receive own disable"]
#[inline (always)] pub fn rod (& mut self) -> RodW < '_ , MaccrSpec > { RodW :: new (self , 13) }
#[doc = "Bit 14 - Fast Ethernet speed"]
#[inline (always)] pub fn fes (& mut self) -> FesW < '_ , MaccrSpec > { FesW :: new (self , 14) }
#[doc = "Bit 16 - Carrier sense disable"]
#[inline (always)] pub fn csd (& mut self) -> CsdW < '_ , MaccrSpec > { CsdW :: new (self , 16) }
#[doc = "Bits 17:19 - Interframe gap"]
#[inline (always)] pub fn ifg (& mut self) -> IfgW < '_ , MaccrSpec > { IfgW :: new (self , 17) }
#[doc = "Bit 22 - Jabber disable"]
#[inline (always)] pub fn jd (& mut self) -> JdW < '_ , MaccrSpec > { JdW :: new (self , 22) }
#[doc = "Bit 23 - Watchdog disable"]
#[inline (always)] pub fn wd (& mut self) -> WdW < '_ , MaccrSpec > { WdW :: new (self , 23) } }
#[doc = "Ethernet MAC configuration register (ETH_MACCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MaccrSpec ; impl crate :: RegisterSpec for MaccrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maccr::R`](R) reader structure"] impl crate :: Readable for MaccrSpec { }
#[doc = "`write(|w| ..)` method takes [`maccr::W`](W) writer structure"] impl crate :: Writable for MaccrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACCR to value 0x8000"] impl crate :: Resettable for MaccrSpec { const RESET_VALUE : u32 = 0x8000 ; } }
#[doc = "MACFFR (rw) register accessor: Ethernet MAC frame filter register (ETH_MACCFFR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macffr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macffr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macffr`] module"]
#[doc (alias = "MACFFR")] pub type Macffr = crate :: Reg < macffr :: MacffrSpec > ;
#[doc = "Ethernet MAC frame filter register (ETH_MACCFFR)"] pub mod macffr {
#[doc = "Register `MACFFR` reader"] pub type R = crate :: R < MacffrSpec > ;
#[doc = "Register `MACFFR` writer"] pub type W = crate :: W < MacffrSpec > ;
#[doc = "Field `PM` reader - Promiscuous mode"] pub type PmR = crate :: BitReader ;
#[doc = "Field `PM` writer - Promiscuous mode"] pub type PmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HU` reader - Hash unicast"] pub type HuR = crate :: BitReader ;
#[doc = "Field `HU` writer - Hash unicast"] pub type HuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HM` reader - Hash multicast"] pub type HmR = crate :: BitReader ;
#[doc = "Field `HM` writer - Hash multicast"] pub type HmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DAIF` reader - Destination address inverse filtering"] pub type DaifR = crate :: BitReader ;
#[doc = "Field `DAIF` writer - Destination address inverse filtering"] pub type DaifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PAM` reader - Pass all multicast"] pub type PamR = crate :: BitReader ;
#[doc = "Field `PAM` writer - Pass all multicast"] pub type PamW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BFD` reader - Broadcast frames disable"] pub type BfdR = crate :: BitReader ;
#[doc = "Field `BFD` writer - Broadcast frames disable"] pub type BfdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PCF` reader - Pass control frames"] pub type PcfR = crate :: FieldReader ;
#[doc = "Field `PCF` writer - Pass control frames"] pub type PcfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SAIF` reader - Source address inverse filtering"] pub type SaifR = crate :: BitReader ;
#[doc = "Field `SAIF` writer - Source address inverse filtering"] pub type SaifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAF` reader - Source address filter"] pub type SafR = crate :: BitReader ;
#[doc = "Field `SAF` writer - Source address filter"] pub type SafW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HPF` reader - Hash or perfect filter"] pub type HpfR = crate :: BitReader ;
#[doc = "Field `HPF` writer - Hash or perfect filter"] pub type HpfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RA` reader - Receive all"] pub type RaR = crate :: BitReader ;
#[doc = "Field `RA` writer - Receive all"] pub type RaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Promiscuous mode"]
#[inline (always)] pub fn pm (& self) -> PmR { PmR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Hash unicast"]
#[inline (always)] pub fn hu (& self) -> HuR { HuR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Hash multicast"]
#[inline (always)] pub fn hm (& self) -> HmR { HmR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Destination address inverse filtering"]
#[inline (always)] pub fn daif (& self) -> DaifR { DaifR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Pass all multicast"]
#[inline (always)] pub fn pam (& self) -> PamR { PamR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Broadcast frames disable"]
#[inline (always)] pub fn bfd (& self) -> BfdR { BfdR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bits 6:7 - Pass control frames"]
#[inline (always)] pub fn pcf (& self) -> PcfR { PcfR :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bit 8 - Source address inverse filtering"]
#[inline (always)] pub fn saif (& self) -> SaifR { SaifR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Source address filter"]
#[inline (always)] pub fn saf (& self) -> SafR { SafR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Hash or perfect filter"]
#[inline (always)] pub fn hpf (& self) -> HpfR { HpfR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 31 - Receive all"]
#[inline (always)] pub fn ra (& self) -> RaR { RaR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Promiscuous mode"]
#[inline (always)] pub fn pm (& mut self) -> PmW < '_ , MacffrSpec > { PmW :: new (self , 0) }
#[doc = "Bit 1 - Hash unicast"]
#[inline (always)] pub fn hu (& mut self) -> HuW < '_ , MacffrSpec > { HuW :: new (self , 1) }
#[doc = "Bit 2 - Hash multicast"]
#[inline (always)] pub fn hm (& mut self) -> HmW < '_ , MacffrSpec > { HmW :: new (self , 2) }
#[doc = "Bit 3 - Destination address inverse filtering"]
#[inline (always)] pub fn daif (& mut self) -> DaifW < '_ , MacffrSpec > { DaifW :: new (self , 3) }
#[doc = "Bit 4 - Pass all multicast"]
#[inline (always)] pub fn pam (& mut self) -> PamW < '_ , MacffrSpec > { PamW :: new (self , 4) }
#[doc = "Bit 5 - Broadcast frames disable"]
#[inline (always)] pub fn bfd (& mut self) -> BfdW < '_ , MacffrSpec > { BfdW :: new (self , 5) }
#[doc = "Bits 6:7 - Pass control frames"]
#[inline (always)] pub fn pcf (& mut self) -> PcfW < '_ , MacffrSpec > { PcfW :: new (self , 6) }
#[doc = "Bit 8 - Source address inverse filtering"]
#[inline (always)] pub fn saif (& mut self) -> SaifW < '_ , MacffrSpec > { SaifW :: new (self , 8) }
#[doc = "Bit 9 - Source address filter"]
#[inline (always)] pub fn saf (& mut self) -> SafW < '_ , MacffrSpec > { SafW :: new (self , 9) }
#[doc = "Bit 10 - Hash or perfect filter"]
#[inline (always)] pub fn hpf (& mut self) -> HpfW < '_ , MacffrSpec > { HpfW :: new (self , 10) }
#[doc = "Bit 31 - Receive all"]
#[inline (always)] pub fn ra (& mut self) -> RaW < '_ , MacffrSpec > { RaW :: new (self , 31) } }
#[doc = "Ethernet MAC frame filter register (ETH_MACCFFR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macffr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macffr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacffrSpec ; impl crate :: RegisterSpec for MacffrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macffr::R`](R) reader structure"] impl crate :: Readable for MacffrSpec { }
#[doc = "`write(|w| ..)` method takes [`macffr::W`](W) writer structure"] impl crate :: Writable for MacffrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACFFR to value 0"] impl crate :: Resettable for MacffrSpec { } }
#[doc = "MACHTHR (rw) register accessor: Ethernet MAC hash table high register\n\nYou can [`read`](crate::Reg::read) this register and get [`machthr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`machthr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@machthr`] module"]
#[doc (alias = "MACHTHR")] pub type Machthr = crate :: Reg < machthr :: MachthrSpec > ;
#[doc = "Ethernet MAC hash table high register"] pub mod machthr {
#[doc = "Register `MACHTHR` reader"] pub type R = crate :: R < MachthrSpec > ;
#[doc = "Register `MACHTHR` writer"] pub type W = crate :: W < MachthrSpec > ;
#[doc = "Field `HTH` reader - Hash table high"] pub type HthR = crate :: FieldReader < u32 > ;
#[doc = "Field `HTH` writer - Hash table high"] pub type HthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Hash table high"]
#[inline (always)] pub fn hth (& self) -> HthR { HthR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Hash table high"]
#[inline (always)] pub fn hth (& mut self) -> HthW < '_ , MachthrSpec > { HthW :: new (self , 0) } }
#[doc = "Ethernet MAC hash table high register\n\nYou can [`read`](crate::Reg::read) this register and get [`machthr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`machthr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MachthrSpec ; impl crate :: RegisterSpec for MachthrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`machthr::R`](R) reader structure"] impl crate :: Readable for MachthrSpec { }
#[doc = "`write(|w| ..)` method takes [`machthr::W`](W) writer structure"] impl crate :: Writable for MachthrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACHTHR to value 0"] impl crate :: Resettable for MachthrSpec { } }
#[doc = "MACHTLR (rw) register accessor: Ethernet MAC hash table low register\n\nYou can [`read`](crate::Reg::read) this register and get [`machtlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`machtlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@machtlr`] module"]
#[doc (alias = "MACHTLR")] pub type Machtlr = crate :: Reg < machtlr :: MachtlrSpec > ;
#[doc = "Ethernet MAC hash table low register"] pub mod machtlr {
#[doc = "Register `MACHTLR` reader"] pub type R = crate :: R < MachtlrSpec > ;
#[doc = "Register `MACHTLR` writer"] pub type W = crate :: W < MachtlrSpec > ;
#[doc = "Field `HTL` reader - Hash table low"] pub type HtlR = crate :: FieldReader < u32 > ;
#[doc = "Field `HTL` writer - Hash table low"] pub type HtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Hash table low"]
#[inline (always)] pub fn htl (& self) -> HtlR { HtlR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Hash table low"]
#[inline (always)] pub fn htl (& mut self) -> HtlW < '_ , MachtlrSpec > { HtlW :: new (self , 0) } }
#[doc = "Ethernet MAC hash table low register\n\nYou can [`read`](crate::Reg::read) this register and get [`machtlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`machtlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MachtlrSpec ; impl crate :: RegisterSpec for MachtlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`machtlr::R`](R) reader structure"] impl crate :: Readable for MachtlrSpec { }
#[doc = "`write(|w| ..)` method takes [`machtlr::W`](W) writer structure"] impl crate :: Writable for MachtlrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACHTLR to value 0"] impl crate :: Resettable for MachtlrSpec { } }
#[doc = "MACMIIAR (rw) register accessor: Ethernet MAC MII address register (ETH_MACMIIAR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macmiiar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macmiiar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macmiiar`] module"]
#[doc (alias = "MACMIIAR")] pub type Macmiiar = crate :: Reg < macmiiar :: MacmiiarSpec > ;
#[doc = "Ethernet MAC MII address register (ETH_MACMIIAR)"] pub mod macmiiar {
#[doc = "Register `MACMIIAR` reader"] pub type R = crate :: R < MacmiiarSpec > ;
#[doc = "Register `MACMIIAR` writer"] pub type W = crate :: W < MacmiiarSpec > ;
#[doc = "Field `MB` reader - MII busy"] pub type MbR = crate :: BitReader ;
#[doc = "Field `MB` writer - MII busy"] pub type MbW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MW` reader - MII write"] pub type MwR = crate :: BitReader ;
#[doc = "Field `MW` writer - MII write"] pub type MwW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CR` reader - Clock range"] pub type CrR = crate :: FieldReader ;
#[doc = "Field `CR` writer - Clock range"] pub type CrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MR` reader - MII register"] pub type MrR = crate :: FieldReader ;
#[doc = "Field `MR` writer - MII register"] pub type MrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `PA` reader - PHY address"] pub type PaR = crate :: FieldReader ;
#[doc = "Field `PA` writer - PHY address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bit 0 - MII busy"]
#[inline (always)] pub fn mb (& self) -> MbR { MbR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - MII write"]
#[inline (always)] pub fn mw (& self) -> MwR { MwR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:4 - Clock range"]
#[inline (always)] pub fn cr (& self) -> CrR { CrR :: new (((self . bits >> 2) & 7) as u8) }
#[doc = "Bits 6:10 - MII register"]
#[inline (always)] pub fn mr (& self) -> MrR { MrR :: new (((self . bits >> 6) & 0x1f) as u8) }
#[doc = "Bits 11:15 - PHY address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (((self . bits >> 11) & 0x1f) as u8) } } impl W {
#[doc = "Bit 0 - MII busy"]
#[inline (always)] pub fn mb (& mut self) -> MbW < '_ , MacmiiarSpec > { MbW :: new (self , 0) }
#[doc = "Bit 1 - MII write"]
#[inline (always)] pub fn mw (& mut self) -> MwW < '_ , MacmiiarSpec > { MwW :: new (self , 1) }
#[doc = "Bits 2:4 - Clock range"]
#[inline (always)] pub fn cr (& mut self) -> CrW < '_ , MacmiiarSpec > { CrW :: new (self , 2) }
#[doc = "Bits 6:10 - MII register"]
#[inline (always)] pub fn mr (& mut self) -> MrW < '_ , MacmiiarSpec > { MrW :: new (self , 6) }
#[doc = "Bits 11:15 - PHY address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , MacmiiarSpec > { PaW :: new (self , 11) } }
#[doc = "Ethernet MAC MII address register (ETH_MACMIIAR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macmiiar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macmiiar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacmiiarSpec ; impl crate :: RegisterSpec for MacmiiarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macmiiar::R`](R) reader structure"] impl crate :: Readable for MacmiiarSpec { }
#[doc = "`write(|w| ..)` method takes [`macmiiar::W`](W) writer structure"] impl crate :: Writable for MacmiiarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACMIIAR to value 0"] impl crate :: Resettable for MacmiiarSpec { } }
#[doc = "MACMIIDR (rw) register accessor: Ethernet MAC MII data register (ETH_MACMIIDR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macmiidr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macmiidr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macmiidr`] module"]
#[doc (alias = "MACMIIDR")] pub type Macmiidr = crate :: Reg < macmiidr :: MacmiidrSpec > ;
#[doc = "Ethernet MAC MII data register (ETH_MACMIIDR)"] pub mod macmiidr {
#[doc = "Register `MACMIIDR` reader"] pub type R = crate :: R < MacmiidrSpec > ;
#[doc = "Register `MACMIIDR` writer"] pub type W = crate :: W < MacmiidrSpec > ;
#[doc = "Field `MD` reader - MII data"] pub type MdR = crate :: FieldReader < u16 > ;
#[doc = "Field `MD` writer - MII data"] pub type MdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - MII data"]
#[inline (always)] pub fn md (& self) -> MdR { MdR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - MII data"]
#[inline (always)] pub fn md (& mut self) -> MdW < '_ , MacmiidrSpec > { MdW :: new (self , 0) } }
#[doc = "Ethernet MAC MII data register (ETH_MACMIIDR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macmiidr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macmiidr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacmiidrSpec ; impl crate :: RegisterSpec for MacmiidrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macmiidr::R`](R) reader structure"] impl crate :: Readable for MacmiidrSpec { }
#[doc = "`write(|w| ..)` method takes [`macmiidr::W`](W) writer structure"] impl crate :: Writable for MacmiidrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACMIIDR to value 0"] impl crate :: Resettable for MacmiidrSpec { } }
#[doc = "MACFCR (rw) register accessor: Ethernet MAC flow control register (ETH_MACFCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macfcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macfcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macfcr`] module"]
#[doc (alias = "MACFCR")] pub type Macfcr = crate :: Reg < macfcr :: MacfcrSpec > ;
#[doc = "Ethernet MAC flow control register (ETH_MACFCR)"] pub mod macfcr {
#[doc = "Register `MACFCR` reader"] pub type R = crate :: R < MacfcrSpec > ;
#[doc = "Register `MACFCR` writer"] pub type W = crate :: W < MacfcrSpec > ;
#[doc = "Field `FCB_BPA` reader - Flow control busy/back pressure activate"] pub type FcbBpaR = crate :: BitReader ;
#[doc = "Field `FCB_BPA` writer - Flow control busy/back pressure activate"] pub type FcbBpaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TFCE` reader - Transmit flow control enable"] pub type TfceR = crate :: BitReader ;
#[doc = "Field `TFCE` writer - Transmit flow control enable"] pub type TfceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RFCE` reader - Receive flow control enable"] pub type RfceR = crate :: BitReader ;
#[doc = "Field `RFCE` writer - Receive flow control enable"] pub type RfceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UPFD` reader - Unicast pause frame detect"] pub type UpfdR = crate :: BitReader ;
#[doc = "Field `UPFD` writer - Unicast pause frame detect"] pub type UpfdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLT` reader - Pause low threshold"] pub type PltR = crate :: FieldReader ;
#[doc = "Field `PLT` writer - Pause low threshold"] pub type PltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ZQPD` reader - Zero-quanta pause disable"] pub type ZqpdR = crate :: BitReader ;
#[doc = "Field `ZQPD` writer - Zero-quanta pause disable"] pub type ZqpdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PT` reader - Pass control frames"] pub type PtR = crate :: FieldReader < u16 > ;
#[doc = "Field `PT` writer - Pass control frames"] pub type PtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bit 0 - Flow control busy/back pressure activate"]
#[inline (always)] pub fn fcb_bpa (& self) -> FcbBpaR { FcbBpaR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transmit flow control enable"]
#[inline (always)] pub fn tfce (& self) -> TfceR { TfceR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Receive flow control enable"]
#[inline (always)] pub fn rfce (& self) -> RfceR { RfceR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Unicast pause frame detect"]
#[inline (always)] pub fn upfd (& self) -> UpfdR { UpfdR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - Pause low threshold"]
#[inline (always)] pub fn plt (& self) -> PltR { PltR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 7 - Zero-quanta pause disable"]
#[inline (always)] pub fn zqpd (& self) -> ZqpdR { ZqpdR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 16:31 - Pass control frames"]
#[inline (always)] pub fn pt (& self) -> PtR { PtR :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W {
#[doc = "Bit 0 - Flow control busy/back pressure activate"]
#[inline (always)] pub fn fcb_bpa (& mut self) -> FcbBpaW < '_ , MacfcrSpec > { FcbBpaW :: new (self , 0) }
#[doc = "Bit 1 - Transmit flow control enable"]
#[inline (always)] pub fn tfce (& mut self) -> TfceW < '_ , MacfcrSpec > { TfceW :: new (self , 1) }
#[doc = "Bit 2 - Receive flow control enable"]
#[inline (always)] pub fn rfce (& mut self) -> RfceW < '_ , MacfcrSpec > { RfceW :: new (self , 2) }
#[doc = "Bit 3 - Unicast pause frame detect"]
#[inline (always)] pub fn upfd (& mut self) -> UpfdW < '_ , MacfcrSpec > { UpfdW :: new (self , 3) }
#[doc = "Bits 4:5 - Pause low threshold"]
#[inline (always)] pub fn plt (& mut self) -> PltW < '_ , MacfcrSpec > { PltW :: new (self , 4) }
#[doc = "Bit 7 - Zero-quanta pause disable"]
#[inline (always)] pub fn zqpd (& mut self) -> ZqpdW < '_ , MacfcrSpec > { ZqpdW :: new (self , 7) }
#[doc = "Bits 16:31 - Pass control frames"]
#[inline (always)] pub fn pt (& mut self) -> PtW < '_ , MacfcrSpec > { PtW :: new (self , 16) } }
#[doc = "Ethernet MAC flow control register (ETH_MACFCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macfcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macfcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacfcrSpec ; impl crate :: RegisterSpec for MacfcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macfcr::R`](R) reader structure"] impl crate :: Readable for MacfcrSpec { }
#[doc = "`write(|w| ..)` method takes [`macfcr::W`](W) writer structure"] impl crate :: Writable for MacfcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACFCR to value 0"] impl crate :: Resettable for MacfcrSpec { } }
#[doc = "MACVLANTR (rw) register accessor: Ethernet MAC VLAN tag register (ETH_MACVLANTR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macvlantr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macvlantr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macvlantr`] module"]
#[doc (alias = "MACVLANTR")] pub type Macvlantr = crate :: Reg < macvlantr :: MacvlantrSpec > ;
#[doc = "Ethernet MAC VLAN tag register (ETH_MACVLANTR)"] pub mod macvlantr {
#[doc = "Register `MACVLANTR` reader"] pub type R = crate :: R < MacvlantrSpec > ;
#[doc = "Register `MACVLANTR` writer"] pub type W = crate :: W < MacvlantrSpec > ;
#[doc = "Field `VLANTI` reader - VLAN tag identifier (for receive frames)"] pub type VlantiR = crate :: FieldReader < u16 > ;
#[doc = "Field `VLANTI` writer - VLAN tag identifier (for receive frames)"] pub type VlantiW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `VLANTC` reader - 12-bit VLAN tag comparison"] pub type VlantcR = crate :: BitReader ;
#[doc = "Field `VLANTC` writer - 12-bit VLAN tag comparison"] pub type VlantcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:15 - VLAN tag identifier (for receive frames)"]
#[inline (always)] pub fn vlanti (& self) -> VlantiR { VlantiR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 16 - 12-bit VLAN tag comparison"]
#[inline (always)] pub fn vlantc (& self) -> VlantcR { VlantcR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - VLAN tag identifier (for receive frames)"]
#[inline (always)] pub fn vlanti (& mut self) -> VlantiW < '_ , MacvlantrSpec > { VlantiW :: new (self , 0) }
#[doc = "Bit 16 - 12-bit VLAN tag comparison"]
#[inline (always)] pub fn vlantc (& mut self) -> VlantcW < '_ , MacvlantrSpec > { VlantcW :: new (self , 16) } }
#[doc = "Ethernet MAC VLAN tag register (ETH_MACVLANTR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macvlantr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macvlantr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacvlantrSpec ; impl crate :: RegisterSpec for MacvlantrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macvlantr::R`](R) reader structure"] impl crate :: Readable for MacvlantrSpec { }
#[doc = "`write(|w| ..)` method takes [`macvlantr::W`](W) writer structure"] impl crate :: Writable for MacvlantrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACVLANTR to value 0"] impl crate :: Resettable for MacvlantrSpec { } }
#[doc = "MACRWUFFR (rw) register accessor: Ethernet MAC remote wakeup frame filter register (ETH_MACRWUFFR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macrwuffr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macrwuffr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macrwuffr`] module"]
#[doc (alias = "MACRWUFFR")] pub type Macrwuffr = crate :: Reg < macrwuffr :: MacrwuffrSpec > ;
#[doc = "Ethernet MAC remote wakeup frame filter register (ETH_MACRWUFFR)"] pub mod macrwuffr {
#[doc = "Register `MACRWUFFR` reader"] pub type R = crate :: R < MacrwuffrSpec > ;
#[doc = "Register `MACRWUFFR` writer"] pub type W = crate :: W < MacrwuffrSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { }
#[doc = "Ethernet MAC remote wakeup frame filter register (ETH_MACRWUFFR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macrwuffr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macrwuffr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacrwuffrSpec ; impl crate :: RegisterSpec for MacrwuffrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macrwuffr::R`](R) reader structure"] impl crate :: Readable for MacrwuffrSpec { }
#[doc = "`write(|w| ..)` method takes [`macrwuffr::W`](W) writer structure"] impl crate :: Writable for MacrwuffrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACRWUFFR to value 0"] impl crate :: Resettable for MacrwuffrSpec { } }
#[doc = "MACPMTCSR (rw) register accessor: Ethernet MAC PMT control and status register (ETH_MACPMTCSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macpmtcsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macpmtcsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macpmtcsr`] module"]
#[doc (alias = "MACPMTCSR")] pub type Macpmtcsr = crate :: Reg < macpmtcsr :: MacpmtcsrSpec > ;
#[doc = "Ethernet MAC PMT control and status register (ETH_MACPMTCSR)"] pub mod macpmtcsr {
#[doc = "Register `MACPMTCSR` reader"] pub type R = crate :: R < MacpmtcsrSpec > ;
#[doc = "Register `MACPMTCSR` writer"] pub type W = crate :: W < MacpmtcsrSpec > ;
#[doc = "Field `PD` reader - Power down"] pub type PdR = crate :: BitReader ;
#[doc = "Field `PD` writer - Power down"] pub type PdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MPE` reader - Magic Packet enable"] pub type MpeR = crate :: BitReader ;
#[doc = "Field `MPE` writer - Magic Packet enable"] pub type MpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WFE` reader - Wakeup frame enable"] pub type WfeR = crate :: BitReader ;
#[doc = "Field `WFE` writer - Wakeup frame enable"] pub type WfeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MPR` reader - Magic packet received"] pub type MprR = crate :: BitReader ;
#[doc = "Field `MPR` writer - Magic packet received"] pub type MprW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WFR` reader - Wakeup frame received"] pub type WfrR = crate :: BitReader ;
#[doc = "Field `WFR` writer - Wakeup frame received"] pub type WfrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GU` reader - Global unicast"] pub type GuR = crate :: BitReader ;
#[doc = "Field `GU` writer - Global unicast"] pub type GuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WFFRPR` reader - Wakeup frame filter register pointer reset"] pub type WffrprR = crate :: BitReader ;
#[doc = "Field `WFFRPR` writer - Wakeup frame filter register pointer reset"] pub type WffrprW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Power down"]
#[inline (always)] pub fn pd (& self) -> PdR { PdR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Magic Packet enable"]
#[inline (always)] pub fn mpe (& self) -> MpeR { MpeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Wakeup frame enable"]
#[inline (always)] pub fn wfe (& self) -> WfeR { WfeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 5 - Magic packet received"]
#[inline (always)] pub fn mpr (& self) -> MprR { MprR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Wakeup frame received"]
#[inline (always)] pub fn wfr (& self) -> WfrR { WfrR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 9 - Global unicast"]
#[inline (always)] pub fn gu (& self) -> GuR { GuR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 31 - Wakeup frame filter register pointer reset"]
#[inline (always)] pub fn wffrpr (& self) -> WffrprR { WffrprR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Power down"]
#[inline (always)] pub fn pd (& mut self) -> PdW < '_ , MacpmtcsrSpec > { PdW :: new (self , 0) }
#[doc = "Bit 1 - Magic Packet enable"]
#[inline (always)] pub fn mpe (& mut self) -> MpeW < '_ , MacpmtcsrSpec > { MpeW :: new (self , 1) }
#[doc = "Bit 2 - Wakeup frame enable"]
#[inline (always)] pub fn wfe (& mut self) -> WfeW < '_ , MacpmtcsrSpec > { WfeW :: new (self , 2) }
#[doc = "Bit 5 - Magic packet received"]
#[inline (always)] pub fn mpr (& mut self) -> MprW < '_ , MacpmtcsrSpec > { MprW :: new (self , 5) }
#[doc = "Bit 6 - Wakeup frame received"]
#[inline (always)] pub fn wfr (& mut self) -> WfrW < '_ , MacpmtcsrSpec > { WfrW :: new (self , 6) }
#[doc = "Bit 9 - Global unicast"]
#[inline (always)] pub fn gu (& mut self) -> GuW < '_ , MacpmtcsrSpec > { GuW :: new (self , 9) }
#[doc = "Bit 31 - Wakeup frame filter register pointer reset"]
#[inline (always)] pub fn wffrpr (& mut self) -> WffrprW < '_ , MacpmtcsrSpec > { WffrprW :: new (self , 31) } }
#[doc = "Ethernet MAC PMT control and status register (ETH_MACPMTCSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macpmtcsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macpmtcsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacpmtcsrSpec ; impl crate :: RegisterSpec for MacpmtcsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macpmtcsr::R`](R) reader structure"] impl crate :: Readable for MacpmtcsrSpec { }
#[doc = "`write(|w| ..)` method takes [`macpmtcsr::W`](W) writer structure"] impl crate :: Writable for MacpmtcsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACPMTCSR to value 0"] impl crate :: Resettable for MacpmtcsrSpec { } }
#[doc = "MACSR (rw) register accessor: Ethernet MAC interrupt status register (ETH_MACSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macsr`] module"]
#[doc (alias = "MACSR")] pub type Macsr = crate :: Reg < macsr :: MacsrSpec > ;
#[doc = "Ethernet MAC interrupt status register (ETH_MACSR)"] pub mod macsr {
#[doc = "Register `MACSR` reader"] pub type R = crate :: R < MacsrSpec > ;
#[doc = "Register `MACSR` writer"] pub type W = crate :: W < MacsrSpec > ;
#[doc = "Field `PMTS` reader - PMT status"] pub type PmtsR = crate :: BitReader ;
#[doc = "Field `PMTS` writer - PMT status"] pub type PmtsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMCS` reader - MMC status"] pub type MmcsR = crate :: BitReader ;
#[doc = "Field `MMCS` writer - MMC status"] pub type MmcsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMCRS` reader - MMC receive status"] pub type MmcrsR = crate :: BitReader ;
#[doc = "Field `MMCRS` writer - MMC receive status"] pub type MmcrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMCTS` reader - MMC transmit status"] pub type MmctsR = crate :: BitReader ;
#[doc = "Field `MMCTS` writer - MMC transmit status"] pub type MmctsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSTS` reader - Time stamp trigger status"] pub type TstsR = crate :: BitReader ;
#[doc = "Field `TSTS` writer - Time stamp trigger status"] pub type TstsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - PMT status"]
#[inline (always)] pub fn pmts (& self) -> PmtsR { PmtsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - MMC status"]
#[inline (always)] pub fn mmcs (& self) -> MmcsR { MmcsR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - MMC receive status"]
#[inline (always)] pub fn mmcrs (& self) -> MmcrsR { MmcrsR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - MMC transmit status"]
#[inline (always)] pub fn mmcts (& self) -> MmctsR { MmctsR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 9 - Time stamp trigger status"]
#[inline (always)] pub fn tsts (& self) -> TstsR { TstsR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 3 - PMT status"]
#[inline (always)] pub fn pmts (& mut self) -> PmtsW < '_ , MacsrSpec > { PmtsW :: new (self , 3) }
#[doc = "Bit 4 - MMC status"]
#[inline (always)] pub fn mmcs (& mut self) -> MmcsW < '_ , MacsrSpec > { MmcsW :: new (self , 4) }
#[doc = "Bit 5 - MMC receive status"]
#[inline (always)] pub fn mmcrs (& mut self) -> MmcrsW < '_ , MacsrSpec > { MmcrsW :: new (self , 5) }
#[doc = "Bit 6 - MMC transmit status"]
#[inline (always)] pub fn mmcts (& mut self) -> MmctsW < '_ , MacsrSpec > { MmctsW :: new (self , 6) }
#[doc = "Bit 9 - Time stamp trigger status"]
#[inline (always)] pub fn tsts (& mut self) -> TstsW < '_ , MacsrSpec > { TstsW :: new (self , 9) } }
#[doc = "Ethernet MAC interrupt status register (ETH_MACSR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacsrSpec ; impl crate :: RegisterSpec for MacsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macsr::R`](R) reader structure"] impl crate :: Readable for MacsrSpec { }
#[doc = "`write(|w| ..)` method takes [`macsr::W`](W) writer structure"] impl crate :: Writable for MacsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACSR to value 0"] impl crate :: Resettable for MacsrSpec { } }
#[doc = "MACIMR (rw) register accessor: Ethernet MAC interrupt mask register (ETH_MACIMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macimr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macimr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@macimr`] module"]
#[doc (alias = "MACIMR")] pub type Macimr = crate :: Reg < macimr :: MacimrSpec > ;
#[doc = "Ethernet MAC interrupt mask register (ETH_MACIMR)"] pub mod macimr {
#[doc = "Register `MACIMR` reader"] pub type R = crate :: R < MacimrSpec > ;
#[doc = "Register `MACIMR` writer"] pub type W = crate :: W < MacimrSpec > ;
#[doc = "Field `PMTIM` reader - PMT interrupt mask"] pub type PmtimR = crate :: BitReader ;
#[doc = "Field `PMTIM` writer - PMT interrupt mask"] pub type PmtimW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSTIM` reader - Time stamp trigger interrupt mask"] pub type TstimR = crate :: BitReader ;
#[doc = "Field `TSTIM` writer - Time stamp trigger interrupt mask"] pub type TstimW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - PMT interrupt mask"]
#[inline (always)] pub fn pmtim (& self) -> PmtimR { PmtimR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 9 - Time stamp trigger interrupt mask"]
#[inline (always)] pub fn tstim (& self) -> TstimR { TstimR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 3 - PMT interrupt mask"]
#[inline (always)] pub fn pmtim (& mut self) -> PmtimW < '_ , MacimrSpec > { PmtimW :: new (self , 3) }
#[doc = "Bit 9 - Time stamp trigger interrupt mask"]
#[inline (always)] pub fn tstim (& mut self) -> TstimW < '_ , MacimrSpec > { TstimW :: new (self , 9) } }
#[doc = "Ethernet MAC interrupt mask register (ETH_MACIMR)\n\nYou can [`read`](crate::Reg::read) this register and get [`macimr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macimr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacimrSpec ; impl crate :: RegisterSpec for MacimrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`macimr::R`](R) reader structure"] impl crate :: Readable for MacimrSpec { }
#[doc = "`write(|w| ..)` method takes [`macimr::W`](W) writer structure"] impl crate :: Writable for MacimrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACIMR to value 0"] impl crate :: Resettable for MacimrSpec { } }
#[doc = "MACA0HR (rw) register accessor: Ethernet MAC address 0 high register (ETH_MACA0HR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maca0hr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca0hr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maca0hr`] module"]
#[doc (alias = "MACA0HR")] pub type Maca0hr = crate :: Reg < maca0hr :: Maca0hrSpec > ;
#[doc = "Ethernet MAC address 0 high register (ETH_MACA0HR)"] pub mod maca0hr {
#[doc = "Register `MACA0HR` reader"] pub type R = crate :: R < Maca0hrSpec > ;
#[doc = "Register `MACA0HR` writer"] pub type W = crate :: W < Maca0hrSpec > ;
#[doc = "Field `MACA0H` reader - MAC address0 high"] pub type Maca0hR = crate :: FieldReader < u16 > ;
#[doc = "Field `MACA0H` writer - MAC address0 high"] pub type Maca0hW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `MO` reader - Always 1"] pub type MoR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - MAC address0 high"]
#[inline (always)] pub fn maca0h (& self) -> Maca0hR { Maca0hR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 31 - Always 1"]
#[inline (always)] pub fn mo (& self) -> MoR { MoR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - MAC address0 high"]
#[inline (always)] pub fn maca0h (& mut self) -> Maca0hW < '_ , Maca0hrSpec > { Maca0hW :: new (self , 0) } }
#[doc = "Ethernet MAC address 0 high register (ETH_MACA0HR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maca0hr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca0hr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Maca0hrSpec ; impl crate :: RegisterSpec for Maca0hrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maca0hr::R`](R) reader structure"] impl crate :: Readable for Maca0hrSpec { }
#[doc = "`write(|w| ..)` method takes [`maca0hr::W`](W) writer structure"] impl crate :: Writable for Maca0hrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACA0HR to value 0x0010_ffff"] impl crate :: Resettable for Maca0hrSpec { const RESET_VALUE : u32 = 0x0010_ffff ; } }
#[doc = "MACA0LR (rw) register accessor: Ethernet MAC address 0 low register\n\nYou can [`read`](crate::Reg::read) this register and get [`maca0lr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca0lr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maca0lr`] module"]
#[doc (alias = "MACA0LR")] pub type Maca0lr = crate :: Reg < maca0lr :: Maca0lrSpec > ;
#[doc = "Ethernet MAC address 0 low register"] pub mod maca0lr {
#[doc = "Register `MACA0LR` reader"] pub type R = crate :: R < Maca0lrSpec > ;
#[doc = "Register `MACA0LR` writer"] pub type W = crate :: W < Maca0lrSpec > ;
#[doc = "Field `MACA0L` reader - MAC address0 low"] pub type Maca0lR = crate :: FieldReader < u32 > ;
#[doc = "Field `MACA0L` writer - MAC address0 low"] pub type Maca0lW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - MAC address0 low"]
#[inline (always)] pub fn maca0l (& self) -> Maca0lR { Maca0lR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - MAC address0 low"]
#[inline (always)] pub fn maca0l (& mut self) -> Maca0lW < '_ , Maca0lrSpec > { Maca0lW :: new (self , 0) } }
#[doc = "Ethernet MAC address 0 low register\n\nYou can [`read`](crate::Reg::read) this register and get [`maca0lr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca0lr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Maca0lrSpec ; impl crate :: RegisterSpec for Maca0lrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maca0lr::R`](R) reader structure"] impl crate :: Readable for Maca0lrSpec { }
#[doc = "`write(|w| ..)` method takes [`maca0lr::W`](W) writer structure"] impl crate :: Writable for Maca0lrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACA0LR to value 0xffff_ffff"] impl crate :: Resettable for Maca0lrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "MACA1HR (rw) register accessor: Ethernet MAC address 1 high register (ETH_MACA1HR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maca1hr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca1hr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maca1hr`] module"]
#[doc (alias = "MACA1HR")] pub type Maca1hr = crate :: Reg < maca1hr :: Maca1hrSpec > ;
#[doc = "Ethernet MAC address 1 high register (ETH_MACA1HR)"] pub mod maca1hr {
#[doc = "Register `MACA1HR` reader"] pub type R = crate :: R < Maca1hrSpec > ;
#[doc = "Register `MACA1HR` writer"] pub type W = crate :: W < Maca1hrSpec > ;
#[doc = "Field `MACA1H` reader - MAC address1 high"] pub type Maca1hR = crate :: FieldReader < u16 > ;
#[doc = "Field `MACA1H` writer - MAC address1 high"] pub type Maca1hW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `MBC` reader - Mask byte control"] pub type MbcR = crate :: FieldReader ;
#[doc = "Field `MBC` writer - Mask byte control"] pub type MbcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `SA` reader - Source address"] pub type SaR = crate :: BitReader ;
#[doc = "Field `SA` writer - Source address"] pub type SaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AE` reader - Address enable"] pub type AeR = crate :: BitReader ;
#[doc = "Field `AE` writer - Address enable"] pub type AeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:15 - MAC address1 high"]
#[inline (always)] pub fn maca1h (& self) -> Maca1hR { Maca1hR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 24:29 - Mask byte control"]
#[inline (always)] pub fn mbc (& self) -> MbcR { MbcR :: new (((self . bits >> 24) & 0x3f) as u8) }
#[doc = "Bit 30 - Source address"]
#[inline (always)] pub fn sa (& self) -> SaR { SaR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Address enable"]
#[inline (always)] pub fn ae (& self) -> AeR { AeR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - MAC address1 high"]
#[inline (always)] pub fn maca1h (& mut self) -> Maca1hW < '_ , Maca1hrSpec > { Maca1hW :: new (self , 0) }
#[doc = "Bits 24:29 - Mask byte control"]
#[inline (always)] pub fn mbc (& mut self) -> MbcW < '_ , Maca1hrSpec > { MbcW :: new (self , 24) }
#[doc = "Bit 30 - Source address"]
#[inline (always)] pub fn sa (& mut self) -> SaW < '_ , Maca1hrSpec > { SaW :: new (self , 30) }
#[doc = "Bit 31 - Address enable"]
#[inline (always)] pub fn ae (& mut self) -> AeW < '_ , Maca1hrSpec > { AeW :: new (self , 31) } }
#[doc = "Ethernet MAC address 1 high register (ETH_MACA1HR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maca1hr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca1hr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Maca1hrSpec ; impl crate :: RegisterSpec for Maca1hrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maca1hr::R`](R) reader structure"] impl crate :: Readable for Maca1hrSpec { }
#[doc = "`write(|w| ..)` method takes [`maca1hr::W`](W) writer structure"] impl crate :: Writable for Maca1hrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACA1HR to value 0xffff"] impl crate :: Resettable for Maca1hrSpec { const RESET_VALUE : u32 = 0xffff ; } }
#[doc = "MACA1LR (rw) register accessor: Ethernet MAC address1 low register\n\nYou can [`read`](crate::Reg::read) this register and get [`maca1lr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca1lr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maca1lr`] module"]
#[doc (alias = "MACA1LR")] pub type Maca1lr = crate :: Reg < maca1lr :: Maca1lrSpec > ;
#[doc = "Ethernet MAC address1 low register"] pub mod maca1lr {
#[doc = "Register `MACA1LR` reader"] pub type R = crate :: R < Maca1lrSpec > ;
#[doc = "Register `MACA1LR` writer"] pub type W = crate :: W < Maca1lrSpec > ;
#[doc = "Field `MACA1L` reader - MAC address1 low"] pub type Maca1lR = crate :: FieldReader < u32 > ;
#[doc = "Field `MACA1L` writer - MAC address1 low"] pub type Maca1lW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - MAC address1 low"]
#[inline (always)] pub fn maca1l (& self) -> Maca1lR { Maca1lR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - MAC address1 low"]
#[inline (always)] pub fn maca1l (& mut self) -> Maca1lW < '_ , Maca1lrSpec > { Maca1lW :: new (self , 0) } }
#[doc = "Ethernet MAC address1 low register\n\nYou can [`read`](crate::Reg::read) this register and get [`maca1lr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca1lr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Maca1lrSpec ; impl crate :: RegisterSpec for Maca1lrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maca1lr::R`](R) reader structure"] impl crate :: Readable for Maca1lrSpec { }
#[doc = "`write(|w| ..)` method takes [`maca1lr::W`](W) writer structure"] impl crate :: Writable for Maca1lrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACA1LR to value 0xffff_ffff"] impl crate :: Resettable for Maca1lrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "MACA2HR (rw) register accessor: Ethernet MAC address 2 high register (ETH_MACA2HR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maca2hr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca2hr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maca2hr`] module"]
#[doc (alias = "MACA2HR")] pub type Maca2hr = crate :: Reg < maca2hr :: Maca2hrSpec > ;
#[doc = "Ethernet MAC address 2 high register (ETH_MACA2HR)"] pub mod maca2hr {
#[doc = "Register `MACA2HR` reader"] pub type R = crate :: R < Maca2hrSpec > ;
#[doc = "Register `MACA2HR` writer"] pub type W = crate :: W < Maca2hrSpec > ;
#[doc = "Field `ETH_MACA2HR` reader - Ethernet MAC address 2 high register"] pub type EthMaca2hrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ETH_MACA2HR` writer - Ethernet MAC address 2 high register"] pub type EthMaca2hrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `MBC` reader - Mask byte control"] pub type MbcR = crate :: FieldReader ;
#[doc = "Field `MBC` writer - Mask byte control"] pub type MbcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `SA` reader - Source address"] pub type SaR = crate :: BitReader ;
#[doc = "Field `SA` writer - Source address"] pub type SaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AE` reader - Address enable"] pub type AeR = crate :: BitReader ;
#[doc = "Field `AE` writer - Address enable"] pub type AeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:15 - Ethernet MAC address 2 high register"]
#[inline (always)] pub fn eth_maca2hr (& self) -> EthMaca2hrR { EthMaca2hrR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 24:29 - Mask byte control"]
#[inline (always)] pub fn mbc (& self) -> MbcR { MbcR :: new (((self . bits >> 24) & 0x3f) as u8) }
#[doc = "Bit 30 - Source address"]
#[inline (always)] pub fn sa (& self) -> SaR { SaR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Address enable"]
#[inline (always)] pub fn ae (& self) -> AeR { AeR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - Ethernet MAC address 2 high register"]
#[inline (always)] pub fn eth_maca2hr (& mut self) -> EthMaca2hrW < '_ , Maca2hrSpec > { EthMaca2hrW :: new (self , 0) }
#[doc = "Bits 24:29 - Mask byte control"]
#[inline (always)] pub fn mbc (& mut self) -> MbcW < '_ , Maca2hrSpec > { MbcW :: new (self , 24) }
#[doc = "Bit 30 - Source address"]
#[inline (always)] pub fn sa (& mut self) -> SaW < '_ , Maca2hrSpec > { SaW :: new (self , 30) }
#[doc = "Bit 31 - Address enable"]
#[inline (always)] pub fn ae (& mut self) -> AeW < '_ , Maca2hrSpec > { AeW :: new (self , 31) } }
#[doc = "Ethernet MAC address 2 high register (ETH_MACA2HR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maca2hr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca2hr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Maca2hrSpec ; impl crate :: RegisterSpec for Maca2hrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maca2hr::R`](R) reader structure"] impl crate :: Readable for Maca2hrSpec { }
#[doc = "`write(|w| ..)` method takes [`maca2hr::W`](W) writer structure"] impl crate :: Writable for Maca2hrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACA2HR to value 0x50"] impl crate :: Resettable for Maca2hrSpec { const RESET_VALUE : u32 = 0x50 ; } }
#[doc = "MACA2LR (rw) register accessor: Ethernet MAC address 2 low register\n\nYou can [`read`](crate::Reg::read) this register and get [`maca2lr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca2lr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maca2lr`] module"]
#[doc (alias = "MACA2LR")] pub type Maca2lr = crate :: Reg < maca2lr :: Maca2lrSpec > ;
#[doc = "Ethernet MAC address 2 low register"] pub mod maca2lr {
#[doc = "Register `MACA2LR` reader"] pub type R = crate :: R < Maca2lrSpec > ;
#[doc = "Register `MACA2LR` writer"] pub type W = crate :: W < Maca2lrSpec > ;
#[doc = "Field `MACA2L` reader - MAC address2 low"] pub type Maca2lR = crate :: FieldReader < u32 > ;
#[doc = "Field `MACA2L` writer - MAC address2 low"] pub type Maca2lW < 'a , REG > = crate :: FieldWriter < 'a , REG , 31 , u32 > ; impl R {
#[doc = "Bits 0:30 - MAC address2 low"]
#[inline (always)] pub fn maca2l (& self) -> Maca2lR { Maca2lR :: new (self . bits & 0x7fff_ffff) } } impl W {
#[doc = "Bits 0:30 - MAC address2 low"]
#[inline (always)] pub fn maca2l (& mut self) -> Maca2lW < '_ , Maca2lrSpec > { Maca2lW :: new (self , 0) } }
#[doc = "Ethernet MAC address 2 low register\n\nYou can [`read`](crate::Reg::read) this register and get [`maca2lr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca2lr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Maca2lrSpec ; impl crate :: RegisterSpec for Maca2lrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maca2lr::R`](R) reader structure"] impl crate :: Readable for Maca2lrSpec { }
#[doc = "`write(|w| ..)` method takes [`maca2lr::W`](W) writer structure"] impl crate :: Writable for Maca2lrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACA2LR to value 0xffff_ffff"] impl crate :: Resettable for Maca2lrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "MACA3HR (rw) register accessor: Ethernet MAC address 3 high register (ETH_MACA3HR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maca3hr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca3hr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maca3hr`] module"]
#[doc (alias = "MACA3HR")] pub type Maca3hr = crate :: Reg < maca3hr :: Maca3hrSpec > ;
#[doc = "Ethernet MAC address 3 high register (ETH_MACA3HR)"] pub mod maca3hr {
#[doc = "Register `MACA3HR` reader"] pub type R = crate :: R < Maca3hrSpec > ;
#[doc = "Register `MACA3HR` writer"] pub type W = crate :: W < Maca3hrSpec > ;
#[doc = "Field `MACA3H` reader - MAC address3 high"] pub type Maca3hR = crate :: FieldReader < u16 > ;
#[doc = "Field `MACA3H` writer - MAC address3 high"] pub type Maca3hW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `MBC` reader - Mask byte control"] pub type MbcR = crate :: FieldReader ;
#[doc = "Field `MBC` writer - Mask byte control"] pub type MbcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `SA` reader - Source address"] pub type SaR = crate :: BitReader ;
#[doc = "Field `SA` writer - Source address"] pub type SaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AE` reader - Address enable"] pub type AeR = crate :: BitReader ;
#[doc = "Field `AE` writer - Address enable"] pub type AeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:15 - MAC address3 high"]
#[inline (always)] pub fn maca3h (& self) -> Maca3hR { Maca3hR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 24:29 - Mask byte control"]
#[inline (always)] pub fn mbc (& self) -> MbcR { MbcR :: new (((self . bits >> 24) & 0x3f) as u8) }
#[doc = "Bit 30 - Source address"]
#[inline (always)] pub fn sa (& self) -> SaR { SaR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Address enable"]
#[inline (always)] pub fn ae (& self) -> AeR { AeR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - MAC address3 high"]
#[inline (always)] pub fn maca3h (& mut self) -> Maca3hW < '_ , Maca3hrSpec > { Maca3hW :: new (self , 0) }
#[doc = "Bits 24:29 - Mask byte control"]
#[inline (always)] pub fn mbc (& mut self) -> MbcW < '_ , Maca3hrSpec > { MbcW :: new (self , 24) }
#[doc = "Bit 30 - Source address"]
#[inline (always)] pub fn sa (& mut self) -> SaW < '_ , Maca3hrSpec > { SaW :: new (self , 30) }
#[doc = "Bit 31 - Address enable"]
#[inline (always)] pub fn ae (& mut self) -> AeW < '_ , Maca3hrSpec > { AeW :: new (self , 31) } }
#[doc = "Ethernet MAC address 3 high register (ETH_MACA3HR)\n\nYou can [`read`](crate::Reg::read) this register and get [`maca3hr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca3hr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Maca3hrSpec ; impl crate :: RegisterSpec for Maca3hrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maca3hr::R`](R) reader structure"] impl crate :: Readable for Maca3hrSpec { }
#[doc = "`write(|w| ..)` method takes [`maca3hr::W`](W) writer structure"] impl crate :: Writable for Maca3hrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACA3HR to value 0xffff"] impl crate :: Resettable for Maca3hrSpec { const RESET_VALUE : u32 = 0xffff ; } }
#[doc = "MACA3LR (rw) register accessor: Ethernet MAC address 3 low register\n\nYou can [`read`](crate::Reg::read) this register and get [`maca3lr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca3lr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@maca3lr`] module"]
#[doc (alias = "MACA3LR")] pub type Maca3lr = crate :: Reg < maca3lr :: Maca3lrSpec > ;
#[doc = "Ethernet MAC address 3 low register"] pub mod maca3lr {
#[doc = "Register `MACA3LR` reader"] pub type R = crate :: R < Maca3lrSpec > ;
#[doc = "Register `MACA3LR` writer"] pub type W = crate :: W < Maca3lrSpec > ;
#[doc = "Field `MBCA3L` reader - MAC address3 low"] pub type Mbca3lR = crate :: FieldReader < u32 > ;
#[doc = "Field `MBCA3L` writer - MAC address3 low"] pub type Mbca3lW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - MAC address3 low"]
#[inline (always)] pub fn mbca3l (& self) -> Mbca3lR { Mbca3lR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - MAC address3 low"]
#[inline (always)] pub fn mbca3l (& mut self) -> Mbca3lW < '_ , Maca3lrSpec > { Mbca3lW :: new (self , 0) } }
#[doc = "Ethernet MAC address 3 low register\n\nYou can [`read`](crate::Reg::read) this register and get [`maca3lr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maca3lr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Maca3lrSpec ; impl crate :: RegisterSpec for Maca3lrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`maca3lr::R`](R) reader structure"] impl crate :: Readable for Maca3lrSpec { }
#[doc = "`write(|w| ..)` method takes [`maca3lr::W`](W) writer structure"] impl crate :: Writable for Maca3lrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MACA3LR to value 0xffff_ffff"] impl crate :: Resettable for Maca3lrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } }
#[doc = "Ethernet: Precision time protocol"] pub type EthernetPtp = crate :: Periph < ethernet_ptp :: RegisterBlock , 0x4002_8700 > ; impl core :: fmt :: Debug for EthernetPtp { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EthernetPtp") . finish () } }
#[doc = "Ethernet: Precision time protocol"] pub mod ethernet_ptp {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ptptscr : Ptptscr , ptpssir : Ptpssir , ptptshr : Ptptshr , ptptslr : Ptptslr , ptptshur : Ptptshur , ptptslur : Ptptslur , ptptsar : Ptptsar , ptptthr : Ptptthr , ptpttlr : Ptpttlr , } impl RegisterBlock {
#[doc = "0x00 - Ethernet PTP time stamp control register (ETH_PTPTSCR)"]
#[inline (always)] pub const fn ptptscr (& self) -> & Ptptscr { & self . ptptscr }
#[doc = "0x04 - Ethernet PTP subsecond increment register"]
#[inline (always)] pub const fn ptpssir (& self) -> & Ptpssir { & self . ptpssir }
#[doc = "0x08 - Ethernet PTP time stamp high register"]
#[inline (always)] pub const fn ptptshr (& self) -> & Ptptshr { & self . ptptshr }
#[doc = "0x0c - Ethernet PTP time stamp low register (ETH_PTPTSLR)"]
#[inline (always)] pub const fn ptptslr (& self) -> & Ptptslr { & self . ptptslr }
#[doc = "0x10 - Ethernet PTP time stamp high update register"]
#[inline (always)] pub const fn ptptshur (& self) -> & Ptptshur { & self . ptptshur }
#[doc = "0x14 - Ethernet PTP time stamp low update register (ETH_PTPTSLUR)"]
#[inline (always)] pub const fn ptptslur (& self) -> & Ptptslur { & self . ptptslur }
#[doc = "0x18 - Ethernet PTP time stamp addend register"]
#[inline (always)] pub const fn ptptsar (& self) -> & Ptptsar { & self . ptptsar }
#[doc = "0x1c - Ethernet PTP target time high register"]
#[inline (always)] pub const fn ptptthr (& self) -> & Ptptthr { & self . ptptthr }
#[doc = "0x20 - Ethernet PTP target time low register"]
#[inline (always)] pub const fn ptpttlr (& self) -> & Ptpttlr { & self . ptpttlr } }
#[doc = "PTPTSCR (rw) register accessor: Ethernet PTP time stamp control register (ETH_PTPTSCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptscr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptscr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptptscr`] module"]
#[doc (alias = "PTPTSCR")] pub type Ptptscr = crate :: Reg < ptptscr :: PtptscrSpec > ;
#[doc = "Ethernet PTP time stamp control register (ETH_PTPTSCR)"] pub mod ptptscr {
#[doc = "Register `PTPTSCR` reader"] pub type R = crate :: R < PtptscrSpec > ;
#[doc = "Register `PTPTSCR` writer"] pub type W = crate :: W < PtptscrSpec > ;
#[doc = "Field `TSE` reader - Time stamp enable"] pub type TseR = crate :: BitReader ;
#[doc = "Field `TSE` writer - Time stamp enable"] pub type TseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSFCU` reader - Time stamp fine or coarse update"] pub type TsfcuR = crate :: BitReader ;
#[doc = "Field `TSFCU` writer - Time stamp fine or coarse update"] pub type TsfcuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSSTI` reader - Time stamp system time initialize"] pub type TsstiR = crate :: BitReader ;
#[doc = "Field `TSSTI` writer - Time stamp system time initialize"] pub type TsstiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSSTU` reader - Time stamp system time update"] pub type TsstuR = crate :: BitReader ;
#[doc = "Field `TSSTU` writer - Time stamp system time update"] pub type TsstuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSITE` reader - Time stamp interrupt trigger enable"] pub type TsiteR = crate :: BitReader ;
#[doc = "Field `TSITE` writer - Time stamp interrupt trigger enable"] pub type TsiteW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSARU` reader - Time stamp addend register update"] pub type TsaruR = crate :: BitReader ;
#[doc = "Field `TSARU` writer - Time stamp addend register update"] pub type TsaruW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Time stamp enable"]
#[inline (always)] pub fn tse (& self) -> TseR { TseR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Time stamp fine or coarse update"]
#[inline (always)] pub fn tsfcu (& self) -> TsfcuR { TsfcuR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Time stamp system time initialize"]
#[inline (always)] pub fn tssti (& self) -> TsstiR { TsstiR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Time stamp system time update"]
#[inline (always)] pub fn tsstu (& self) -> TsstuR { TsstuR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Time stamp interrupt trigger enable"]
#[inline (always)] pub fn tsite (& self) -> TsiteR { TsiteR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Time stamp addend register update"]
#[inline (always)] pub fn tsaru (& self) -> TsaruR { TsaruR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Time stamp enable"]
#[inline (always)] pub fn tse (& mut self) -> TseW < '_ , PtptscrSpec > { TseW :: new (self , 0) }
#[doc = "Bit 1 - Time stamp fine or coarse update"]
#[inline (always)] pub fn tsfcu (& mut self) -> TsfcuW < '_ , PtptscrSpec > { TsfcuW :: new (self , 1) }
#[doc = "Bit 2 - Time stamp system time initialize"]
#[inline (always)] pub fn tssti (& mut self) -> TsstiW < '_ , PtptscrSpec > { TsstiW :: new (self , 2) }
#[doc = "Bit 3 - Time stamp system time update"]
#[inline (always)] pub fn tsstu (& mut self) -> TsstuW < '_ , PtptscrSpec > { TsstuW :: new (self , 3) }
#[doc = "Bit 4 - Time stamp interrupt trigger enable"]
#[inline (always)] pub fn tsite (& mut self) -> TsiteW < '_ , PtptscrSpec > { TsiteW :: new (self , 4) }
#[doc = "Bit 5 - Time stamp addend register update"]
#[inline (always)] pub fn tsaru (& mut self) -> TsaruW < '_ , PtptscrSpec > { TsaruW :: new (self , 5) } }
#[doc = "Ethernet PTP time stamp control register (ETH_PTPTSCR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptscr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptscr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtptscrSpec ; impl crate :: RegisterSpec for PtptscrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptptscr::R`](R) reader structure"] impl crate :: Readable for PtptscrSpec { }
#[doc = "`write(|w| ..)` method takes [`ptptscr::W`](W) writer structure"] impl crate :: Writable for PtptscrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PTPTSCR to value 0"] impl crate :: Resettable for PtptscrSpec { } }
#[doc = "PTPSSIR (rw) register accessor: Ethernet PTP subsecond increment register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptpssir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptpssir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptpssir`] module"]
#[doc (alias = "PTPSSIR")] pub type Ptpssir = crate :: Reg < ptpssir :: PtpssirSpec > ;
#[doc = "Ethernet PTP subsecond increment register"] pub mod ptpssir {
#[doc = "Register `PTPSSIR` reader"] pub type R = crate :: R < PtpssirSpec > ;
#[doc = "Register `PTPSSIR` writer"] pub type W = crate :: W < PtpssirSpec > ;
#[doc = "Field `STSSI` reader - System time subsecond increment"] pub type StssiR = crate :: FieldReader ;
#[doc = "Field `STSSI` writer - System time subsecond increment"] pub type StssiW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - System time subsecond increment"]
#[inline (always)] pub fn stssi (& self) -> StssiR { StssiR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - System time subsecond increment"]
#[inline (always)] pub fn stssi (& mut self) -> StssiW < '_ , PtpssirSpec > { StssiW :: new (self , 0) } }
#[doc = "Ethernet PTP subsecond increment register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptpssir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptpssir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtpssirSpec ; impl crate :: RegisterSpec for PtpssirSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptpssir::R`](R) reader structure"] impl crate :: Readable for PtpssirSpec { }
#[doc = "`write(|w| ..)` method takes [`ptpssir::W`](W) writer structure"] impl crate :: Writable for PtpssirSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PTPSSIR to value 0"] impl crate :: Resettable for PtpssirSpec { } }
#[doc = "PTPTSHR (r) register accessor: Ethernet PTP time stamp high register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptshr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptptshr`] module"]
#[doc (alias = "PTPTSHR")] pub type Ptptshr = crate :: Reg < ptptshr :: PtptshrSpec > ;
#[doc = "Ethernet PTP time stamp high register"] pub mod ptptshr {
#[doc = "Register `PTPTSHR` reader"] pub type R = crate :: R < PtptshrSpec > ;
#[doc = "Field `STS` reader - System time second"] pub type StsR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - System time second"]
#[inline (always)] pub fn sts (& self) -> StsR { StsR :: new (self . bits) } }
#[doc = "Ethernet PTP time stamp high register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptshr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtptshrSpec ; impl crate :: RegisterSpec for PtptshrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptptshr::R`](R) reader structure"] impl crate :: Readable for PtptshrSpec { }
#[doc = "`reset()` method sets PTPTSHR to value 0"] impl crate :: Resettable for PtptshrSpec { } }
#[doc = "PTPTSLR (r) register accessor: Ethernet PTP time stamp low register (ETH_PTPTSLR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptslr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptptslr`] module"]
#[doc (alias = "PTPTSLR")] pub type Ptptslr = crate :: Reg < ptptslr :: PtptslrSpec > ;
#[doc = "Ethernet PTP time stamp low register (ETH_PTPTSLR)"] pub mod ptptslr {
#[doc = "Register `PTPTSLR` reader"] pub type R = crate :: R < PtptslrSpec > ;
#[doc = "Field `STSS` reader - System time subseconds"] pub type StssR = crate :: FieldReader < u32 > ;
#[doc = "Field `STPNS` reader - System time positive or negative sign"] pub type StpnsR = crate :: BitReader ; impl R {
#[doc = "Bits 0:30 - System time subseconds"]
#[inline (always)] pub fn stss (& self) -> StssR { StssR :: new (self . bits & 0x7fff_ffff) }
#[doc = "Bit 31 - System time positive or negative sign"]
#[inline (always)] pub fn stpns (& self) -> StpnsR { StpnsR :: new (((self . bits >> 31) & 1) != 0) } }
#[doc = "Ethernet PTP time stamp low register (ETH_PTPTSLR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptslr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtptslrSpec ; impl crate :: RegisterSpec for PtptslrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptptslr::R`](R) reader structure"] impl crate :: Readable for PtptslrSpec { }
#[doc = "`reset()` method sets PTPTSLR to value 0"] impl crate :: Resettable for PtptslrSpec { } }
#[doc = "PTPTSHUR (rw) register accessor: Ethernet PTP time stamp high update register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptshur::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptshur::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptptshur`] module"]
#[doc (alias = "PTPTSHUR")] pub type Ptptshur = crate :: Reg < ptptshur :: PtptshurSpec > ;
#[doc = "Ethernet PTP time stamp high update register"] pub mod ptptshur {
#[doc = "Register `PTPTSHUR` reader"] pub type R = crate :: R < PtptshurSpec > ;
#[doc = "Register `PTPTSHUR` writer"] pub type W = crate :: W < PtptshurSpec > ;
#[doc = "Field `TSUS` reader - Time stamp update second"] pub type TsusR = crate :: FieldReader < u32 > ;
#[doc = "Field `TSUS` writer - Time stamp update second"] pub type TsusW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Time stamp update second"]
#[inline (always)] pub fn tsus (& self) -> TsusR { TsusR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Time stamp update second"]
#[inline (always)] pub fn tsus (& mut self) -> TsusW < '_ , PtptshurSpec > { TsusW :: new (self , 0) } }
#[doc = "Ethernet PTP time stamp high update register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptshur::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptshur::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtptshurSpec ; impl crate :: RegisterSpec for PtptshurSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptptshur::R`](R) reader structure"] impl crate :: Readable for PtptshurSpec { }
#[doc = "`write(|w| ..)` method takes [`ptptshur::W`](W) writer structure"] impl crate :: Writable for PtptshurSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PTPTSHUR to value 0"] impl crate :: Resettable for PtptshurSpec { } }
#[doc = "PTPTSLUR (rw) register accessor: Ethernet PTP time stamp low update register (ETH_PTPTSLUR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptslur::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptslur::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptptslur`] module"]
#[doc (alias = "PTPTSLUR")] pub type Ptptslur = crate :: Reg < ptptslur :: PtptslurSpec > ;
#[doc = "Ethernet PTP time stamp low update register (ETH_PTPTSLUR)"] pub mod ptptslur {
#[doc = "Register `PTPTSLUR` reader"] pub type R = crate :: R < PtptslurSpec > ;
#[doc = "Register `PTPTSLUR` writer"] pub type W = crate :: W < PtptslurSpec > ;
#[doc = "Field `TSUSS` reader - Time stamp update subseconds"] pub type TsussR = crate :: FieldReader < u32 > ;
#[doc = "Field `TSUSS` writer - Time stamp update subseconds"] pub type TsussW < 'a , REG > = crate :: FieldWriter < 'a , REG , 31 , u32 > ;
#[doc = "Field `TSUPNS` reader - Time stamp update positive or negative sign"] pub type TsupnsR = crate :: BitReader ;
#[doc = "Field `TSUPNS` writer - Time stamp update positive or negative sign"] pub type TsupnsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:30 - Time stamp update subseconds"]
#[inline (always)] pub fn tsuss (& self) -> TsussR { TsussR :: new (self . bits & 0x7fff_ffff) }
#[doc = "Bit 31 - Time stamp update positive or negative sign"]
#[inline (always)] pub fn tsupns (& self) -> TsupnsR { TsupnsR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bits 0:30 - Time stamp update subseconds"]
#[inline (always)] pub fn tsuss (& mut self) -> TsussW < '_ , PtptslurSpec > { TsussW :: new (self , 0) }
#[doc = "Bit 31 - Time stamp update positive or negative sign"]
#[inline (always)] pub fn tsupns (& mut self) -> TsupnsW < '_ , PtptslurSpec > { TsupnsW :: new (self , 31) } }
#[doc = "Ethernet PTP time stamp low update register (ETH_PTPTSLUR)\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptslur::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptslur::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtptslurSpec ; impl crate :: RegisterSpec for PtptslurSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptptslur::R`](R) reader structure"] impl crate :: Readable for PtptslurSpec { }
#[doc = "`write(|w| ..)` method takes [`ptptslur::W`](W) writer structure"] impl crate :: Writable for PtptslurSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PTPTSLUR to value 0"] impl crate :: Resettable for PtptslurSpec { } }
#[doc = "PTPTSAR (rw) register accessor: Ethernet PTP time stamp addend register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptsar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptsar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptptsar`] module"]
#[doc (alias = "PTPTSAR")] pub type Ptptsar = crate :: Reg < ptptsar :: PtptsarSpec > ;
#[doc = "Ethernet PTP time stamp addend register"] pub mod ptptsar {
#[doc = "Register `PTPTSAR` reader"] pub type R = crate :: R < PtptsarSpec > ;
#[doc = "Register `PTPTSAR` writer"] pub type W = crate :: W < PtptsarSpec > ;
#[doc = "Field `TSA` reader - Time stamp addend"] pub type TsaR = crate :: FieldReader < u32 > ;
#[doc = "Field `TSA` writer - Time stamp addend"] pub type TsaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Time stamp addend"]
#[inline (always)] pub fn tsa (& self) -> TsaR { TsaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Time stamp addend"]
#[inline (always)] pub fn tsa (& mut self) -> TsaW < '_ , PtptsarSpec > { TsaW :: new (self , 0) } }
#[doc = "Ethernet PTP time stamp addend register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptsar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptsar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtptsarSpec ; impl crate :: RegisterSpec for PtptsarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptptsar::R`](R) reader structure"] impl crate :: Readable for PtptsarSpec { }
#[doc = "`write(|w| ..)` method takes [`ptptsar::W`](W) writer structure"] impl crate :: Writable for PtptsarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PTPTSAR to value 0"] impl crate :: Resettable for PtptsarSpec { } }
#[doc = "PTPTTHR (rw) register accessor: Ethernet PTP target time high register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptthr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptthr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptptthr`] module"]
#[doc (alias = "PTPTTHR")] pub type Ptptthr = crate :: Reg < ptptthr :: PtptthrSpec > ;
#[doc = "Ethernet PTP target time high register"] pub mod ptptthr {
#[doc = "Register `PTPTTHR` reader"] pub type R = crate :: R < PtptthrSpec > ;
#[doc = "Register `PTPTTHR` writer"] pub type W = crate :: W < PtptthrSpec > ;
#[doc = "Field `TTSH` reader - Target time stamp high"] pub type TtshR = crate :: FieldReader < u32 > ;
#[doc = "Field `TTSH` writer - Target time stamp high"] pub type TtshW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Target time stamp high"]
#[inline (always)] pub fn ttsh (& self) -> TtshR { TtshR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Target time stamp high"]
#[inline (always)] pub fn ttsh (& mut self) -> TtshW < '_ , PtptthrSpec > { TtshW :: new (self , 0) } }
#[doc = "Ethernet PTP target time high register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptptthr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptptthr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtptthrSpec ; impl crate :: RegisterSpec for PtptthrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptptthr::R`](R) reader structure"] impl crate :: Readable for PtptthrSpec { }
#[doc = "`write(|w| ..)` method takes [`ptptthr::W`](W) writer structure"] impl crate :: Writable for PtptthrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PTPTTHR to value 0"] impl crate :: Resettable for PtptthrSpec { } }
#[doc = "PTPTTLR (rw) register accessor: Ethernet PTP target time low register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptpttlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptpttlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ptpttlr`] module"]
#[doc (alias = "PTPTTLR")] pub type Ptpttlr = crate :: Reg < ptpttlr :: PtpttlrSpec > ;
#[doc = "Ethernet PTP target time low register"] pub mod ptpttlr {
#[doc = "Register `PTPTTLR` reader"] pub type R = crate :: R < PtpttlrSpec > ;
#[doc = "Register `PTPTTLR` writer"] pub type W = crate :: W < PtpttlrSpec > ;
#[doc = "Field `TTSL` reader - Target time stamp low"] pub type TtslR = crate :: FieldReader < u32 > ;
#[doc = "Field `TTSL` writer - Target time stamp low"] pub type TtslW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Target time stamp low"]
#[inline (always)] pub fn ttsl (& self) -> TtslR { TtslR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Target time stamp low"]
#[inline (always)] pub fn ttsl (& mut self) -> TtslW < '_ , PtpttlrSpec > { TtslW :: new (self , 0) } }
#[doc = "Ethernet PTP target time low register\n\nYou can [`read`](crate::Reg::read) this register and get [`ptpttlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ptpttlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PtpttlrSpec ; impl crate :: RegisterSpec for PtpttlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ptpttlr::R`](R) reader structure"] impl crate :: Readable for PtpttlrSpec { }
#[doc = "`write(|w| ..)` method takes [`ptpttlr::W`](W) writer structure"] impl crate :: Writable for PtpttlrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PTPTTLR to value 0"] impl crate :: Resettable for PtpttlrSpec { } } }
#[doc = "Ethernet: DMA controller operation"] pub type EthernetDma = crate :: Periph < ethernet_dma :: RegisterBlock , 0x4002_9000 > ; impl core :: fmt :: Debug for EthernetDma { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EthernetDma") . finish () } }
#[doc = "Ethernet: DMA controller operation"] pub mod ethernet_dma {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { dmabmr : Dmabmr , dmatpdr : Dmatpdr , dmarpdr : Dmarpdr , dmardlar : Dmardlar , dmatdlar : Dmatdlar , dmasr : Dmasr , dmaomr : Dmaomr , dmaier : Dmaier , dmamfbocr : Dmamfbocr , _reserved9 : [u8 ; 0x24] , dmachtdr : Dmachtdr , dmachrdr : Dmachrdr , dmachtbar : Dmachtbar , dmachrbar : Dmachrbar , } impl RegisterBlock {
#[doc = "0x00 - Ethernet DMA bus mode register"]
#[inline (always)] pub const fn dmabmr (& self) -> & Dmabmr { & self . dmabmr }
#[doc = "0x04 - Ethernet DMA transmit poll demand register"]
#[inline (always)] pub const fn dmatpdr (& self) -> & Dmatpdr { & self . dmatpdr }
#[doc = "0x08 - EHERNET DMA receive poll demand register"]
#[inline (always)] pub const fn dmarpdr (& self) -> & Dmarpdr { & self . dmarpdr }
#[doc = "0x0c - Ethernet DMA receive descriptor list address register"]
#[inline (always)] pub const fn dmardlar (& self) -> & Dmardlar { & self . dmardlar }
#[doc = "0x10 - Ethernet DMA transmit descriptor list address register"]
#[inline (always)] pub const fn dmatdlar (& self) -> & Dmatdlar { & self . dmatdlar }
#[doc = "0x14 - Ethernet DMA status register"]
#[inline (always)] pub const fn dmasr (& self) -> & Dmasr { & self . dmasr }
#[doc = "0x18 - Ethernet DMA operation mode register"]
#[inline (always)] pub const fn dmaomr (& self) -> & Dmaomr { & self . dmaomr }
#[doc = "0x1c - Ethernet DMA interrupt enable register"]
#[inline (always)] pub const fn dmaier (& self) -> & Dmaier { & self . dmaier }
#[doc = "0x20 - Ethernet DMA missed frame and buffer overflow counter register"]
#[inline (always)] pub const fn dmamfbocr (& self) -> & Dmamfbocr { & self . dmamfbocr }
#[doc = "0x48 - Ethernet DMA current host transmit descriptor register"]
#[inline (always)] pub const fn dmachtdr (& self) -> & Dmachtdr { & self . dmachtdr }
#[doc = "0x4c - Ethernet DMA current host receive descriptor register"]
#[inline (always)] pub const fn dmachrdr (& self) -> & Dmachrdr { & self . dmachrdr }
#[doc = "0x50 - Ethernet DMA current host transmit buffer address register"]
#[inline (always)] pub const fn dmachtbar (& self) -> & Dmachtbar { & self . dmachtbar }
#[doc = "0x54 - Ethernet DMA current host receive buffer address register"]
#[inline (always)] pub const fn dmachrbar (& self) -> & Dmachrbar { & self . dmachrbar } }
#[doc = "DMABMR (rw) register accessor: Ethernet DMA bus mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmabmr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmabmr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmabmr`] module"]
#[doc (alias = "DMABMR")] pub type Dmabmr = crate :: Reg < dmabmr :: DmabmrSpec > ;
#[doc = "Ethernet DMA bus mode register"] pub mod dmabmr {
#[doc = "Register `DMABMR` reader"] pub type R = crate :: R < DmabmrSpec > ;
#[doc = "Register `DMABMR` writer"] pub type W = crate :: W < DmabmrSpec > ;
#[doc = "Field `SR` reader - Software reset"] pub type SrR = crate :: BitReader ;
#[doc = "Field `SR` writer - Software reset"] pub type SrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DA` reader - DMA Arbitration"] pub type DaR = crate :: BitReader ;
#[doc = "Field `DA` writer - DMA Arbitration"] pub type DaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DSL` reader - Descriptor skip length"] pub type DslR = crate :: FieldReader ;
#[doc = "Field `DSL` writer - Descriptor skip length"] pub type DslW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `PBL` reader - Programmable burst length"] pub type PblR = crate :: FieldReader ;
#[doc = "Field `PBL` writer - Programmable burst length"] pub type PblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `RTPR` reader - Rx Tx priority ratio"] pub type RtprR = crate :: FieldReader ;
#[doc = "Field `RTPR` writer - Rx Tx priority ratio"] pub type RtprW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `FB` reader - Fixed burst"] pub type FbR = crate :: BitReader ;
#[doc = "Field `FB` writer - Fixed burst"] pub type FbW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RDP` reader - Rx DMA PBL"] pub type RdpR = crate :: FieldReader ;
#[doc = "Field `RDP` writer - Rx DMA PBL"] pub type RdpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `USP` reader - Use separate PBL"] pub type UspR = crate :: BitReader ;
#[doc = "Field `USP` writer - Use separate PBL"] pub type UspW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FPM` reader - 4xPBL mode"] pub type FpmR = crate :: BitReader ;
#[doc = "Field `FPM` writer - 4xPBL mode"] pub type FpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AAB` reader - Address-aligned beats"] pub type AabR = crate :: BitReader ;
#[doc = "Field `AAB` writer - Address-aligned beats"] pub type AabW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Software reset"]
#[inline (always)] pub fn sr (& self) -> SrR { SrR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DMA Arbitration"]
#[inline (always)] pub fn da (& self) -> DaR { DaR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:6 - Descriptor skip length"]
#[inline (always)] pub fn dsl (& self) -> DslR { DslR :: new (((self . bits >> 2) & 0x1f) as u8) }
#[doc = "Bits 8:13 - Programmable burst length"]
#[inline (always)] pub fn pbl (& self) -> PblR { PblR :: new (((self . bits >> 8) & 0x3f) as u8) }
#[doc = "Bits 14:15 - Rx Tx priority ratio"]
#[inline (always)] pub fn rtpr (& self) -> RtprR { RtprR :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bit 16 - Fixed burst"]
#[inline (always)] pub fn fb (& self) -> FbR { FbR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:22 - Rx DMA PBL"]
#[inline (always)] pub fn rdp (& self) -> RdpR { RdpR :: new (((self . bits >> 17) & 0x3f) as u8) }
#[doc = "Bit 23 - Use separate PBL"]
#[inline (always)] pub fn usp (& self) -> UspR { UspR :: new (((self . bits >> 23) & 1) != 0) }
#[doc = "Bit 24 - 4xPBL mode"]
#[inline (always)] pub fn fpm (& self) -> FpmR { FpmR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - Address-aligned beats"]
#[inline (always)] pub fn aab (& self) -> AabR { AabR :: new (((self . bits >> 25) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Software reset"]
#[inline (always)] pub fn sr (& mut self) -> SrW < '_ , DmabmrSpec > { SrW :: new (self , 0) }
#[doc = "Bit 1 - DMA Arbitration"]
#[inline (always)] pub fn da (& mut self) -> DaW < '_ , DmabmrSpec > { DaW :: new (self , 1) }
#[doc = "Bits 2:6 - Descriptor skip length"]
#[inline (always)] pub fn dsl (& mut self) -> DslW < '_ , DmabmrSpec > { DslW :: new (self , 2) }
#[doc = "Bits 8:13 - Programmable burst length"]
#[inline (always)] pub fn pbl (& mut self) -> PblW < '_ , DmabmrSpec > { PblW :: new (self , 8) }
#[doc = "Bits 14:15 - Rx Tx priority ratio"]
#[inline (always)] pub fn rtpr (& mut self) -> RtprW < '_ , DmabmrSpec > { RtprW :: new (self , 14) }
#[doc = "Bit 16 - Fixed burst"]
#[inline (always)] pub fn fb (& mut self) -> FbW < '_ , DmabmrSpec > { FbW :: new (self , 16) }
#[doc = "Bits 17:22 - Rx DMA PBL"]
#[inline (always)] pub fn rdp (& mut self) -> RdpW < '_ , DmabmrSpec > { RdpW :: new (self , 17) }
#[doc = "Bit 23 - Use separate PBL"]
#[inline (always)] pub fn usp (& mut self) -> UspW < '_ , DmabmrSpec > { UspW :: new (self , 23) }
#[doc = "Bit 24 - 4xPBL mode"]
#[inline (always)] pub fn fpm (& mut self) -> FpmW < '_ , DmabmrSpec > { FpmW :: new (self , 24) }
#[doc = "Bit 25 - Address-aligned beats"]
#[inline (always)] pub fn aab (& mut self) -> AabW < '_ , DmabmrSpec > { AabW :: new (self , 25) } }
#[doc = "Ethernet DMA bus mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmabmr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmabmr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmabmrSpec ; impl crate :: RegisterSpec for DmabmrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmabmr::R`](R) reader structure"] impl crate :: Readable for DmabmrSpec { }
#[doc = "`write(|w| ..)` method takes [`dmabmr::W`](W) writer structure"] impl crate :: Writable for DmabmrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMABMR to value 0x0002_0101"] impl crate :: Resettable for DmabmrSpec { const RESET_VALUE : u32 = 0x0002_0101 ; } }
#[doc = "DMATPDR (rw) register accessor: Ethernet DMA transmit poll demand register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmatpdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmatpdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmatpdr`] module"]
#[doc (alias = "DMATPDR")] pub type Dmatpdr = crate :: Reg < dmatpdr :: DmatpdrSpec > ;
#[doc = "Ethernet DMA transmit poll demand register"] pub mod dmatpdr {
#[doc = "Register `DMATPDR` reader"] pub type R = crate :: R < DmatpdrSpec > ;
#[doc = "Register `DMATPDR` writer"] pub type W = crate :: W < DmatpdrSpec > ;
#[doc = "Field `TPD` reader - Transmit poll demand"] pub type TpdR = crate :: FieldReader < u32 > ;
#[doc = "Field `TPD` writer - Transmit poll demand"] pub type TpdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Transmit poll demand"]
#[inline (always)] pub fn tpd (& self) -> TpdR { TpdR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Transmit poll demand"]
#[inline (always)] pub fn tpd (& mut self) -> TpdW < '_ , DmatpdrSpec > { TpdW :: new (self , 0) } }
#[doc = "Ethernet DMA transmit poll demand register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmatpdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmatpdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmatpdrSpec ; impl crate :: RegisterSpec for DmatpdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmatpdr::R`](R) reader structure"] impl crate :: Readable for DmatpdrSpec { }
#[doc = "`write(|w| ..)` method takes [`dmatpdr::W`](W) writer structure"] impl crate :: Writable for DmatpdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMATPDR to value 0"] impl crate :: Resettable for DmatpdrSpec { } }
#[doc = "DMARPDR (rw) register accessor: EHERNET DMA receive poll demand register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmarpdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmarpdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmarpdr`] module"]
#[doc (alias = "DMARPDR")] pub type Dmarpdr = crate :: Reg < dmarpdr :: DmarpdrSpec > ;
#[doc = "EHERNET DMA receive poll demand register"] pub mod dmarpdr {
#[doc = "Register `DMARPDR` reader"] pub type R = crate :: R < DmarpdrSpec > ;
#[doc = "Register `DMARPDR` writer"] pub type W = crate :: W < DmarpdrSpec > ;
#[doc = "Field `RPD` reader - Receive poll demand"] pub type RpdR = crate :: FieldReader < u32 > ;
#[doc = "Field `RPD` writer - Receive poll demand"] pub type RpdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Receive poll demand"]
#[inline (always)] pub fn rpd (& self) -> RpdR { RpdR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Receive poll demand"]
#[inline (always)] pub fn rpd (& mut self) -> RpdW < '_ , DmarpdrSpec > { RpdW :: new (self , 0) } }
#[doc = "EHERNET DMA receive poll demand register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmarpdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmarpdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarpdrSpec ; impl crate :: RegisterSpec for DmarpdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmarpdr::R`](R) reader structure"] impl crate :: Readable for DmarpdrSpec { }
#[doc = "`write(|w| ..)` method takes [`dmarpdr::W`](W) writer structure"] impl crate :: Writable for DmarpdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMARPDR to value 0"] impl crate :: Resettable for DmarpdrSpec { } }
#[doc = "DMARDLAR (rw) register accessor: Ethernet DMA receive descriptor list address register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmardlar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmardlar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmardlar`] module"]
#[doc (alias = "DMARDLAR")] pub type Dmardlar = crate :: Reg < dmardlar :: DmardlarSpec > ;
#[doc = "Ethernet DMA receive descriptor list address register"] pub mod dmardlar {
#[doc = "Register `DMARDLAR` reader"] pub type R = crate :: R < DmardlarSpec > ;
#[doc = "Register `DMARDLAR` writer"] pub type W = crate :: W < DmardlarSpec > ;
#[doc = "Field `SRL` reader - Start of receive list"] pub type SrlR = crate :: FieldReader < u32 > ;
#[doc = "Field `SRL` writer - Start of receive list"] pub type SrlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Start of receive list"]
#[inline (always)] pub fn srl (& self) -> SrlR { SrlR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Start of receive list"]
#[inline (always)] pub fn srl (& mut self) -> SrlW < '_ , DmardlarSpec > { SrlW :: new (self , 0) } }
#[doc = "Ethernet DMA receive descriptor list address register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmardlar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmardlar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmardlarSpec ; impl crate :: RegisterSpec for DmardlarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmardlar::R`](R) reader structure"] impl crate :: Readable for DmardlarSpec { }
#[doc = "`write(|w| ..)` method takes [`dmardlar::W`](W) writer structure"] impl crate :: Writable for DmardlarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMARDLAR to value 0"] impl crate :: Resettable for DmardlarSpec { } }
#[doc = "DMATDLAR (rw) register accessor: Ethernet DMA transmit descriptor list address register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmatdlar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmatdlar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmatdlar`] module"]
#[doc (alias = "DMATDLAR")] pub type Dmatdlar = crate :: Reg < dmatdlar :: DmatdlarSpec > ;
#[doc = "Ethernet DMA transmit descriptor list address register"] pub mod dmatdlar {
#[doc = "Register `DMATDLAR` reader"] pub type R = crate :: R < DmatdlarSpec > ;
#[doc = "Register `DMATDLAR` writer"] pub type W = crate :: W < DmatdlarSpec > ;
#[doc = "Field `STL` reader - Start of transmit list"] pub type StlR = crate :: FieldReader < u32 > ;
#[doc = "Field `STL` writer - Start of transmit list"] pub type StlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Start of transmit list"]
#[inline (always)] pub fn stl (& self) -> StlR { StlR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Start of transmit list"]
#[inline (always)] pub fn stl (& mut self) -> StlW < '_ , DmatdlarSpec > { StlW :: new (self , 0) } }
#[doc = "Ethernet DMA transmit descriptor list address register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmatdlar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmatdlar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmatdlarSpec ; impl crate :: RegisterSpec for DmatdlarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmatdlar::R`](R) reader structure"] impl crate :: Readable for DmatdlarSpec { }
#[doc = "`write(|w| ..)` method takes [`dmatdlar::W`](W) writer structure"] impl crate :: Writable for DmatdlarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMATDLAR to value 0"] impl crate :: Resettable for DmatdlarSpec { } }
#[doc = "DMASR (rw) register accessor: Ethernet DMA status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmasr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmasr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmasr`] module"]
#[doc (alias = "DMASR")] pub type Dmasr = crate :: Reg < dmasr :: DmasrSpec > ;
#[doc = "Ethernet DMA status register"] pub mod dmasr {
#[doc = "Register `DMASR` reader"] pub type R = crate :: R < DmasrSpec > ;
#[doc = "Register `DMASR` writer"] pub type W = crate :: W < DmasrSpec > ;
#[doc = "Field `TS` reader - Transmit status"] pub type TsR = crate :: BitReader ;
#[doc = "Field `TS` writer - Transmit status"] pub type TsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TPSS` reader - Transmit process stopped status"] pub type TpssR = crate :: BitReader ;
#[doc = "Field `TPSS` writer - Transmit process stopped status"] pub type TpssW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TBUS` reader - Transmit buffer unavailable status"] pub type TbusR = crate :: BitReader ;
#[doc = "Field `TBUS` writer - Transmit buffer unavailable status"] pub type TbusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TJTS` reader - Transmit jabber timeout status"] pub type TjtsR = crate :: BitReader ;
#[doc = "Field `TJTS` writer - Transmit jabber timeout status"] pub type TjtsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ROS` reader - Receive overflow status"] pub type RosR = crate :: BitReader ;
#[doc = "Field `ROS` writer - Receive overflow status"] pub type RosW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TUS` reader - Transmit underflow status"] pub type TusR = crate :: BitReader ;
#[doc = "Field `TUS` writer - Transmit underflow status"] pub type TusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RS` reader - Receive status"] pub type RsR = crate :: BitReader ;
#[doc = "Field `RS` writer - Receive status"] pub type RsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RBUS` reader - Receive buffer unavailable status"] pub type RbusR = crate :: BitReader ;
#[doc = "Field `RBUS` writer - Receive buffer unavailable status"] pub type RbusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RPSS` reader - Receive process stopped status"] pub type RpssR = crate :: BitReader ;
#[doc = "Field `RPSS` writer - Receive process stopped status"] pub type RpssW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWTS` reader - Receive watchdog timeout status"] pub type PwtsR = crate :: BitReader ;
#[doc = "Field `PWTS` writer - Receive watchdog timeout status"] pub type PwtsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETS` reader - Early transmit status"] pub type EtsR = crate :: BitReader ;
#[doc = "Field `ETS` writer - Early transmit status"] pub type EtsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBES` reader - Fatal bus error status"] pub type FbesR = crate :: BitReader ;
#[doc = "Field `FBES` writer - Fatal bus error status"] pub type FbesW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERS` reader - Early receive status"] pub type ErsR = crate :: BitReader ;
#[doc = "Field `ERS` writer - Early receive status"] pub type ErsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AIS` reader - Abnormal interrupt summary"] pub type AisR = crate :: BitReader ;
#[doc = "Field `AIS` writer - Abnormal interrupt summary"] pub type AisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NIS` reader - Normal interrupt summary"] pub type NisR = crate :: BitReader ;
#[doc = "Field `NIS` writer - Normal interrupt summary"] pub type NisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RPS` reader - Receive process state"] pub type RpsR = crate :: FieldReader ;
#[doc = "Field `TPS` reader - Transmit process state"] pub type TpsR = crate :: FieldReader ;
#[doc = "Field `EBS` reader - Error bits status"] pub type EbsR = crate :: FieldReader ;
#[doc = "Field `MMCS` reader - MMC status"] pub type MmcsR = crate :: BitReader ;
#[doc = "Field `PMTS` reader - PMT status"] pub type PmtsR = crate :: BitReader ;
#[doc = "Field `TSTS` reader - Time stamp trigger status"] pub type TstsR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Transmit status"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transmit process stopped status"]
#[inline (always)] pub fn tpss (& self) -> TpssR { TpssR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmit buffer unavailable status"]
#[inline (always)] pub fn tbus (& self) -> TbusR { TbusR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmit jabber timeout status"]
#[inline (always)] pub fn tjts (& self) -> TjtsR { TjtsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Receive overflow status"]
#[inline (always)] pub fn ros (& self) -> RosR { RosR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Transmit underflow status"]
#[inline (always)] pub fn tus (& self) -> TusR { TusR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Receive status"]
#[inline (always)] pub fn rs (& self) -> RsR { RsR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Receive buffer unavailable status"]
#[inline (always)] pub fn rbus (& self) -> RbusR { RbusR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Receive process stopped status"]
#[inline (always)] pub fn rpss (& self) -> RpssR { RpssR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Receive watchdog timeout status"]
#[inline (always)] pub fn pwts (& self) -> PwtsR { PwtsR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Early transmit status"]
#[inline (always)] pub fn ets (& self) -> EtsR { EtsR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 13 - Fatal bus error status"]
#[inline (always)] pub fn fbes (& self) -> FbesR { FbesR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Early receive status"]
#[inline (always)] pub fn ers (& self) -> ErsR { ErsR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Abnormal interrupt summary"]
#[inline (always)] pub fn ais (& self) -> AisR { AisR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Normal interrupt summary"]
#[inline (always)] pub fn nis (& self) -> NisR { NisR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:19 - Receive process state"]
#[inline (always)] pub fn rps (& self) -> RpsR { RpsR :: new (((self . bits >> 17) & 7) as u8) }
#[doc = "Bits 20:22 - Transmit process state"]
#[inline (always)] pub fn tps (& self) -> TpsR { TpsR :: new (((self . bits >> 20) & 7) as u8) }
#[doc = "Bits 23:25 - Error bits status"]
#[inline (always)] pub fn ebs (& self) -> EbsR { EbsR :: new (((self . bits >> 23) & 7) as u8) }
#[doc = "Bit 27 - MMC status"]
#[inline (always)] pub fn mmcs (& self) -> MmcsR { MmcsR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - PMT status"]
#[inline (always)] pub fn pmts (& self) -> PmtsR { PmtsR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Time stamp trigger status"]
#[inline (always)] pub fn tsts (& self) -> TstsR { TstsR :: new (((self . bits >> 29) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transmit status"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , DmasrSpec > { TsW :: new (self , 0) }
#[doc = "Bit 1 - Transmit process stopped status"]
#[inline (always)] pub fn tpss (& mut self) -> TpssW < '_ , DmasrSpec > { TpssW :: new (self , 1) }
#[doc = "Bit 2 - Transmit buffer unavailable status"]
#[inline (always)] pub fn tbus (& mut self) -> TbusW < '_ , DmasrSpec > { TbusW :: new (self , 2) }
#[doc = "Bit 3 - Transmit jabber timeout status"]
#[inline (always)] pub fn tjts (& mut self) -> TjtsW < '_ , DmasrSpec > { TjtsW :: new (self , 3) }
#[doc = "Bit 4 - Receive overflow status"]
#[inline (always)] pub fn ros (& mut self) -> RosW < '_ , DmasrSpec > { RosW :: new (self , 4) }
#[doc = "Bit 5 - Transmit underflow status"]
#[inline (always)] pub fn tus (& mut self) -> TusW < '_ , DmasrSpec > { TusW :: new (self , 5) }
#[doc = "Bit 6 - Receive status"]
#[inline (always)] pub fn rs (& mut self) -> RsW < '_ , DmasrSpec > { RsW :: new (self , 6) }
#[doc = "Bit 7 - Receive buffer unavailable status"]
#[inline (always)] pub fn rbus (& mut self) -> RbusW < '_ , DmasrSpec > { RbusW :: new (self , 7) }
#[doc = "Bit 8 - Receive process stopped status"]
#[inline (always)] pub fn rpss (& mut self) -> RpssW < '_ , DmasrSpec > { RpssW :: new (self , 8) }
#[doc = "Bit 9 - Receive watchdog timeout status"]
#[inline (always)] pub fn pwts (& mut self) -> PwtsW < '_ , DmasrSpec > { PwtsW :: new (self , 9) }
#[doc = "Bit 10 - Early transmit status"]
#[inline (always)] pub fn ets (& mut self) -> EtsW < '_ , DmasrSpec > { EtsW :: new (self , 10) }
#[doc = "Bit 13 - Fatal bus error status"]
#[inline (always)] pub fn fbes (& mut self) -> FbesW < '_ , DmasrSpec > { FbesW :: new (self , 13) }
#[doc = "Bit 14 - Early receive status"]
#[inline (always)] pub fn ers (& mut self) -> ErsW < '_ , DmasrSpec > { ErsW :: new (self , 14) }
#[doc = "Bit 15 - Abnormal interrupt summary"]
#[inline (always)] pub fn ais (& mut self) -> AisW < '_ , DmasrSpec > { AisW :: new (self , 15) }
#[doc = "Bit 16 - Normal interrupt summary"]
#[inline (always)] pub fn nis (& mut self) -> NisW < '_ , DmasrSpec > { NisW :: new (self , 16) } }
#[doc = "Ethernet DMA status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmasr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmasr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmasrSpec ; impl crate :: RegisterSpec for DmasrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmasr::R`](R) reader structure"] impl crate :: Readable for DmasrSpec { }
#[doc = "`write(|w| ..)` method takes [`dmasr::W`](W) writer structure"] impl crate :: Writable for DmasrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMASR to value 0"] impl crate :: Resettable for DmasrSpec { } }
#[doc = "DMAOMR (rw) register accessor: Ethernet DMA operation mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmaomr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmaomr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmaomr`] module"]
#[doc (alias = "DMAOMR")] pub type Dmaomr = crate :: Reg < dmaomr :: DmaomrSpec > ;
#[doc = "Ethernet DMA operation mode register"] pub mod dmaomr {
#[doc = "Register `DMAOMR` reader"] pub type R = crate :: R < DmaomrSpec > ;
#[doc = "Register `DMAOMR` writer"] pub type W = crate :: W < DmaomrSpec > ;
#[doc = "Field `SR` reader - SR"] pub type SrR = crate :: BitReader ;
#[doc = "Field `SR` writer - SR"] pub type SrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSF` reader - OSF"] pub type OsfR = crate :: BitReader ;
#[doc = "Field `OSF` writer - OSF"] pub type OsfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTC` reader - RTC"] pub type RtcR = crate :: FieldReader ;
#[doc = "Field `RTC` writer - RTC"] pub type RtcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `FUGF` reader - FUGF"] pub type FugfR = crate :: BitReader ;
#[doc = "Field `FUGF` writer - FUGF"] pub type FugfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FEF` reader - FEF"] pub type FefR = crate :: BitReader ;
#[doc = "Field `FEF` writer - FEF"] pub type FefW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ST` reader - ST"] pub type StR = crate :: BitReader ;
#[doc = "Field `ST` writer - ST"] pub type StW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TTC` reader - TTC"] pub type TtcR = crate :: FieldReader ;
#[doc = "Field `TTC` writer - TTC"] pub type TtcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `FTF` reader - FTF"] pub type FtfR = crate :: BitReader ;
#[doc = "Field `FTF` writer - FTF"] pub type FtfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSF` reader - TSF"] pub type TsfR = crate :: BitReader ;
#[doc = "Field `TSF` writer - TSF"] pub type TsfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DFRF` reader - DFRF"] pub type DfrfR = crate :: BitReader ;
#[doc = "Field `DFRF` writer - DFRF"] pub type DfrfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RSF` reader - RSF"] pub type RsfR = crate :: BitReader ;
#[doc = "Field `RSF` writer - RSF"] pub type RsfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DTCEFD` reader - DTCEFD"] pub type DtcefdR = crate :: BitReader ;
#[doc = "Field `DTCEFD` writer - DTCEFD"] pub type DtcefdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 1 - SR"]
#[inline (always)] pub fn sr (& self) -> SrR { SrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - OSF"]
#[inline (always)] pub fn osf (& self) -> OsfR { OsfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 3:4 - RTC"]
#[inline (always)] pub fn rtc (& self) -> RtcR { RtcR :: new (((self . bits >> 3) & 3) as u8) }
#[doc = "Bit 6 - FUGF"]
#[inline (always)] pub fn fugf (& self) -> FugfR { FugfR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - FEF"]
#[inline (always)] pub fn fef (& self) -> FefR { FefR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 13 - ST"]
#[inline (always)] pub fn st (& self) -> StR { StR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bits 14:16 - TTC"]
#[inline (always)] pub fn ttc (& self) -> TtcR { TtcR :: new (((self . bits >> 14) & 7) as u8) }
#[doc = "Bit 20 - FTF"]
#[inline (always)] pub fn ftf (& self) -> FtfR { FtfR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - TSF"]
#[inline (always)] pub fn tsf (& self) -> TsfR { TsfR :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 24 - DFRF"]
#[inline (always)] pub fn dfrf (& self) -> DfrfR { DfrfR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 25 - RSF"]
#[inline (always)] pub fn rsf (& self) -> RsfR { RsfR :: new (((self . bits >> 25) & 1) != 0) }
#[doc = "Bit 26 - DTCEFD"]
#[inline (always)] pub fn dtcefd (& self) -> DtcefdR { DtcefdR :: new (((self . bits >> 26) & 1) != 0) } } impl W {
#[doc = "Bit 1 - SR"]
#[inline (always)] pub fn sr (& mut self) -> SrW < '_ , DmaomrSpec > { SrW :: new (self , 1) }
#[doc = "Bit 2 - OSF"]
#[inline (always)] pub fn osf (& mut self) -> OsfW < '_ , DmaomrSpec > { OsfW :: new (self , 2) }
#[doc = "Bits 3:4 - RTC"]
#[inline (always)] pub fn rtc (& mut self) -> RtcW < '_ , DmaomrSpec > { RtcW :: new (self , 3) }
#[doc = "Bit 6 - FUGF"]
#[inline (always)] pub fn fugf (& mut self) -> FugfW < '_ , DmaomrSpec > { FugfW :: new (self , 6) }
#[doc = "Bit 7 - FEF"]
#[inline (always)] pub fn fef (& mut self) -> FefW < '_ , DmaomrSpec > { FefW :: new (self , 7) }
#[doc = "Bit 13 - ST"]
#[inline (always)] pub fn st (& mut self) -> StW < '_ , DmaomrSpec > { StW :: new (self , 13) }
#[doc = "Bits 14:16 - TTC"]
#[inline (always)] pub fn ttc (& mut self) -> TtcW < '_ , DmaomrSpec > { TtcW :: new (self , 14) }
#[doc = "Bit 20 - FTF"]
#[inline (always)] pub fn ftf (& mut self) -> FtfW < '_ , DmaomrSpec > { FtfW :: new (self , 20) }
#[doc = "Bit 21 - TSF"]
#[inline (always)] pub fn tsf (& mut self) -> TsfW < '_ , DmaomrSpec > { TsfW :: new (self , 21) }
#[doc = "Bit 24 - DFRF"]
#[inline (always)] pub fn dfrf (& mut self) -> DfrfW < '_ , DmaomrSpec > { DfrfW :: new (self , 24) }
#[doc = "Bit 25 - RSF"]
#[inline (always)] pub fn rsf (& mut self) -> RsfW < '_ , DmaomrSpec > { RsfW :: new (self , 25) }
#[doc = "Bit 26 - DTCEFD"]
#[inline (always)] pub fn dtcefd (& mut self) -> DtcefdW < '_ , DmaomrSpec > { DtcefdW :: new (self , 26) } }
#[doc = "Ethernet DMA operation mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmaomr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmaomr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmaomrSpec ; impl crate :: RegisterSpec for DmaomrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmaomr::R`](R) reader structure"] impl crate :: Readable for DmaomrSpec { }
#[doc = "`write(|w| ..)` method takes [`dmaomr::W`](W) writer structure"] impl crate :: Writable for DmaomrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAOMR to value 0"] impl crate :: Resettable for DmaomrSpec { } }
#[doc = "DMAIER (rw) register accessor: Ethernet DMA interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmaier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmaier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmaier`] module"]
#[doc (alias = "DMAIER")] pub type Dmaier = crate :: Reg < dmaier :: DmaierSpec > ;
#[doc = "Ethernet DMA interrupt enable register"] pub mod dmaier {
#[doc = "Register `DMAIER` reader"] pub type R = crate :: R < DmaierSpec > ;
#[doc = "Register `DMAIER` writer"] pub type W = crate :: W < DmaierSpec > ;
#[doc = "Field `TIE` reader - Transmit interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Transmit interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TPSIE` reader - Transmit process stopped interrupt enable"] pub type TpsieR = crate :: BitReader ;
#[doc = "Field `TPSIE` writer - Transmit process stopped interrupt enable"] pub type TpsieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TBUIE` reader - Transmit buffer unavailable interrupt enable"] pub type TbuieR = crate :: BitReader ;
#[doc = "Field `TBUIE` writer - Transmit buffer unavailable interrupt enable"] pub type TbuieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TJTIE` reader - Transmit jabber timeout interrupt enable"] pub type TjtieR = crate :: BitReader ;
#[doc = "Field `TJTIE` writer - Transmit jabber timeout interrupt enable"] pub type TjtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ROIE` reader - Overflow interrupt enable"] pub type RoieR = crate :: BitReader ;
#[doc = "Field `ROIE` writer - Overflow interrupt enable"] pub type RoieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TUIE` reader - Underflow interrupt enable"] pub type TuieR = crate :: BitReader ;
#[doc = "Field `TUIE` writer - Underflow interrupt enable"] pub type TuieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RIE` reader - Receive interrupt enable"] pub type RieR = crate :: BitReader ;
#[doc = "Field `RIE` writer - Receive interrupt enable"] pub type RieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RBUIE` reader - Receive buffer unavailable interrupt enable"] pub type RbuieR = crate :: BitReader ;
#[doc = "Field `RBUIE` writer - Receive buffer unavailable interrupt enable"] pub type RbuieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RPSIE` reader - Receive process stopped interrupt enable"] pub type RpsieR = crate :: BitReader ;
#[doc = "Field `RPSIE` writer - Receive process stopped interrupt enable"] pub type RpsieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RWTIE` reader - receive watchdog timeout interrupt enable"] pub type RwtieR = crate :: BitReader ;
#[doc = "Field `RWTIE` writer - receive watchdog timeout interrupt enable"] pub type RwtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETIE` reader - Early transmit interrupt enable"] pub type EtieR = crate :: BitReader ;
#[doc = "Field `ETIE` writer - Early transmit interrupt enable"] pub type EtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FBEIE` reader - Fatal bus error interrupt enable"] pub type FbeieR = crate :: BitReader ;
#[doc = "Field `FBEIE` writer - Fatal bus error interrupt enable"] pub type FbeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERIE` reader - Early receive interrupt enable"] pub type ErieR = crate :: BitReader ;
#[doc = "Field `ERIE` writer - Early receive interrupt enable"] pub type ErieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AISE` reader - Abnormal interrupt summary enable"] pub type AiseR = crate :: BitReader ;
#[doc = "Field `AISE` writer - Abnormal interrupt summary enable"] pub type AiseW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NISE` reader - Normal interrupt summary enable"] pub type NiseR = crate :: BitReader ;
#[doc = "Field `NISE` writer - Normal interrupt summary enable"] pub type NiseW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transmit interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transmit process stopped interrupt enable"]
#[inline (always)] pub fn tpsie (& self) -> TpsieR { TpsieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmit buffer unavailable interrupt enable"]
#[inline (always)] pub fn tbuie (& self) -> TbuieR { TbuieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmit jabber timeout interrupt enable"]
#[inline (always)] pub fn tjtie (& self) -> TjtieR { TjtieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Overflow interrupt enable"]
#[inline (always)] pub fn roie (& self) -> RoieR { RoieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Underflow interrupt enable"]
#[inline (always)] pub fn tuie (& self) -> TuieR { TuieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Receive interrupt enable"]
#[inline (always)] pub fn rie (& self) -> RieR { RieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Receive buffer unavailable interrupt enable"]
#[inline (always)] pub fn rbuie (& self) -> RbuieR { RbuieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Receive process stopped interrupt enable"]
#[inline (always)] pub fn rpsie (& self) -> RpsieR { RpsieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - receive watchdog timeout interrupt enable"]
#[inline (always)] pub fn rwtie (& self) -> RwtieR { RwtieR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Early transmit interrupt enable"]
#[inline (always)] pub fn etie (& self) -> EtieR { EtieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 13 - Fatal bus error interrupt enable"]
#[inline (always)] pub fn fbeie (& self) -> FbeieR { FbeieR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Early receive interrupt enable"]
#[inline (always)] pub fn erie (& self) -> ErieR { ErieR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Abnormal interrupt summary enable"]
#[inline (always)] pub fn aise (& self) -> AiseR { AiseR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Normal interrupt summary enable"]
#[inline (always)] pub fn nise (& self) -> NiseR { NiseR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transmit interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DmaierSpec > { TieW :: new (self , 0) }
#[doc = "Bit 1 - Transmit process stopped interrupt enable"]
#[inline (always)] pub fn tpsie (& mut self) -> TpsieW < '_ , DmaierSpec > { TpsieW :: new (self , 1) }
#[doc = "Bit 2 - Transmit buffer unavailable interrupt enable"]
#[inline (always)] pub fn tbuie (& mut self) -> TbuieW < '_ , DmaierSpec > { TbuieW :: new (self , 2) }
#[doc = "Bit 3 - Transmit jabber timeout interrupt enable"]
#[inline (always)] pub fn tjtie (& mut self) -> TjtieW < '_ , DmaierSpec > { TjtieW :: new (self , 3) }
#[doc = "Bit 4 - Overflow interrupt enable"]
#[inline (always)] pub fn roie (& mut self) -> RoieW < '_ , DmaierSpec > { RoieW :: new (self , 4) }
#[doc = "Bit 5 - Underflow interrupt enable"]
#[inline (always)] pub fn tuie (& mut self) -> TuieW < '_ , DmaierSpec > { TuieW :: new (self , 5) }
#[doc = "Bit 6 - Receive interrupt enable"]
#[inline (always)] pub fn rie (& mut self) -> RieW < '_ , DmaierSpec > { RieW :: new (self , 6) }
#[doc = "Bit 7 - Receive buffer unavailable interrupt enable"]
#[inline (always)] pub fn rbuie (& mut self) -> RbuieW < '_ , DmaierSpec > { RbuieW :: new (self , 7) }
#[doc = "Bit 8 - Receive process stopped interrupt enable"]
#[inline (always)] pub fn rpsie (& mut self) -> RpsieW < '_ , DmaierSpec > { RpsieW :: new (self , 8) }
#[doc = "Bit 9 - receive watchdog timeout interrupt enable"]
#[inline (always)] pub fn rwtie (& mut self) -> RwtieW < '_ , DmaierSpec > { RwtieW :: new (self , 9) }
#[doc = "Bit 10 - Early transmit interrupt enable"]
#[inline (always)] pub fn etie (& mut self) -> EtieW < '_ , DmaierSpec > { EtieW :: new (self , 10) }
#[doc = "Bit 13 - Fatal bus error interrupt enable"]
#[inline (always)] pub fn fbeie (& mut self) -> FbeieW < '_ , DmaierSpec > { FbeieW :: new (self , 13) }
#[doc = "Bit 14 - Early receive interrupt enable"]
#[inline (always)] pub fn erie (& mut self) -> ErieW < '_ , DmaierSpec > { ErieW :: new (self , 14) }
#[doc = "Bit 15 - Abnormal interrupt summary enable"]
#[inline (always)] pub fn aise (& mut self) -> AiseW < '_ , DmaierSpec > { AiseW :: new (self , 15) }
#[doc = "Bit 16 - Normal interrupt summary enable"]
#[inline (always)] pub fn nise (& mut self) -> NiseW < '_ , DmaierSpec > { NiseW :: new (self , 16) } }
#[doc = "Ethernet DMA interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmaier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmaier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmaierSpec ; impl crate :: RegisterSpec for DmaierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmaier::R`](R) reader structure"] impl crate :: Readable for DmaierSpec { }
#[doc = "`write(|w| ..)` method takes [`dmaier::W`](W) writer structure"] impl crate :: Writable for DmaierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAIER to value 0"] impl crate :: Resettable for DmaierSpec { } }
#[doc = "DMAMFBOCR (r) register accessor: Ethernet DMA missed frame and buffer overflow counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmamfbocr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmamfbocr`] module"]
#[doc (alias = "DMAMFBOCR")] pub type Dmamfbocr = crate :: Reg < dmamfbocr :: DmamfbocrSpec > ;
#[doc = "Ethernet DMA missed frame and buffer overflow counter register"] pub mod dmamfbocr {
#[doc = "Register `DMAMFBOCR` reader"] pub type R = crate :: R < DmamfbocrSpec > ;
#[doc = "Field `MFC` reader - Missed frames by the controller"] pub type MfcR = crate :: FieldReader < u16 > ;
#[doc = "Field `OMFC` reader - Overflow bit for missed frame counter"] pub type OmfcR = crate :: BitReader ;
#[doc = "Field `MFA` reader - Missed frames by the application"] pub type MfaR = crate :: FieldReader < u16 > ;
#[doc = "Field `OFOC` reader - Overflow bit for FIFO overflow counter"] pub type OfocR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Missed frames by the controller"]
#[inline (always)] pub fn mfc (& self) -> MfcR { MfcR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 16 - Overflow bit for missed frame counter"]
#[inline (always)] pub fn omfc (& self) -> OmfcR { OmfcR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:27 - Missed frames by the application"]
#[inline (always)] pub fn mfa (& self) -> MfaR { MfaR :: new (((self . bits >> 17) & 0x07ff) as u16) }
#[doc = "Bit 28 - Overflow bit for FIFO overflow counter"]
#[inline (always)] pub fn ofoc (& self) -> OfocR { OfocR :: new (((self . bits >> 28) & 1) != 0) } }
#[doc = "Ethernet DMA missed frame and buffer overflow counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmamfbocr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmamfbocrSpec ; impl crate :: RegisterSpec for DmamfbocrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmamfbocr::R`](R) reader structure"] impl crate :: Readable for DmamfbocrSpec { }
#[doc = "`reset()` method sets DMAMFBOCR to value 0"] impl crate :: Resettable for DmamfbocrSpec { } }
#[doc = "DMACHTDR (r) register accessor: Ethernet DMA current host transmit descriptor register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmachtdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmachtdr`] module"]
#[doc (alias = "DMACHTDR")] pub type Dmachtdr = crate :: Reg < dmachtdr :: DmachtdrSpec > ;
#[doc = "Ethernet DMA current host transmit descriptor register"] pub mod dmachtdr {
#[doc = "Register `DMACHTDR` reader"] pub type R = crate :: R < DmachtdrSpec > ;
#[doc = "Field `HTDAP` reader - Host transmit descriptor address pointer"] pub type HtdapR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Host transmit descriptor address pointer"]
#[inline (always)] pub fn htdap (& self) -> HtdapR { HtdapR :: new (self . bits) } }
#[doc = "Ethernet DMA current host transmit descriptor register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmachtdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmachtdrSpec ; impl crate :: RegisterSpec for DmachtdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmachtdr::R`](R) reader structure"] impl crate :: Readable for DmachtdrSpec { }
#[doc = "`reset()` method sets DMACHTDR to value 0"] impl crate :: Resettable for DmachtdrSpec { } }
#[doc = "DMACHRDR (r) register accessor: Ethernet DMA current host receive descriptor register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmachrdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmachrdr`] module"]
#[doc (alias = "DMACHRDR")] pub type Dmachrdr = crate :: Reg < dmachrdr :: DmachrdrSpec > ;
#[doc = "Ethernet DMA current host receive descriptor register"] pub mod dmachrdr {
#[doc = "Register `DMACHRDR` reader"] pub type R = crate :: R < DmachrdrSpec > ;
#[doc = "Field `HRDAP` reader - Host receive descriptor address pointer"] pub type HrdapR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Host receive descriptor address pointer"]
#[inline (always)] pub fn hrdap (& self) -> HrdapR { HrdapR :: new (self . bits) } }
#[doc = "Ethernet DMA current host receive descriptor register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmachrdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmachrdrSpec ; impl crate :: RegisterSpec for DmachrdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmachrdr::R`](R) reader structure"] impl crate :: Readable for DmachrdrSpec { }
#[doc = "`reset()` method sets DMACHRDR to value 0"] impl crate :: Resettable for DmachrdrSpec { } }
#[doc = "DMACHTBAR (r) register accessor: Ethernet DMA current host transmit buffer address register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmachtbar::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmachtbar`] module"]
#[doc (alias = "DMACHTBAR")] pub type Dmachtbar = crate :: Reg < dmachtbar :: DmachtbarSpec > ;
#[doc = "Ethernet DMA current host transmit buffer address register"] pub mod dmachtbar {
#[doc = "Register `DMACHTBAR` reader"] pub type R = crate :: R < DmachtbarSpec > ;
#[doc = "Field `HTBAP` reader - Host transmit buffer address pointer"] pub type HtbapR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Host transmit buffer address pointer"]
#[inline (always)] pub fn htbap (& self) -> HtbapR { HtbapR :: new (self . bits) } }
#[doc = "Ethernet DMA current host transmit buffer address register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmachtbar::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmachtbarSpec ; impl crate :: RegisterSpec for DmachtbarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmachtbar::R`](R) reader structure"] impl crate :: Readable for DmachtbarSpec { }
#[doc = "`reset()` method sets DMACHTBAR to value 0"] impl crate :: Resettable for DmachtbarSpec { } }
#[doc = "DMACHRBAR (r) register accessor: Ethernet DMA current host receive buffer address register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmachrbar::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmachrbar`] module"]
#[doc (alias = "DMACHRBAR")] pub type Dmachrbar = crate :: Reg < dmachrbar :: DmachrbarSpec > ;
#[doc = "Ethernet DMA current host receive buffer address register"] pub mod dmachrbar {
#[doc = "Register `DMACHRBAR` reader"] pub type R = crate :: R < DmachrbarSpec > ;
#[doc = "Field `HRBAP` reader - Host receive buffer address pointer"] pub type HrbapR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Host receive buffer address pointer"]
#[inline (always)] pub fn hrbap (& self) -> HrbapR { HrbapR :: new (self . bits) } }
#[doc = "Ethernet DMA current host receive buffer address register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmachrbar::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmachrbarSpec ; impl crate :: RegisterSpec for DmachrbarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dmachrbar::R`](R) reader structure"] impl crate :: Readable for DmachrbarSpec { }
#[doc = "`reset()` method sets DMACHRBAR to value 0"] impl crate :: Resettable for DmachrbarSpec { } } }
#[doc = "System control block ACTLR"] pub type ScbActrl = crate :: Periph < scb_actrl :: RegisterBlock , 0xe000_e008 > ; impl core :: fmt :: Debug for ScbActrl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ScbActrl") . finish () } }
#[doc = "System control block ACTLR"] pub mod scb_actrl {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { actrl : Actrl , } impl RegisterBlock {
#[doc = "0x00 - Auxiliary control register"]
#[inline (always)] pub const fn actrl (& self) -> & Actrl { & self . actrl } }
#[doc = "ACTRL (rw) register accessor: Auxiliary control register\n\nYou can [`read`](crate::Reg::read) this register and get [`actrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`actrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@actrl`] module"]
#[doc (alias = "ACTRL")] pub type Actrl = crate :: Reg < actrl :: ActrlSpec > ;
#[doc = "Auxiliary control register"] pub mod actrl {
#[doc = "Register `ACTRL` reader"] pub type R = crate :: R < ActrlSpec > ;
#[doc = "Register `ACTRL` writer"] pub type W = crate :: W < ActrlSpec > ;
#[doc = "Field `DISFOLD` reader - DISFOLD"] pub type DisfoldR = crate :: BitReader ;
#[doc = "Field `DISFOLD` writer - DISFOLD"] pub type DisfoldW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FPEXCODIS` reader - FPEXCODIS"] pub type FpexcodisR = crate :: BitReader ;
#[doc = "Field `FPEXCODIS` writer - FPEXCODIS"] pub type FpexcodisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISRAMODE` reader - DISRAMODE"] pub type DisramodeR = crate :: BitReader ;
#[doc = "Field `DISRAMODE` writer - DISRAMODE"] pub type DisramodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISITMATBFLUSH` reader - DISITMATBFLUSH"] pub type DisitmatbflushR = crate :: BitReader ;
#[doc = "Field `DISITMATBFLUSH` writer - DISITMATBFLUSH"] pub type DisitmatbflushW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - DISFOLD"]
#[inline (always)] pub fn disfold (& self) -> DisfoldR { DisfoldR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 10 - FPEXCODIS"]
#[inline (always)] pub fn fpexcodis (& self) -> FpexcodisR { FpexcodisR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - DISRAMODE"]
#[inline (always)] pub fn disramode (& self) -> DisramodeR { DisramodeR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - DISITMATBFLUSH"]
#[inline (always)] pub fn disitmatbflush (& self) -> DisitmatbflushR { DisitmatbflushR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 2 - DISFOLD"]
#[inline (always)] pub fn disfold (& mut self) -> DisfoldW < '_ , ActrlSpec > { DisfoldW :: new (self , 2) }
#[doc = "Bit 10 - FPEXCODIS"]
#[inline (always)] pub fn fpexcodis (& mut self) -> FpexcodisW < '_ , ActrlSpec > { FpexcodisW :: new (self , 10) }
#[doc = "Bit 11 - DISRAMODE"]
#[inline (always)] pub fn disramode (& mut self) -> DisramodeW < '_ , ActrlSpec > { DisramodeW :: new (self , 11) }
#[doc = "Bit 12 - DISITMATBFLUSH"]
#[inline (always)] pub fn disitmatbflush (& mut self) -> DisitmatbflushW < '_ , ActrlSpec > { DisitmatbflushW :: new (self , 12) } }
#[doc = "Auxiliary control register\n\nYou can [`read`](crate::Reg::read) this register and get [`actrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`actrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ActrlSpec ; impl crate :: RegisterSpec for ActrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`actrl::R`](R) reader structure"] impl crate :: Readable for ActrlSpec { }
#[doc = "`write(|w| ..)` method takes [`actrl::W`](W) writer structure"] impl crate :: Writable for ActrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ACTRL to value 0"] impl crate :: Resettable for ActrlSpec { } } }
#[doc = "Nested vectored interrupt controller"] pub type NvicStir = crate :: Periph < nvic_stir :: RegisterBlock , 0xe000_ef00 > ; impl core :: fmt :: Debug for NvicStir { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("NvicStir") . finish () } }
#[doc = "Nested vectored interrupt controller"] pub mod nvic_stir {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { stir : Stir , } impl RegisterBlock {
#[doc = "0x00 - Software trigger interrupt register"]
#[inline (always)] pub const fn stir (& self) -> & Stir { & self . stir } }
#[doc = "STIR (rw) register accessor: Software trigger interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`stir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stir`] module"]
#[doc (alias = "STIR")] pub type Stir = crate :: Reg < stir :: StirSpec > ;
#[doc = "Software trigger interrupt register"] pub mod stir {
#[doc = "Register `STIR` reader"] pub type R = crate :: R < StirSpec > ;
#[doc = "Register `STIR` writer"] pub type W = crate :: W < StirSpec > ;
#[doc = "Field `INTID` reader - Software generated interrupt ID"] pub type IntidR = crate :: FieldReader < u16 > ;
#[doc = "Field `INTID` writer - Software generated interrupt ID"] pub type IntidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R {
#[doc = "Bits 0:8 - Software generated interrupt ID"]
#[inline (always)] pub fn intid (& self) -> IntidR { IntidR :: new ((self . bits & 0x01ff) as u16) } } impl W {
#[doc = "Bits 0:8 - Software generated interrupt ID"]
#[inline (always)] pub fn intid (& mut self) -> IntidW < '_ , StirSpec > { IntidW :: new (self , 0) } }
#[doc = "Software trigger interrupt register\n\nYou can [`read`](crate::Reg::read) this register and get [`stir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StirSpec ; impl crate :: RegisterSpec for StirSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`stir::R`](R) reader structure"] impl crate :: Readable for StirSpec { }
#[doc = "`write(|w| ..)` method takes [`stir::W`](W) writer structure"] impl crate :: Writable for StirSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets STIR to value 0"] impl crate :: Resettable for StirSpec { } } }
#[doc = "SysTick timer"] pub type Stk = crate :: Periph < stk :: RegisterBlock , 0xe000_e010 > ; impl core :: fmt :: Debug for Stk { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Stk") . finish () } }
#[doc = "SysTick timer"] pub mod stk {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : Ctrl , load_ : Load_ , val : Val , calib : Calib , } impl RegisterBlock {
#[doc = "0x00 - SysTick control and status register"]
#[inline (always)] pub const fn ctrl (& self) -> & Ctrl { & self . ctrl }
#[doc = "0x04 - SysTick reload value register"]
#[inline (always)] pub const fn load_ (& self) -> & Load_ { & self . load_ }
#[doc = "0x08 - SysTick current value register"]
#[inline (always)] pub const fn val (& self) -> & Val { & self . val }
#[doc = "0x0c - SysTick calibration value register"]
#[inline (always)] pub const fn calib (& self) -> & Calib { & self . calib } }
#[doc = "CTRL (rw) register accessor: SysTick control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
#[doc (alias = "CTRL")] pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ;
#[doc = "SysTick control and status register"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ;
#[doc = "Field `ENABLE` reader - Counter enable"] pub type EnableR = crate :: BitReader ;
#[doc = "Field `ENABLE` writer - Counter enable"] pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TICKINT` reader - SysTick exception request enable"] pub type TickintR = crate :: BitReader ;
#[doc = "Field `TICKINT` writer - SysTick exception request enable"] pub type TickintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLKSOURCE` reader - Clock source selection"] pub type ClksourceR = crate :: BitReader ;
#[doc = "Field `CLKSOURCE` writer - Clock source selection"] pub type ClksourceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COUNTFLAG` reader - COUNTFLAG"] pub type CountflagR = crate :: BitReader ;
#[doc = "Field `COUNTFLAG` writer - COUNTFLAG"] pub type CountflagW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - SysTick exception request enable"]
#[inline (always)] pub fn tickint (& self) -> TickintR { TickintR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Clock source selection"]
#[inline (always)] pub fn clksource (& self) -> ClksourceR { ClksourceR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 16 - COUNTFLAG"]
#[inline (always)] pub fn countflag (& self) -> CountflagR { CountflagR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn enable (& mut self) -> EnableW < '_ , CtrlSpec > { EnableW :: new (self , 0) }
#[doc = "Bit 1 - SysTick exception request enable"]
#[inline (always)] pub fn tickint (& mut self) -> TickintW < '_ , CtrlSpec > { TickintW :: new (self , 1) }
#[doc = "Bit 2 - Clock source selection"]
#[inline (always)] pub fn clksource (& mut self) -> ClksourceW < '_ , CtrlSpec > { ClksourceW :: new (self , 2) }
#[doc = "Bit 16 - COUNTFLAG"]
#[inline (always)] pub fn countflag (& mut self) -> CountflagW < '_ , CtrlSpec > { CountflagW :: new (self , 16) } }
#[doc = "SysTick control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { } }
#[doc = "LOAD_ (rw) register accessor: SysTick reload value register\n\nYou can [`read`](crate::Reg::read) this register and get [`load_::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`load_::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@load_`] module"]
#[doc (alias = "LOAD_")] pub type Load_ = crate :: Reg < load_ :: Load_Spec > ;
#[doc = "SysTick reload value register"] pub mod load_ {
#[doc = "Register `LOAD_` reader"] pub type R = crate :: R < Load_Spec > ;
#[doc = "Register `LOAD_` writer"] pub type W = crate :: W < Load_Spec > ;
#[doc = "Field `RELOAD` reader - RELOAD value"] pub type ReloadR = crate :: FieldReader < u32 > ;
#[doc = "Field `RELOAD` writer - RELOAD value"] pub type ReloadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 24 , u32 > ; impl R {
#[doc = "Bits 0:23 - RELOAD value"]
#[inline (always)] pub fn reload (& self) -> ReloadR { ReloadR :: new (self . bits & 0x00ff_ffff) } } impl W {
#[doc = "Bits 0:23 - RELOAD value"]
#[inline (always)] pub fn reload (& mut self) -> ReloadW < '_ , Load_Spec > { ReloadW :: new (self , 0) } }
#[doc = "SysTick reload value register\n\nYou can [`read`](crate::Reg::read) this register and get [`load_::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`load_::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Load_Spec ; impl crate :: RegisterSpec for Load_Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`load_::R`](R) reader structure"] impl crate :: Readable for Load_Spec { }
#[doc = "`write(|w| ..)` method takes [`load_::W`](W) writer structure"] impl crate :: Writable for Load_Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LOAD_ to value 0"] impl crate :: Resettable for Load_Spec { } }
#[doc = "VAL (rw) register accessor: SysTick current value register\n\nYou can [`read`](crate::Reg::read) this register and get [`val::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`val::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@val`] module"]
#[doc (alias = "VAL")] pub type Val = crate :: Reg < val :: ValSpec > ;
#[doc = "SysTick current value register"] pub mod val {
#[doc = "Register `VAL` reader"] pub type R = crate :: R < ValSpec > ;
#[doc = "Register `VAL` writer"] pub type W = crate :: W < ValSpec > ;
#[doc = "Field `CURRENT` reader - Current counter value"] pub type CurrentR = crate :: FieldReader < u32 > ;
#[doc = "Field `CURRENT` writer - Current counter value"] pub type CurrentW < 'a , REG > = crate :: FieldWriter < 'a , REG , 24 , u32 > ; impl R {
#[doc = "Bits 0:23 - Current counter value"]
#[inline (always)] pub fn current (& self) -> CurrentR { CurrentR :: new (self . bits & 0x00ff_ffff) } } impl W {
#[doc = "Bits 0:23 - Current counter value"]
#[inline (always)] pub fn current (& mut self) -> CurrentW < '_ , ValSpec > { CurrentW :: new (self , 0) } }
#[doc = "SysTick current value register\n\nYou can [`read`](crate::Reg::read) this register and get [`val::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`val::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ValSpec ; impl crate :: RegisterSpec for ValSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`val::R`](R) reader structure"] impl crate :: Readable for ValSpec { }
#[doc = "`write(|w| ..)` method takes [`val::W`](W) writer structure"] impl crate :: Writable for ValSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets VAL to value 0"] impl crate :: Resettable for ValSpec { } }
#[doc = "CALIB (rw) register accessor: SysTick calibration value register\n\nYou can [`read`](crate::Reg::read) this register and get [`calib::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calib::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@calib`] module"]
#[doc (alias = "CALIB")] pub type Calib = crate :: Reg < calib :: CalibSpec > ;
#[doc = "SysTick calibration value register"] pub mod calib {
#[doc = "Register `CALIB` reader"] pub type R = crate :: R < CalibSpec > ;
#[doc = "Register `CALIB` writer"] pub type W = crate :: W < CalibSpec > ;
#[doc = "Field `TENMS` reader - Calibration value"] pub type TenmsR = crate :: FieldReader < u32 > ;
#[doc = "Field `TENMS` writer - Calibration value"] pub type TenmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 24 , u32 > ; impl R {
#[doc = "Bits 0:23 - Calibration value"]
#[inline (always)] pub fn tenms (& self) -> TenmsR { TenmsR :: new (self . bits & 0x00ff_ffff) } } impl W {
#[doc = "Bits 0:23 - Calibration value"]
#[inline (always)] pub fn tenms (& mut self) -> TenmsW < '_ , CalibSpec > { TenmsW :: new (self , 0) } }
#[doc = "SysTick calibration value register\n\nYou can [`read`](crate::Reg::read) this register and get [`calib::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calib::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CalibSpec ; impl crate :: RegisterSpec for CalibSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`calib::R`](R) reader structure"] impl crate :: Readable for CalibSpec { }
#[doc = "`write(|w| ..)` method takes [`calib::W`](W) writer structure"] impl crate :: Writable for CalibSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CALIB to value 0"] impl crate :: Resettable for CalibSpec { } } }
#[no_mangle] static mut DEVICE_PERIPHERALS : bool = false ;
#[doc = r" All the peripherals."]
#[allow (non_snake_case)] pub struct Peripherals {
#[doc = "FSMC"] pub fsmc : Fsmc ,
#[doc = "PWR"] pub pwr : Pwr ,
#[doc = "RCC"] pub rcc : Rcc ,
#[doc = "GPIOA"] pub gpioa : Gpioa ,
#[doc = "GPIOB"] pub gpiob : Gpiob ,
#[doc = "GPIOC"] pub gpioc : Gpioc ,
#[doc = "GPIOD"] pub gpiod : Gpiod ,
#[doc = "GPIOE"] pub gpioe : Gpioe ,
#[doc = "GPIOF"] pub gpiof : Gpiof ,
#[doc = "GPIOG"] pub gpiog : Gpiog ,
#[doc = "AFIO"] pub afio : Afio ,
#[doc = "EXTI"] pub exti : Exti ,
#[doc = "DMA1"] pub dma1 : Dma1 ,
#[doc = "DMA2"] pub dma2 : Dma2 ,
#[doc = "SDIO"] pub sdio : Sdio ,
#[doc = "RTC"] pub rtc : Rtc ,
#[doc = "BKP"] pub bkp : Bkp ,
#[doc = "IWDG"] pub iwdg : Iwdg ,
#[doc = "WWDG"] pub wwdg : Wwdg ,
#[doc = "TIM1"] pub tim1 : Tim1 ,
#[doc = "TIM8"] pub tim8 : Tim8 ,
#[doc = "TIM2"] pub tim2 : Tim2 ,
#[doc = "TIM3"] pub tim3 : Tim3 ,
#[doc = "TIM4"] pub tim4 : Tim4 ,
#[doc = "TIM5"] pub tim5 : Tim5 ,
#[doc = "TIM9"] pub tim9 : Tim9 ,
#[doc = "TIM12"] pub tim12 : Tim12 ,
#[doc = "TIM10"] pub tim10 : Tim10 ,
#[doc = "TIM11"] pub tim11 : Tim11 ,
#[doc = "TIM13"] pub tim13 : Tim13 ,
#[doc = "TIM14"] pub tim14 : Tim14 ,
#[doc = "TIM6"] pub tim6 : Tim6 ,
#[doc = "TIM7"] pub tim7 : Tim7 ,
#[doc = "I2C1"] pub i2c1 : I2c1 ,
#[doc = "I2C2"] pub i2c2 : I2c2 ,
#[doc = "SPI1"] pub spi1 : Spi1 ,
#[doc = "SPI2"] pub spi2 : Spi2 ,
#[doc = "SPI3"] pub spi3 : Spi3 ,
#[doc = "USART1"] pub usart1 : Usart1 ,
#[doc = "USART2"] pub usart2 : Usart2 ,
#[doc = "USART3"] pub usart3 : Usart3 ,
#[doc = "ADC1"] pub adc1 : Adc1 ,
#[doc = "ADC2"] pub adc2 : Adc2 ,
#[doc = "ADC3"] pub adc3 : Adc3 ,
#[doc = "CAN1"] pub can1 : Can1 ,
#[doc = "CAN2"] pub can2 : Can2 ,
#[doc = "DAC"] pub dac : Dac ,
#[doc = "DBG"] pub dbg : Dbg ,
#[doc = "UART4"] pub uart4 : Uart4 ,
#[doc = "UART5"] pub uart5 : Uart5 ,
#[doc = "CRC"] pub crc : Crc ,
#[doc = "FLASH"] pub flash : Flash ,
#[doc = "USB"] pub usb : Usb ,
#[doc = "OTG_FS_DEVICE"] pub otg_fs_device : OtgFsDevice ,
#[doc = "OTG_FS_GLOBAL"] pub otg_fs_global : OtgFsGlobal ,
#[doc = "OTG_FS_HOST"] pub otg_fs_host : OtgFsHost ,
#[doc = "OTG_FS_PWRCLK"] pub otg_fs_pwrclk : OtgFsPwrclk ,
#[doc = "ETHERNET_MMC"] pub ethernet_mmc : EthernetMmc ,
#[doc = "ETHERNET_MAC"] pub ethernet_mac : EthernetMac ,
#[doc = "ETHERNET_PTP"] pub ethernet_ptp : EthernetPtp ,
#[doc = "ETHERNET_DMA"] pub ethernet_dma : EthernetDma ,
#[doc = "SCB_ACTRL"] pub scb_actrl : ScbActrl ,
#[doc = "NVIC_STIR"] pub nvic_stir : NvicStir ,
#[doc = "STK"] pub stk : Stk , } impl Peripherals {
#[doc = r" Returns all the peripherals *once*."]
#[cfg (feature = "critical-section")]
#[inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) }
#[doc = r" Unchecked version of `Peripherals::take`."]
#[doc = r""]
#[doc = r" # Safety"]
#[doc = r""]
#[doc = r" Each of the returned peripherals must be used at most once."]
#[inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { fsmc : Fsmc :: steal () , pwr : Pwr :: steal () , rcc : Rcc :: steal () , gpioa : Gpioa :: steal () , gpiob : Gpiob :: steal () , gpioc : Gpioc :: steal () , gpiod : Gpiod :: steal () , gpioe : Gpioe :: steal () , gpiof : Gpiof :: steal () , gpiog : Gpiog :: steal () , afio : Afio :: steal () , exti : Exti :: steal () , dma1 : Dma1 :: steal () , dma2 : Dma2 :: steal () , sdio : Sdio :: steal () , rtc : Rtc :: steal () , bkp : Bkp :: steal () , iwdg : Iwdg :: steal () , wwdg : Wwdg :: steal () , tim1 : Tim1 :: steal () , tim8 : Tim8 :: steal () , tim2 : Tim2 :: steal () , tim3 : Tim3 :: steal () , tim4 : Tim4 :: steal () , tim5 : Tim5 :: steal () , tim9 : Tim9 :: steal () , tim12 : Tim12 :: steal () , tim10 : Tim10 :: steal () , tim11 : Tim11 :: steal () , tim13 : Tim13 :: steal () , tim14 : Tim14 :: steal () , tim6 : Tim6 :: steal () , tim7 : Tim7 :: steal () , i2c1 : I2c1 :: steal () , i2c2 : I2c2 :: steal () , spi1 : Spi1 :: steal () , spi2 : Spi2 :: steal () , spi3 : Spi3 :: steal () , usart1 : Usart1 :: steal () , usart2 : Usart2 :: steal () , usart3 : Usart3 :: steal () , adc1 : Adc1 :: steal () , adc2 : Adc2 :: steal () , adc3 : Adc3 :: steal () , can1 : Can1 :: steal () , can2 : Can2 :: steal () , dac : Dac :: steal () , dbg : Dbg :: steal () , uart4 : Uart4 :: steal () , uart5 : Uart5 :: steal () , crc : Crc :: steal () , flash : Flash :: steal () , usb : Usb :: steal () , otg_fs_device : OtgFsDevice :: steal () , otg_fs_global : OtgFsGlobal :: steal () , otg_fs_host : OtgFsHost :: steal () , otg_fs_pwrclk : OtgFsPwrclk :: steal () , ethernet_mmc : EthernetMmc :: steal () , ethernet_mac : EthernetMac :: steal () , ethernet_ptp : EthernetPtp :: steal () , ethernet_dma : EthernetDma :: steal () , scb_actrl : ScbActrl :: steal () , nvic_stir : NvicStir :: steal () , stk : Stk :: steal () , } } }